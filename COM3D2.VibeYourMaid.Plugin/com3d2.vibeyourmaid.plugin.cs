using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Threading;
using UnityEngine;
using UnityInjector;
using UnityInjector.Attributes;

using CM3D2.ExternalSaveData.Managed;

// コンパイル用コマンド （ ..\COM3D2\ 部分は環境に合わせて変更 足りないdllはソースと同じ場所にコピーでも可）
//   C:\Windows\Microsoft.NET\Framework\v3.5\csc.exe /o /t:library /lib:"..\COM3D2\Sybaris" /lib:"..\COM3D2\Sybaris\UnityInjector" /lib:"..\COM3D2\COM3D2x64_Data\Managed" /r:UnityEngine.dll /r:UnityEngine.VR.dll /r:UnityInjector.dll /r:Assembly-CSharp.dll /r:Assembly-CSharp-firstpass.dll /r:Assembly-UnityScript-firstpass.dll /r:COM3D2.ExternalSaveData.Managed.dll COM3D2.VibeYourMaid.Plugin.cs COM3D2.VibeYourMaid.Language.cs
// コンパイルオプション
//   被写界深度有効 -define:DOF
//   エンパイアズライフ有効 -define:EmpiresLife
//   2.5用 (2.5環境のパスでビルド) -define:COM3D2_5
//   DCM連携 (DCM側dllも要修正)  /r:COM3D2.DanceCameraMotion.Plugin.dll -define:DCM

//#define:DOF
//#define EmpiresLife
//#define UNITY_2022_3

#if UNITY_2022_3
#elif COM3D2_5
[assembly: AssemblyTitle("VibeYourMaid COM3D2.5")]
#else
[assembly: AssemblyTitle("VibeYourMaid COM3D2")]
#endif

#if !UNITY_2022_3
[assembly: AssemblyVersion("2.1.0.5")]
#endif

namespace CM3D2.VibeYourMaid.Plugin
{
    [
      PluginFilter("COM3D2x64"), PluginFilter("COM3D2VRx64"), PluginFilter("COM3D2OHx64"), PluginFilter("COM3D2OHVRx64"),
      PluginName("VibeYourMaid"), PluginVersion("2.1.0.5.ovr"),
      DefaultExecutionOrder(-1) //プラグインの実行順を他のプラグインより前にする
    ]
    public class VibeYourMaid : PluginBase
    {
        const string PluginVersion = "2.1.0.5";

        /// <summary>
        /// 設定パラメータクラス
        /// config.xmlに保存される
        /// GUIで設定保存したい変数はここ
        /// </summary>
        public class VibeYourMaidCfgWriting  //@API実装//→API用にpublicに変更
        {
          public VibeYourMaidCfgWriting() { }

          public bool initialLoadThreading = true; //初期データの読み込みを別スレッドで実行
          public int initialMotionLoadWait = 5000; //別スレッドでの読み込み時 モーション一覧の読み込み処理を遅らせる (ミリ秒)

          //GUIパネル 表示
          public bool bPluginEnabledV = true;                 //　本プラグインの有効状態（下記キーでON/OFFトグル）
          public int mainGuiFlag = 1;                         //　GUIの表示フラグ（0：非表示、1：表示、2：最小化）
          public int subGuiFlag = 0;                          //　サブキャラ操作画面の表示フラグ
          public bool configGuiFlag = false;                  //　設定画面の表示フラグ
          public bool unzipGuiFlag = false;                   //　命令画面の表示フラグ

          //通常のキーとマウスイベントを無効化 「o」と「i」キーは有効 (VRで不要なキー判定を減らす)
          public bool ShortCutKeyMouseDisabled = false;
          //UIが最小化or非表示中はシェイプキー等の変形をスキップして動作を軽くする
          public bool DanceLightweightMode = false;

          //キー設定  設定なし→KeyCode.None
          public KeyCode keyPluginToggleV0 = KeyCode.I;        //　本プラグインの有効無効の切替キー（Ｉキー）
          public KeyCode keyPluginToggleV1 = KeyCode.O;        //　GUI表示切り替えキー（Ｏキー）
          public KeyCode keyPluginToggleV2 = KeyCode.J;        //　バイブ停止キー（Ｊキー）
          public KeyCode keyPluginToggleV3 = KeyCode.K;        //　バイブ弱キー（Ｋキー）
          public KeyCode keyPluginToggleV4 = KeyCode.L;        //　バイブ強キー（Ｌキー）
          //public KeyCode keyPluginToggleV5 = KeyCode.P;        //　メイド切替（Ｐキー）
          public KeyCode keyPluginToggleV6 = KeyCode.N;        //　男表示切替（Ｎキー）
          public KeyCode keyPluginToggleV7 = KeyCode.Keypad1;  //　一人称視点切替（テンキー１）
          public KeyCode keyPluginToggleV8 = KeyCode.Keypad2;  //　快感値ロック（テンキー２）
          public KeyCode keyPluginToggleV9 = KeyCode.Keypad3;  //　絶頂値ロック（テンキー３）
          public KeyCode keyPluginToggleV10 = KeyCode.Keypad4; //　オートモード切り替え
          public KeyCode keyPluginToggleV11 = KeyCode.Keypad9; //　エンパイアズライフスタート

          public KeyCode keyPluginMaidPrev = KeyCode.LeftArrow;  //前のメイドを選択 （左右設定なら左)
          public KeyCode keyPluginMaidNext = KeyCode.RightArrow; //次のメイドを選択 （左右設定なら右)
          public KeyCode keyPluginMaidFront = KeyCode.UpArrow;   //正面のメイド
          public KeyCode keyPluginMaid1 = KeyCode.None;  //1人目のメイド選択
          public KeyCode keyPluginMaid2 = KeyCode.None;  //2人目のメイド選択
          public KeyCode keyPluginMaid3 = KeyCode.None;  //3人目のメイド選択

          public bool[] andKeyEnabled = new bool[]{ true , false , false }; //同時押しキーの設定 Ctrl Shift Alt

          //GUIパネル 設定
          public bool guiStopPropagation = true;  //マウスクリックを伝播しない
          public string guiOrigin = "RB";  //GUIパネルの原点 (左上:LT 左下:LB 右上:RT 右下:RB)
          public int guiOffsetX = 0;       //表示位置調整 横
          public int guiOffsetY = 0;       //表示位置調整 縦
          public int guiOffsetXSub = 0;    //サブキャラ操作画面 表示位置調整 横
          public int guiOffsetYSub = 0;    //サブキャラ操作画面 表示位置調整 縦
          public int guiOffsetXConfig = 0; //設定画面 表示位置調整 横
          public int guiOffsetYConfig = 0; //設定画面 表示位置調整 縦
          public int guiOffsetXUnzip = 0;  //命令画面 表示位置調整 横
          public int guiOffsetYUnzip = 0;  //命令画面 表示位置調整 縦
          public int guiHeightUnzip = 220; //UNZIPパネルの高さ 初期値 220
          public int[] guiHoverColor = new int[]{48, 48, 48, 224}; //マウスオーバー時のGUI背景色と不透明度 RGBA 0～255

          //　表情テーブル　（バイブ）
          public string[][] sFaceAnime20Vibe = new string[][] {
            new string[] { "困った" , "ダンス困り顔" , "恥ずかしい" , "苦笑い" , "エロ羞恥１" , "まぶたギュ" },
            new string[] { "困った" , "ダンス困り顔" , "恥ずかしい" , "苦笑い" , "エロ羞恥１" , "まぶたギュ" },
            new string[] { "怒り" , "興奮射精後１" , "発情" , "エロ痛み２" , "エロ羞恥２" , "エロ我慢３" },
            new string[] { "怒り" , "興奮射精後１" , "発情" , "エロ痛み２" , "エロ羞恥２" , "エロ我慢３" }
          };
          public string[][] sFaceAnime30Vibe = new string[][] {
            new string[] { "エロ痛み１" , "エロ痛み２" , "エロ我慢１" , "エロ我慢２" , "泣き" , "怒り" },
            new string[] { "エロ痛み１" , "エロ痛み２" , "エロ我慢１" , "エロ我慢２" , "泣き" , "怒り" },
            new string[] { "エロ痛み我慢" , "エロ痛み我慢２" , "エロ痛み我慢３" , "エロメソ泣き" , "エロ羞恥３" , "エロ我慢３" },
            new string[] { "エロ痛み我慢" , "エロ痛み我慢２" , "エロ痛み我慢３" , "エロメソ泣き" , "エロ羞恥３" , "エロ我慢３" }
          };
          public string[] sFaceAnime40Vibe = new string[] { "少し怒り" , "思案伏せ目" , "まぶたギュ" , "エロメソ泣き" };

          public string[] sFaceAnimeStun = new string[] { "絶頂射精後１" , "興奮射精後１" , "エロメソ泣き" , "エロ痛み２" , "エロ我慢３" , "引きつり笑顔" , "エロ通常３" , "泣き" };

          //シェイプキーアニメリスト
          public string[] ShapeListR = new string[] { "randamX" , "randamY" };
          public string[] ShapeListW = new string[] { "X1" , "Y1" , "waveX" , "waveY" };
          public string[] ShapeListW2 = new string[] { "逆反復" };
          public string[] ShapeListI = new string[] { "シェイプキーを記述" };

          //一般設定
          public bool bVoiceOverrideEnabledV = true;          //　キス時の音声オーバライド（上書き）機能を使う
          public int iYodareAppearLevelV = 3;                 //　所定の興奮レベル以上でよだれをつける（１～４のどれかを入れる、０で無効）
          public int vExciteLevelThresholdV1 = 100;           //　興奮レベル１→２閾値
          public int vExciteLevelThresholdV2 = 180;           //　興奮レベル２→３閾値
          public int vExciteLevelThresholdV3 = 250;           //　興奮レベル３→４閾値

          //public bool ClearEnabled = false; //未使用
          //public bool TaikiEnabled = true;  //未使用

          public int SelectSE = 2;
          public bool ntrBlock = true;


          //基本動作に関連する設定
          //移動量初期値(m)
          public float moveValueDefault = 0.05f;
          //カメラ距離修正
          public bool onloadAdjustCameraDistance = false; //シーン切り替わり時にカメラのターゲットが近すぎたらターゲットをメイドとの距離で修正する
          //その他
          public bool useMekureController = true; //CRCボディもぽろりにmekureControllerのはだけを利用する

          //地面判定
          public int[] BoneHitHeight = {40, 55, 65, 85};
          public bool fixBoneHitHeight = true;  //メイドの読み込み時に-10m以下の地面判定を0に補正する


          //カメラ
          public bool camCheckEnabled = false;
          public float camCheckRange = 0.15f;

          //バイブのリンク対象
          public int vibeLinkType = 1; //リモコンのボタンとショートカットキーでの操作体操  0:メインメイドのみ 1:メイン＋リンクしているメイド 2:UNZIPのメインとサブメイド 9:表示中のメイド全員
          public bool vibeLookingMaid = true;   //VR操作 HMD視野の中心のメイドをバイブ対象にする

          //表情管理（バイブ）
          public int vStateAltTimeVBase = 180;                 //　フェイスアニメの変化時間（秒）
          public int vStateAltTimeVRandomExtend = 240;         //　変化時間へのランダム加算（秒）
          public float fAnimeFadeTimeV = 1.0f;                 //　バイブモードのフェイスアニメ等のフェード時間（秒）

          //バイブ弱時のアニメーション設定
          public float RandamMin1 = 0f;
          public float RandamMax1 = 30f;

          public float WaveMin1 = 0f;
          public float WaveMax1 = 100f;
          public float WaveSpead1 = 12f;

          public float IncreaseMax1 = 100f;
          public float IncreaseSpead1 = 5f;

          //バイブ強時のアニメーション設定
          public float RandamMin2 = 0f;
          public float RandamMax2 = 60f;

          public float WaveMin2 = 0f;
          public float WaveMax2 = 100f;
          public float WaveSpead2 = 20f;

          public float IncreaseMax2 = 100f;
          public float IncreaseSpead2 = 10f;

          //秘部
          //バイブ開始時に開度スライダーの値をkupaシェイプキーの値に合わせて開いたままにする（UNZIPが開始されていない場合のみ）
          public bool kupaSliderSync = true;
          //バイブ動作中のKupeとAnalの開閉速度 1秒間に増えるシェイプキー(0-100)の値
          public float kupaOpenSpeed = 60f;  //Kupeの開く速度
          public float kupaCloseSpeed = 40f; //Kupeの閉じる速度
          public float analOpenSpeed = 60f;  //Analの開く速度
          public float analCloseSpeed = 40f; //Analの閉じる速度
          //バイブ停止中のKupeとAnalの開閉速度 (状態一時変更や外部操作時)
          public float kupaTempOpenSpeed = 30f;
          public float kupaTempCloseSpeed = 20f; //バイブ停止中のみ
          public float analTempOpenSpeed = 30f;
          public float analTempCloseSpeed = 20f; //バイブ停止中のみ
          //クリの動作速度 通常は興奮度に応じて大きくなる
          public float bokkiShrinkSpeed = 3f   ; //クリの時間経過での縮小速度
          public float bokkiTempGrowSpeed = 20f; //クリ一時変更拡大時のアニメーション速度

          //クリトリス勃起設定 クリの勃起とlabiakupaのスケール(共通) 個別のクリスケールにも乗算される
          public float clitorisMax = 100f;
          //巨クリやふたなりはクリ肥大時に個別指定したクリスケールよりも大きくする 0なら肥大しない (クリスケール50%で 0.5なら最大75% 0.2なら最大60%)
          public float cliHidaiRate = 0.2f;


          //絶頂設定
          //興奮値
          public bool yotogiExciteLink = true; //絶頂値と夜伽スライダーを連動
          public int[] yotogiExciteLinkValue = new int[]{0, 100, 150, 200, 300}; //連動時のレベルに対応する興奮値
          public bool maidStatusLinkVoiceSetExite = true;  //ボイスセットの興奮レベル判定に興奮値を利用
          public bool maidStatusLinkVoiceSetOrgasm = true; //ボイスセットの絶頂レベル判定に興奮値を利用

          //痙攣幅の設定
          public float orgasmValue1 = 15f;
          public float orgasmValue2 = 30f;
          public float orgasmValue3 = 40f;
          //絶頂時の尿と潮
          public float orgazmNyoLowerLimit = 0f;  //絶頂時の放尿乱数下限 120で毎回放尿 失神時は50
          public float orgazmSioLowerLimit = 0f;  //絶頂時の潮吹き乱数下限 30で毎回潮吹き
          //絶頂時の潮吹き間隔
          public float orgazmSioDuration = 4f;   //絶頂後の潮吹き持続時間 この秒数+sioVolume/30 長いと複数回潮を吹く
          public float orgazmSioStartMin = 0.5f; //絶頂後の潮吹き始め開始秒 乱数最小値
          public float orgazmSioStartMax = 1f;   //絶頂後の潮吹き始め開始秒 乱数最大値
          public float orgazmSioNextMin = 2f;    //絶頂後の潮吹き2回目以降の間隔 乱数最小値
          public float orgazmSioNextMax = 4f;    //絶頂後の潮吹き2回目以降の間隔 乱数最大値

          //射精
          public float syaseiLimit = 85f;        //メイド絶頂時、男モーション変更時、「抜く」実行時に射精値がこれより高ければ精液処理する
          public float sotodashiDelay = 1.0f; //外出し射精時の待機秒数
          public float forceSyaseiValue = 99f;   //100だと待たずに射精する

          //男表示
          public bool forceManChinkoVisible = false; //男表示時に竿を強制表示
          #if COM3D2_5
          public bool useRealMan = true;  //UNZIPで男ボディを使うならtrue ※CRCモーションでないと動かない
          public float realManHideOffsetY = -10f;  //ロード中にY位置をずらして非表示にする 0なら非表示処理しない
          #endif
          
          //ちんぽ勃起設定
          public float ChinpoMax = 100f;
          public float ChinpoMin = 50f;
          public float SoriMax = 100f;
          public float SoriMin = 50f;
          public float TamaValue = 0f;

          //有効シーン設定
          public int[] SceneList = new int[] { 3,20,22,5,4,15,26,24,28,27,30,31,32,34,35,36,37,43 };

          //演出有効フラグ
          public bool NamidaEnabled = true;
          public bool YodareEnabled = true;
          public bool CliAnimeEnabled = true;
          public bool OrgsmAnimeEnabled = false;
          public bool ToikiEnabled = true;
          public bool AiekiEnabled = true;
          public bool AheEnabled = true;
          public bool NyoEnabled = true;
          public bool SioEnabled = true;
          public bool HohoEnabled = true;
          public string sekimenKey = "hoho2";    //赤面シェイプキー名
          public int sekimenEnableLevel = 9;     //赤面が有効になる快感レベル
          public int sekimenDisableLevel = 4;    //赤面が無効になる快感レベル


          //尿と潮のパーティクル置き換え スクリプト@AddPrefabCharaのコールバックを入れ替える シーンロード時に実行
          public bool ScriptReplaceNyoSioPrefabMotion = false;     //夜伽コマンドでの尿と潮を置き換える
          public bool ScriptReplaceNyoSioPrefabYotogiKag = false;  //夜伽中のスクリプトの尿と潮を置き換える
          public bool ScriptReplaceNyoSioPrefabAdvKag = false;     //シナリオスクリプトの尿と潮を置き換える
          public bool ScriptReplaceNyoSioPrefabTmpKag = false;     //Tmpスクリプトの尿と潮を置き換える (帝国荘で利用？)
          public bool ScriptReplaceNyoSioPrefabPrivateKag = false; //プライベートモードスクリプトの尿と潮を置き換える
          public int ScriptReplaceSioCount = 2; //公式を置き換えた場合の潮吹きの連続実行回数 1だと少ない場合に増やす
          
          public bool NyoWaitPlaying = true;  //放尿中に次の放尿を開始しない

          public float NyoKupaMove = 0.0145f;    //尿のクパ値に応じた移動量 (体の前側が正)
          public float NyoOffsetY = 0.012f;      //尿の前後補正 (体の前側が正)
          public float NyoInvertOffsetY = 0.01f; //俯せで尿道が下になる場合の追加補正量 (体の前側が正) ※尿パーティクルが上寄りのため
          public float NyoOffsetZ = 0f;          //尿の上下補正 (奥側が正)
          public float SioKupaMove = 0.014f;     //潮のクパ値に応じた移動量 (体の前側が正)
          public float SioOffsetY = 0.0125f;     //潮の前後補正 (体の前側が正)
          public float SioOffsetZ = -0.03f;      //潮の上下補正 (奥側=頭側が正)
          //尿と潮の描画優先度 半透明スカートに合わせた値
          public int NyoRenderQueue = 3172;
          public int SioRenderQueue = 3172;
          
          public string SioParticle  = "pSIO02_com3D2";  //潮パーティクル 通常
          public string SioParticle2 = "pSIO01_com3D2";  //潮パーティクル 増量 連続潮吹き時
          public string SioParticle3 = "pSIO03_com3D2";  //潮パーティクル さらに増量 連続潮吹き時
          //潮の種別ランダム比率 [[前回の潮吹きからの秒数, SioParticle2の%, SioParticle3の%]] 0は初回時
          public float[][] SioTimeRate = new float[][]{new float[]{0, 5, 5}, new float[]{5, 60, 40}, new float[]{30, 30, 20}};
          public float[] SioScale = {0.1f, 0.1f, 0.6f}; //潮パーティクルのスケール
          public float SioGravity = 0.5f;  //潮パーティクルの飛散時の重力
          public float SioDuration = 2.5f; //潮吹き終わりまでの秒数 短いとまとめて出る

          //尿と潮の当たり判定 (上の設定が優先される)
          public bool NyoHeightFix = true;  //平面との衝突時は地面判定の高さに衝突面を合わせる 衝突がWorldなら地面高に平面コライダーを配置
          public bool NyoCollisionTypeWorld = false;   //コライダーと衝突するが地面判定が無効になる 衝突しても平面反射エフェクトになるので非推奨
          public int  NyoCollisionLayer = 1<<MuneCollider.LAYER_NO;
          public bool SioCollisionDisabled = false;    //潮の衝突無効 ※男ボディと当たって表示されない場合に設定 床とも衝突しなくなる
          public bool SioHeightFix = true;  //平面との衝突時は地面判定の高さに衝突面を合わせる 衝突がWorldなら地面高に平面コライダーを配置
          public bool SioCollisionTypeWorld = false;   //コライダーと衝突するが地面判定が無効になる
          public int  SioCollisionLayer = 1<<MuneCollider.LAYER_NO;
          public float SioCollisionBounceRate = 0.5f;  //コライダーと衝突した後に加える力 倍率
          public float SioCollisionDampenRate = 3f;    //コライダーと衝突した後の減速 倍率
          public float SioCollisionRadiusScale = 1f; //潮パーティクルの当たり半径拡大倍率
          public float SioCollisionOffsetRadiusScale = 1.5f; //オフセット調整があったときの当たり半径拡大倍率 当たりやすいように大きくする
          public float SioCollisionOffsetCancelRadiusScale = 0.1f; //挿入中等でオフセット調整がキャンセルされた場合の半径拡大倍率 当たらないように小さくする
          public float SioCollisionOffsetZ = 0.1f;     //竿コライダーと重なっていたらこの距離より体の奥を潮の原点にする (おさわりコライダーは無視)

          public float FloorColliderSize = 10f;    //床コライダーのサイズ 正方形 全メイド共通
          public float FloorColliderOffsetY = 0f;  //床コライダーの高さ調整用 BoneHeightだと少し上になるのを調整したい場合に設定
          public float NyoFloorColliderTime = 8f;  //尿の床コライダーが消えるまでの時間 他に影響はないので長めに設定
          public float SioFloorColliderTime = 2f;  //潮の床コライダーが消えるまでの時間 他に影響はないので長めに設定

          public float[] AiekiScale = {0.5f, 0.5f, 0.6f}; //愛液1～3パーティクルのスケール
          public float AiekiGravity = 0.05f;  //愛液1～3飛散時の重力
          public float AiekiDuration = 0.25f; //愛液1～3吹き終わりまでの秒数 短いとまとめて出る

          public bool aseAnimeEnabled = true;
          public float aseDryMin = 60f;    //dry最小値 スタミナに応じて100～60に変化 小さいほど大きく 100で見えなくなる
          public float aseSwet = 0.5f;     //汗シェイプキー倍率
          public float aseSwetTare = 1.0f; //汗シェイプキー倍率
          public float aseSwetBig = 0.1f;  //汗シェイプキー倍率

          public bool zViceWaitEnabled = true;
          public bool MouthNomalEnabled = true;
          public bool MouthKissEnabled = true;
          public bool MouthFeraEnabled = true;
          public bool MouthZeccyouEnabled = true;

          public bool hibuAnime1Enabled = true;
          public float kupaWave = 5f;
          public bool hibuAnime2Enabled = true;
          public bool uDatsuEnabled = false;


          //モーション関連
          public float motionChangeFade = 0.7f;  //MaidMotionchangeでのモーションのクロスフェード時間 余韻時は1.0固定
          
          public bool autoMoveEnabled = true;   //メインメイド切り替えに連動
          public bool autoManEnabled = true;    //UNZIP 男自動表示
          public bool crcMotionVisible = false; //UNZIP CRCモーションを表示
          public string excludeMotion = "^(josikai|kaiwa.?_sofa_)"; //除外するモーション正規表現
          public int[] YotogiMenuColumns = DefaultYotogiMenuColumns; //UNZIPのボタン列数 長さ14の配列 設定初期化時に長さや値は調整している

          //素股からの挿入後の基本モーションの例外置換(完全一致) 素股に戻る用の逆変換も行う  _sumata_f と ‗sumata_1_f はこの置換の後に部分一致で変換している
          public string[][] sumataInsertedMotionReplace = {
            new string[]{"tikan_aibu_sumata_f", "tikan_sex_1_f"},
            new string[]{"kijyoui_sumata_1_f", "taimenkijyoui_1_f"},
            new string[]{"kijyoui_sumata_tekoki_1_f", "taimenkijyoui_1_f"},
            new string[]{"kijyoui_sumata_ryoumomi_f", "taimenkijyoui_1_f"},
          };

          public bool majEnabled = true;
          public bool majItemClear = true;
          public bool majStartTaikMotion = true;   //バイブが止まっていたら待機モーションで開始
          public bool majInMotionVibeLevel = true; //UNZIP開始時にバイブを弱に設定する 現在のバイブ状態より強くなる場合のみ変更
          public bool majKupaEnabled = true;
          //クパ設定がない場合の前挿入時のデフォルト値 -1なら現在の値から変更しない
          public float majDefaultKupa1 = 70f; 
          public float majDefaultAnal1 = 10f;
          public float majDefaultKupa2 = 15f;
          public float majDefaultAnal2 = 5f;
          //アナルモードの時にAnalの値をKupaの値と入れ替えた後に拡張する
          public float majAnalModeExtend = 20f;

          public float majKupaOpenDelay = 0.7f;    //クパとアナルが拡がり始めるまでの待ち時間(デフォルト)
          public float majFadeTime = 1.0f;
          public float majOutSyaseiFade = 0.7f;    //抜くの外出しモーションの遷移時間(射精あり)
          public float majOutFade = 0.7f;          //抜くモーションの遷移時間(射精なし)
          public float majOutFadeAf = 1.5f;        //抜いた後の待機か射精後モーションの遷移時間
          public int majOutMotionFlag = 1;         //射精なしの場合の抜きモーション(共通設定) 1=射精後 2=待機 3=射精後→待機 4=待機→射精後 +8=常時射精 +16=射精時に待機に遷移 +32=挿入モーションなし
          public bool majSkipStartInMotion = true; //前のモーションが挿入中だったら新しいUNZIP洗濯時の挿入モーションはスキップ
          //設置アイテム高さ初期値
          public float[] majPrefabOffset = new float[] { 0f, 0f, -0.6f, -0.4f, -0.35f, -0.11f, 0f, 0f, 0f, -0.8f, -0.7f};


          //ボイスセット
          public int voiceHoldTimeBase = 240;         //60fsp換算
          public int voiceHoldTimeRandomExtend = 360; //60fsp換算
          public float voiceSetInterval = 10;     //ボイスセット再生間隔 基準秒数
          public float voiceSetIntervalRange = 8; //ボイスセット再生間隔 変動秒数 (基準秒数に-4～+4 で変動)

          //public bool keepVoiceSet = false;    //ボイスセット設定を記憶
          public bool keepKissVoiceSet = true; //キスボイスセット設定を記憶 フェード終了時に毎回自動設定しない
          public bool camCheckVoiceEnabled = false; //顔に近づいたときにキスボイスを再生する（【カメラの距離判定機能】「距離とキスボイスを連動」）

          //キスボイス自動設定 上から順に判定(空文字なら次の条件) "なし"等の指定でファイルが存在しない名称はボイス無し <camCheckVoiceEnabled>true のときに自動再生
          public string autoKissVoiceSetMarried  = "キス(結婚)"; //結婚
          public string autoKissVoiceSetSlave = "キス(慣れ)"; //愛奴
          public string autoKissVoiceSetLover = "キス(慣れ)"; //恋人
          public string autoKissVoiceSetLoverVirgin = "キス(慣れ)"; //処女恋人
          public string autoKissVoiceSetTrust = "キス(初々)";   //信頼
          public string autoKissVoiceSetTrustVirgin = "キス(初々)"; //非処女信頼
          public string autoKissVoiceSetInnocent = "キス(初々)"; //上記以外
          //メイド個別指定 姓名の間のスペースは無し 空文字ならボイスなし
          public string[][] autoKissVoiceSetMaid = new string[][]{};
          //設定例:
          // <autoKissVoiceSetMaid>
          //   <ArrayOfString><string><string>聖道まりあ</string><string>キス(初々)</string></ArrayOfString>
          //   <ArrayOfString><string><string>猪狩いたみ</string><string>キス(嫌悪)</string></ArrayOfString>
          //   <ArrayOfString><string><string>雛口紗姫</string><string></string></ArrayOfString>
          // </autoKissVoiceSetMaid>

          public bool sotodashiReactionPlay = true; //UNZIPで外出し時にボイスを再生するならtrue
          public string sotodashiVoiceSet = "絶頂(外出し)"; //UNZIPで外出し時(「抜く」選択後の射精時)に再生するボイスセット 
          public string kaodashiVoiceSet = "絶頂(顔射)";    //UNZIPでフェラ状態での射精時に再生するボイスセット (口の状態と射精タイプで自動切換え)
          
          public bool voiceSetPlayTangOff = true; //ボイスセット再生時に舌を引っ込める フェラ状態でない場合のみ
          public bool voiceSetPlayLipSync = true; //ボイスセット再生時にリップシンク強制ON フェラ状態でない場合のみ

          public bool UndressingReaction = true; //脱衣時のリアクション


          //メイド切り替え
          public bool CamChangeEnabled = true;
          public float cameraChangeDistance = 1.5f;      //メイド切り替え時の距離 0なら距離は変更しない
          public int cameraChangeTurn = 0;               //カメラジャンプ時の回転 (0=回転なし 1=body0の正面 2=顔の正面)
          //メイド切り替え 左右位置のメイド
          public bool besideMaidTarget = true;           //メイド切り替えをメイド順ではなく対象メイドの左右位置のメイドに切り替える(3人以上の場合)
          public bool besideMaidOpposite = true;         //左右メイド選択の場合 一番端の場合は反対側のメイドを選択
          public float besideMaidCorrectZ = 0.01f;       //左右メイド選択の場合 前後の距離を左右に加算して遠くする割合 手前が優先される 2乗した値を設定
          //メイド選択
          public float lookingMaidBodyRadius = 0.25f;    //正面のメイド取得時の体の半径  距離に応じて幅の分だけ中央寄りにする

          //メイド固定
          public int maidFollowLookPoint = 0;              //メイド固定のデフォルトの注視点 (胸:0 顔:1 腰:2)
          public float maidFollowKeepHeightTop = 0.1f;     //メイド固定時の高さ戻り許容範囲 上側 メートル
          public float maidFollowKeepHeightBottom = 0f;    //メイド固定時の高さ戻り許容範囲 下側 メートル (0以上で設定)
          public bool maidFollowCameraAdjust = true;       //メイド固定開始時のカメラ位置の調整 trueならHMDの位置と向きに合わせてメイド固定開始 GripMoveの移動量もリセット 正面も変わる
          public bool maidFollowDisabledDanceStart = true; //ダンス開始時にメイド固定を解除
          public float maidFollowSpeed = 1f;               //メイド固定追従速度
          public float maidFollowAngleSpeed = 1f;          //メイド固定アングル回転速度
          public float maidFollowAngleHeightRate = 1.0f;   //アングル固定時の上下変動倍率 (顔のみ) 上下向きに応じた高さこの倍率で変更する
          public float maidFollowAngleHeightLimit = 1.0f;  //VRでのアングル固定時の上下方向の移動制限制限 メイドから離れたときの変動しすぎないようにする
          public float maidFollowAngleHeightLimitBottom = -1.0f;
          public float cameraMoveReturnSpeedY = 1f;        //メイド固定時のカメラ高さ方向の戻り速度 0なら高さは戻らなくなる 5で通常速度 メイド切り替え時は常に通常速度

          //1人称視点
          public bool fpsManChange = true;        //1人称視点自動変更有効 falseなら1人目固定 trueならフェード解除時と男表示切替操作時に最初に表示されている男を1人称視点対象とする
          public float fpsManHeadOffsetY = 0.1f;  //1人称視点の上下位置オフセット 上が+
          public float fpsManHeadOffsetZ = 0.0f;  //1人称視点の前後位置オフセット 前が+
          public bool fpsHideManHead = true;      //1人称視点で男の頭を消す
          public bool fpsHideNewManHead = true;   //1人称視点で男新ボディの顔を消す

          //おさわり
          public bool osawariEnabled = false;
          public bool osawariAlways = false;       //常時おさわり
          public float osawariMoveRate = 1.0f;
          public string osawariButton = "AX";      //VRおさわりボタン (AX,BY,Tigger,Grip)
          public float osawariRelease = 0.2f;      //VRのおさわり解除距離
          public float osawariHandRadius = 0.015f; //手の当たり判定の球半径
          public float osawariHSliderMin = 20f;    //おさわり挿入後のスライダ最小値 前
          public float osawariASliderMin = 15f;    //おさわり挿入後のスライダ最小値 後
          public float osawariSensitive = 1.0f;     //興奮レベルの上がる感度
          public float osawariHoleSensitive = 2.0f; //前後の穴の感度増量
          //おさわりレベルがこれより低ければモーション変更はキャンセル
          //0→触ったらすぐに反応  1→少し動かすと反応 2→そこそこ動かすと反応  3→モーションは変わらない
          public int osawariGamanLevel = 0;
          //おさわりの尻の可動範囲
          public float osawariMoveHipCkackT1 = 0.3f;
          public float osawariMoveHipTypeA = 0.3f;
          public float osawariMoveHipTypeV = 0.3f;
          public float osawariMoveSlimHip1 = 0.3f;
          public float osawariMoveSlimHip2 = 0.3f;
          public float osawariMoveSlimOsihri = 0.2f;
          public float osawariMoveDebuPelvisX = 0.3f;

          //胸変形の基準値 ノーマルボディ用 横と縦
          public float jbMuneMoveRatioX = 50f;
          public float jbMuneMoveRatioY = 60f;
          #if COM3D2_5
          //胸変形の基準値 CRCボディ用 横と縦
          public float dbMuneMoveRatioX = 200f;
          public float dbMuneMoveRatioY = 100f;
          #endif

          //胸と腕の衝突判定
          public bool muneYoriEnabled = false;
          public bool muneYoriEditSecneEnabled = false; //エディットシーンでも有効にする
          //調整用Gizmo表示
          public bool muneDrawGizmo = false;

          //変形速度 目標位置まで1秒で移動する距離の倍率 毎フレーム実行ごとに距離が短くなるため近づくほど遅くなる
          public float muneMoveSpeedTime = 10f;
          public float muneMoveSpeedAmp = 20f;

          //衝突時の移動量倍率
          public float muneMoveRatioX = 1.2f;
          public float muneMoveRatioY = 0.7f;
          public float muneMoveLimitX = 1.0f; //Ratioの倍率になる前にこの倍率で制限
          public float muneMoveLimitY = 0.6f; //Ratioの倍率になる前にこの倍率で制限
          //移動量の両端を2次曲線にするときの0～1の分割位置
          public float muneCurvePointX = 0.7f;
          public float muneCurvePointY = 0.5f;

          //腕側の判定原点オフセット Yはサイズでの補正あり
          public float muneArmX   =  0.0f;  //左右 外が+
          public float muneArmY   = -0.01f; //上下 上が+
          public float muneArmZ   =  0.0f;  //前後 前が+

          //胸の回転 胸寄り50のときの正面に対する胸の角度
          public float muneAngleX =  5.0f; //X軸 +で前が上がる
          public float muneAngleY = 22.5f; //Y軸 +で外に広がる 胸寄り設定値がこれに加算される
          public float muneAngleZ =  0.0f; //Z軸 基本は0 正面から見て時計回りが+

          //Mune L/R の原点からの範囲 (単位メートル)
          //左右座標 (外側が+)
          public float muneOutside     =  0.09f; //乳外端
          public float muneCenterX     = -0.01f; //乳の左右の中心
          //上下座標 (上が+)
          public float muneTop         =  0.07f; //乳上側高さ
          public float muneCenterY     = -0.02f; //乳の上下の中心
          public float muneBottom      = -0.09f; //乳下側高さ
          //前後座標 (前が+)
          public float muneFront       =  0.12f; //乳前
          public float muneCenterZ     =  0.04f; //乳中心 前  (muneCenterBackZまで直線になる)
          public float muneCenterBackZ =  0.02f; //乳中心 後方  (下げると後ろ側の移動量が増える)
          public float muneBack        = -0.04f; //乳後  胴体の真ん中～後ろのあたり
          //乳上下 乳下げ時に利用
          public float muneDownOutside =  0.06f; //乳下げ時の横幅
          public float muneDownCenterX = -0.01f; //乳下げ時の左右中心
          public float muneDownTop     =  0.07f; //乳下げ時の高さ 上側
          public float muneDownCenterY =  0.0f;  //乳下げ時の上下中心  (乳の中心より上寄 乳下げはここが最大になる)
          public float muneDownBottom  = -0.02f; //乳下げ時の高さ 下側
          public float muneDownFront   =  0.12f; //乳下げ時の前
          public float muneDownCenterZ =  0.04f; //乳下げ時の前後中心
          public float muneDownBack    =  0.0f;  //乳下げ時の後

          //胸サイズに応じた拡大 (単位cm) (胸サイズに1:1で比例) 40以下は補正なし (0.02なら 40以下:-0.2cm 50:0cm 70:0.4cm 100:1cm 150:2cm)
          public float muneArmOffsetY  = 0.02f;  //胸サイズ+1での腕の原点の下移動量
          public float muneSizeExpandX = 0.02f;  //胸サイズ+1での横拡張量
          public float muneSizeExpandY = 0.05f;  //胸サイズ+1での下移動量 bottomのみ下がる
          public float muneSizeExpandZ = 0.07f;  //胸サイズ+1での前拡張量
          //胸位置に応じた移動量 (単位cm) (サイズで補正あり 0→0倍 50→1倍 100→2倍)
          public float muneUpDownAdjust = 0.01f; //胸上下+1での上への移動量
          public float muneTareAdjust   = 0.01f; //胸たれ+1での下への移動量


          //胸位置の球状のコライダー 各コライダー（前腕、竿、ポール、VRハンド）との当たり判定用  VR用は入れ替える
          public bool muneColliderEnabled = false;        //胸コライダー有効
          public float muneColliderRadiusExpand = 0.025f; //胸コライダー半径拡張
          public float muneColliderOffsetX = -0.02f;      //胸コライダー位置 左右 +が外
          public float muneColliderOffsetY = -0.02f;      //胸コライダー位置 上下 +が上
          public float muneColliderOffsetZ = -0.055f;     //胸コライダー位置 前後 +が前
          public float muneColliderOffsetCrcX = -0.03f;   //胸コライダー位置 左右 CRCボディ用
          public float muneColliderOffsetCrcY = -0.0f;    //胸コライダー位置 上下 CRCボディ用
          public float muneColliderOffsetCrcZ = -0.08f;   //胸コライダー位置 前後 CRCボディ用
          public float muneColliderOffsetXRatio = 0.8f;   //胸コライダー左右補正倍率 半径増加分をこの倍率で外側に移動する
          public float muneColliderOffsetYRatio = 1.0f;   //胸コライダー上下補正倍率 半径増加分をこの倍率で下に移動する 胸サイズ50以下は補正しない
          public float muneColliderOffsetZRatio = 2.0f;   //胸コライダー前後補正倍率 半径増加分をこの倍率で前に移動する
          //胸のコライダーでの稼働範囲
          public float muneColliderFrontLimit = 0f;       //胸コライダー 前側移動制限 +で通常位置より前に出る
          public float muneHitLimitDistanceMin = 0.01f;   //胸のコライダーでの稼働範囲 0.01
          public float muneHitLimitDistanceMax = 0.06f;   //胸のコライダーでの稼働範囲 0.04 大きいほど凹む
          //胸コライダーのばね設定 (UnityのSpringJointの設定)
          public float muneColliderSpring = 300f;         //ばねの弾性力 (初期値:500)
          public float muneColliderDamper = 0.5f;         //バネの力を減衰するのに使用します (初期値:0.5)
          public float muneColliderMinDistance = 0f;      //身体からの距離の初期値に対する最小距離 (初期値:0)
          public float muneColliderMaxDistance = 0f;      //身体からの距離の初期値に対する最大距離 (初期値:0)
          public float muneColliderTolerance = 0.001f;    //現在のばねの長さと minDistance と maxDistance によって定義される長さの間の最大許容誤差 (初期値:0.001)
          //前腕コライダー
          public bool muneHitForearmEnabled = true;       //前腕コライダー有効
          public float muneHitForearmRadius = 0.015f;     //前腕側のコライダーの半径 m
          public float muneHitForearmLength = 0.21f;      //前腕側のコライダーの長さ m
          public float muneHitForearmOffsetX =  0.01f;    //前腕側のコライダーの位置 m
          public float muneHitForearmOffsetY = -0.005f;   //前腕側のコライダーの位置 m +が指先側
          public float muneHitForearmOffsetZ =  0.0f;     //前腕側のコライダーの位置 m 右は反転
          public float muneHitForearmAngleX = 4f;         //前腕側のコライダーの角度
          public float muneHitForearmAngleZ = 0f;         //前腕側のコライダーの角度
          //竿のコライダー
          public bool muneHitChinkoEnabled = true;        //竿のコライダー有効
          public float muneHitChinkoCheckInterval = 1.0f; //男の表示状態チェック間隔の秒数
          public bool muneHitChinkoCheckVisible = true;   //竿のコライダーの表示状態に連動して有効無効切り替え falseにすると非表示でもコライダー有効
          public float muneHitChinkoRadius = 0.015f;      //竿のコライダーの半径 m
          public float muneHitChinkoLength = 0.20f;       //竿のコライダーの長さ m
          public float muneHitChinkoOffsetX = -0.08f;     //竿のコライダーの位置 m
          public float muneHitChinkoOffsetY = -0.002f;    //竿のコライダーの位置 m
          public float muneHitChinkoAngle = 93f;          //竿のコライダーの角度 +で上 反り返る分を少し上に
          public bool muneHitChinkoDisabledDanceStart = true;  //ダンス開始時に竿のコライダーと男の表示状態チェックを無効にする 開始前にONなら終了後に戻す
          //VRコントローラー
          public bool muneTouchColliderEnabled = true;    //VRコントローラーの胸のあたり判定有効
          public float muneTouchColliderRadius = 0.03f;   //VRコントローラーのコライダーサイズ (初期値:0.05)
          public bool muneTouchColliderDisabledDanceStart = true;  //ダンス開始時にVRコントローラーのコライダーを無効にする 開始前にONなら終了後に戻す
          //カメラコライダー
          public bool camColliderEnabled = true;      //カメラ位置にコライダー設定
          public float camColliderRadius = 0.1f;      //カメラ位置のコライダーサイズ
          public float camColliderOffsetY = -0.05f;   //カメラ位置のコライダー上下オフセット
          public float camColliderOffsetZ = 0f;       //カメラ位置のコライダー前後オフセット +が前
          public bool camColliderDisabledDanceStart = true;  //ダンス開始時にカメラ位置のコライダーを無効にする 開始前にONなら終了後に戻す
          //ポールダンスのポール
          public float muneHitPoleRadius = 0.03f;     //ポールの太さ 実サイズは半径2.5cm あまり当たらないので少し太くする 0以下なら無効


          //VRショートカット
          public bool vrShortCut = false;                 //VRショートカット有効
          //トリガー・グリップは文字列で設定 (左トリガー:LT , 右トリガー:RT , 左グリップ:LG , 右グリップ:RG , 常時有効:ALWAYS , それ以外なら操作無効)
          public string vrShortCutFollowOn = "RT";        //VRメイド固定 開始 右トリガー(変更可) + AXボタンでメイド固定ON (固定開始時にHMD中央のメイドに自動切換え)
          public string vrShortCutFollowOff = "RG";       //VRメイド固定 解除 右グリップ(変更可) + AXボタンでメイド固定OFF (※開始と同じボタンならトグル動作になる)
          public string vrShortCutMaidTarget = "RT";      //VRメイド切替 トリガー+スティック左右でメイド切り替え
          public string vrShortCutMaidFocus = "RTG";       //VRメイド切替 メイド切り替え時にカメラをメイドの近くにジャンプさせる
          public string vrShortCutVibe = "RG";            //VRバイブ操作 グリップ+スティック上下で強弱切 (※トリガーとグリップ同時押し時は動作しない)
          public string vrShortCutMotion = "RTG";         //VRモーション切替 ボタンとスティック上下 LT,LG,LTG,RT,RG,RTG 設定時のみ有効

          //VRカメラ移動
          public string vrCameraFreeMoveMode = "GRIP";    //自由移動時の移動モード 移動処理は "GRIP"→GripMoveと同じ "HAND"→HANDモードと同じ "TRACKING"→HMD移動と同じ(非推奨)
          public bool vrCameraMoveHeadDirection = false;  //VR自由移動をHMDの向きに合わせる
          public bool vrCameraMoveHeadFixHeight = true;   //VR自由移動をHMDの向きに合わせたとき前後左右スティックでは上下方向は移動させない
          public float vrCamSetDistanceAdjust = 2.0f;     //VRだとSetDistanceで2倍にする必要がある

          //最短距離制限
          public bool vrCameraMoveLimit = true;           //自由移動中の最短距離制限 (GRIPの時のみ有効)
          public bool vrCameraMoveLimitAlways = false;    //グリップ等の操作なしでも常時最短距離制限を有効にする
          public float vrCameraMoveLimitDistance = 0.5f;  //最短距離制限時の対象メイドまでの最短距離
          public bool vrCameraMoveLimitHorizontal = true; //正面方向の水平距離で制限 メイドが横にいても正面方向のみで判定 falseならメイドがカメラの上下にいるときの角度も考慮
          public float vrCameraMoveLimitMaidHeadOffsetY = 0.1f; //仰角方向含めた距離制限時に頭の上下の中心を補正
          public float vrCameraMoveLimitMaidHeadOffsetZ = 0f;   //仰角方向含めた距離制限時に頭の前後の中心を補正

          //最短距離制限対象メイド自動切替
          public string vrFrontMaidTrigger = "RG";    //正面判定の制御変更 このボタン+カメラ移動制限トリガー+スティック上→強制正面チェック スティック下→正面の判定範囲を拡大 (範囲外判定は無効)
          public bool vrFrontMaidCenter = true;      //trueなら中央寄りのメイドを取得 falseなら範囲内の近くのメイドを優先
          public float vrFrontMaidAngle = 20f;        //正面のメイド判定 正面左右の角度（カメラ位置から） グリップorカーソル上時
          public float vrFrontMaidBackward = 0.5f;    //正面のメイド判定 角度原点後方移動量 グリップorカーソル上時
          //public float vrFrontMaidExtendAngle = 80f;  //正面のメイド判定 拡大時 正面左右の角度 スティック下時（自由移動前の位置から）
          //public float vrFrontExtendBackward = 3.0f;  //正面のメイド判定 拡大時 角度原点後方移動量 スティック下時
          public bool vrOutsideMaidChange = true;        //対象のメイドがカメラ範囲外になった時に正面のメイドに切り替える
          //public bool vrOutsideMaidChangeAlways = false; //正面のメイド判定を制御するボタンを押していなくても範囲外チェックを実行する
          public float vrOutsideMaidAngle = 15f;         //カメラ範囲外判定 正面左右の角度（カメラ位置から） 0なら正面メイドにすぐに切り替え
          public float vrOutsideMaidFrontAngle = 10f;    //カメラ範囲外 正面メイド取得角度（カメラ位置から）
          public float vrOutsideMaidBackward = 0.1f;     //カメラ範囲外判定 角度原点後方移動量
          public bool vrAutoMaidChange = true;        //カメラジャンプ時に正面のメイドに切り替える
          public float vrAutoMaidAngle = 20f;         //カメラジャンプ時の正面メイド判定 HMD正面左右の角度（自由移動前の位置から）
          public float vrAutoMaidBackward = 0.5f;     //カメラジャンプ時の正面メイド判定位置 自由移動前の初期位置を後ろへ移動する
          public bool vrAutoMaidRetry = true;         //カメラジャンプ時の正面メイド判定 取得できない場合は倍の範囲で再取得する
          public float vrAutoMaidRetryAngle = 30f;    //カメラジャンプ時の正面メイド判定 再取得時の角度

          //カメラジャンプ
          public float vrCameraJumpDistance = 0.3f;  //前のフレームのカメラ位置からの移動距離(m) これより移動していたらカメラジャンプと判定する
          public bool vrCameraJumpFixPos = true;     //カメラジャンプ時は常に位置をリセットする（高さずれの位置調整しない場合のカメラジャンプ時）
          public bool vrCameraJumpFixPosX = true;    //カメラジャンプ時に左右を初期位置に戻す
          public bool vrCameraJumpFixPosY = true;    //カメラジャンプ時に高さを初期位置に戻す
          public bool vrCameraJumpFixPosZ = true;    //カメラジャンプ時に前後を初期位置に戻す
          public bool vrCameraJumpFixRot = true;     //カメラジャンプ時に回転をリセットする
          public string vrCameraJumpFixCancelButton = "RT"; //前後位置リセットとズーム補正を無視するボタン (RT,LT,A,X,設定なしなら無効)
          public float vrCameraJumpFixPosZoomRate = 0.5f;   //ズーム補正の割合 前後のリセット時に対象メイドとの水平距離に応じた割合近づける
          public float vrCameraJumpFixPosZoomLimit = 0.5f;  //ズーム補正制限 対象メイドとカメラの距離がこれより近い場合はズーム補正を行わない ズーム補正量も制限距離分少なくなる
          public bool vrCameraJumpAdjustHeight = true;       //カメラジャンプ時に高さ補正をする(初期位置にリセット+高さ補正) 
          public float vrCameraJumpAdjustHeightTh = 1f;      //高さずれ判定用の高さ この高さよりメイドが下にいる場合カメラ位置を補正する
          public float vrCameraJumpAdjustHeightRate = 0.3f;  //高さずれ補正時にカメラ位置を下げる対象メイドの顔とカメラの高さの割合
          public float vrCameraJumpAdjustHeightZRate = 0.1f; //メイドからの距離を判定高に加算するときの係数 後ろに下がるほど判定高が高くなる

          public float vrBaseHeadHeightGap = -0.9f; //初期位置に戻す時にSteamVRでBaseHeadとBaseRoomの高さずれ補正

          //トリガー・グリップは文字列で設定 (左トリガー:LT , 右トリガー:RT , 左グリップ:LG , 右グリップ:RG , それ以外なら操作無効)
          public string vrCameraSpeedTrigger = "LT";     //VRカメラ移動速度トリガー トリガー/グリップが押されている場合のみスティック移動が有効
          public string vrCameraMoveLimitTrigger = "LT"; //VRカメラ移動制限トリガー
          //スティック感度
          public float vrCameraSpeedStickMargin = 0.1f; //移動時のスティックの遊び これ以下は無視され遊び位置が0になる
          public float vrCameraSpeedStart = 0.05f;     //VRカメラ移動開始速度トリガーの入力開始時の速度 (トリガーの遊びを設定しているため)
          public float vrCameraSpeedMax = 1.0f;        //VRカメラ移動速度の倍率
          public string vrCameraBreakTrigger = "LG";   //VRカメラ移動速度減速グリップ ↑のトリガーと同時押しで有効
          public float vrCameraBreakSpeed = 0.25f;     //減速最大時の速度 1より大きい場合は加速する
          public float vrCameraMoveZoomMin = 0.3f;     //メイド固定時のズーム時の最短距離
          //各スティックのコントローラーと速度 (左:L 右:R それ以外ならスティック操作無効)
          public string vrCameraMoveStickZoom = "L";   //ズーム   スティック上下
          public string vrCameraMoveStickUD = "R";     //上下移動 スティック上下
          public string vrCameraMoveStickAround = "L"; //周回     スティック左右 (メイド固定時)
          public string vrCameraMoveStickLR = "L";     //左右移動 スティック左右 (メイド固定解除時)
          public string vrCameraMoveStickTurn = "R";   //左右回転 スティック左右 (メイド固定解除時)

          //移動速度倍率 メイド固定時
          public float vrCameraFollowSpeedZoom = 1f;   //移動速度倍率 ズーム (メイド固定時)
          public float vrCameraFollowSpeedAround = 1f; //移動速度倍率 周回 (メイド固定時)
          public float vrCameraFollowSpeedUD = 0.8f;   //移動速度倍率 上下移動 (メイド固定時)
          //public float vrCameraFollowSpeedLR = 1f;     //移動速度倍率 左右移動 (メイド固定時)
          public float vrCameraFollowSpeedDistanceRate = 0.5f; //距離による速度調整係数

          //移動速度倍率 自由移動時
          public float vrCameraMoveSpeedZoom = 1.5f;   //移動速度倍率 ズーム
          public float vrCameraMoveSpeedUD = 0.8f;     //移動速度倍率 上下移動
          public float vrCameraMoveSpeedLR = 1f;       //移動速度倍率 左右移動
          public float vrCameraMoveSpeedTurn = 0.6f;   //移動速度倍率 左右回転

          #if DOF
          //被写界深度設定 DepthOfFieldScatterの初期値
          public bool DepthEnabled = false;
          public float DepthDistanceCloseLimit = 1f;      //距離接近時のボケ制限 これより近くてもこの距離でのボケ量になる
          public float DepthDistanceCorrectRate = 0.5f;     //距離補正の倍率  0なら距離補正なし 0.5なら半分の距離と同じボケになる
          public float DepthFocalTransformRadius = 0.05f; //頭の半径 中心からこの距離分手前で判定
          public float DepthFocalTransformTime = 0.3f;    //フォーカス対象をスムーズに切り替える時間
          public bool DepthHighResolution = false; //高解像度
          public int DepthBlurSample = 0; // 0=Low 1=Midium 2=High  DX11では未使用
          //public bool DepthNearBlur = false; //フォーカス前後のの近くがホケなくなる → 常時false
          public float DepthMaxBlurSize = 1f;  //初期値:2 ボケが汚くなるので小さく
          public float DepthFocalSize = 0.05f; //初期値:0.05 ピントの合う範囲
          public float DepthAperture = 11.5f;    //ボケ量 f値ではなく大きいほどボケる VRは平面より小さめに設定
          public float DepthForegroundOverlap = 1f; //手前側のボケを増やす
          public bool DepthDX11 = true;
          public float DepthDx11Threshhold = 0.5f;
          public float DepthDx11SpawnHeuristic = 0.0875f;
          public float DepthDx11BokehScale = 1.2f;
          public float DepthDx11BokehIntensity = 2.5f;
          #endif

          //モーションリストをファイルに出力 すでにファイルがあれば出力しない
          public bool outputMotionList = false;

        }

        VibeYourMaidCfgWriting cfgw = new VibeYourMaidCfgWriting();


        #region VoiceSet
          public BasicVoiceSet[] bvs;
          /// <summary>
          /// 各性格の音声設定 ベースクラス
          /// BasicVoiceSet に性格毎のXMLファイルで保存される
          /// </summary>
          public class BasicVoiceSet
          {
            //弱バイブ　通常
            public string[][] sLoopVoice20Vibe;
            //弱バイブ　フェラ
            public string[][] sLoopVoice20Fera;
            //強バイブ　通常
            public string[][] sLoopVoice30Vibe;
            //強バイブ　フェラ
            public string[][] sLoopVoice30Fera;
            //絶頂　通常
            public string[][] sOrgasmVoice30Vibe;
            //絶頂　フェラ
            public string[][] sOrgasmVoice30Fera;
            //停止時
            public string[] sLoopVoice40Vibe;

            //各性格のクラスでオーバーライドされる
            public BasicVoiceSet()
            {
              sLoopVoice20Vibe = new string[][]{};
              sLoopVoice20Fera = new string[][]{};
              sLoopVoice30Vibe = new string[][]{};
              sLoopVoice30Fera = new string[][]{};
              sOrgasmVoice30Vibe = new string[][]{};
              sOrgasmVoice30Fera = new string[][]{};
              sLoopVoice40Vibe = new string[]{};
            }
            //getBaseから利用
            public BasicVoiceSet(string[][] v1, string[][] v2, string[][] v3, string[][] v4, string[][] v5, string[][] v6, string[] v7)
            {
              sLoopVoice20Vibe = v1;
              sLoopVoice20Fera = v2;
              sLoopVoice30Vibe = v3;
              sLoopVoice30Fera = v4;
              sOrgasmVoice30Vibe = v5;
              sOrgasmVoice30Fera = v6;
              sLoopVoice40Vibe = v7;
            }
            //XML出力用に親クラスを返す
            public BasicVoiceSet getBase()
            {
              return new BasicVoiceSet(sLoopVoice20Vibe, sLoopVoice20Fera, sLoopVoice30Vibe, sLoopVoice30Fera, sOrgasmVoice30Vibe, sOrgasmVoice30Fera, sLoopVoice40Vibe);
            }
          }

            //性格別声テーブル　ツンデレ---------------------------------------------------------------
            class BasicVoicePride : BasicVoiceSet { public BasicVoicePride() {
              //弱バイブ　通常
              sLoopVoice20Vibe = new string[][] {
              new string[] { "S0_01244.ogg" , "S0_01245.ogg" , "S0_01252.ogg" , "S0_01253.ogg" , "s0_01236.ogg" , "s0_01237.ogg" },
              new string[] { "S0_01236.ogg" , "S0_01237.ogg" , "S0_103950.ogg", "S0_103951.ogg", "s0_01238.ogg" , "s0_01239.ogg" },
              new string[] { "S0_01246.ogg" , "S0_01247.ogg" , "S0_01254.ogg" , "S0_01255.ogg" },
              new string[] { "S0_01238.ogg" , "S0_01239.ogg" , "S0_103952.ogg", "S0_103953.ogg" },
              //new string[] { "S0_01268.ogg" , "S0_01269.ogg" , "S0_01270.ogg" , "S0_01271.ogg" } //ca001e(L0-L3)首絞め
              new string[] { "S0_01296.ogg" , "S0_01297.ogg" , "S0_01304.ogg" , "S0_01305.ogg" }
              };
              //弱バイブ　フェラ
              sLoopVoice20Fera = new string[][] {
              new string[] { "S0_01383.ogg" , "S0_01367.ogg" , "S0_01384.ogg" , "S0_01369.ogg" },
              new string[] { "S0_01383.ogg" , "S0_01367.ogg" , "S0_01384.ogg" , "S0_01369.ogg" },
              new string[] { "S0_01383.ogg" , "S0_01367.ogg" , "S0_01384.ogg" , "S0_01369.ogg" },
              new string[] { "S0_01383.ogg" , "S0_01367.ogg" , "S0_01384.ogg" , "S0_01369.ogg" },
              new string[] { "S0_01383.ogg" , "S0_01367.ogg" , "S0_01384.ogg" , "S0_01369.ogg" }
              };
              //強バイブ　通常
              sLoopVoice30Vibe = new string[][] {
              new string[] { "S0_01248.ogg" , "S0_01249.ogg" , "S0_01255.ogg" , "S0_01256.ogg" },
              new string[] { "S0_01240.ogg" , "S0_01241.ogg" , "S0_103954.ogg", "S0_103955.ogg", "s0_01326.ogg" , "s0_01327.ogg" },
              new string[] { "S0_01250.ogg" , "S0_01251.ogg" , "S0_01257.ogg" , "S0_01258.ogg" , "s0_01330.ogg" , "s0_01331.ogg" },
              new string[] { "S0_01242.ogg" , "S0_01243.ogg" , "S0_103956.ogg", "S0_103957.ogg" },
              //new string[] { "S0_01272.ogg" , "S0_01273.ogg" , "S0_01274.ogg" , "S0_01275.ogg" } //ca001e(L4-L7)首絞め
              new string[] { "S0_01298.ogg" , "S0_01299.ogg" , "S0_01306.ogg" , "S0_01307.ogg" }
              };
              //強バイブ　フェラ
              sLoopVoice30Fera = new string[][] {
              new string[] { "S0_01385.ogg" , "S0_01371.ogg" , "S0_01386.ogg" , "S0_01387.ogg" },
              new string[] { "S0_01385.ogg" , "S0_01371.ogg" , "S0_01386.ogg" , "S0_01387.ogg" },
              new string[] { "S0_01385.ogg" , "S0_01371.ogg" , "S0_01386.ogg" , "S0_01387.ogg" },
              new string[] { "S0_01385.ogg" , "S0_01371.ogg" , "S0_01386.ogg" , "S0_01387.ogg" },
              new string[] { "S0_01383.ogg" , "S0_01367.ogg" , "S0_01384.ogg" , "S0_01369.ogg" }
              };
              //絶頂　通常
              sOrgasmVoice30Vibe = new string[][] {
              new string[] { "s0_01898.ogg" , "s0_01899.ogg" , "s0_01902.ogg" , "s0_01900.ogg" },
              new string[] { "s0_01913.ogg" , "s0_01918.ogg" , "s0_01919.ogg" , "s0_01917.ogg" , "S0_104118.ogg", "S0_104122.ogg" },
              new string[] { "s0_09072.ogg" , "s0_09070.ogg" , "s0_09099.ogg" , "s0_09059.ogg" ,
                             "S0_104554.ogg", "S0_17233.ogg" , "S0_00774.ogg" ,
                             "s0_01913.ogg" , "s0_01918.ogg" , "s0_01919.ogg" , "s0_01917.ogg" , "S0_104118.ogg", "S0_104122.ogg" }, //2行目と同じ
              new string[] { "s0_09067.ogg" , "s0_09068.ogg" , "s0_09069.ogg" , "s0_09071.ogg" , "s0_09085.ogg" , "s0_09086.ogg" , "s0_09087.ogg" , "s0_09091.ogg" ,
                             "S0_104554.ogg", "S0_17233.ogg" , "S0_00774.ogg" , //4行目と同じ
                             "S0_104564.ogg", "S0_104498.ogg", "S0_104504.ogg" },
              new string[] { "s0_01898.ogg" , "s0_01899.ogg" , "s0_01902.ogg" , "s0_01900.ogg" }
              };
              //絶頂　フェラ
              sOrgasmVoice30Fera = new string[][] {
              new string[] { "S0_01922.ogg" , "S0_01920.ogg" , "S0_01921.ogg" },
              new string[] { "S0_01922.ogg" , "S0_01920.ogg" , "S0_01921.ogg" },
              new string[] { "S0_01922.ogg" , "S0_01920.ogg" , "S0_01921.ogg" },
              new string[] { "S0_11361.ogg" , "S0_01931.ogg" , "S0_11350.ogg" , "S0_11349.ogg" },
              new string[] { "S0_01922.ogg" , "S0_01920.ogg" , "S0_01921.ogg" }
              };
              //停止時
              sLoopVoice40Vibe = new string[] { "S0_01967.ogg" , "S0_01968.ogg" , "S0_01968.ogg" , "S0_01969.ogg" , "S0_01969.ogg" };
            }}


            //性格別声テーブル　クーデレ---------------------------------------------------------------
            class BasicVoiceCool : BasicVoiceSet { public BasicVoiceCool() {
              //弱バイブ　通常
              sLoopVoice20Vibe = new string[][] {
              new string[] { "S1_02317.ogg" , "S1_02318.ogg" , "S1_02325.ogg" , "S1_02326.ogg" , "s1_02396.ogg" , "s1_02390.ogg" },
              new string[] { "S1_02309.ogg" , "S1_02310.ogg" , "S1_102717.ogg", "S1_102718.ogg", "s1_02391.ogg" , "s1_02392.ogg" },
              new string[] { "S1_02319.ogg" , "S1_02320.ogg" , "S1_02327.ogg" , "S1_02328.ogg" },
              new string[] { "S1_02311.ogg" , "S1_02312.ogg" , "S1_102719.ogg", "S1_102720.ogg" },
              //new string[] { "S1_02341.ogg" , "S1_02342.ogg" , "S1_02343.ogg" , "S1_02344.ogg" } //ca001e(L0-L3)首絞め
              new string[] { "S1_02369.ogg" , "S1_02370.ogg" , "S1_02377.ogg" , "S1_02378.ogg" }
              };
              //弱バイブ　フェラ
              sLoopVoice20Fera = new string[][] {
              new string[] { "S1_02455.ogg" , "S1_02440.ogg" , "S1_02457.ogg" , "S1_02442.ogg" },
              new string[] { "S1_02455.ogg" , "S1_02440.ogg" , "S1_02457.ogg" , "S1_02442.ogg" },
              new string[] { "S1_02455.ogg" , "S1_02440.ogg" , "S1_02457.ogg" , "S1_02442.ogg" },
              new string[] { "S1_02455.ogg" , "S1_02440.ogg" , "S1_02457.ogg" , "S1_02442.ogg" },
              new string[] { "S1_02455.ogg" , "S1_02440.ogg" , "S1_02457.ogg" , "S1_02442.ogg" }
              };
              //強バイブ　通常
              sLoopVoice30Vibe = new string[][] {
              new string[] { "S1_02321.ogg" , "S1_02322.ogg" , "S1_02329.ogg" , "S1_02330.ogg" },
              new string[] { "S1_02313.ogg" , "S1_02314.ogg" , "S1_102721.ogg", "S1_102722.ogg", "s1_02401.ogg" , "s1_02400.ogg" },
              new string[] { "S1_02323.ogg" , "S1_02324.ogg" , "S1_02331.ogg" , "S1_02332.ogg" , "s1_02402.ogg" , "s1_02404.ogg" },
              new string[] { "S1_02315.ogg" , "S1_02316.ogg" , "S1_102723.ogg", "S1_102724.ogg" },
              //new string[] { "S1_02345.ogg" , "S1_02346.ogg" , "S1_02347.ogg" , "S1_02348.ogg" } //ca001e(L4-L7)首絞め
              new string[] { "S1_02371.ogg" , "S1_02372.ogg" , "S1_02379.ogg" , "S1_02380.ogg" }
              };
              //強バイブ　フェラ
              sLoopVoice30Fera = new string[][] {
              new string[] { "S1_02458.ogg" , "S1_02459.ogg" , "S1_02444.ogg" , "S1_02460.ogg" },
              new string[] { "S1_02458.ogg" , "S1_02459.ogg" , "S1_02444.ogg" , "S1_02460.ogg" },
              new string[] { "S1_02458.ogg" , "S1_02459.ogg" , "S1_02444.ogg" , "S1_02460.ogg" },
              new string[] { "S1_02458.ogg" , "S1_02459.ogg" , "S1_02444.ogg" , "S1_02460.ogg" },
              new string[] { "S1_02455.ogg" , "S1_02440.ogg" , "S1_02457.ogg" , "S1_02442.ogg" }
              };
              //絶頂　通常
              sOrgasmVoice30Vibe = new string[][] {
              new string[] { "s1_03223.ogg" , "s1_03246.ogg" , "s1_03247.ogg" , "s1_03210.ogg" },
              new string[] { "s1_03214.ogg" , "s1_03215.ogg" , "s1_03216.ogg" , "s1_03209.ogg" , "S1_104637.ogg", "S1_100941.ogg" },
              new string[] { "s1_03207.ogg" , "s1_03205.ogg" , "s1_08993.ogg" , "s1_08971.ogg" ,
                             "S1_100945.ogg", "S1_101869.ogg", "S1_101750.ogg" ,
                             "s1_03214.ogg" , "s1_03215.ogg" , "s1_03216.ogg" , "s1_03209.ogg" , "S1_104637.ogg", "S1_100941.ogg" }, //2行目と同じ
              new string[] { "s1_09344.ogg" , "s1_09370.ogg" , "s1_09371.ogg" , "s1_09372.ogg" , "s1_09374.ogg" , "s1_09398.ogg" , "s1_09392.ogg" , "s1_09365.ogg" ,
                             "S1_100945.ogg", "S1_101869.ogg", "S1_101750.ogg" , //4行目と同じ
                             "S1_104903.ogg", "S1_100946.ogg", "S1_100953.ogg", "S1_100957.ogg", "S1_101537.ogg", "S1_103993.ogg", "S1_100933.ogg", "S1_103640.ogg" , "S1_104784.ogg"},
              new string[] { "s1_03223.ogg" , "s1_03246.ogg" , "s1_03247.ogg" , "s1_03210.ogg" }
              };
              //絶頂　フェラ
              sOrgasmVoice30Fera = new string[][] {
              new string[] { "S1_03219.ogg" , "S1_03218.ogg" , "S1_03228.ogg" },
              new string[] { "S1_03219.ogg" , "S1_03218.ogg" , "S1_03228.ogg" },
              new string[] { "S1_03219.ogg" , "S1_03218.ogg" , "S1_03228.ogg" },
              new string[] { "S1_11440.ogg" , "S1_11429.ogg" , "S1_11952.ogg" , "S1_19221.ogg" },
              new string[] { "S1_03219.ogg" , "S1_03218.ogg" , "S1_03228.ogg" }
              };
              //停止時
              sLoopVoice40Vibe = new string[] { "S1_03264.ogg" , "S1_03265.ogg" , "S1_03265.ogg" , "S1_03266.ogg" , "S1_03266.ogg" };
            }}


            //性格別声テーブル　純真---------------------------------------------------------------
            class BasicVoicePure : BasicVoiceSet { public BasicVoicePure() {
              //弱バイブ　通常
              sLoopVoice20Vibe = new string[][] {
              new string[] { "S2_01158.ogg" , "S2_01159.ogg" , "S2_01166.ogg" , "S2_01167.ogg" , "s2_01235.ogg" , "s2_01236.ogg" },
              new string[] { "S2_01150.ogg" , "S2_01151.ogg" , "S2_104161.ogg", "S2_104162.ogg", "s2_01237.ogg" , "s2_01238.ogg" },
              new string[] { "S2_01160.ogg" , "S2_01161.ogg" , "S2_01168.ogg" , "S2_01169.ogg" },
              new string[] { "S2_01152.ogg" , "S2_01153.ogg" , "S2_104163.ogg", "S2_104164.ogg" },
              new string[] { "S2_01182.ogg" , "S2_01183.ogg" , "S2_01184.ogg" , "S2_01185.ogg" } //ca001e(L4-L7)首絞め
              };
              //弱バイブ　フェラ
              sLoopVoice20Fera = new string[][] {
              new string[] { "S2_01296.ogg" , "S2_01281.ogg" , "S2_01298.ogg" , "S2_01282.ogg" },
              new string[] { "S2_01296.ogg" , "S2_01281.ogg" , "S2_01298.ogg" , "S2_01282.ogg" },
              new string[] { "S2_01296.ogg" , "S2_01281.ogg" , "S2_01298.ogg" , "S2_01282.ogg" },
              new string[] { "S2_01296.ogg" , "S2_01281.ogg" , "S2_01298.ogg" , "S2_01282.ogg" },
              new string[] { "S2_01296.ogg" , "S2_01281.ogg" , "S2_01298.ogg" , "S2_01282.ogg" }
              };
              //強バイブ　通常
              sLoopVoice30Vibe = new string[][] {
              new string[] { "S2_01162.ogg" , "S2_01163.ogg" , "S2_01170.ogg" , "S2_01171.ogg" },
              new string[] { "S2_01154.ogg" , "S2_01155.ogg" , "S2_104165.ogg", "S2_104166.ogg", "s2_01185.ogg" , "s2_01186.ogg" },
              new string[] { "S2_01164.ogg" , "S2_01165.ogg" , "S2_01172.ogg" , "S2_01173.ogg" , "s2_01187.ogg" , "s2_01188.ogg" },
              new string[] { "S2_01156.ogg" , "S2_01157.ogg" , "S2_104167.ogg", "S2_104168.ogg" },
              new string[] { "S2_01186.ogg" , "S2_01187.ogg" , "S2_01188.ogg" , "S2_01189.ogg" } //ca001e(L4-L7)首絞め
              };
              //強バイブ　フェラ
              sLoopVoice30Fera = new string[][] {
              new string[] { "S2_01299.ogg" , "S2_01300.ogg" , "S2_01285.ogg" , "S2_01301.ogg" },
              new string[] { "S2_01299.ogg" , "S2_01300.ogg" , "S2_01285.ogg" , "S2_01301.ogg" },
              new string[] { "S2_01299.ogg" , "S2_01300.ogg" , "S2_01285.ogg" , "S2_01301.ogg" },
              new string[] { "S2_01299.ogg" , "S2_01300.ogg" , "S2_01285.ogg" , "S2_01301.ogg" },
              new string[] { "S2_01296.ogg" , "S2_01281.ogg" , "S2_01298.ogg" , "S2_01282.ogg" }
              };
              //絶頂　通常
              sOrgasmVoice30Vibe = new string[][] {
              new string[] { "s2_01478.ogg" , "s2_01477.ogg" , "s2_01476.ogg" , "s2_01475.ogg" },
              new string[] { "s2_01432.ogg" , "s2_01433.ogg" , "s2_01434.ogg" , "s2_01436.ogg" , "S2_00713.ogg" },
              new string[] { "s2_09039.ogg" , "s2_09067.ogg" , "s2_09052.ogg" , "s2_08502.ogg" , "s2_103519.ogg",
                             "S2_104346.ogg", "S2_104720.ogg", "S2_104670.ogg", "S2_00715.ogg" , "S2_100074.ogg",
                             "s2_01432.ogg" , "s2_01433.ogg" , "s2_01434.ogg" , "s2_01436.ogg" , "S2_00713.ogg" }, //2行目と同じ
              new string[] { "s2_09047.ogg" , "s2_09048.ogg" , "s2_09049.ogg" , "s2_09050.ogg" , "s2_09051.ogg" , "s2_09066.ogg" , "s2_09069.ogg" , "s2_09073.ogg",
                             "S2_104346.ogg", "S2_104720.ogg", "S2_104670.ogg", "S2_00715.ogg" , "S2_100074.ogg",  //4行目と同じ
                             "S2_104730.ogg", "S2_100492.ogg", "S2_100488.ogg", "S2_100540.ogg", "S2_101263.ogg", "S2_104611.ogg", "S2_100265.ogg", "s2_103499.ogg", "s2_103507.ogg" },
              new string[] { "s2_01478.ogg" , "s2_01477.ogg" , "s2_01476.ogg" , "s2_01475.ogg" }
              };
              //絶頂　フェラ
              sOrgasmVoice30Fera = new string[][] {
              new string[] { "S2_01446.ogg" , "S2_01445.ogg" , "S2_01495.ogg" },
              new string[] { "S2_01446.ogg" , "S2_01445.ogg" , "S2_01495.ogg" },
              new string[] { "S2_01446.ogg" , "S2_01445.ogg" , "S2_01495.ogg" },
              new string[] { "S2_11371.ogg" , "S2_11370.ogg" , "S2_11358.ogg" , "S2_11347.ogg" },
              new string[] { "S2_01446.ogg" , "S2_01445.ogg" , "S2_01495.ogg" }
              };
              //停止時
              sLoopVoice40Vibe = new string[] { "s2_01491.ogg" , "s2_01492.ogg" , "s2_01492.ogg" , "s2_01493.ogg" , "s2_01493.ogg" };
            }}


            //性格別声テーブル　ヤンデレ---------------------------------------------------------------
            class BasicVoiceYandere : BasicVoiceSet { public BasicVoiceYandere() {
              //弱バイブ　通常
              sLoopVoice20Vibe = new string[][] {
              new string[] { "S3_02695.ogg" , "S3_02696.ogg" , "S3_02703.ogg" , "S3_02704.ogg" , "s3_02767.ogg" , "s3_02768.ogg" },
              new string[] { "S3_02687.ogg" , "S3_02688.ogg" , "S3_101125.ogg", "S3_101126.ogg", "s3_02769.ogg" , "s3_02770.ogg" },
              new string[] { "S3_02697.ogg" , "S3_02698.ogg" , "S3_02705.ogg" , "S3_02706.ogg" },
              new string[] { "S3_02689.ogg" , "S3_02690.ogg" , "S3_101127.ogg", "S3_101128.ogg" },
              new string[] { "S3_02747.ogg" , "S3_02748.ogg" , "S3_02755.ogg" , "S3_02756.ogg" } //ca001f(L4-L5)喪失 + ca001g(L4-L5)酔い
              };
              //弱バイブ　フェラ
              sLoopVoice20Fera = new string[][] {
              new string[] { "S3_02833.ogg" , "S3_02818.ogg" , "S3_02835.ogg" , "S3_02820.ogg" },
              new string[] { "S3_02833.ogg" , "S3_02818.ogg" , "S3_02835.ogg" , "S3_02820.ogg" },
              new string[] { "S3_02833.ogg" , "S3_02818.ogg" , "S3_02835.ogg" , "S3_02820.ogg" },
              new string[] { "S3_02833.ogg" , "S3_02818.ogg" , "S3_02835.ogg" , "S3_02820.ogg" },
              new string[] { "S3_02833.ogg" , "S3_02818.ogg" , "S3_02835.ogg" , "S3_02820.ogg" }
              };

              //強バイブ　通常
              sLoopVoice30Vibe = new string[][] {
              new string[] { "S3_02699.ogg" , "S3_02700.ogg" , "S3_02707.ogg" , "S3_02708.ogg" },
              new string[] { "S3_02691.ogg" , "S3_02692.ogg" , "S3_101129.ogg", "S3_101130.ogg", "s3_02797.ogg" , "s3_02798.ogg" },
              new string[] { "S3_02701.ogg" , "S3_02702.ogg" , "S3_02709.ogg" , "S3_02710.ogg" , "s3_02691.ogg" , "s3_02796.ogg" },
              new string[] { "S3_02693.ogg" , "S3_02694.ogg" , "S3_02757.ogg" , "S3_02758.ogg" }, //ca001g(L6,L7)酔い 入れ替え
              new string[] { "S3_02749.ogg" , "S3_02750.ogg" , "S3_101147.ogg", "S3_101148.ogg" } //ca001f(L6,L7)処女喪失 ca001k(L6,L7)発情奉仕
              };
              //強バイブ　フェラ
              sLoopVoice30Fera = new string[][] {
              new string[] { "S3_02836.ogg" , "S3_02837.ogg" , "S3_02822.ogg" , "S3_02838.ogg" },
              new string[] { "S3_02836.ogg" , "S3_02837.ogg" , "S3_02822.ogg" , "S3_02838.ogg" },
              new string[] { "S3_02836.ogg" , "S3_02837.ogg" , "S3_02822.ogg" , "S3_02838.ogg" },
              new string[] { "S3_02836.ogg" , "S3_02837.ogg" , "S3_02822.ogg" , "S3_02838.ogg" },
              new string[] { "S3_02833.ogg" , "S3_02818.ogg" , "S3_02835.ogg" , "S3_02820.ogg" }
              };
              //絶頂　通常
              sOrgasmVoice30Vibe = new string[][] {
              new string[] { "s3_02908.ogg" , "s3_02950.ogg" , "s3_02923.ogg" , "s3_02932.ogg" , "S3_02882.ogg" , "S3_02947.ogg" , "S3_02886.ogg" , "S3_02866.ogg" , "S3_101160.ogg" },
              new string[] { "s3_02909.ogg" , "s3_02910.ogg" , "s3_02915.ogg" , "s3_02914.ogg" , "S3_104995.ogg", "S3_104612.ogg" },
              new string[] { "s3_02905.ogg" , "s3_02906.ogg" , "s3_02907.ogg" , "s3_05540.ogg" ,
                             "S3_104994.ogg", "S3_104995.ogg", "S3_33652.ogg" , "S3_08304.ogg" , "S3_104853.ogg",
                             "s3_02909.ogg" , "s3_02910.ogg" , "s3_02915.ogg" , "s3_02914.ogg" , "S3_104995.ogg", "S3_104612.ogg" }, //2行目と同じ
              new string[] { "s3_05658.ogg" , "s3_05659.ogg" , "s3_05660.ogg" , "s3_05661.ogg" , "s3_05651.ogg" ,
                             "S3_104994.ogg", "S3_104995.ogg", "S3_33652.ogg" , "S3_08304.ogg" , "S3_104853.ogg", //4行目と同じ
                             "S3_104935.ogg", "S3_104936.ogg", "S3_102812.ogg" },
              new string[] { "s3_02908.ogg" , "s3_02950.ogg" , "s3_02923.ogg" , "s3_02932.ogg" , "S3_02882.ogg" , "S3_02947.ogg" , "S3_02886.ogg" , "S3_02866.ogg" , "S3_101160.ogg" }
              };
              //絶頂　フェラ
              sOrgasmVoice30Fera = new string[][] {
              new string[] { "S3_02919.ogg" , "S3_02918.ogg" , "S3_02928.ogg" },
              new string[] { "S3_02919.ogg" , "S3_02918.ogg" , "S3_02928.ogg" },
              new string[] { "S3_02919.ogg" , "S3_02918.ogg" , "S3_02928.ogg" },
              new string[] { "S3_03084.ogg" , "S3_03184.ogg" , "S3_03162.ogg" , "S3_18748.ogg" },
              new string[] { "S3_02919.ogg" , "S3_02918.ogg" , "S3_02928.ogg" }
              };
              //停止時
              sLoopVoice40Vibe = new string[] { "S3_02964.ogg" , "S3_02965.ogg" , "S3_02966.ogg" , "S3_02966.ogg" , "S3_02967.ogg" };
            }}


            //性格別声テーブル　お姉ちゃん---------------------------------------------------------------
            class BasicVoiceAnesan : BasicVoiceSet { public BasicVoiceAnesan() {
              //弱バイブ　通常
              sLoopVoice20Vibe = new string[][] {
              new string[] { "s4_08211.ogg" , "s4_08212.ogg" , "s4_08213.ogg" , "s4_08214.ogg" },
              new string[] { "S4_08127.ogg" , "S4_08128.ogg" , "S4_102930.ogg", "S4_102931.ogg"},
              new string[] { "S4_08137.ogg" , "S4_08138.ogg" , "S4_08129.ogg" , "S4_08130.ogg" },
              new string[] { "S4_08129.ogg" , "S4_08130.ogg" , "S4_102932.ogg", "S4_102933.ogg" },
              new string[] { "S4_08187.ogg" , "S4_08188.ogg" , "S4_08195.ogg" , "S4_08196.ogg" }
              };
              //弱バイブ　フェラ
              sLoopVoice20Fera = new string[][] {
              new string[] { "S4_08241.ogg" , "S4_08258.ogg" , "S4_08243.ogg" , "S4_08259.ogg" },
              new string[] { "S4_08241.ogg" , "S4_08258.ogg" , "S4_08243.ogg" , "S4_08259.ogg" },
              new string[] { "S4_08241.ogg" , "S4_08258.ogg" , "S4_08243.ogg" , "S4_08259.ogg" },
              new string[] { "S4_08241.ogg" , "S4_08258.ogg" , "S4_08243.ogg" , "S4_08259.ogg" },
              new string[] { "S4_08241.ogg" , "S4_08258.ogg" , "S4_08243.ogg" , "S4_08259.ogg" }
              };
              //強バイブ　通常
              sLoopVoice30Vibe = new string[][] {
              new string[] { "S4_08139.ogg" , "S4_08140.ogg" , "S4_08131.ogg" , "S4_08132.ogg" },
              new string[] { "S4_08131.ogg" , "S4_08132.ogg" , "S4_102934.ogg", "S4_102935.ogg", "s4_08140.ogg" , "s4_08141.ogg" },
              new string[] { "S4_08141.ogg" , "S4_08142.ogg" , "S4_08133.ogg" , "S4_08134.ogg" , "s4_08142.ogg" , "s4_08145.ogg" },
              new string[] { "S4_08133.ogg" , "S4_08134.ogg" , "S4_102936.ogg", "S4_102937.ogg" },
              new string[] { "S4_08189.ogg" , "S4_08190.ogg" , "S4_08197.ogg" , "S4_08198.ogg" }
              };
              //強バイブ　フェラ
              sLoopVoice30Fera = new string[][] {
              new string[] { "S4_08244.ogg" , "S4_08245.ogg" , "S4_08262.ogg" , "S4_08246.ogg" },
              new string[] { "S4_08244.ogg" , "S4_08245.ogg" , "S4_08262.ogg" , "S4_08246.ogg" },
              new string[] { "S4_08244.ogg" , "S4_08245.ogg" , "S4_08262.ogg" , "S4_08246.ogg" },
              new string[] { "S4_08244.ogg" , "S4_08245.ogg" , "S4_08262.ogg" , "S4_08246.ogg" },
              new string[] { "S4_08241.ogg" , "S4_08258.ogg" , "S4_08243.ogg" , "S4_08259.ogg" }
              };
              //絶頂　通常
              sOrgasmVoice30Vibe = new string[][] {
              new string[] { "s4_08348.ogg" , "s4_08354.ogg" , "s4_08365.ogg" , "s4_08374.ogg" },
              new string[] { "s4_08345.ogg" , "s4_08346.ogg" , "s4_08349.ogg" , "s4_08350.ogg" },
              new string[] { "s4_08347.ogg" , "s4_08355.ogg" , "s4_08356.ogg" , "s4_11658.ogg" },
              new string[] { "s4_11684.ogg" , "s4_11677.ogg" , "s4_11680.ogg" , "s4_11683.ogg" , "s4_11661.ogg" , "s4_11659.ogg" , "s4_11654.ogg" , "s4_11660.ogg" },
              new string[] { "s4_08348.ogg" , "s4_08354.ogg" , "s4_08365.ogg" , "s4_08374.ogg" }
              };
              //絶頂　フェラ
              sOrgasmVoice30Fera = new string[][] {
              new string[] { "S4_08359.ogg" , "S4_08358.ogg" , "S4_08368.ogg" },
              new string[] { "S4_08359.ogg" , "S4_08358.ogg" , "S4_08368.ogg" },
              new string[] { "S4_08359.ogg" , "S4_08358.ogg" , "S4_08368.ogg" },
              new string[] { "S4_05728.ogg" , "S4_05726.ogg" , "S4_05680.ogg" , "S4_05668.ogg" },
              new string[] { "S4_08359.ogg" , "S4_08358.ogg" , "S4_08368.ogg" }
              };
              //停止時
              sLoopVoice40Vibe = new string[] { "s4_08424.ogg" , "s4_08426.ogg" , "s4_08427.ogg" , "s4_08428.ogg" , "s4_08428.ogg" };
            }}


            //性格別声テーブル　ボクっ娘---------------------------------------------------------------
            class BasicVoiceGenki : BasicVoiceSet { public BasicVoiceGenki() {
              //弱バイブ　通常
              sLoopVoice20Vibe = new string[][] {
              new string[] { "S5_04055.ogg" , "S5_04056.ogg" , "S5_04047.ogg" , "S5_04048.ogg" , "s5_04127.ogg" , "s5_04129.ogg" , "s5_04130.ogg" , "s5_04131.ogg" },
              new string[] { "S5_04047.ogg" , "S5_04048.ogg" , "S5_102337.ogg", "S5_102338.ogg" },
              new string[] { "S5_04057.ogg" , "S5_04058.ogg" , "S5_04049.ogg" , "S5_04050.ogg" },
              new string[] { "S5_04049.ogg" , "S5_04050.ogg" , "S5_102339.ogg", "S5_102340.ogg"},
              new string[] { "S5_04105.ogg" , "S5_04106.ogg" , "S5_04107.ogg" , "S5_04108.ogg" } //ca001f(L2-L5)喪失
              };
              //弱バイブ　フェラ
              sLoopVoice20Fera = new string[][] {
              new string[] { "S5_04163.ogg" , "S5_04162.ogg" , "S5_04179.ogg" , "S5_04181.ogg" },
              new string[] { "S5_04163.ogg" , "S5_04162.ogg" , "S5_04179.ogg" , "S5_04181.ogg" },
              new string[] { "S5_04163.ogg" , "S5_04162.ogg" , "S5_04179.ogg" , "s5_04174.ogg" },
              new string[] { "S5_04163.ogg" , "S5_04162.ogg" , "S5_04179.ogg" , "s5_04174.ogg" },
              new string[] { "S5_04163.ogg" , "S5_04162.ogg" , "S5_04179.ogg" , "s5_04174.ogg" }
              };
              //強バイブ　通常
              sLoopVoice30Vibe = new string[][] {
              new string[] { "S5_04059.ogg" , "S5_04060.ogg" , "S5_04051.ogg" , "S5_04052.ogg" , "s5_04133.ogg" , "s5_04134.ogg" },
              new string[] { "S5_04051.ogg" , "S5_04052.ogg" , "S5_102341.ogg", "S5_102342.ogg" },
              new string[] { "S5_04061.ogg" , "S5_04062.ogg" , "S5_04053.ogg" , "S5_04054.ogg" },
              new string[] { "S5_04053.ogg" , "S5_04054.ogg" , "S5_102343.ogg", "S5_102344.ogg" },
              new string[] { "S5_04109.ogg" , "S5_04110.ogg" , "S5_04117.ogg" , "S5_04118.ogg" }
              };
              //強バイブ　フェラ
              sLoopVoice30Fera = new string[][] {
              new string[] { "S5_04093.ogg" , "S5_04094.ogg" , "S5_04102.ogg" , "S5_04100.ogg" },
              new string[] { "S5_04093.ogg" , "S5_04094.ogg" , "S5_04102.ogg" , "S5_04100.ogg" },
              new string[] { "S5_04093.ogg" , "S5_04094.ogg" , "S5_04102.ogg" , "S5_04100.ogg" },
              new string[] { "S5_04093.ogg" , "S5_04094.ogg" , "S5_04102.ogg" , "S5_04100.ogg" },
              new string[] { "S5_04163.ogg" , "S5_04162.ogg" , "S5_04179.ogg" , "s5_04174.ogg" }
              };
              //絶頂　通常
              sOrgasmVoice30Vibe = new string[][] {
              new string[] { "s5_04264.ogg" , "s5_04258.ogg" , "s5_04256.ogg" , "s5_04255.ogg" },
              new string[] { "s5_04265.ogg" , "s5_04270.ogg" , "s5_04267.ogg" , "s5_04268.ogg" },
              new string[] { "s5_04266.ogg" , "s5_18375.ogg" , "s5_18380.ogg" , "s5_18393.ogg" },
              new string[] { "s5_18379.ogg" , "s5_18380.ogg" , "s5_18382.ogg" , "s5_18384.ogg" , "s5_18385.ogg" , "s5_18400.ogg" , "s5_18402.ogg" , "s5_18119.ogg" },
              new string[] { "s5_04264.ogg" , "s5_04258.ogg" , "s5_04256.ogg" , "s5_04255.ogg" }
              };
              //絶頂　フェラ
              sOrgasmVoice30Fera = new string[][] {
              new string[] { "s5_04271.ogg" , "s5_04272.ogg" , "s5_04273.ogg" },
              new string[] { "s5_04271.ogg" , "s5_04272.ogg" , "s5_04273.ogg" },
              new string[] { "s5_04271.ogg" , "s5_04272.ogg" , "s5_04273.ogg" },
              new string[] { "S5_07752.ogg" , "S5_07753.ogg" , "s5_04273.ogg" , "s5_04271.ogg" },
              new string[] { "s5_04271.ogg" , "s5_04272.ogg" , "s5_04273.ogg" }
              };
              //停止時
              sLoopVoice40Vibe = new string[] { "s5_04127.ogg" , "s5_04129.ogg" , "s5_04131.ogg" , "s5_04134.ogg" , "s5_04134.ogg" };
            }}


            //性格別声テーブル　ドＳ---------------------------------------------------------------
            class BasicVoiceSadist : BasicVoiceSet { public BasicVoiceSadist() {
              //弱バイブ　通常
              sLoopVoice20Vibe = new string[][] {
              new string[] { "S6_02479.ogg" , "S6_02480.ogg" , "S6_02259.ogg" , "S6_02260.ogg" },
              new string[] { "S6_02179.ogg" , "S6_02180.ogg" , "S6_102978.ogg", "S6_102979.ogg" },
              new string[] { "S6_02481.ogg" , "S6_02482.ogg" , "S6_02261.ogg" , "S6_02262.ogg" },
              new string[] { "S6_02184.ogg" , "S6_02254.ogg" , "S6_02255.ogg" , "S6_02247.ogg" }, //ca001a(L5) + ca001k(L3,L4)奉仕 + ca001g(L4)酔い
              new string[] { "S6_02239.ogg" , "S6_02240.ogg" , "S6_02248.ogg" , "S6_02256.ogg" }  //ca001f(L4-L5)喪失 + ca001g(L5)酔い + ca001k(L5)奉仕
              };
              //弱バイブ　フェラ
              sLoopVoice20Fera = new string[][] {
              new string[] { "S6_02219.ogg" , "S6_02220.ogg" , "S6_02221.ogg" , "S6_02222.ogg" },
              new string[] { "S6_02219.ogg" , "S6_02220.ogg" , "S6_02221.ogg" , "S6_02222.ogg" },
              new string[] { "S6_02219.ogg" , "S6_02220.ogg" , "S6_02221.ogg" , "S6_02222.ogg" },
              new string[] { "S6_02219.ogg" , "S6_02220.ogg" , "S6_02221.ogg" , "S6_02222.ogg" },
              new string[] { "S6_02219.ogg" , "S6_02220.ogg" , "S6_02221.ogg" , "S6_02222.ogg" }
              };
              //強バイブ　通常
              sLoopVoice30Vibe = new string[][] {
              new string[] { "S6_02483.ogg" , "S6_02484.ogg" , "S6_02263.ogg" , "S6_02264.ogg" },
              new string[] { "S6_02183.ogg" , "S6_02184.ogg" , "S6_102982.ogg", "S6_102983.ogg" },
              new string[] { "S6_02485.ogg" , "S6_02486.ogg" , "S6_02265.ogg" , "S6_02266.ogg" },
              new string[] { "S6_02185.ogg" , "S6_02186.ogg" , "S6_02241.ogg" , "S6_02242.ogg" }, //ca001a(L6,L7) + ca001f(L6-L7)喪失
              new string[] { "S6_102984.ogg", "S6_102985.ogg", "S6_02250.ogg" , "S6_02256.ogg" }  //ca001j(L6,L7)発情 + ca001g(L7)酔い + ca001k(L7)奉仕
              };
              //強バイブ　フェラ
              sLoopVoice30Fera = new string[][] {
              new string[] { "S6_02223.ogg" , "S6_02224.ogg" , "S6_02225.ogg" , "S6_02226.ogg" },
              new string[] { "S6_02223.ogg" , "S6_02224.ogg" , "S6_02225.ogg" , "S6_02226.ogg" },
              new string[] { "S6_02223.ogg" , "S6_02224.ogg" , "S6_02225.ogg" , "S6_02226.ogg" },
              new string[] { "S6_02223.ogg" , "S6_02224.ogg" , "S6_02225.ogg" , "S6_02226.ogg" },
              new string[] { "S6_02219.ogg" , "S6_02220.ogg" , "S6_02221.ogg" , "S6_02222.ogg" }
              };
              //絶頂　通常
              sOrgasmVoice30Vibe = new string[][] {
              new string[] { "s6_01744.ogg" , "s6_02700.ogg" , "s6_02450.ogg" , "s6_02357.ogg" },
              new string[] { "S6_28847.ogg" , "S6_28853.ogg" , "S6_28814.ogg" , "S6_02397.ogg" },
              new string[] { "S6_28817.ogg" , "S6_02398.ogg" , "S6_02399.ogg" , "s6_02402.ogg" ,
                             "S6_103866.ogg", "S6_103987.ogg", "S6_103721.ogg", "S6_102819.ogg", "S6_103720.ogg" },
              new string[] { "S6_09048.ogg" , "S6_01984.ogg" , "S6_01988.ogg" , "S6_01991.ogg" , "S6_02000.ogg" , "S6_01996.ogg" , "S6_01997.ogg" , "S6_01998.ogg" ,
                             "S6_01999.ogg" , "S6_02001.ogg" , "s6_05796.ogg" , "s6_05797.ogg" , "s6_05798.ogg" , "s6_05799.ogg" , "s6_05800.ogg" , "s6_05801.ogg",
                             "S6_103866.ogg", "S6_103987.ogg", "S6_103721.ogg", "S6_102819.ogg", "S6_103720.ogg", //4行目と同じ
                             "S6_103419.ogg", "S6_09230.ogg" , "S6_102809.ogg", "S6_102820.ogg" },
              new string[] { "s6_01744.ogg" , "s6_02700.ogg" , "s6_02450.ogg" , "s6_02357.ogg" }
              };
              //絶頂　フェラ
              sOrgasmVoice30Fera = new string[][] {
              new string[] { "S6_28832.ogg" , "s6_02403.ogg" , "S6_28835.ogg" },
              new string[] { "S6_28835.ogg" , "s6_02403.ogg" , "s6_02404.ogg" },
              new string[] { "S6_28838.ogg" , "s6_02404.ogg" , "s6_02405.ogg" },
              new string[] { "S6_02420.ogg" , "S6_08109.ogg" , "S6_08112.ogg" , "S6_08114.ogg" , "s6_02404.ogg" , "s6_02405.ogg"  },
              new string[] { "S6_28832.ogg" , "s6_02403.ogg" , "S6_28835.ogg" }
              };
              //停止時
              sLoopVoice40Vibe = new string[] { "s6_02477.ogg" , "s6_02478.ogg" , "s6_02479.ogg" , "s6_02481.ogg" , "s6_02480.ogg" };
            }}


            //性格別声テーブル　無垢---------------------------------------------------------------
            class BasicVoiceMuku : BasicVoiceSet { public BasicVoiceMuku() {
              //弱バイブ　通常
              sLoopVoice20Vibe = new string[][] {
              new string[] { "H0_00053.ogg" , "H0_00054.ogg" , "H0_09210.ogg" , "H0_09211.ogg" },
              new string[] { "H0_00069.ogg" , "H0_00070.ogg" , "H0_00229.ogg" , "H0_00230.ogg" },
              new string[] { "H0_00055.ogg" , "H0_00056.ogg" , "H0_09212.ogg" , "H0_09213.ogg" },
              new string[] { "H0_00071.ogg" , "H0_00072.ogg" , "H0_00231.ogg" , "H0_00232.ogg" },
              new string[] { "H0_00085.ogg" , "H0_00086.ogg" , "H0_00087.ogg" , "H0_00088.ogg" }
              //new string[] { "H0_00217.ogg" , "H0_00218.ogg" , "H0_00121.ogg" , "H0_00122.ogg" } //ca001h(L4,L5)初心 + ca001g(L4,L5)酔い
              };
              //弱バイブ　フェラ
              sLoopVoice20Fera = new string[][] {
              new string[] { "H0_00093.ogg" , "H0_00094.ogg" , "H0_00101.ogg" , "H0_00102.ogg" },
              new string[] { "H0_00093.ogg" , "H0_00094.ogg" , "H0_00101.ogg" , "H0_00102.ogg" },
              new string[] { "H0_00095.ogg" , "H0_00096.ogg" , "H0_00103.ogg" , "H0_00104.ogg" },
              new string[] { "H0_00095.ogg" , "H0_00096.ogg" , "H0_00103.ogg" , "H0_00104.ogg" },
              new string[] { "H0_00093.ogg" , "H0_00094.ogg" , "H0_00101.ogg" , "H0_00102.ogg" }
              };
              //強バイブ　通常
              sLoopVoice30Vibe = new string[][] {
              new string[] { "H0_00057.ogg" , "H0_00058.ogg" , "H0_09214.ogg" , "H0_09215.ogg" },
              new string[] { "H0_00073.ogg" , "H0_00074.ogg" , "H0_00233.ogg" , "H0_00234.ogg" },
              new string[] { "H0_00059.ogg" , "H0_00060.ogg" , "H0_09216.ogg" , "H0_09217.ogg" },
              new string[] { "H0_00075.ogg" , "H0_00076.ogg" , "H0_00235.ogg" , "H0_00236.ogg" }, //H0_00252
              new string[] { "H0_00089.ogg" , "H0_00090.ogg" , "H0_00087.ogg" , "H0_00088.ogg" }
              //new string[] { "H0_00219.ogg" , "H0_00220.ogg" , "H0_00123.ogg" , "H0_00124.ogg" } //ca001h(L6,L7)初心 + ca001g(L6,L7)酔い
              };
              //強バイブ　フェラ
              sLoopVoice30Fera = new string[][] {
              new string[] { "H0_00105.ogg" , "H0_00106.ogg" , "H0_00097.ogg" , "H0_00098.ogg" },
              new string[] { "H0_00105.ogg" , "H0_00106.ogg" , "H0_00097.ogg" , "H0_00098.ogg" },
              new string[] { "H0_00107.ogg" , "H0_00108.ogg" , "H0_00099.ogg" , "H0_00100.ogg" },
              new string[] { "H0_00107.ogg" , "H0_00108.ogg" , "H0_00099.ogg" , "H0_00100.ogg" },
              new string[] { "H0_00105.ogg" , "H0_00106.ogg" , "H0_00097.ogg" , "H0_00098.ogg" }
              };
              //絶頂　通常
              sOrgasmVoice30Vibe = new string[][] {
              new string[] { "H0_00289.ogg" , "H0_00290.ogg" , "H0_00291.ogg" , "H0_00292.ogg" },
              new string[] { "H0_07822.ogg" , "H0_07826.ogg" , "H0_10642.ogg" , "H0_10619.ogg" , "H0_07825.ogg" },
              new string[] { "H0_10874.ogg" , "H0_10860.ogg" , "H0_10957.ogg" , "H0_10960.ogg" , "H0_10869.ogg" , "H0_09681.ogg" , "H0_09691.ogg" , "H0_09712.ogg" , "H0_09724.ogg"},
              new string[] { "H0_06353.ogg" , "H0_06358.ogg" , "H0_10859.ogg" , "H0_10870.ogg" , "H0_10860.ogg" , "H0_10961.ogg" , "H0_10962.ogg" ,
                             "H0_10963.ogg" , "H0_07695.ogg" , "H0_09708.ogg" , "H0_09713.ogg" , "H0_10470.ogg" , "H0_10471.ogg" , "H0_10476.ogg" ,
                             "H0_10479.ogg" , "H0_10480.ogg" , "H0_13669.ogg" , "H0_00567.ogg" , "H0_05H_15068.ogg" , "H0_05H_15079.ogg" , "H0_05H_15080.ogg" ,
                             "H0_05H_15081.ogg" , "H0_06062.ogg" , "H0_10473.ogg" , "H0_10474.ogg" , "H0_10475.ogg" , "H0_10477.ogg" , "H0_10478.ogg" , "H0_10926.ogg" ,
                             "H0_11359.ogg" , "H0_12625.ogg" , "H0_FEB_20458.ogg" , "H0_09681.ogg" , "H0_09682.ogg" , "H0_09714.ogg" },
              new string[] { "H0_07604.ogg" , "H0_07603.ogg" , "H0_07614.ogg" , "H0_07644.ogg" }
              };
              //絶頂　フェラ
              sOrgasmVoice30Fera = new string[][] {
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" }
              };
              //停止時
              sLoopVoice40Vibe = new string[] { "H0_00134.ogg" , "H0_00136.ogg" , "H0_09239.ogg" , "H0_09240.ogg" , "H0_00142.ogg" };
            }}


            //性格別声テーブル　真面目---------------------------------------------------------------
            class BasicVoiceMajime : BasicVoiceSet { public BasicVoiceMajime() {
              //弱バイブ　通常
              sLoopVoice20Vibe = new string[][] {
              new string[] { "H1_00225.ogg" , "H1_00226.ogg" , "H1_08952.ogg" , "H1_08953.ogg" },
              new string[] { "H1_00241.ogg" , "H1_00242.ogg" , "H1_00401.ogg" , "H1_00402.ogg" },
              new string[] { "H1_00227.ogg" , "H1_00228.ogg" , "H1_08954.ogg" , "H1_08955.ogg" },
              new string[] { "H1_00243.ogg" , "H1_00244.ogg" , "H1_00403.ogg" , "H1_00404.ogg" },
              new string[] { "H1_00257.ogg" , "H1_00258.ogg" , "H1_00259.ogg" , "H1_00260.ogg" }
              };
              //弱バイブ　フェラ
              sLoopVoice20Fera = new string[][] {
              new string[] { "H1_00265.ogg" , "H1_00266.ogg" , "H1_00273.ogg" , "H1_00274.ogg" },
              new string[] { "H1_00265.ogg" , "H1_00266.ogg" , "H1_00273.ogg" , "H1_00274.ogg" },
              new string[] { "H1_00267.ogg" , "H1_00268.ogg" , "H1_00275.ogg" , "H1_00276.ogg" },
              new string[] { "H1_00267.ogg" , "H1_00268.ogg" , "H1_00275.ogg" , "H1_00276.ogg" },
              new string[] { "H1_00265.ogg" , "H1_00266.ogg" , "H1_00273.ogg" , "H1_00274.ogg" }
              };
              //強バイブ　通常
              sLoopVoice30Vibe = new string[][] {
              new string[] { "H1_00229.ogg" , "H1_00230.ogg" , "H1_08956.ogg" , "H1_08957.ogg" },
              new string[] { "H1_00245.ogg" , "H1_00246.ogg" , "H1_00405.ogg" , "H1_00406.ogg" },
              new string[] { "H1_00231.ogg" , "H1_00232.ogg" , "H1_08958.ogg" , "H1_08959.ogg" },
              new string[] { "H1_00247.ogg" , "H1_00248.ogg" , "H1_00407.ogg" , "H1_00408.ogg" },
              new string[] { "H1_00262.ogg" , "H1_00263.ogg" , "H1_00264.ogg" , "H1_00261.ogg" }
              };
              //強バイブ　フェラ
              sLoopVoice30Fera = new string[][] {
              new string[] { "H1_00269.ogg" , "H1_00270.ogg" , "H1_00277.ogg" , "H1_00278.ogg" },
              new string[] { "H1_00269.ogg" , "H1_00270.ogg" , "H1_00277.ogg" , "H1_00278.ogg" },
              new string[] { "H1_00271.ogg" , "H1_00272.ogg" , "H1_00279.ogg" , "H1_00280.ogg" },
              new string[] { "H1_00271.ogg" , "H1_00272.ogg" , "H1_00279.ogg" , "H1_00280.ogg" },
              new string[] { "H1_00269.ogg" , "H1_00270.ogg" , "H1_00277.ogg" , "H1_00278.ogg" }
              };
              //絶頂　通常
              sOrgasmVoice30Vibe = new string[][] {
              new string[] { "H1_11482.ogg" , "H1_13858.ogg" , "H1_13879.ogg" , "H1_13918.ogg" },
              new string[] { "H1_11492.ogg" , "H1_11514.ogg" , "H1_10519.ogg" , "H1_10516.ogg" },
              new string[] { "H1_11427.ogg" , "H1_11513.ogg" , "H1_05640.ogg" , "H1_09232.ogg" },
              new string[] { "H1_11425.ogg" , "H1_11424.ogg" , "H1_11427.ogg" , "H1_09232.ogg" , "H1_10397.ogg" , "H1_11645.ogg" , "H1_11654.ogg" , "H1_11747.ogg" , "H1_10313.ogg" , "H1_11254.ogg" , "H1_11402.ogg" , "H1_09829.ogg" , "H1_04547.ogg" , "H1_12675.ogg" , "H1_01477.ogg" , "H1_00739.ogg" , "H1_06987.ogg" , "H1_13138.ogg" , "H1_13372.ogg" , "H1_12929.ogg" , "H1_11404.ogg" , "H1_05638.ogg" , "H1_09837.ogg" , "H1_03615.ogg" , "H1_11513.ogg" , "H1_05640.ogg" },
              new string[] { "H1_10493.ogg" , "H1_10482.ogg" , "H1_10523.ogg" , "H1_10732.ogg" }
              };
              //絶頂　フェラ
              sOrgasmVoice30Fera = new string[][] {
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { "H1_09840.ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { "H1_12857.ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" }
              };
              //停止時
              sLoopVoice40Vibe = new string[] { "H1_00305.ogg" , "H1_08979.ogg" , "H1_08980.ogg" , "H1_08982.ogg" , "H1_00313.ogg" };
            }}


            //性格別声テーブル　凛デレ---------------------------------------------------------------
            class BasicVoiceRindere : BasicVoiceSet { public BasicVoiceRindere() {
              //弱バイブ　通常
              sLoopVoice20Vibe = new string[][] {
              new string[] { "H2_00027.ogg" , "H2_00028.ogg" , "H2_09827.ogg" , "H2_09828.ogg" },
              new string[] { "H2_00043.ogg" , "H2_00044.ogg" , "H2_00203.ogg" , "H2_00204.ogg" },
              new string[] { "H2_00029.ogg" , "H2_00030.ogg" , "H2_09829.ogg" , "H2_09830.ogg" },
              new string[] { "H2_00045.ogg" , "H2_00046.ogg" , "H2_00205.ogg" , "H2_00206.ogg" },
              new string[] { "H2_00059.ogg" , "H2_00060.ogg" , "H2_00061.ogg" , "H2_00062.ogg" }
              };
              //弱バイブ　フェラ
              sLoopVoice20Fera = new string[][] {
              new string[] { "H2_00067.ogg" , "H2_00068.ogg" , "H2_00075.ogg" , "H2_00076.ogg" },
              new string[] { "H2_00067.ogg" , "H2_00068.ogg" , "H2_00075.ogg" , "H2_00076.ogg" },
              new string[] { "H2_00069.ogg" , "H2_00070.ogg" , "H2_00077.ogg" , "H2_00078.ogg" },
              new string[] { "H2_00069.ogg" , "H2_00070.ogg" , "H2_00077.ogg" , "H2_00078.ogg" },
              new string[] { "H2_00067.ogg" , "H2_00068.ogg" , "H2_00075.ogg" , "H2_00076.ogg" }
              };
              //強バイブ　通常
              sLoopVoice30Vibe = new string[][] {
              new string[] { "H2_00031.ogg" , "H2_00032.ogg" , "H2_09831.ogg" , "H2_09832.ogg" },
              new string[] { "H2_00047.ogg" , "H2_00048.ogg" , "H2_00207.ogg" , "H2_00208.ogg" },
              new string[] { "H2_00033.ogg" , "H2_00034.ogg" , "H2_09833.ogg" , "H2_09834.ogg" },
              new string[] { "H2_00049.ogg" , "H2_00050.ogg" , "H2_00209.ogg" , "H2_00210.ogg" },
              new string[] { "H2_00063.ogg" , "H2_00064.ogg" , "H2_00061.ogg" , "H2_00062.ogg" }
              };
              //強バイブ　フェラ
              sLoopVoice30Fera = new string[][] {
              new string[] { "H2_00071.ogg" , "H2_00072.ogg" , "H2_00079.ogg" , "H2_00080.ogg" },
              new string[] { "H2_00071.ogg" , "H2_00072.ogg" , "H2_00079.ogg" , "H2_00080.ogg" },
              new string[] { "H2_00073.ogg" , "H2_00074.ogg" , "H2_00081.ogg" , "H2_00082.ogg" },
              new string[] { "H2_00073.ogg" , "H2_00074.ogg" , "H2_00081.ogg" , "H2_00082.ogg" },
              new string[] { "H2_00071.ogg" , "H2_00072.ogg" , "H2_00079.ogg" , "H2_00080.ogg" }
              };
              //絶頂　通常
              sOrgasmVoice30Vibe = new string[][] {
              new string[] { "H2_06092.ogg" , "H2_00252.ogg" , "H2_00285.ogg" , "H2_00277.ogg" },
              new string[] { "H2_10293.ogg" , "H2_10381.ogg" , "H2_10444.ogg" , "H2_11040.ogg" , "H2_07976.ogg" },
              new string[] { "H2_08156.ogg" , "H2_10980.ogg" , "H2_11120.ogg" , "H2_11141.ogg" , "H2_11143.ogg" , "H2_11229.ogg" },
              new string[] { "H2_10580.ogg" , "H2_10581.ogg" , "H2_10584.ogg" , "H2_10585.ogg" , "H2_10586.ogg" , "H2_10587.ogg" , "H2_10064.ogg" , "H2_13912.ogg" , "H2_11118.ogg" , "H2_11119.ogg" , "H2_08338.ogg" , "H2_11371.ogg" , "H2_11464.ogg" , "H2_13449.ogg" , "H2_10971.ogg" , "H2_06130.ogg" , "H2_01902.ogg" , "H2_03017.ogg" , "H2_02782.ogg" , "H2_02861.ogg" , "H2_10573.ogg" , "H2_00865.ogg" , "H2_02550.ogg" , "H2_02603.ogg" , "H2_02606.ogg" , "H2_08156.ogg" , "H2_10980.ogg" , "H2_11120.ogg" , "H2_11141.ogg" , "H2_11143.ogg" , "H2_11229.ogg" },
              new string[] { "H2_08095.ogg" , "H2_08116.ogg" , "H2_08121.ogg" , "H2_08126.ogg" }
              };
              //絶頂　フェラ
              sOrgasmVoice30Fera = new string[][] {
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" }
              };
              //停止時
              sLoopVoice40Vibe = new string[] { "H2_00108.ogg" , "H2_00110.ogg" , "H2_00111.ogg" , "H2_00113.ogg" , "H2_00118.ogg" };
            }}


            //性格別声テーブル　無口---------------------------------------------------------------
            class BasicVoiceSilent : BasicVoiceSet { public BasicVoiceSilent() {
              //弱バイブ　通常
              sLoopVoice20Vibe = new string[][] {
              new string[] { "H3_00518.ogg" , "H3_00519.ogg" , "H3_00526.ogg" , "H3_00527.ogg" },
              new string[] { "H3_00534.ogg" , "H3_00535.ogg" , "H3_00734.ogg" , "H3_00735.ogg" },
              new string[] { "H3_00520.ogg" , "H3_00521.ogg" , "H3_00528.ogg" , "H3_00529.ogg" },
              new string[] { "H3_00536.ogg" , "H3_00537.ogg" , "H3_00736.ogg" , "H3_00737.ogg" },
              new string[] { "H3_00558.ogg" , "H3_00559.ogg" , "H3_00734.ogg" , "H3_00735.ogg" }
              };
              //弱バイブ　フェラ
              sLoopVoice20Fera = new string[][] {
              new string[] { "H3_00566.ogg" , "H3_00567.ogg" , "H3_00702.ogg" , "H3_00703.ogg" },
              new string[] { "H3_00566.ogg" , "H3_00567.ogg" , "H3_00702.ogg" , "H3_00703.ogg" },
              new string[] { "H3_00568.ogg" , "H3_00569.ogg" , "H3_00704.ogg" , "H3_00705.ogg" },
              new string[] { "H3_00568.ogg" , "H3_00569.ogg" , "H3_00704.ogg" , "H3_00705.ogg" },
              new string[] { "H3_00566.ogg" , "H3_00567.ogg" , "H3_00568.ogg" , "H3_00569.ogg" }
              };
              //強バイブ　通常
              sLoopVoice30Vibe = new string[][] {
              new string[] { "H3_00522.ogg" , "H3_00523.ogg" , "H3_00530.ogg" , "H3_00531.ogg" },
              new string[] { "H3_00538.ogg" , "H3_00539.ogg" , "H3_00738.ogg" , "H3_00739.ogg" },
              new string[] { "H3_00524.ogg" , "H3_00525.ogg" , "H3_00532.ogg" , "H3_00533.ogg" },
              new string[] { "H3_00540.ogg" , "H3_00541.ogg" , "H3_00740.ogg" , "H3_00741.ogg" },
              new string[] { "H3_00560.ogg" , "H3_00561.ogg" , "H3_00562.ogg" , "H3_00563.ogg" }
              };
              //強バイブ　フェラ
              sLoopVoice30Fera = new string[][] {
              new string[] { "H3_00570.ogg" , "H3_00571.ogg" , "H3_00706.ogg" , "H3_00707.ogg" },
              new string[] { "H3_00570.ogg" , "H3_00571.ogg" , "H3_00706.ogg" , "H3_00707.ogg" },
              new string[] { "H3_00572.ogg" , "H3_00573.ogg" , "H3_00708.ogg" , "H3_00709.ogg" },
              new string[] { "H3_00572.ogg" , "H3_00573.ogg" , "H3_00708.ogg" , "H3_00709.ogg" },
              new string[] { "H3_00570.ogg" , "H3_00571.ogg" , "H3_00706.ogg" , "H3_00707.ogg" }
              };
              //絶頂　通常
              sOrgasmVoice30Vibe = new string[][] {
              new string[] { "H3_00779.ogg" , "H3_00783.ogg" , "H3_00785.ogg" , "H3_00800.ogg" },
              new string[] { "H3_08926.ogg" , "H3_08112.ogg" , "H3_04262.ogg" , "H3_05125.ogg" , "H3_08926.ogg" },
              new string[] { "H3_02523.ogg" , "H3_04910.ogg" , "H3_07704.ogg" , "H3_04967.ogg" , "H3_04974.ogg" , "H3_05026.ogg" },
              new string[] { "H3_07068.ogg" , "H3_02584.ogg" , "H3_01906.ogg" , "H3_07314.ogg" , "H3_07315.ogg" , "H3_07316.ogg" , "H3_06965.ogg" , "H3_01858.ogg" , "H3_01906.ogg" , "H3_01925.ogg" , "H3_04252.ogg" , "H3_04228.ogg" , "H3_04639.ogg" , "H3_07121.ogg" , "H3_03827.ogg" , "H3_01928.ogg" , "H3_02336.ogg" , "H3_07069.ogg" , "H3_07996.ogg" , "H3_08950.ogg" },
              new string[] { "H3_00779.ogg" , "H3_00783.ogg" , "H3_00785.ogg" , "H3_00800.ogg" }
              };
              //絶頂　フェラ
              sOrgasmVoice30Fera = new string[][] {
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" }
              };
              //停止時
              sLoopVoice40Vibe = new string[] { "H3_00622.ogg" , "H3_00625.ogg" , "H3_00627.ogg" , "H3_00628.ogg" , "H3_00641.ogg" };
            }}


            //性格別声テーブル　小悪魔---------------------------------------------------------------
            class BasicVoiceDevilish : BasicVoiceSet { public BasicVoiceDevilish() {
              //弱バイブ　通常
              sLoopVoice20Vibe = new string[][] {
              new string[] { "H4_00853.ogg" , "H4_00854.ogg" , "H4_00861.ogg" , "H4_00862.ogg" },
              new string[] { "H4_00869.ogg" , "H4_00870.ogg" , "H4_01069.ogg" , "H4_01070.ogg" },
              new string[] { "H4_00855.ogg" , "H4_00856.ogg" , "H4_00863.ogg" , "H4_00864.ogg" },
              new string[] { "H4_00871.ogg" , "H4_00872.ogg" , "H4_01071.ogg" , "H4_01072.ogg" },
              new string[] { "H4_00893.ogg" , "H4_00894.ogg" , "H4_01069.ogg" , "H4_01070.ogg" }
              };
              //弱バイブ　フェラ
              sLoopVoice20Fera = new string[][] {
              new string[] { "H4_00901.ogg" , "H4_00902.ogg" , "H4_01037.ogg" , "H4_01038.ogg" },
              new string[] { "H4_00901.ogg" , "H4_00902.ogg" , "H4_01037.ogg" , "H4_01038.ogg" },
              new string[] { "H4_00903.ogg" , "H4_00904.ogg" , "H4_01039.ogg" , "H4_01040.ogg" },
              new string[] { "H4_00903.ogg" , "H4_00904.ogg" , "H4_01039.ogg" , "H4_01040.ogg" },
              new string[] { "H4_00901.ogg" , "H4_00902.ogg" , "H4_00903.ogg" , "H4_00904.ogg" }
              };
              //強バイブ　通常
              sLoopVoice30Vibe = new string[][] {
              new string[] { "H4_00857.ogg" , "H4_00858.ogg" , "H4_00865.ogg" , "H4_00866.ogg" },
              new string[] { "H4_00873.ogg" , "H4_00874.ogg" , "H4_01073.ogg" , "H4_01074.ogg" },
              new string[] { "H4_00859.ogg" , "H4_00860.ogg" , "H4_00867.ogg" , "H4_00868.ogg" },
              new string[] { "H4_00875.ogg" , "H4_00876.ogg" , "H4_01075.ogg" , "H4_01076.ogg" },
              new string[] { "H4_00895.ogg" , "H4_00896.ogg" , "H4_00897.ogg" , "H4_00898.ogg" }
              };
              //強バイブ　フェラ
              sLoopVoice30Fera = new string[][] {
              new string[] { "H4_00905.ogg" , "H4_00906.ogg" , "H4_01041.ogg" , "H4_01042.ogg" },
              new string[] { "H4_00905.ogg" , "H4_00906.ogg" , "H4_01041.ogg" , "H4_01042.ogg" },
              new string[] { "H4_00907.ogg" , "H4_00908.ogg" , "H4_01043.ogg" , "H4_01044.ogg" },
              new string[] { "H4_00907.ogg" , "H4_00908.ogg" , "H4_01043.ogg" , "H4_01044.ogg" },
              new string[] { "H4_00905.ogg" , "H4_00906.ogg" , "H4_01041.ogg" , "H4_01042.ogg" }
              };
              //絶頂　通常
              sOrgasmVoice30Vibe = new string[][] {
              new string[] { "H4_01200.ogg" , "H4_01204.ogg" , "H4_01209.ogg" , "H4_01208.ogg" },
              new string[] { "H4_03190.ogg" , "H4_02024.ogg" , "H4_02026.ogg" , "H4_02030.ogg" , "H4_02018.ogg" },
              new string[] { "H4_01907.ogg" , "H4_01908.ogg" , "H4_05097.ogg" , "H4_05098.ogg" , "H4_03190.ogg" , "H4_03290.ogg" ,"H4_02020.ogg" , "H4_00583.ogg" , "H4_08568.ogg" },
              new string[] { "H4_03413.ogg" , "H4_08495.ogg" , "H4_08182.ogg" , "H4_02777.ogg" , "H4_03019.ogg" , "H4_06292.ogg" , "H4_06308.ogg" , "H4_06328.ogg" , "H4_08574.ogg" , "H4_08578.ogg" , "H4_08579.ogg" , "H4_08580.ogg" , "H4_08607.ogg" , "H4_08608.ogg" , "H4_08568.ogg" , "H4_08591.ogg" , "H4_04328.ogg" , "H4_03190.ogg" , "H4_06136.ogg" , "H4_00537.ogg" , "H4_00583.ogg" , "H4_08568.ogg" , "H4_02024.ogg" , "H4_02026.ogg" , "H4_02030.ogg" , "H4_02018.ogg" , "H4_04840.ogg" , "H4_05503.ogg" , "H4_08165.ogg" , "H4_08169.ogg" , "H4_PMD_14155.ogg" , "H4_PMD_14156.ogg" , "H4_PMD_14157.ogg" , "H4_Y_13333.ogg" , "H4_Y_13335.ogg" , "H4_Y_13336.ogg" , "H4_Y_13337.ogg" , "H4_Y_13338.ogg" , "H4_Y_13339.ogg" , "H4_Y_13340.ogg" , "H4_Y_13342.ogg" , "H4_Y_13343.ogg" , "H4_Y_13353.ogg" , "H4_Y_13355.ogg" , "H4_Y_13356.ogg" , "H4_Y_13360.ogg" , "H4_Y_13371.ogg", "H4_ADD_10717.ogg", "H4_ADD_10718.ogg", "H4_ADD_10721.ogg", "H4_ADD_10722.ogg", "H4_ADD_10723.ogg", "H4_ADD_11330.ogg", "H4_ADD_11331.ogg", "H4_ADD_11332.ogg", "H4_ADD_11333.ogg", "H4_ADD_11334.ogg", "H4_ADD_11344.ogg", "H4_ADD_11345.ogg", "H4_ADD_11346.ogg", "H4_ADD_11348.ogg", "H4_ADD_11349.ogg", "H4_ADD_11356.ogg", "H4_ADD_11359.ogg", "H4_ADD_11360.ogg", "H4_ADD_11361.ogg", "H4_ADD_11362.ogg" },
              new string[] { "H4_01200.ogg" , "H4_01204.ogg" , "H4_01209.ogg" , "H4_01208.ogg" }
              };
              //絶頂　フェラ
              sOrgasmVoice30Fera = new string[][] {
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" }
              };
              //停止時
              sLoopVoice40Vibe = new string[] { "H4_00959.ogg" , "H4_00962.ogg" , "H4_00963.ogg" , "H4_00977.ogg" , "H4_00980.ogg" };
            }}


            //性格別声テーブル　おしとやか---------------------------------------------------------------
            class BasicVoiceLadylike : BasicVoiceSet { public BasicVoiceLadylike() {
              //弱バイブ　通常
              sLoopVoice20Vibe = new string[][] {
              new string[] { "H5_00592.ogg" , "H5_00593.ogg" , "H5_00600.ogg" , "H5_00601.ogg" },
              new string[] { "H5_00808.ogg" , "H5_00809.ogg" , "H5_00608.ogg" , "H5_00609.ogg" },
              new string[] { "H5_00594.ogg" , "H5_00595.ogg" , "H5_00602.ogg" , "H5_00603.ogg" },
              new string[] { "H5_00810.ogg" , "H5_00811.ogg" , "H5_00610.ogg" , "H5_00611.ogg" },
              new string[] { "H5_00624.ogg" , "H5_00625.ogg" , "H5_00632.ogg" , "H5_00633.ogg" }
              };
              //弱バイブ　フェラ
              sLoopVoice20Fera = new string[][] {
              new string[] { "H5_00640.ogg" , "H5_00641.ogg" , "H5_00648.ogg" , "H5_00649.ogg" },
              new string[] { "H5_00640.ogg" , "H5_00641.ogg" , "H5_00648.ogg" , "H5_00649.ogg" },
              new string[] { "H5_00642.ogg" , "H5_00643.ogg" , "H5_00650.ogg" , "H5_00651.ogg" },
              new string[] { "H5_00642.ogg" , "H5_00643.ogg" , "H5_00650.ogg" , "H5_00651.ogg" },
              new string[] { "H5_00640.ogg" , "H5_00641.ogg" , "H5_00642.ogg" , "H5_00643.ogg" }
              };
              //強バイブ　通常
              sLoopVoice30Vibe = new string[][] {
              new string[] { "H5_00596.ogg" , "H5_00597.ogg" , "H5_00604.ogg" , "H5_00605.ogg" },
              new string[] { "H5_00812.ogg" , "H5_00813.ogg" , "H5_00612.ogg" , "H5_00613.ogg" },
              new string[] { "H5_00598.ogg" , "H5_00599.ogg" , "H5_00606.ogg" , "H5_00607.ogg" },
              new string[] { "H5_00814.ogg" , "H5_00815.ogg" , "H5_00614.ogg" , "H5_00615.ogg" },
              new string[] { "H5_00626.ogg" , "H5_00627.ogg" , "H5_00634.ogg" , "H5_00635.ogg" }
              };
              //強バイブ　フェラ
              sLoopVoice30Fera = new string[][] {
              new string[] { "H5_00644.ogg" , "H5_00645.ogg" , "H5_00652.ogg" , "H5_00653.ogg" },
              new string[] { "H5_00644.ogg" , "H5_00645.ogg" , "H5_00652.ogg" , "H5_00653.ogg" },
              new string[] { "H5_00646.ogg" , "H5_00647.ogg" , "H5_00654.ogg" , "H5_00655.ogg" },
              new string[] { "H5_00646.ogg" , "H5_00647.ogg" , "H5_00654.ogg" , "H5_00655.ogg" },
              new string[] { "H5_00644.ogg" , "H5_00645.ogg" , "H5_00646.ogg" , "H5_00647.ogg" }
              };
              //絶頂　通常
              sOrgasmVoice30Vibe = new string[][] {
              new string[] { "H5_00943.ogg" , "H5_00944.ogg" , "H5_00948.ogg" , "H5_00874.ogg" },
              new string[] { "H5_00859.ogg" , "H5_00857.ogg" , "H5_00858.ogg" , "H5_00855.ogg" , "H5_02835.ogg" },
              new string[] { "H5_08487.ogg" , "H5_00250.ogg" , "H5_00259.ogg" , "H5_00270.ogg" , "H5_00290.ogg" , "H5_00370.ogg" , "H5_02835.ogg" , "H5_03009.ogg" , "H5_00479.ogg" },
              new string[] { "H5_08158.ogg" , "H5_08153.ogg" , "H5_08155.ogg" , "H5_08482.ogg" , "H5_08484.ogg" , "H5_08485.ogg" , "H5_08486.ogg" , "H5_08487.ogg" , "H5_08488.ogg" , "H5_03789.ogg" , "H5_02561.ogg" , "H5_00370.ogg" , "H5_00379.ogg" , "H5_00398.ogg" , "H5_00399.ogg" , "H5_03009.ogg" , "H5_00479.ogg" , "H5_03462.ogg" , "H5_03464.ogg" , "H5_03465.ogg" , "H5_03468.ogg" , "H5_04142.ogg" , "H5_04144.ogg" , "H5_01588.ogg" , "H5_01596.ogg" , "H5_01597.ogg" , "H5_01598.ogg" },
              new string[] { "H5_00943.ogg" , "H5_00944.ogg" , "H5_00948.ogg" , "H5_00874.ogg" }
              };
              //絶頂　フェラ
              sOrgasmVoice30Fera = new string[][] {
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" }
              };
              //停止時
              sLoopVoice40Vibe = new string[] { "H5_00922.ogg" , "H5_00923.ogg" , "H5_00916.ogg" , "H5_00917.ogg" , "H5_00920.ogg" };
            }}


            //性格別声テーブル　メイド秘書---------------------------------------------------------------
            class BasicVoiceSecretary : BasicVoiceSet { public BasicVoiceSecretary() {
              //弱バイブ　通常
              sLoopVoice20Vibe = new string[][] {
              new string[] { "H6_00158.ogg" , "H6_00159.ogg" , "H6_00166.ogg" , "H6_00167.ogg" },
              new string[] { "H6_00374.ogg" , "H6_00375.ogg" , "H6_00174.ogg" , "H6_00175.ogg" },
              new string[] { "H6_00160.ogg" , "H6_00161.ogg" , "H6_00168.ogg" , "H6_00169.ogg" },
              new string[] { "H6_00376.ogg" , "H6_00377.ogg" , "H6_00176.ogg" , "H6_00177.ogg" },
              new string[] { "H6_00190.ogg" , "H6_00191.ogg" , "H6_00192.ogg" , "H6_00193.ogg" }
              };
              //弱バイブ　フェラ
              sLoopVoice20Fera = new string[][] {
              new string[] { "H6_00206.ogg" , "H6_00207.ogg" , "H6_00214.ogg" , "H6_00215.ogg" },
              new string[] { "H6_00206.ogg" , "H6_00207.ogg" , "H6_00214.ogg" , "H6_00215.ogg" },
              new string[] { "H6_00208.ogg" , "H6_00209.ogg" , "H6_00216.ogg" , "H6_00217.ogg" },
              new string[] { "H6_00208.ogg" , "H6_00209.ogg" , "H6_00216.ogg" , "H6_00217.ogg" },
              new string[] { "H6_00198.ogg" , "H6_00199.ogg" , "H6_00200.ogg" , "H6_00201.ogg" }
              };
              //強バイブ　通常
              sLoopVoice30Vibe = new string[][] {
              new string[] { "H6_00162.ogg" , "H6_00163.ogg" , "H6_00170.ogg" , "H6_00171.ogg" },
              new string[] { "H6_00378.ogg" , "H6_00379.ogg" , "H6_00178.ogg" , "H6_00179.ogg" },
              new string[] { "H6_00164.ogg" , "H6_00165.ogg" , "H6_00172.ogg" , "H6_00173.ogg" },
              new string[] { "H6_00380.ogg" , "H6_00381.ogg" , "H6_00180.ogg" , "H6_00181.ogg" },
              new string[] { "H6_00194.ogg" , "H6_00195.ogg" , "H6_00196.ogg" , "H6_00197.ogg" }
              };
              //強バイブ　フェラ
              sLoopVoice30Fera = new string[][] {
              new string[] { "H6_00210.ogg" , "H6_00211.ogg" , "H6_00218.ogg" , "H6_00219.ogg" },
              new string[] { "H6_00210.ogg" , "H6_00211.ogg" , "H6_00218.ogg" , "H6_00219.ogg" },
              new string[] { "H6_00212.ogg" , "H6_00213.ogg" , "H6_00220.ogg" , "H6_00221.ogg" },
              new string[] { "H6_00212.ogg" , "H6_00213.ogg" , "H6_00220.ogg" , "H6_00221.ogg" },
              new string[] { "H6_00202.ogg" , "H6_00203.ogg" , "H6_00204.ogg" , "H6_00205.ogg" }
              };
              //絶頂　通常
              sOrgasmVoice30Vibe = new string[][] {
              new string[] { "H6_00421.ogg" , "H6_00429.ogg" , "H6_00448.ogg" , "H6_00409.ogg" },
              new string[] { "H6_08956.ogg" , "H6_08721.ogg" , "H6_08731.ogg" , "H6_09052.ogg" , "H6_00413.ogg" },
              new string[] { "H6_04166.ogg" , "H6_04305.ogg" , "H6_05273.ogg" , "H6_06550.ogg" , "H6_06555.ogg" , "H6_05185.ogg" , "H6_08956.ogg" , "H6_08721.ogg" , "H6_08731.ogg" , "H6_02949.ogg" , "H6_03938.ogg" , "H6_00936.ogg" , "H6_05653.ogg" },
              new string[] { "H6_08869.ogg" , "H6_06946.ogg" , "H6_06610.ogg" , "H6_06615.ogg" , "H6_06627.ogg" , "H6_08868.ogg" , "H6_08948.ogg" , "H6_09026.ogg" , "H6_05578.ogg" , "H6_06985.ogg" , "H6_05688.ogg" , "H6_01064.ogg" , "H6_03986.ogg" , "H6_01165.ogg" , "H6_04233.ogg" , "H6_08717.ogg" , "H6_08718.ogg" , "H6_08719.ogg" , "H6_08721.ogg" , "H6_08867.ogg" , "H6_08953.ogg" , "H6_08956.ogg" , "H6_08958.ogg" , "H6_09001.ogg" , "H6_09002.ogg" , "H6_09008.ogg" , "H6_09023.ogg" , "H6_09025.ogg" , "H6_09028.ogg" , "H6_06006.ogg" , "H6_04130.ogg" },
              new string[] { "H6_09028.ogg" , "H6_09023.ogg" , "H6_09002.ogg" , "H6_08956.ogg" , "H6_00421.ogg" , "H6_00429.ogg" , "H6_00448.ogg" , "H6_00409.ogg" }
              };
              //絶頂　フェラ
              sOrgasmVoice30Fera = new string[][] {
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" }
              };
              //停止時
              sLoopVoice40Vibe = new string[] { "H6_00263.ogg" , "H6_00264.ogg" , "H6_00267.ogg" , "H6_00268.ogg" , "H6_00284.ogg" };
            }}


            //性格別声テーブル　ふわふわ妹---------------------------------------------------------------
            class BasicVoiceSister : BasicVoiceSet { public BasicVoiceSister() {
              //弱バイブ　通常
              sLoopVoice20Vibe = new string[][] {
              new string[] { "H7_02762.ogg" , "H7_02763.ogg" , "H7_02770.ogg" , "H7_02771.ogg" },
              new string[] { "H7_02978.ogg" , "H7_02979.ogg" , "H7_02850.ogg" , "H7_02851.ogg" },
              new string[] { "H7_02764.ogg" , "H7_02765.ogg" , "H7_02772.ogg" , "H7_02773.ogg" },
              new string[] { "H7_02980.ogg" , "H7_02981.ogg" , "H7_02852.ogg" , "H7_02853.ogg" },
              new string[] { "H7_02962.ogg" , "H7_02963.ogg" , "H7_02802.ogg" , "H7_02803.ogg" }
              };
              //弱バイブ　フェラ
              sLoopVoice20Fera = new string[][] {
              new string[] { "H7_02810.ogg" , "H7_02811.ogg" , "H7_02818.ogg" , "H7_02819.ogg" },
              new string[] { "H7_02810.ogg" , "H7_02811.ogg" , "H7_02818.ogg" , "H7_02819.ogg" },
              new string[] { "H7_02812.ogg" , "H7_02813.ogg" , "H7_02820.ogg" , "H7_02821.ogg" },
              new string[] { "H7_02812.ogg" , "H7_02813.ogg" , "H7_02820.ogg" , "H7_02821.ogg" },
              new string[] { "H7_02810.ogg" , "H7_02811.ogg" , "H7_02818.ogg" , "H7_02819.ogg" }
              };
              //強バイブ　通常
              sLoopVoice30Vibe = new string[][] {
              new string[] { "H7_02766.ogg" , "H7_02767.ogg" , "H7_02774.ogg" , "H7_02775.ogg" },
              new string[] { "H7_02982.ogg" , "H7_02983.ogg" , "H7_02854.ogg" , "H7_02855.ogg" },
              new string[] { "H7_02768.ogg" , "H7_02769.ogg" , "H7_02776.ogg" , "H7_02777.ogg" },
              new string[] { "H7_02984.ogg" , "H7_02985.ogg" , "H7_02856.ogg" , "H7_02857.ogg" },
              new string[] { "H7_02964.ogg" , "H7_02965.ogg" , "H7_02804.ogg" , "H7_02805.ogg" }
              };
              //強バイブ　フェラ
              sLoopVoice30Fera = new string[][] {
              new string[] { "H7_02814.ogg" , "H7_02815.ogg" , "H7_02822.ogg" , "H7_02823.ogg" },
              new string[] { "H7_02814.ogg" , "H7_02815.ogg" , "H7_02822.ogg" , "H7_02823.ogg" },
              new string[] { "H7_02816.ogg" , "H7_02817.ogg" , "H7_02824.ogg" , "H7_02825.ogg" },
              new string[] { "H7_02816.ogg" , "H7_02817.ogg" , "H7_02824.ogg" , "H7_02825.ogg" },
              new string[] { "H7_02812.ogg" , "H7_02813.ogg" , "H7_02820.ogg" , "H7_02821.ogg" }
              };
              //絶頂　通常
              sOrgasmVoice30Vibe = new string[][] {
              new string[] { "H7_03163.ogg" , "H7_03167.ogg" , "H7_03164.ogg" , "H7_03172.ogg" },
              new string[] { "H7_08797.ogg" , "H7_07791.ogg" , "H7_02309.ogg" , "H7_02353.ogg" , "H7_01991.ogg" , "H7_02498.ogg" },
              new string[] { "H7_05958.ogg" , "H7_02353.ogg" , "H7_02410.ogg" , "H7_04331.ogg" , "H7_01699.ogg" , "H7_02060.ogg" , "H7_05359.ogg" , "H7_02506.ogg" , "H7_01821.ogg" , "H7_02301.ogg" , "H7_01744.ogg" , "H7_02498.ogg" },
              new string[] { "H7_04244.ogg" , "H7_00531.ogg" , "H7_01330.ogg" , "H7_01334.ogg" , "H7_02130.ogg" , "H7_02210.ogg" , "H7_01029.ogg" , "H7_05585.ogg" , "H7_01341.ogg" , "H7_01349.ogg" , "H7_04080.ogg" , "H7_01989.ogg" , "H7_07979.ogg" , "H7_05958.ogg" , "H7_02353.ogg" , "H7_04331.ogg" , "H7_02060.ogg" , "H7_02506.ogg" , "H7_01821.ogg" , "H7_02301.ogg" , "H7_01744.ogg" , "H7_02498.ogg" , "H7_08797.ogg" , "H7_07791.ogg" , "H7_02309.ogg" , "H7_02353.ogg" , "H7_01991.ogg" , "H7_02498.ogg" },
              new string[] { "H7_03163.ogg" , "H7_03167.ogg" , "H7_03164.ogg" , "H7_03172.ogg" }
              };
              //絶頂　フェラ
              sOrgasmVoice30Fera = new string[][] {
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" }
              };
              //停止時
              sLoopVoice40Vibe = new string[] { "H7_03086.ogg" , "H7_03087.ogg" , "H7_03102.ogg" , "H7_03103.ogg" , "H7_02889.ogg" };
            }}


            //性格別声テーブル　無愛想---------------------------------------------------------------
            class BasicVoiceCurtness : BasicVoiceSet { public BasicVoiceCurtness() {
              //弱バイブ　通常
              sLoopVoice20Vibe = new string[][] {
              new string[] { "H8_01331.ogg" , "H8_01332.ogg" , "H8_01139.ogg" , "H8_01140.ogg" },
              new string[] { "H8_01347.ogg" , "H8_01348.ogg" , "H8_01131.ogg" , "H8_01132.ogg" },
              new string[] { "H8_01333.ogg" , "H8_01334.ogg" , "H8_01141.ogg" , "H8_01142.ogg" },
              new string[] { "H8_01349.ogg" , "H8_01350.ogg" , "H8_01133.ogg" , "H8_01134.ogg" },
              new string[] { "H8_01163.ogg" , "H8_01164.ogg" , "H8_01171.ogg" , "H8_01172.ogg" }
              };
              //弱バイブ　フェラ
              sLoopVoice20Fera = new string[][] {
              new string[] { "H8_01179.ogg" , "H8_01180.ogg" , "H8_01187.ogg" , "H8_01188.ogg" },
              new string[] { "H8_01179.ogg" , "H8_01180.ogg" , "H8_01187.ogg" , "H8_01188.ogg" },
              new string[] { "H8_01181.ogg" , "H8_01182.ogg" , "H8_01189.ogg" , "H8_01190.ogg" },
              new string[] { "H8_01181.ogg" , "H8_01182.ogg" , "H8_01189.ogg" , "H8_01190.ogg" },
              new string[] { "H8_01179.ogg" , "H8_01180.ogg" , "H8_01187.ogg" , "H8_01188.ogg" }
              };
              //強バイブ　通常
              sLoopVoice30Vibe = new string[][] {
              new string[] { "H8_01335.ogg" , "H8_01336.ogg" , "H8_01143.ogg" , "H8_01144.ogg" },
              new string[] { "H8_01351.ogg" , "H8_01352.ogg" , "H8_01135.ogg" , "H8_01136.ogg" },
              new string[] { "H8_01337.ogg" , "H8_01338.ogg" , "H8_01145.ogg" , "H8_01146.ogg" },
              new string[] { "H8_01353.ogg" , "H8_01354.ogg" , "H8_01137.ogg" , "H8_01138.ogg" },
              new string[] { "H8_01165.ogg" , "H8_01166.ogg" , "H8_01173.ogg" , "H8_01174.ogg" }
              };
              //強バイブ　フェラ
              sLoopVoice30Fera = new string[][] {
              new string[] { "H8_01183.ogg" , "H8_01184.ogg" , "H8_01191.ogg" , "H8_01192.ogg" },
              new string[] { "H8_01183.ogg" , "H8_01184.ogg" , "H8_01191.ogg" , "H8_01192.ogg" },
              new string[] { "H8_01185.ogg" , "H8_01186.ogg" , "H8_01193.ogg" , "H8_01194.ogg" },
              new string[] { "H8_01185.ogg" , "H8_01186.ogg" , "H8_01193.ogg" , "H8_01194.ogg" },
              new string[] { "H8_01181.ogg" , "H8_01182.ogg" , "H8_01189.ogg" , "H8_01190.ogg" }
              };
              //絶頂　通常
              sOrgasmVoice30Vibe = new string[][] {
              new string[] { "H8_08466.ogg" , "H8_01430.ogg" , "H8_01421.ogg" , "H8_01382.ogg" , "H8_01396.ogg" , "H8_01398.ogg" },
              new string[] { "H8_08440.ogg" , "H8_08455.ogg" , "H8_08456.ogg" , "H8_08485.ogg" , "H8_08497.ogg" , "H8_08499.ogg" , "H8_02017.ogg" },
              new string[] { "H8_08471.ogg" , "H8_08473.ogg" , "H8_08500.ogg" , "H8_05361.ogg" , "H8_01936.ogg" , "H8_00646.ogg" , "H8_00648.ogg" , "H8_00657.ogg" , "H8_02023.ogg" , "H8_02025.ogg" , "H8_00717.ogg" , "H8_05547.ogg" },
              new string[] { "H8_08463.ogg" , "H8_08464.ogg" , "H8_08465.ogg" , "H8_08486.ogg" , "H8_08492.ogg" , "H8_08505.ogg" , "H8_07064.ogg" , "H8_09399.ogg" , "H8_09402.ogg" , "H8_09474.ogg" , "H8_02953.ogg" , "H8_05361.ogg" , "H8_02971.ogg" , "H8_01936.ogg" , "H8_03201.ogg" , "H8_03206.ogg" , "H8_00617.ogg" , "H8_00646.ogg" , "H8_00657.ogg" , "H8_02025.ogg" , "H8_00747.ogg" , "H8_00768.ogg" , "H8_01626.ogg" , "H8_00830.ogg" , "H8_07061.ogg" , "H8_07062.ogg" , "H8_00918.ogg" , "H8_05277.ogg" , "H8_04988.ogg" , "H8_05006.ogg" , "H8_05322.ogg" , "H8_05214.ogg" , "H8_05249.ogg" , "H8_05252.ogg" , "H8_09710.ogg" , "H8_09711.ogg" , "H8_09712.ogg" , "H8_01396.ogg" },
              new string[] { "H8_01427.ogg" , "H8_01382.ogg" , "H8_01421.ogg" , "H8_01401.ogg" , "H8_01396.ogg" , "H8_01398.ogg" }
              };
              //絶頂　フェラ
              sOrgasmVoice30Fera = new string[][] {
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" }
              };
              //停止時
              sLoopVoice40Vibe = new string[] { "H8_01455.ogg" , "H8_01456.ogg" , "H8_01457.ogg" , "H8_01472.ogg" , "H8_01459.ogg" };
            }}


            //性格別声テーブル　お嬢様---------------------------------------------------------------
            class BasicVoiceMissy : BasicVoiceSet { public BasicVoiceMissy() {
              //弱バイブ　通常
              sLoopVoice20Vibe = new string[][] {
              new string[] { "H9_00586.ogg" , "H9_00587.ogg" , "H9_00578.ogg" , "H9_00579.ogg" },
              new string[] { "H9_00786.ogg" , "H9_00787.ogg" , "H9_00570.ogg" , "H9_00571.ogg" },//{ "H9_00788.ogg" , "H9_00789.ogg" , "H9_00805.ogg" , "H9_00806.ogg" },
              new string[] { "H9_00588.ogg" , "H9_00589.ogg" , "H9_00580.ogg" , "H9_00581.ogg" },
              new string[] { "H9_00788.ogg" , "H9_00789.ogg" , "H9_00572.ogg" , "H9_00573.ogg" },//{ "H9_00807.ogg" , "H9_00790.ogg" , "H9_00791.ogg" , "H9_00574.ogg" },
              new string[] { "H9_00612.ogg" , "H9_00613.ogg" , "H9_00610.ogg" , "H9_00611.ogg" } //{ "H9_00637.ogg" , "H9_00638.ogg" , "H9_00773.ogg" , "H9_00774.ogg" } // ca001f(L3-L5)喪失 + ca001h(L3,L4)初心
              };
              //弱バイブ　フェラ
              sLoopVoice20Fera = new string[][] {
              new string[] { "H9_00618.ogg" , "H9_00619.ogg" , "H9_00626.ogg" , "H9_00627.ogg" },
              new string[] { "H9_00618.ogg" , "H9_00619.ogg" , "H9_00626.ogg" , "H9_00627.ogg" },
              new string[] { "H9_00620.ogg" , "H9_00621.ogg" , "H9_00628.ogg" , "H9_00629.ogg" },
              new string[] { "H9_00620.ogg" , "H9_00621.ogg" , "H9_00628.ogg" , "H9_00629.ogg" },
              new string[] { "H9_00618.ogg" , "H9_00619.ogg" , "H9_00626.ogg" , "H9_00627.ogg" }
              };
              //強バイブ　通常
              sLoopVoice30Vibe = new string[][] {
              new string[] { "H9_00590.ogg" , "H9_00591.ogg" , "H9_00582.ogg" , "H9_00583.ogg" },
              new string[] { "H9_00790.ogg" , "H9_00791.ogg" , "H9_00574.ogg" , "H9_00575.ogg" },//{ "H9_00808.ogg" , "H9_00792.ogg" , "H9_00574.ogg" , "H9_00575.ogg" },
              new string[] { "H9_00592.ogg" , "H9_00593.ogg" , "H9_00584.ogg" , "H9_00585.ogg" },
              new string[] { "H9_00792.ogg" , "H9_00793.ogg" , "H9_00576.ogg" , "H9_00577.ogg" },//{ "H9_00809.ogg" , "H9_00793.ogg" , "H9_00576.ogg" , "H9_00577.ogg" },
              new string[] { "H9_00614.ogg" , "H9_00615.ogg" , "H9_00617.ogg" , "H9_00616.ogg" } //{ "H9_00639.ogg" , "H9_00640.ogg" , "H9_00647.ogg" , "H9_00775.ogg" } // ca001f(L5-L76喪失 + ca001g(L5)酔い + ca001h(L5)初心 ※L6L7は音が小さい
              };
              //強バイブ　フェラ
              sLoopVoice30Fera = new string[][] {
              new string[] { "H9_00622.ogg" , "H9_00623.ogg" , "H9_00630.ogg" , "H9_00631.ogg" },
              new string[] { "H9_00622.ogg" , "H9_00623.ogg" , "H9_00630.ogg" , "H9_00631.ogg" },
              new string[] { "H9_00624.ogg" , "H9_00625.ogg" , "H9_00632.ogg" , "H9_00633.ogg" },
              new string[] { "H9_00624.ogg" , "H9_00625.ogg" , "H9_00632.ogg" , "H9_00633.ogg" },
              new string[] { "H9_00622.ogg" , "H9_00623.ogg" , "H9_00630.ogg" , "H9_00631.ogg" }
              };
              //絶頂　通常
              sOrgasmVoice30Vibe = new string[][] {
              new string[] { "H9_00825.ogg" , "H9_00833.ogg" , "H9_00841.ogg" , "H9_00824.ogg" , "H9_00966.ogg" , "H9_00860.ogg" , "H9_00987.ogg" },
              new string[] { "H9_09425.ogg" , "H9_04328.ogg" , "H9_09398.ogg" , "H9_00837.ogg" , "H9_04410.ogg" , "H9_07850.ogg" , "H9_04310.ogg" , "H9_04320.ogg" , "H9_04391.ogg" , "H9_09446.ogg" , "H9_04408.ogg" },
              new string[] { "H9_07848.ogg" , "H9_06388.ogg" , "H9_06428.ogg" , "H9_06468.ogg" , "H9_09446.ogg" , "H9_07851.ogg" , "H9_04310.ogg" , "H9_04287.ogg" , "H9_09438.ogg" , "H9_04187.ogg" , "H9_09303.ogg" , "H9_04114.ogg" , "H9_06929.ogg" , "H9_03989.ogg" },
              new string[] { "H9_09304.ogg" , "H9_03822.ogg" , "H9_02024.ogg" , "H9_06487.ogg" , "H9_05299.ogg" , "H9_09423.ogg" , "H9_08378.ogg" , "H9_09362.ogg" , "H9_07836.ogg" , "H9_04325.ogg" , "H9_08215.ogg" , "H9_06562.ogg" , "H9_06426.ogg" , "H9_07096.ogg" , "H9_07848.ogg" , "H9_03812.ogg" , "H9_03439.ogg" , "H9_06428.ogg" , "H9_05297.ogg" , "H9_09440.ogg" , "H9_09433.ogg" , "H9_06589.ogg" , "H9_04054.ogg" , "H9_04328.ogg" , "H9_00333.ogg" , "H9_03821.ogg" , "H9_06407.ogg" , "H9_09439.ogg" , "H9_07837.ogg" , "H9_07851.ogg" , "H9_06586.ogg" , "H9_04049.ogg" , "H9_05794.ogg" , "H9_04310.ogg" , "H9_05711.ogg" , "H9_04324.ogg" , "H9_03491.ogg" , "H9_06573.ogg" , "H9_07826.ogg" , "H9_09430.ogg" , "H9_09353.ogg" , "H9_04287.ogg" , "H9_04326.ogg" , "H9_09303.ogg" , "H9_04187.ogg" , "H9_03571.ogg" , "H9_03842.ogg" , "H9_03834.ogg" , "H9_07847.ogg" , "H9_06553.ogg" , "H9_04327.ogg" , "H9_03506.ogg" },
              new string[] { "H9_00825.ogg" , "H9_00833.ogg" , "H9_00841.ogg" , "H9_00824.ogg" , "H9_00966.ogg" , "H9_00860.ogg" , "H9_00987.ogg" }
              };
              //絶頂　フェラ
              sOrgasmVoice30Fera = new string[][] {
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" }
              };
              //停止時
              sLoopVoice40Vibe = new string[] { "H9_00894.ogg" , "H9_00909.ogg" , "H9_00895.ogg" , "H9_00910.ogg" , "H9_04413.ogg" };
            }}


            //性格別声テーブル　幼馴染---------------------------------------------------------------
            class BasicVoiceChildhood : BasicVoiceSet { public BasicVoiceChildhood() {
              //弱バイブ　通常
              sLoopVoice20Vibe = new string[][] {
              new string[] { "H10_03849.ogg" , "H10_03850.ogg" , "H10_03857.ogg" , "H10_03858.ogg" },
              new string[] { "H10_03841.ogg" , "H10_03842.ogg" , "H10_04057.ogg" , "H10_04058.ogg" },
              new string[] { "H10_03851.ogg" , "H10_03852.ogg" , "H10_03859.ogg" , "H10_03860.ogg" },
              new string[] { "H10_03843.ogg" , "H10_03844.ogg" , "H10_04059.ogg" , "H10_04060.ogg" },
              new string[] { "H10_03881.ogg" , "H10_03882.ogg" , "H10_03883.ogg" , "H10_03884.ogg" }
              };
              //弱バイブ　フェラ
              sLoopVoice20Fera = new string[][] {
              new string[] { "H10_03889.ogg" , "H10_03890.ogg" , "H10_03897.ogg" , "H10_03898.ogg" },
              new string[] { "H10_03889.ogg" , "H10_03890.ogg" , "H10_03897.ogg" , "H10_03898.ogg" },
              new string[] { "H10_03891.ogg" , "H10_03892.ogg" , "H10_03899.ogg" , "H10_03900.ogg" },
              new string[] { "H10_03891.ogg" , "H10_03892.ogg" , "H10_03899.ogg" , "H10_03900.ogg" },
              new string[] { "H10_03889.ogg" , "H10_03890.ogg" , "H10_03897.ogg" , "H10_03898.ogg" }
              };
              //強バイブ　通常
              sLoopVoice30Vibe = new string[][] {
              new string[] { "H10_03853.ogg" , "H10_03854.ogg" , "H10_03861.ogg" , "H10_03862.ogg" },
              new string[] { "H10_03845.ogg" , "H10_03846.ogg" , "H10_04061.ogg" , "H10_04062.ogg" },
              new string[] { "H10_03855.ogg" , "H10_03856.ogg" , "H10_03863.ogg" , "H10_03864.ogg" },
              new string[] { "H10_03847.ogg" , "H10_03848.ogg" , "H10_04063.ogg" , "H10_04064.ogg" },
              new string[] { "H10_03885.ogg" , "H10_03886.ogg" , "H10_03887.ogg" , "H10_03888.ogg" }
              };
              //強バイブ　フェラ
              sLoopVoice30Fera = new string[][] {
              new string[] { "H10_03893.ogg" , "H10_03894.ogg" , "H10_03901.ogg" , "H10_03902.ogg" },
              new string[] { "H10_03893.ogg" , "H10_03894.ogg" , "H10_03901.ogg" , "H10_03902.ogg" },
              new string[] { "H10_03895.ogg" , "H10_03896.ogg" , "H10_03903.ogg" , "H10_03904.ogg" },
              new string[] { "H10_03895.ogg" , "H10_03896.ogg" , "H10_03903.ogg" , "H10_03904.ogg" },
              new string[] { "H10_03893.ogg" , "H10_03894.ogg" , "H10_03901.ogg" , "H10_03902.ogg" }
              };
              //絶頂　通常
              sOrgasmVoice30Vibe = new string[][] {
              new string[] { "H10_04104.ogg" , "H10_04120.ogg" , "H10_04108.ogg" , "H10_04092.ogg" , "H10_04112.ogg" , "H10_04242.ogg" , "H10_04253.ogg" },
              new string[] { "H10_08819.ogg" , "H10_09457.ogg" , "H10_09058.ogg" , "H10_07196.ogg" , "H10_07216.ogg" , "H10_08271.ogg" , "H10_09813.ogg" },
              new string[] { "H10_09415.ogg" , "H10_09993.ogg" , "H10_08334.ogg" , "H10_01736.ogg" , "H10_01739.ogg" , "H10_03656.ogg" , "H10_03475.ogg" , "H10_03050.ogg" , "H10_03714.ogg" , "H10_03717.ogg" , "H10_03504.ogg" , "H10_03752.ogg" , "H10_04738.ogg" , "H10_08819.ogg" , "H10_09457.ogg" , "H10_09058.ogg" , "H10_07196.ogg" , "H10_07216.ogg" , "H10_08271.ogg" , "H10_09813.ogg" },
              new string[] { "H10_09415.ogg" , "H10_09993.ogg" , "H10_08334.ogg" , "H10_01736.ogg" , "H10_01739.ogg" , "H10_03656.ogg" , "H10_03475.ogg" , "H10_03050.ogg" , "H10_03714.ogg" , "H10_03717.ogg" , "H10_03504.ogg" , "H10_03752.ogg" , "H10_04738.ogg" , "H10_08819.ogg" , "H10_09457.ogg" , "H10_09058.ogg" , "H10_07196.ogg" , "H10_07216.ogg" , "H10_08271.ogg" , "H10_09813.ogg" , "H10_07212.ogg" , "H10_09173.ogg" , "H10_01079.ogg" , "H10_01553.ogg" , "H10_00671.ogg" , "H10_03456.ogg" , "H10_09207.ogg" , "H10_05225.ogg" , "H10_05228.ogg" , "H10_05231.ogg" , "H10_05617.ogg" , "H10_05393.ogg" , "H10_06041.ogg" , "H10_06229.ogg" , "H10_06066.ogg" , "H10_07020.ogg" , "H10_07021.ogg" },
              new string[] { "H10_04104.ogg" , "H10_04120.ogg" , "H10_04108.ogg" , "H10_04092.ogg" , "H10_04112.ogg" , "H10_04242.ogg" , "H10_04253.ogg" }
              };
              //絶頂　フェラ
              sOrgasmVoice30Fera = new string[][] {
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" }
              };
              //停止時
              sLoopVoice40Vibe = new string[] { "H10_04171.ogg" , "H10_04165.ogg" , "H10_04166.ogg" , "H10_04168.ogg" , "H10_04170.ogg" };
            }}


            //性格別声テーブル　ドＭ---------------------------------------------------------------
            class BasicVoiceMasochist : BasicVoiceSet { public BasicVoiceMasochist() {
              //弱バイブ　通常
              sLoopVoice20Vibe = new string[][] {
              new string[] { "H11_00673.ogg" , "H11_00674.ogg" , "H11_00681.ogg" , "H11_00682.ogg" }, //ca001a + ca001b(L0,L1)
              new string[] { "H11_00865.ogg" , "H11_00866.ogg" , "H11_00689.ogg" , "H11_00690.ogg" }, //ca001j(L0,L1) + ca001c(L0,L1)
              new string[] { "H11_00675.ogg" , "H11_00676.ogg" , "H11_00683.ogg" , "H11_00684.ogg" }, //ca001a(L2,L3) + ca001b(L2,L3)
              new string[] { "H11_00867.ogg" , "H11_00868.ogg" , "H11_00691.ogg" , "H11_00692.ogg" }, //ca001j(L2,L3) + ca001c(L2,L3)
              new string[] { "H11_00705.ogg" , "H11_00706.ogg" , "H11_00729.ogg" , "H11_00730.ogg" }  //ca001d(L0,L1) + ca001f(L0,L1)
              };
              //弱バイブ　フェラ
              sLoopVoice20Fera = new string[][] {
              new string[] { "H11_00713.ogg" , "H11_00714.ogg" , "H11_00721.ogg" , "H11_00722.ogg" }, //ca003a(L0,L1) + ca003b(L0,L1)
              new string[] { "H11_00713.ogg" , "H11_00714.ogg" , "H11_00721.ogg" , "H11_00722.ogg" },
              new string[] { "H11_00715.ogg" , "H11_00716.ogg" , "H11_00723.ogg" , "H11_00724.ogg" }, //ca003a(L2,L3) + ca003b(L2,L3)
              new string[] { "H11_00715.ogg" , "H11_00716.ogg" , "H11_00723.ogg" , "H11_00724.ogg" },
              new string[] { "H11_00713.ogg" , "H11_00714.ogg" , "H11_00721.ogg" , "H11_00722.ogg" }
              };
              //強バイブ　通常
              sLoopVoice30Vibe = new string[][] {
              new string[] { "H11_00677.ogg" , "H11_00678.ogg" , "H11_00685.ogg" , "H11_00686.ogg" }, //ca001a(L4,L5) + ca001b(L4,L5)
              new string[] { "H11_00869.ogg" , "H11_00870.ogg" , "H11_00693.ogg" , "H11_00694.ogg" }, //ca001j(L4,L5) + ca001c(L4,L5)
              new string[] { "H11_00679.ogg" , "H11_00680.ogg" , "H11_00687.ogg" , "H11_00688.ogg" }, //ca001a(L6,L7) + ca001b(L6,L7)
              new string[] { "H11_00871.ogg" , "H11_00872.ogg" , "H11_00695.ogg" , "H11_00696.ogg" }, //ca001j(L6,L7) + ca001c(L6,L7)
              new string[] { "H11_00708.ogg" , "H11_00707.ogg" , "H11_00731.ogg" , "H11_00732.ogg" }  //ca001d(L2,L3) + ca001f(L2,L3)
              };
              //強バイブ　フェラ
              sLoopVoice30Fera = new string[][] {
              new string[] { "H11_00717.ogg" , "H11_00718.ogg" , "H11_00725.ogg" , "H11_00726.ogg" }, //ca003a(L4,L5) + ca003b(L4,L5)
              new string[] { "H11_00717.ogg" , "H11_00718.ogg" , "H11_00725.ogg" , "H11_00726.ogg" },
              new string[] { "H11_00719.ogg" , "H11_00720.ogg" , "H11_00727.ogg" , "H11_00728.ogg" }, //ca003a(L6,L7) + ca003b(L6,L7)
              new string[] { "H11_00719.ogg" , "H11_00720.ogg" , "H11_00727.ogg" , "H11_00728.ogg" },
              new string[] { "H11_00717.ogg" , "H11_00718.ogg" , "H11_00725.ogg" , "H11_00726.ogg" }
              };
              //絶頂　通常
              sOrgasmVoice30Vibe = new string[][] {
              new string[] { "H11_00902.ogg" , "H11_00905.ogg" , "H11_00923.ogg" , "H11_00924.ogg" }, //sou_00001(L1) sou_00002(L0) yam02(L2,L3)
              new string[] { "H11_04914.ogg" , "H11_04738.ogg" , "H11_04915.ogg" , "H11_04983.ogg" ,"H11_05086.ogg" }, //ntr_0005(L20) ? ntr_0005(L21) ntr_0010(L17) nytg_ntr_advhook_0001(L22)
              new string[] { "H11_01458.ogg" , "H11_02000.ogg" , "H11_01850.ogg" , "H11_01963.ogg" , "H11_04177.ogg" , "H11_04265.ogg" , "H11_01980.ogg" , "H11_01988.ogg" , "H11_02029.ogg" ,
                             "H11_04914.ogg" , "H11_04738.ogg" , "H11_04915.ogg" , "H11_04983.ogg" ,"H11_05086.ogg" }, //2行目と同じ
              new string[] { "H11_04902.ogg" , "H11_05069.ogg" , "H11_05104.ogg" , "H11_05150.ogg" , "H11_04450.ogg" , "H11_01875.ogg" , "H11_01880.ogg" , "H11_01883.ogg" , "H11_01885.ogg" , "H11_02204.ogg" , "H11_01945.ogg" , "H11_04253.ogg" , "H11_03646.ogg" , "H11_03545.ogg" , "H11_03414.ogg" , "H11_03548.ogg" , "H11_03596.ogg" , "H11_05093.ogg" , "H11_01988.ogg" ,
                             "H11_04914.ogg" , "H11_04738.ogg" , "H11_04915.ogg" , "H11_04983.ogg" ,"H11_05086.ogg" }, //2行目と同じ
              new string[] { "H11_00902.ogg" , "H11_00905.ogg" , "H11_00923.ogg" , "H11_00924.ogg" }
              };
              //絶頂　フェラ
              sOrgasmVoice30Fera = new string[][] {
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" }
              };
              //停止時
              sLoopVoice40Vibe = new string[] { "H11_00957.ogg" , "H11_00969.ogg" , "H11_00958.ogg" , "H11_00970.ogg" , "H11_02817.ogg" };
            }}


            //性格別声テーブル　腹黒---------------------------------------------------------------
            class BasicVoiceCrafty : BasicVoiceSet { public BasicVoiceCrafty() {
              //弱バイブ　通常
              sLoopVoice20Vibe = new string[][] {
              new string[] { "H12_01213.ogg" , "H12_01214.ogg" , "H12_01221.ogg" , "H12_01222.ogg" },
              new string[] { "H12_01205.ogg" , "H12_01206.ogg" , "H12_01421.ogg" , "H12_01422.ogg" },
              new string[] { "H12_01215.ogg" , "H12_01216.ogg" , "H12_01223.ogg" , "H12_01227.ogg" },
              new string[] { "H12_01207.ogg" , "H12_01208.ogg" , "H12_01423.ogg" , "H12_01424.ogg" },
              new string[] { "H12_01245.ogg" , "H12_01247.ogg" , "H12_01248.ogg" , "H12_01249.ogg" }
              };
              //弱バイブ　フェラ
              sLoopVoice20Fera = new string[][] {
              new string[] { "H12_01253.ogg" , "H12_01254.ogg" , "H12_01261.ogg" , "H12_01262.ogg" },
              new string[] { "H12_01253.ogg" , "H12_01254.ogg" , "H12_01261.ogg" , "H12_01262.ogg" },
              new string[] { "H12_01255.ogg" , "H12_01256.ogg" , "H12_01263.ogg" , "H12_01264.ogg" },
              new string[] { "H12_01255.ogg" , "H12_01256.ogg" , "H12_01263.ogg" , "H12_01264.ogg" },
              new string[] { "H12_01253.ogg" , "H12_01254.ogg" , "H12_01261.ogg" , "H12_01262.ogg" }
              };
              //強バイブ　通常
              sLoopVoice30Vibe = new string[][] {
              new string[] { "H12_01217.ogg" , "H12_01218.ogg" , "H12_01225.ogg" , "H12_01226.ogg" },
              new string[] { "H12_01209.ogg" , "H12_01210.ogg" , "H12_01425.ogg" , "H12_01426.ogg" },
              new string[] { "H12_01219.ogg" , "H12_01220.ogg" , "H12_01227.ogg" , "H12_01228.ogg" },
              new string[] { "H12_01211.ogg" , "H12_01212.ogg" , "H12_01427.ogg" , "H12_01428.ogg" },
              new string[] { "H12_01249.ogg" , "H12_01250.ogg" , "H12_01251.ogg" , "H12_01252.ogg" }
              };
              //強バイブ　フェラ
              sLoopVoice30Fera = new string[][] {
              new string[] { "H12_01257.ogg" , "H12_01258.ogg" , "H12_01265.ogg" , "H12_01266.ogg" },
              new string[] { "H12_01257.ogg" , "H12_01258.ogg" , "H12_01265.ogg" , "H12_01266.ogg" },
              new string[] { "H12_01259.ogg" , "H12_01260.ogg" , "H12_01267.ogg" , "H12_01268.ogg" },
              new string[] { "H12_01259.ogg" , "H12_01260.ogg" , "H12_01267.ogg" , "H12_01268.ogg" },
              new string[] { "H12_01257.ogg" , "H12_01258.ogg" , "H12_01265.ogg" , "H12_01266.ogg" }
              };
              //絶頂　通常
              sOrgasmVoice30Vibe = new string[][] {
              new string[] { "H12_01487.ogg" , "H12_01488.ogg" , "H12_01487.ogg" , "H12_01488.ogg" },
              new string[] { "H12_01488.ogg" , "H12_01663.ogg" , "H12_03082.ogg" , "H12_03084.ogg" ,"H12_03115.ogg" },
              new string[] { "H12_03082.ogg" , "H12_01725.ogg" , "H12_03082.ogg" , "H12_01870.ogg" , "H12_01799.ogg" , "H12_01787.ogg", "H12_01488.ogg" , "H12_01663.ogg" , "H12_03084.ogg" ,"H12_03115.ogg" },
              new string[] { "H12_01487.ogg" , "H12_01665.ogg" , "H12_01870.ogg" , "H12_01799.ogg" , "H12_01725.ogg" , "H12_03084.ogg" , "H12_03096.ogg" , "H12_03115.ogg" , "H12_01663.ogg" , "H12_01787.ogg" , "H12_01666.ogg"  },
              new string[] { "H12_01487.ogg" , "H12_01488.ogg" , "H12_01487.ogg" , "H12_01488.ogg" }
              };
              //絶頂　フェラ
              sOrgasmVoice30Fera = new string[][] {
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" }
              };
              //停止時
              sLoopVoice40Vibe = new string[] { "H12_01529.ogg" , "H12_01544.ogg" , "H12_01530.ogg" , "H12_01545.ogg" , "H12_01534.ogg" };
            }}


            //性格別声テーブル　気さく---------------------------------------------------------------
            class BasicVoiceFriendly : BasicVoiceSet { public BasicVoiceFriendly() {
              //弱バイブ　通常
              sLoopVoice20Vibe = new string[][] {
              new string[] { "V1_00490.ogg" , "V1_00491.ogg" , "V1_00498.ogg" , "V1_00499.ogg" }, //ca001b(L0,L1) + ca001c(L0,L1)
              new string[] { "V1_00482.ogg" , "V1_00483.ogg" , "V1_00698.ogg" , "V1_00699.ogg" }, //ca001a(L0,L1) + ca001j(L0,L1)発情
              new string[] { "V1_00492.ogg" , "V1_00493.ogg" , "V1_00500.ogg" , "V1_00501.ogg" }, //1行目続き (L2,L3)
              new string[] { "V1_00484.ogg" , "V1_00485.ogg" , "V1_00700.ogg" , "V1_00701.ogg" }, //2行目続き (L2,L3)
              //new string[] { "V1_00522.ogg" , "V1_00523.ogg" , "V1_00524.ogg" , "V1_00525.ogg" }  //ca001e(L0-L3)首絞め
              new string[] { "V1_00550.ogg" , "V1_00551.ogg" , "V1_00558.ogg" , "V1_00559.ogg" }  //ca001f(L4-L5)喪失 + ca001g(L4-L5)酔い
              };
              //弱バイブ　フェラ
              sLoopVoice20Fera = new string[][] {
              new string[] { "V1_00530.ogg" , "V1_00531.ogg" , "V1_00538.ogg" , "V1_00539.ogg" }, //ca003a(L0,L1) + ca003b(L0,L1)
              new string[] { "V1_00530.ogg" , "V1_00531.ogg" , "V1_00538.ogg" , "V1_00539.ogg" }, //↑と同じ
              new string[] { "V1_00532.ogg" , "V1_00533.ogg" , "V1_00540.ogg" , "V1_00541.ogg" }, //1行目続き (L2,L3)
              new string[] { "V1_00532.ogg" , "V1_00533.ogg" , "V1_00540.ogg" , "V1_00541.ogg" }, //↑と同じ
              new string[] { "V1_00530.ogg" , "V1_00531.ogg" , "V1_00538.ogg" , "V1_00539.ogg" }  //1行目と同じ
              };
              //強バイブ　通常
              sLoopVoice30Vibe = new string[][] {
              new string[] { "V1_00494.ogg" , "V1_00495.ogg" , "V1_00502.ogg" , "V1_00503.ogg" }, //ca001b(L4,L5) + ca001c(L4,L5)
              new string[] { "V1_00486.ogg" , "V1_00487.ogg" , "V1_00702.ogg" , "V1_00703.ogg" }, //ca001a(L4,L5) + ca001j(L4,L5)発情
              new string[] { "V1_00496.ogg" , "V1_00497.ogg" , "V1_00504.ogg" , "V1_00505.ogg" }, //1行目続き (L6,L7)
              new string[] { "V1_00488.ogg" , "V1_00489.ogg" , "V1_00704.ogg" , "V1_00705.ogg" }, //2行目続き (L6,L7)
              //new string[] { "V1_00526.ogg" , "V1_00527.ogg" , "V1_00528.ogg" , "V1_00529.ogg" }  //ca001e(L4-L7)首絞め
              new string[] { "V1_00552.ogg" , "V1_00553.ogg" , "V1_00560.ogg" , "V1_00561.ogg" }  //ca001f(L6,L7)喪失 + ca001g(L6,L7)酔い
              };
              //強バイブ　フェラ
              sLoopVoice30Fera = new string[][] {
              new string[] { "V1_00534.ogg" , "V1_00535.ogg" , "V1_00542.ogg" , "V1_00543.ogg" }, //ca003a(L4,L5) + ca003b(L4,L5)
              new string[] { "V1_00534.ogg" , "V1_00535.ogg" , "V1_00542.ogg" , "V1_00543.ogg" }, //↑と同じ
              new string[] { "V1_00536.ogg" , "V1_00537.ogg" , "V1_00544.ogg" , "V1_00545.ogg" }, //1行目続き (L6,L7)
              new string[] { "V1_00536.ogg" , "V1_00537.ogg" , "V1_00544.ogg" , "V1_00545.ogg" }, //↑と同じ
              new string[] { "V1_00534.ogg" , "V1_00535.ogg" , "V1_00542.ogg" , "V1_00543.ogg" }  //1行目と同じ
              };
              //絶頂　通常
              sOrgasmVoice30Vibe = new string[][] {
              new string[] { "V1_00745.ogg" , "V1_00781.ogg" , "V1_00749.ogg" , "V1_00733.ogg" , "V1_00753.ogg" , "V1_00834.ogg" , "V1_00850.ogg" }, //sou_00001(L3), yam01_抜く(L3), sou06_アナル処女喪失挿入(L3),sou01_性器に挿入(L3),sou07_発情挿入(L3),sa_被虐ダメージ台詞_叩く(L7),sa_被虐ダメージ台詞_ロウ(L11)
              new string[] { "V1_12062.ogg" , "V1_12234.ogg" , "V1_11722.ogg" , "V1_11768.ogg" , "V1_11769.ogg" }, //kashizuki初々しい,慣れ始め,VIP純愛 あたりから抽出
              new string[] { "V1_12363.ogg" , "V1_12364.ogg" , "V1_12365.ogg" , "V1_12378.ogg" , "V1_12399.ogg" , "V1_12400.ogg" , "V1_11553.ogg" ,  //kashizuki慣れ,VIP NTR, 愛撫 あたりから抽出
                             "V1_09218.ogg" , "V1_09219.ogg" , "V1_09302.ogg" , "V1_09312.ogg" , "V1_11618.ogg" , "V1_11624.ogg" , "V1_11896.ogg" ,"V1_11721.ogg" ,  //↑の続き
                             "V1_12062.ogg" , "V1_12234.ogg" , "V1_11722.ogg" , "V1_11768.ogg" , "V1_11769.ogg" , //2行目と同じ
                             "V1_09597.ogg" }, //3に入れないもの
              new string[] { "V1_12363.ogg" , "V1_12364.ogg" , "V1_12365.ogg" , "V1_12378.ogg" , "V1_12399.ogg" , "V1_12400.ogg" , "V1_11553.ogg" ,  //3行目と同じ
                             "V1_09218.ogg" , "V1_09219.ogg" , "V1_09302.ogg" , "V1_09312.ogg" , "V1_11618.ogg" , "V1_11624.ogg" , "V1_11896.ogg" ,"V1_11721.ogg" ,  //4行目と同じ
                             "V1_12062.ogg" , "V1_12234.ogg" , "V1_11723.ogg" , "V1_11768.ogg" , "V1_11769.ogg" ,  //2行目と同じ 一部変更
                             "V1_00111.ogg" , "V1_09594.ogg" , "V1_06544.ogg" , "V1_13386.ogg" , "V1_06966.ogg" , "V1_11743.ogg" }, //覚醒愛撫 他
              new string[] { "V1_00745.ogg" , "V1_00781.ogg" , "V1_00749.ogg" , "V1_00733.ogg" , "V1_00753.ogg" , "V1_00834.ogg" , "V1_00850.ogg" }  //1行目と同じ
              };
              //絶頂　フェラ
              sOrgasmVoice30Fera = new string[][] {
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" }
              };
              //停止時
              sLoopVoice40Vibe = new string[] { "V1_00806.ogg" , "V1_00812.ogg" , "V1_00807.ogg" , "V1_00810.ogg" , "V1_00811.ogg" }; //rr2_ca001c(L0), rr2_ca001a(L0,L1), rr2_ca001b(L0,L1)
            }}


            //性格別声テーブル　淑女---------------------------------------------------------------
            class BasicVoiceDame : BasicVoiceSet { public BasicVoiceDame() {
              //弱バイブ　通常
              sLoopVoice20Vibe = new string[][] {
              new string[] { "V0_00488.ogg" , "V0_00489.ogg" , "V0_00496.ogg" , "V0_00497.ogg" }, //ca001b(L0,L1) + ca001c(L0,L1)
              new string[] { "V0_00480.ogg" , "V0_00481.ogg" , "V0_00696.ogg" , "V0_00697.ogg" }, //ca001a(L0,L1) + ca001j(L0,L1)発情
              new string[] { "V0_00490.ogg" , "V0_00491.ogg" , "V0_00498.ogg" , "V0_00499.ogg" }, //1行目続き (L2,L3)
              new string[] { "V0_00482.ogg" , "V0_00483.ogg" , "V0_00698.ogg" , "V0_00699.ogg" }, //2行目続き (L2,L3)
              //new string[] { "V0_00520.ogg" , "V0_00521.ogg" , "V0_00522.ogg" , "V0_00523.ogg" }  //ca001e(L0-L3)首絞め
              new string[] { "V0_00546.ogg" , "V0_00547.ogg" , "V0_00548.ogg" , "V0_00549.ogg" }  //ca001f(L2-L5)喪失
              };
              //弱バイブ　フェラ
              sLoopVoice20Fera = new string[][] {
              new string[] { "V0_00528.ogg" , "V0_00529.ogg" , "V0_00536.ogg" , "V0_00537.ogg" }, //ca003a(L0,L1) + ca003b(L0,L1)
              new string[] { "V0_00528.ogg" , "V0_00529.ogg" , "V0_00536.ogg" , "V0_00537.ogg" }, //↑と同じ
              new string[] { "V0_00530.ogg" , "V0_00531.ogg" , "V0_00538.ogg" , "V0_00539.ogg" }, //1行目続き (L2,L3)
              new string[] { "V0_00530.ogg" , "V0_00531.ogg" , "V0_00538.ogg" , "V0_00539.ogg" }, //↑と同じ
              new string[] { "V0_00528.ogg" , "V0_00529.ogg" , "V0_00536.ogg" , "V0_00537.ogg" }  //1行目と同じ
              };
              //強バイブ　通常
              sLoopVoice30Vibe = new string[][] {
              new string[] { "V0_00492.ogg" , "V0_00493.ogg" , "V0_00500.ogg" , "V0_00501.ogg" }, //ca001b(L4,L5) + ca001c(L4,L5)
              new string[] { "V0_00484.ogg" , "V0_00485.ogg" , "V0_00700.ogg" , "V0_00701.ogg" }, //ca001a(L4,L5) + ca001j(L4,L5)発情
              new string[] { "V0_00494.ogg" , "V0_00495.ogg" , "V0_00502.ogg" , "V0_00503.ogg" }, //1行目続き (L6,L7)
              new string[] { "V0_00486.ogg" , "V0_00487.ogg" , "V0_00702.ogg" , "V0_00703.ogg" }, //2行目続き (L6,L7)
              //new string[] { "V0_00524.ogg" , "V0_00525.ogg" , "V0_00526.ogg" , "V0_00527.ogg" }  //ca001e(L4-L7)首絞め
              new string[] { "V0_00550.ogg" , "V0_00551.ogg" , "V0_00558.ogg" , "V0_00559.ogg" }  //ca001f(L6,L7)喪失 + ca001g(L6,L7)酔い
              };
              //強バイブ　フェラ
              sLoopVoice30Fera = new string[][] {
              new string[] { "V0_00532.ogg" , "V0_00533.ogg" , "V0_00540.ogg" , "V0_00541.ogg" }, //ca003a(L4,L5) + ca003b(L4,L5)
              new string[] { "V0_00532.ogg" , "V0_00533.ogg" , "V0_00540.ogg" , "V0_00541.ogg" }, //↑と同じ
              new string[] { "V0_00534.ogg" , "V0_00535.ogg" , "V0_00542.ogg" , "V0_00543.ogg" }, //1行目続き (L6,L7)
              new string[] { "V0_00534.ogg" , "V0_00535.ogg" , "V0_00542.ogg" , "V0_00543.ogg" }, //↑と同じ
              new string[] { "V0_00532.ogg" , "V0_00533.ogg" , "V0_00540.ogg" , "V0_00541.ogg" }  //1行目と同じ
              };
              //絶頂　通常
              sOrgasmVoice30Vibe = new string[][] {
              new string[] { "V0_00743.ogg" , "V0_00763.ogg" , "V0_00747.ogg" , "V0_00731.ogg" , "V0_00751.ogg" , "V0_00832.ogg" , "V0_00848.ogg" , "V0_10704.ogg" , "V0_10750.ogg"}, //sou_00001(L3), yam01_抜く(L3), sou06_アナル処女喪失挿入(L3),sou01_性器に挿入(L3),sou07_発情挿入(L3),sa_被虐ダメージ台詞_叩く(L7),sa_被虐ダメージ台詞_ロウ(L11)
              new string[] { "V0_09763.ogg" , "V0_09813.ogg" , "V0_09511.ogg" , "V0_10702.ogg" , "V0_10705.ogg" , "V0_10651.ogg"}, //kashizuki初々しい,慣れ始め,VIP純愛 あたりから抽出
              new string[] { "V0_09912.ogg" , "V0_09913.ogg" , "V0_09976.ogg" , "V0_10604.ogg" , "V0_10651.ogg" , "V0_11154.ogg" , //kashizuki慣れ,VIP ntr, 愛撫 あたりから抽出
                             "V0_11177.ogg" , "V0_11249.ogg" , "V0_11282.ogg" , "V0_11375.ogg" , "V0_11376.ogg" , "V0_09941.ogg",  //↑の続き
                             "V0_09763.ogg" , "V0_09813.ogg" , "V0_09511.ogg" , "V0_10702.ogg" , "V0_10705.ogg" }, //2行目と同じ
              new string[] { "V0_09912.ogg" , "V0_09913.ogg" , "V0_10604.ogg" , "V0_11154.ogg" ,                   //3行目と同じ 少し減らす
                             "V0_11177.ogg" , "V0_11249.ogg" , "V0_11282.ogg" , "V0_11376.ogg" , "V0_09941.ogg" ,  //4行目と同じ 少し減らす
                             "V0_09763.ogg" , "V0_09813.ogg" , "V0_09511.ogg" , "V0_10702.ogg" , "V0_10705.ogg" ,  //2行目と同じ
                             "V0_06225.ogg" , "V0_05516.ogg" , "V0_06949.ogg" , "V0_07658.ogg" , "V0_10749.ogg"  },
              new string[] { "V0_00743.ogg" , "V0_00763.ogg" , "V0_00747.ogg" , "V0_00731.ogg" , "V0_00751.ogg" , "V0_00832.ogg" , "V0_00848.ogg" , "V0_10704.ogg" , "V0_10750.ogg"}  //1行目と同じ
              };
              //絶頂　フェラ
              sOrgasmVoice30Fera = new string[][] {
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" }
              };
              //停止時
              sLoopVoice40Vibe = new string[] { "V0_00810.ogg" , "V0_00804.ogg" , "V0_00805.ogg" , "V0_00807.ogg" , "V0_00808.ogg" }; //rr2_ca001c(L0), rr2_ca001a(L0,L1), rr2_ca001b(L0,L1)
            }}


            //性格別声テーブル　ギャル---------------------------------------------------------------
            class BasicVoiceGal : BasicVoiceSet { public BasicVoiceGal() {
              //弱バイブ　通常
              sLoopVoice20Vibe = new string[][] {
              new string[] { "H13_01036.ogg" , "H13_01037.ogg" , "H13_01044.ogg" , "H13_01045.ogg" }, //ca001a + ca001b(L0,L1)
              new string[] { "H13_01252.ogg" , "H13_01253.ogg" , "H13_01052.ogg" , "H13_01053.ogg" }, //ca001j(L0,L1) + ca001c(L0,L1)
              new string[] { "H13_01038.ogg" , "H13_01039.ogg" , "H13_01046.ogg" , "H13_01047.ogg" }, //ca001a(L2,L3) + ca001b(L2,L3)
              new string[] { "H13_01254.ogg" , "H13_01255.ogg" , "H13_01054.ogg" , "H13_01055.ogg" }, //ca001j(L2,L3) + ca001c(L2,L3)
              //new string[] { "H13_01068.ogg" , "H13_01069.ogg" , "H13_01100.ogg" , "H13_011001.ogg" }  //ca001d(L0,L1) + ca001f(L0,L1)
              new string[] { "H13_01104.ogg" , "H13_01105.ogg" , "H13_01112.ogg" , "H13_01113.ogg" }  //ca001f(L4-L5)喪失 + ca001g(L4-L5)酔い
              };
              //弱バイブ　フェラ
              sLoopVoice20Fera = new string[][] {
              new string[] { "H13_01084.ogg" , "H13_01085.ogg" , "H13_01092.ogg" , "H13_01093.ogg" }, //ca003a(L0,L1) + ca003b(L0,L1)
              new string[] { "H13_01084.ogg" , "H13_01085.ogg" , "H13_01092.ogg" , "H13_01093.ogg" },
              new string[] { "H13_01086.ogg" , "H13_01087.ogg" , "H13_01094.ogg" , "H13_01095.ogg" }, //ca003a(L2,L3) + ca003b(L2,L3)
              new string[] { "H13_01086.ogg" , "H13_01087.ogg" , "H13_01094.ogg" , "H13_01095.ogg" },
              new string[] { "H13_01084.ogg" , "H13_01085.ogg" , "H13_01092.ogg" , "H13_01093.ogg" }
              };
              //強バイブ　通常
              sLoopVoice30Vibe = new string[][] {
              new string[] { "H13_01040.ogg" , "H13_01041.ogg" , "H13_01048.ogg" , "H13_01049.ogg" }, //ca001a(L4,L5) + ca001b(L4,L5)
              new string[] { "H13_01256.ogg" , "H13_01257.ogg" , "H13_01056.ogg" , "H13_01057.ogg" }, //ca001j(L4,L5) + ca001c(L4,L5)
              new string[] { "H13_01042.ogg" , "H13_01043.ogg" , "H13_01050.ogg" , "H13_01051.ogg" }, //ca001a(L6,L7) + ca001b(L6,L7)
              new string[] { "H13_01258.ogg" , "H13_01259.ogg" , "H13_01058.ogg" , "H13_01059.ogg" }, //ca001j(L6,L7) + ca001c(L6,L7)
              //new string[] { "H13_01070.ogg" , "H13_01071.ogg" , "H13_01102.ogg" , "H13_01103.ogg" }  //ca001d(L2,L3) + ca001f(L2,L3)
              new string[] { "H13_01106.ogg" , "H13_01107.ogg" , "H13_01114.ogg" , "H13_01115.ogg" }  //ca001f(L6,L7)喪失 + ca001g(L6,L7)酔い
              };
              //強バイブ　フェラ
              sLoopVoice30Fera = new string[][] {
              new string[] { "H13_01088.ogg" , "H13_01089.ogg" , "H13_01096.ogg" , "H13_01097.ogg" }, //ca003a(L4,L5) + ca003b(L4,L5)
              new string[] { "H13_01088.ogg" , "H13_01089.ogg" , "H13_01096.ogg" , "H13_01097.ogg" },
              new string[] { "H13_01090.ogg" , "H13_01091.ogg" , "H13_01098.ogg" , "H13_01099.ogg" }, //ca003a(L6,L7) + ca003b(L6,L7)
              new string[] { "H13_01090.ogg" , "H13_01091.ogg" , "H13_01098.ogg" , "H13_01099.ogg" },
              new string[] { "H13_01088.ogg" , "H13_01089.ogg" , "H13_01096.ogg" , "H13_01097.ogg" }
              };
              //絶頂　通常
              sOrgasmVoice30Vibe = new string[][] {
              new string[] { "H13_01297.ogg" , "H13_01298.ogg" , "H13_01306.ogg" , "H13_01307.ogg" , "H13_01289.ogg" }, //sou_00001(L1,L2) sou_00005(L2,L3) 未使用音声
              new string[] { "H13_04314.ogg" , "H13_04358.ogg" , "H13_04428.ogg" , "H13_04469.ogg" , "H13_04856.ogg" , "H13_04877.ogg" },
              new string[] { "H13_00543.ogg" , "H13_00698.ogg" , "H13_00725.ogg" , "H13_04621.ogg" , "H13_04622.ogg" , "H13_04693.ogg" ,
                             "H13_04046.ogg" , //p1_slave 
                             "H13_04314.ogg" , "H13_04358.ogg" , "H13_04428.ogg" , "H13_04469.ogg" , "H13_04856.ogg" , "H13_04877.ogg" }, //2行目と同じ
              new string[] { "H13_00450.ogg" , "H13_00550.ogg" , "H13_00818.ogg" , "H13_02260.ogg" , "H13_03328.ogg" , "H13_03371.ogg" , "H13_03602.ogg" ,
                             "H13_03997.ogg" , "H13_04010.ogg" , "H13_04047.ogg" , //p1_slave 
                             "H13_04621.ogg" , //3行目の一部
                             "H13_04314.ogg" , "H13_04358.ogg" , "H13_04428.ogg" , "H13_04469.ogg" , "H13_04856.ogg" , "H13_04877.ogg" }, //2行目と同じ
              new string[] { "H13_01297.ogg" , "H13_01298.ogg" , "H13_01306.ogg" , "H13_01307.ogg" , "H13_01289.ogg" } //1行目と同じ
              };
              //絶頂　フェラ
              sOrgasmVoice30Fera = new string[][] {
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
              new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" }
              };
              //停止時
              sLoopVoice40Vibe = new string[] { "H13_01366.ogg" , "H13_01360.ogg" , "H13_01361.ogg" , "H13_01364.ogg" , "H13_01365.ogg" }; //rr2_ca001c(L0), rr2_ca001a(L0,L1), rr2_ca001b(L1,L2)
            }}


            //　性格別声テーブル　こっち来て
            //public string[] sCallVoice = new string[] { "S0_13972.ogg" , "S1_03893.ogg" , "s2_08163.ogg" , "S3_11386.ogg" , "s4_15255.ogg" , "s5_16924.ogg" , "s6_18089.ogg" , "" , "" };

        #endregion


        #region CustomVoice
            /*
            //カスタム音声テーブル　弱バイブ版---------------------------------------------------------------
              //カスタムボイス１
              public string[][] sLoopVoice20Custom1 = new string[][] {
              new string[] { "N0_00435.ogg" , "N0_00449.ogg" },
              new string[] { "N0_00435.ogg" , "N0_00449.ogg" },
              new string[] { "N0_00435.ogg" , "N0_00449.ogg" },
              new string[] { "N0_00435.ogg" , "N0_00449.ogg" },
              new string[] { "N0_00435.ogg" , "N0_00449.ogg" }
              };
              //カスタムボイス２
              public string[][] sLoopVoice20Custom2 = new string[][] {
              new string[] { "N7_00262.ogg" , "N7_00267.ogg" , "N7_00269.ogg" , "N7_00272.ogg" },
              new string[] { "N7_00262.ogg" , "N7_00267.ogg" , "N7_00269.ogg" , "N7_00272.ogg" },
              new string[] { "N7_00262.ogg" , "N7_00267.ogg" , "N7_00269.ogg" , "N7_00272.ogg" },
              new string[] { "N7_00262.ogg" , "N7_00267.ogg" , "N7_00269.ogg" , "N7_00272.ogg" },
              new string[] { "N7_00262.ogg" , "N7_00267.ogg" , "N7_00269.ogg" , "N7_00272.ogg" }
              };
              //カスタムボイス３
              public string[][] sLoopVoice20Custom3 = new string[][] {
              new string[] { "N1_00170.ogg" , "N1_00191.ogg" , "N1_00192.ogg" , "N1_00194.ogg" },
              new string[] { "N1_00170.ogg" , "N1_00191.ogg" , "N1_00192.ogg" , "N1_00194.ogg" },
              new string[] { "N1_00170.ogg" , "N1_00191.ogg" , "N1_00192.ogg" , "N1_00194.ogg" },
              new string[] { "N1_00170.ogg" , "N1_00191.ogg" , "N1_00192.ogg" , "N1_00194.ogg" },
              new string[] { "N1_00170.ogg" , "N1_00191.ogg" , "N1_00192.ogg" , "N1_00194.ogg" }
              };
              //カスタムボイス４
              public string[][] sLoopVoice20Custom4 = new string[][] {
              new string[] { "N3_00157.ogg" , "N3_00370.ogg" },
              new string[] { "N3_00157.ogg" , "N3_00370.ogg" },
              new string[] { "N3_00157.ogg" , "N3_00370.ogg" },
              new string[] { "N3_00157.ogg" , "N3_00370.ogg" },
              new string[] { "N3_00157.ogg" , "N3_00370.ogg" }
              };

            //カスタム音声テーブル　強バイブ版---------------------------------------------------------------
              public string[][] sLoopVoice30Custom1 = new string[][] {
              new string[] { "N0_00421.ogg" , "N0_00422.ogg" , "N0_00423.ogg" },
              new string[] { "N0_00421.ogg" , "N0_00422.ogg" , "N0_00423.ogg" },
              new string[] { "N0_00421.ogg" , "N0_00422.ogg" , "N0_00423.ogg" },
              new string[] { "N0_00421.ogg" , "N0_00422.ogg" , "N0_00423.ogg" },
              new string[] { "N0_00435.ogg" , "N0_00449.ogg" }
              };
              public string[][] sLoopVoice30Custom2 = new string[][] {
              new string[] { "N7_00252.ogg" , "N7_00255.ogg" , "N7_00267.ogg" , "N7_00261.ogg" },
              new string[] { "N7_00252.ogg" , "N7_00255.ogg" , "N7_00267.ogg" , "N7_00261.ogg" },
              new string[] { "N7_00252.ogg" , "N7_00255.ogg" , "N7_00267.ogg" , "N7_00261.ogg" },
              new string[] { "N7_00252.ogg" , "N7_00255.ogg" , "N7_00267.ogg" , "N7_00261.ogg" },
              new string[] { "N7_00262.ogg" , "N7_00267.ogg" , "N7_00269.ogg" , "N7_00272.ogg" }
              };
              public string[][] sLoopVoice30Custom3 = new string[][] {
              new string[] { "N1_00183.ogg" , "N1_00195.ogg" , "N1_00323.ogg" , "N1_00330.ogg" },
              new string[] { "N1_00183.ogg" , "N1_00195.ogg" , "N1_00323.ogg" , "N1_00330.ogg" },
              new string[] { "N1_00183.ogg" , "N1_00195.ogg" , "N1_00323.ogg" , "N1_00330.ogg" },
              new string[] { "N1_00183.ogg" , "N1_00195.ogg" , "N1_00323.ogg" , "N1_00330.ogg" },
              new string[] { "N1_00170.ogg" , "N1_00191.ogg" , "N1_00192.ogg" , "N1_00194.ogg" }
              };
              public string[][] sLoopVoice30Custom4 = new string[][] {
              new string[] { "N3_00310.ogg" , "N3_00318.ogg" , "N3_00377.ogg" },
              new string[] { "N3_00310.ogg" , "N3_00318.ogg" , "N3_00377.ogg" },
              new string[] { "N3_00310.ogg" , "N3_00318.ogg" , "N3_00377.ogg" },
              new string[] { "N3_00310.ogg" , "N3_00318.ogg" , "N3_00377.ogg" },
              new string[] { "N3_00157.ogg" , "N3_00370.ogg" }
              };

            //カスタム音声テーブル　絶頂時---------------------------------------------------------------
              public string[][] sOrgasmVoice30Custom1 = new string[][] {
              new string[] { "N0_00424.ogg" , "N0_00459.ogg" , "N0_00503.ogg" , "N0_00508.ogg" , "N0_00534.ogg" },
              new string[] { "N0_00424.ogg" , "N0_00459.ogg" , "N0_00503.ogg" , "N0_00508.ogg" , "N0_00534.ogg" },
              new string[] { "N0_00424.ogg" , "N0_00457.ogg" , "N0_00503.ogg" , "N0_00508.ogg" , "N0_00534.ogg" },
              new string[] { "N0_00456.ogg" , "N0_00457.ogg" , "N0_00458.ogg" , "N0_00534.ogg" , "N0_00288.ogg" , "N0_00292.ogg" , "N0_00293.ogg" },
              new string[] { "N0_00424.ogg" , "N0_00459.ogg" , "N0_00503.ogg" , "N0_00508.ogg" , "N0_00534.ogg" }
              };
              public string[][] sOrgasmVoice30Custom2 = new string[][] {
              new string[] { "N7_00251.ogg" , "N7_00267.ogg" , "N7_00275.ogg" , "N7_00276.ogg" , "N7_00280.ogg" },
              new string[] { "N7_00251.ogg" , "N7_00267.ogg" , "N7_00275.ogg" , "N7_00276.ogg" , "N7_00280.ogg" },
              new string[] { "N7_00251.ogg" , "N7_00267.ogg" , "N7_00275.ogg" , "N7_00276.ogg" , "N7_00280.ogg" },
              new string[] { "N7_00284.ogg" , "N7_00291.ogg" , "N7_00293.ogg" , "N7_00294.ogg" , "N7_00295.ogg" , "N7_00275.ogg" , "n7_00295.ogg" },
              new string[] { "N7_00251.ogg" , "N7_00267.ogg" , "N7_00275.ogg" , "N7_00276.ogg" , "N7_00280.ogg" }
              };
              public string[][] sOrgasmVoice30Custom3 = new string[][] {
              new string[] { "N1_00179.ogg" , "N1_00180.ogg" , "N1_00200.ogg" , "N1_00204.ogg" , "N1_00209.ogg" },
              new string[] { "N1_00179.ogg" , "N1_00180.ogg" , "N1_00200.ogg" , "N1_00204.ogg" , "N1_00209.ogg" },
              new string[] { "N1_00179.ogg" , "N1_00180.ogg" , "N1_00200.ogg" , "N1_00204.ogg" , "N1_00209.ogg" },
              new string[] { "N1_00179.ogg" , "N1_00180.ogg" , "N1_00198.ogg" , "N1_00199.ogg" , "N1_00205.ogg" , "N1_00217.ogg" , "N1_00333.ogg" },
              new string[] { "N1_00179.ogg" , "N1_00180.ogg" , "N1_00200.ogg" , "N1_00204.ogg" , "N1_00209.ogg" }
              };
              public string[][] sOrgasmVoice30Custom4 = new string[][] {
              new string[] { "N3_00193.ogg" , "N3_00194.ogg" , "N3_00195.ogg" , "N3_00330.ogg" , "N3_00378.ogg" },
              new string[] { "N3_00193.ogg" , "N3_00194.ogg" , "N3_00195.ogg" , "N3_00330.ogg" , "N3_00378.ogg" },
              new string[] { "N3_00193.ogg" , "N3_00194.ogg" , "N3_00195.ogg" , "N3_00330.ogg" , "N3_00378.ogg" },
              new string[] { "N3_00376.ogg" , "N3_00194.ogg" , "N3_00195.ogg" , "N3_00197.ogg" , "N3_00203.ogg" , "N3_00328.ogg" , "N3_00330.ogg" , "N3_00379.ogg" },
              new string[] { "N3_00193.ogg" , "N3_00194.ogg" , "N3_00195.ogg" , "N3_00330.ogg" , "N3_00378.ogg" }
              };

            //カスタム音声テーブル　停止時---------------------------------------------------------------
              public string[] sLoopVoice40Custom1 = new string[] { "N0_00460.ogg" , "N0_00460.ogg" , "N0_00460.ogg" , "N0_00460.ogg" , "N0_00460.ogg" };
              public string[] sLoopVoice40Custom2 = new string[] { "N7_00277.ogg" , "N7_00277.ogg" , "N7_00277.ogg" , "N7_00277.ogg" , "N7_00277.ogg" };
              public string[] sLoopVoice40Custom3 = new string[] { "N1_00382.ogg" , "N1_00382.ogg" , "N1_00382.ogg" , "N1_00382.ogg" , "N1_00382.ogg" };
              public string[] sLoopVoice40Custom4 = new string[] { "N3_00205.ogg" , "N3_00205.ogg" , "N3_00205.ogg" , "N3_00205.ogg" , "N3_00205.ogg" };

            //改変終了---------------------------------------
            */
        #endregion


        #if EmpiresLife
        private GameObject gameObject_ui;
        //脱衣処理用
	      private bool isItem = true; //メイドアイテム
        //private bool StartFlag = false; //　シーンがかわってから操作されたかどうか
        #endif

        //脱衣チェックフラグ 現状EmpiresLifeでのみ利用している
        public bool dCheck = false;

        private CameraMain mainCamera;

        //メイド取得フラグ
        private bool reGetMaid = false;

        //男モデル
        private Maid fpsMan; //1人称用 男エディットボディが有効ならそれ設定する
        private Maid[] SubMans = new Maid[5];
        private int[] MansTg = new int[5];
        private string[] SubMansName = new string[]{ "ご主人様" , "モブ男Ａ" , "モブ男Ｂ" , "モブ男Ｃ" , "モブ男Ｄ" };
        private float[] syaseiValue = new float[]{ 0f , 0f , 0f , 0f , 0f };
        private int[] mansLevel = new int[]{ 0 , 0 , 0 , 0 , 0 };
        private bool[] syaseiLock = new bool[]{ false , false , false , false , false };
        //private int MansFGet = 0;

        //　音声・表情のモード切り替え用
        private string[][] personalList = new string[][] { //性格追加時に更新
          new string[] {
            "ツンデレ" , "クーデレ" , "純真" , "ヤンデレ" , "姉ちゃん" , "僕っ娘" , "ドＳ" ,
            "無垢" , "真面目" , "凛デレ" , "無口" , "小悪魔" , "お淑やか" , "ﾒｲﾄﾞ秘書" , "ふわ妹" , "無愛想" , "お嬢様" , "幼馴染" ,
            "ドＭ" , "腹黒" , "気さく" , "淑女" , "ギャル" , "指定無" },
          new string[] {
            "Pride" , "Cool" , "Pure" , "Yandere" , "Anesan" , "Genki" , "Sadist" ,
            "Muku" , "Majime" , "Rindere" , "Silent" , "Devilish" , "Ladylike" , "Secretary" , "Sister" , "Curtness" , "Missy" , "Childhood" ,
            "Masochist" , "Crafty" , "Friendly" , "Dame" , "Gal" }
        };

        public string[][] reactionVoice = new string[][] { //性格追加時に更新
          new string[] { "s0_01898.ogg" , "s0_01899.ogg" , "s0_01902.ogg" , "s0_01900.ogg" },
          new string[] { "s1_03223.ogg" , "s1_03246.ogg" , "s1_03247.ogg" , "s1_03210.ogg" },
          new string[] { "s2_01478.ogg" , "s2_01477.ogg" , "s2_01476.ogg" , "s2_01475.ogg" },
          new string[] { "s3_02908.ogg" , "s3_02950.ogg" , "s3_02923.ogg" , "s3_02932.ogg" },
          new string[] { "s4_08348.ogg" , "s4_08354.ogg" , "s4_08365.ogg" , "s4_08374.ogg" },
          new string[] { "s5_04264.ogg" , "s5_04258.ogg" , "s5_04256.ogg" , "s5_04255.ogg" },
          new string[] { "s6_01744.ogg" , "s6_02700.ogg" , "s6_02450.ogg" , "s6_02357.ogg" },
          new string[] { "H0_00289.ogg" , "H0_00290.ogg" , "H0_00291.ogg" , "H0_00292.ogg" },
          new string[] { "H1_11482.ogg" , "H1_13858.ogg" , "H1_13879.ogg" , "H1_13918.ogg" },
          new string[] { "H2_06092.ogg" , "H2_00252.ogg" , "H2_00285.ogg" , "H2_00277.ogg" },
          new string[] { "H3_00779.ogg" , "H3_00783.ogg" , "H3_00785.ogg" , "H3_00800.ogg" },
          new string[] { "H4_01200.ogg" , "H4_01204.ogg" , "H4_01209.ogg" , "H4_01208.ogg" },
          new string[] { "H5_00943.ogg" , "H5_00944.ogg" , "H5_00948.ogg" , "H5_00874.ogg" },
          new string[] { "H6_00421.ogg" , "H6_00429.ogg" , "H6_00448.ogg" , "H6_00409.ogg" },
          new string[] { "H7_03163.ogg" , "H7_03167.ogg" , "H7_03164.ogg" , "H7_03172.ogg" },
          new string[] { "H8_08466.ogg" , "H8_01430.ogg" , "H8_01421.ogg" , "H8_01382.ogg" , "H8_01396.ogg" , "H8_01398.ogg" },
          new string[] { "H9_00825.ogg" , "H9_00833.ogg" , "H9_00841.ogg" , "H9_00824.ogg" , "H9_00966.ogg" , "H9_00860.ogg" , "H9_00987.ogg" },
          new string[] { "H10_04104.ogg", "H10_04120.ogg", "H10_04108.ogg", "H10_04092.ogg", "H10_04112.ogg", "H10_04242.ogg", "H10_04253.ogg" },
          new string[] { "H11_00902.ogg", "H11_00905.ogg", "H11_00923.ogg", "H11_00924.ogg" },
          new string[] { "H12_01467.ogg", "H12_01468.ogg", "H12_01475.ogg", "H12_01460.ogg" },
          new string[] { "V1_00744.ogg" , "V1_00745.ogg" , "V1_00751.ogg" , "V1_00737.ogg" }, //気さく w1_sou05_処女挿入喪失.ks(L2,L3), w1_sou07_発情挿入.ks(L1) w1_sou03_酔い挿入.ks(L3)
          new string[] { "V0_00742.ogg" , "V0_00743.ogg" , "V0_00749.ogg" , "V0_00735.ogg" }, //淑女   v1_sou05_処女挿入喪失.ks(L2,L3), v1_sou07_発情挿入.ks(L1) v1_sou03_酔い挿入.ks(L3)
          new string[] { "H13_01298.ogg", "H13_01299.ogg", "H13_01286.ogg", "H13_01287.ogg" } //ギャル p1_sou0001(L2,L3) p1_sou0009(L2,L3)
        };

        //脱衣ボイス script/sex/yotogi/99_system 各興奮度(250,150,50,-100) トップx4, ボトムx4, ブラx4, パンツx4(200→抜くL3 150→L4 50→L3), ずらしx4(150と250→拘束愛撫L6～L10 or 抜くL2～L3) 50と-100→パンツL1 
        public string[][] UndressingVoice = new string[][] { //性格追加時に更新
          new string[] { "S0_05670" , "S0_05669" , "S0_05668" , "S0_05667" ,  "S0_05674" , "S0_05673" , "S0_05672" , "S0_05671" ,  "S0_05682" , "S0_05681" , "S0_05680" , "S0_05679" ,  "S0_01950" , "S0_05686" , "S0_05685" , "S0_05683" ,  "S0_05529" , "S0_05538" , "S0_05684" , "S0_05684" },
          new string[] { "S1_05467" , "S1_05466" , "S1_05465" , "S1_05464" ,  "S1_05471" , "S1_05470" , "S1_05469" , "S1_05468" ,  "S1_05479" , "S1_05478" , "S1_05477" , "S1_05476" ,  "S1_03247" , "S1_05483" , "S1_05482" , "S1_05480" ,  "S1_05258" , "S1_05258" , "S1_05481" , "S1_05481" },
          new string[] { "S2_04500" , "S2_04499" , "S2_04498" , "S2_04497" ,  "S2_04504" , "S2_04503" , "S2_04502" , "S2_04501" ,  "S2_04512" , "S2_04511" , "S2_04510" , "S2_04509" ,  "S2_01474" , "S2_04516" , "S2_04515" , "S2_04513" ,  "S2_05138" , "S2_05135" , "S2_04514" , "S2_04514" },
          new string[] { "S3_02670" , "S3_02669" , "S3_02668" , "S3_02667" ,  "S3_02674" , "S3_02673" , "S3_02672" , "S3_02671" ,  "S3_02682" , "S3_02681" , "S3_02680" , "S3_02679" ,  "S3_02947" , "S3_02686" , "S3_12579" , "S3_02685" ,  "S3_101167", "S3_12577" , "S3_02684" , "S3_02684" },
          new string[] { "S4_08407" , "S4_08406" , "S4_08405" , "S4_08404" ,  "S4_08411" , "S4_08410" , "S4_08409" , "S4_08408" ,  "S4_08419" , "S4_08418" , "S4_08417" , "S4_08416" ,  "S4_08387" , "S4_08423" , "S4_08422" , "S4_08420" ,  "S4_08448" , "S4_08444" , "S4_08421" , "S4_08421" },
          new string[] { "S5_04327" , "S5_04326" , "S5_04325" , "S5_04324" ,  "S5_04331" , "S5_04330" , "S5_04329" , "S5_04328" ,  "S5_04339" , "S5_04338" , "S5_04337" , "S5_04336" ,  "S5_04307" , "S5_04343" , "S5_04342" , "S5_04340" ,  "S5_04368" , "S5_04365" , "S5_04341" , "S5_04341" },
          new string[] { "S6_02456" , "S6_02457" , "S6_02458" , "S6_02459" ,  "S6_02460" , "S6_02461" , "S6_02462" , "S6_02463" ,  "S6_02468" , "S6_02469" , "S6_02470" , "S6_02471" ,  "S6_02439" , "S6_02472" , "S6_02473" , "S6_02475" ,  "S6_02500" , "S6_02498" , "S6_02474" , "S6_02474" },
          new string[] { "H0_00320" , "H0_00319" , "H0_00318" , "H0_00317" ,  "H0_00324" , "H0_00323" , "H0_00322" , "H0_00321" ,  "H0_00332" , "H0_00331" , "H0_00330" , "H0_00329" ,  "H0_00292" , "H0_00336" , "H0_00335" , "H0_00333" ,  "H0_00368" , "H0_00367" , "H0_00334" , "H0_00334" },
          new string[] { "H1_00492" , "H1_00491" , "H1_00490" , "H1_00489" ,  "H1_00496" , "H1_00495" , "H1_00494" , "H1_00493" ,  "H1_00504" , "H1_00503" , "H1_00502" , "H1_00501" ,  "H1_00464" , "H1_00508" , "H1_00507" , "H1_00505" ,  "H1_00539" , "H1_00536" , "H1_00506" , "H1_00506" },
          new string[] { "H2_00294" , "H2_00293" , "H2_00292" , "H2_00291" ,  "H2_00298" , "H2_00297" , "H2_00296" , "H2_00295" ,  "H2_00306" , "H2_00305" , "H2_00304" , "H2_00303" ,  "H2_00266" , "H2_00310" , "H2_00309" , "H2_00307" ,  "H2_00341" , "H2_00338" , "H2_00308" , "H2_00308" },
          new string[] { "H3_00825" , "H3_00824" , "H3_00823" , "H3_00822" ,  "H3_00829" , "H3_00828" , "H3_00827" , "H3_00826" ,  "H3_00837" , "H3_00836" , "H3_00835" , "H3_00834" ,  "H3_00797" , "H3_00841" , "H3_00840" , "H3_00838" ,  "H3_00873" , "H3_00872" , "H3_00839" , "H3_00839" },
          new string[] { "H4_01160" , "H4_01159" , "H4_01158" , "H4_01157" ,  "H4_01164" , "H4_01163" , "H4_01162" , "H4_01161" ,  "H4_01172" , "H4_01171" , "H4_01170" , "H4_01169" ,  "H4_01132" , "H4_01176" , "H4_01175" , "H4_01173" ,  "H4_01206" , "H4_01205" , "H4_01174" , "H4_01174" },
          new string[] { "H5_00899" , "H5_00898" , "H5_00897" , "H5_00896" ,  "H5_00903" , "H5_00902" , "H5_00901" , "H5_00900" ,  "H5_00911" , "H5_00910" , "H5_00909" , "H5_00908" ,  "H5_00871" , "H5_00915" , "H5_00914" , "H5_00912" ,  "H5_00947" , "H5_00946" , "H5_00913" , "H5_00913" },
          new string[] { "H6_00465" , "H6_00464" , "H6_00463" , "H6_00462" ,  "H6_00469" , "H6_00468" , "H6_00467" , "H6_00466" ,  "H6_00477" , "H6_00476" , "H6_00475" , "H6_00474" ,  "H6_00437" , "H6_00481" , "H6_00480" , "H6_00478" ,  "H6_00512" , "H6_00506" , "H6_00479" , "H6_00479" },
          new string[] { "H7_03069" , "H7_03068" , "H7_03067" , "H7_03066" ,  "H7_03073" , "H7_03072" , "H7_03071" , "H7_03070" ,  "H7_03081" , "H7_03080" , "H7_03079" , "H7_03078" ,  "H7_03041" , "H7_03085" , "H7_03084" , "H7_03082" ,  "H7_03165" , "H7_03164" , "H7_03083" , "H7_03083" },
          new string[] { "H8_01438" , "H8_01437" , "H8_01436" , "H8_01435" ,  "H8_01442" , "H8_01441" , "H8_01440" , "H8_01439" ,  "H8_01450" , "H8_01449" , "H8_01448" , "H8_01447" ,  "H8_01410" , "H8_01454" , "H8_01453" , "H8_01451" ,  "H8_01534" , "H8_01409" , "H8_01452" , "H8_01452" },
          new string[] { "H9_00877" , "H9_00876" , "H9_00875" , "H9_00874" ,  "H9_00881" , "H9_00880" , "H9_00879" , "H9_00878" ,  "H9_00889" , "H9_00888" , "H9_00887" , "H9_00886" ,  "H9_00849" , "H9_00893" , "H9_00892" , "H9_00890" ,  "H9_00848" , "H9_00847" , "H9_00891" , "H9_00891" },
          new string[] { "H10_04148", "H10_04147", "H10_04146", "H10_04145",  "H10_04152", "H10_04151", "H10_04150", "H10_04149",  "H10_04160", "H10_04159", "H10_04158", "H10_04157",  "H10_04120", "H10_04164", "H10_04163", "H10_04161",  "H10_04119", "H10_04140", "H10_04162", "H10_04162"},
          new string[] { "H11_00940", "H11_00939", "H11_00938", "H11_00937",  "H11_00944", "H11_00943", "H11_00942", "H11_00941",  "H11_00952", "H11_00951", "H11_00950", "H11_00949",  "H11_00920", "H11_00956", "H11_00955", "H11_00953",  "H11_01032", "H11_01031", "H11_00954", "H11_00954"},
          new string[] { "H12_01512", "H12_01511", "H12_01510", "H12_01509",  "H12_01516", "H12_01515", "H12_01514", "H12_01513",  "H12_01524", "H12_01523", "H12_01522", "H12_01521",  "H12_01484", "H12_01528", "H12_01527", "H12_01525",  "H12_01607", "H12_01606", "H12_01526", "H12_01526"},
          new string[] { "V1_00789" , "V1_00788" , "V1_00787" , "V1_00786" ,  "V1_00793" , "V1_00792" , "V1_00791" , "V1_00790" ,  "V1_00801" , "V1_00800" , "V1_00799" , "V1_00798" ,  "V1_00761" , "V1_00805" , "V1_00804" , "V1_00802" ,  "V1_00836" , "V1_00833" , "V1_00803" , "V1_00803" },
          new string[] { "V0_00787" , "V0_00786" , "V0_00785" , "V0_00784" ,  "V0_00791" , "V0_00790" , "V0_00789" , "V0_00788" ,  "V0_00799" , "V0_00798" , "V0_00797" , "V0_00796" ,  "V0_00759" , "V0_00803" , "V0_00802" , "V0_00800" ,  "V0_00834" , "V0_00832" , "V0_00801" , "V0_00801" },
          new string[] { "H13_01343", "H13_01342", "H13_01341", "H13_01340",  "H13_01347", "H13_01346", "H13_01345", "H13_01344",  "H13_01355", "H13_01354", "H13_01353", "H13_01352",  "H13_01315", "H13_01359", "H13_01358", "H13_01356",  "H13_01315", "H13_01313", "H13_01357", "H13_01357"}
        };

        //SE切替関連
        private string[][] SeFileList = new string[][] {
          new string[] { "バイブ音" , "抽挿音" , "オート" },
          new string[] { "se020.ogg" , "se028.ogg" },
          new string[] { "se019.ogg" , "se029.ogg" }
        };


        //アヘ関連
        private float fEyePosToSliderMul  = 5000f;

        //ロック関連
        private bool ExciteLock = false;
        private bool OrgasmLock = false;

        private float ShapeKeySpeedRate = 60f;              // 60fps を基本倍率とする
        //private int shapeTgNum1 = 0;
        private int shapeTgNum2 = 0;


        //private float WaitTime = 0;                         //　シーン15開始時の待機時間用
        private float timerRate = Time.deltaTime * 60;

        private float chinkoCheckTime = float.PositiveInfinity; //男の表示時のコライダー設定タイマー

        private bool scKeyOff = false;

        //胸コライダー制御用クラス
        MuneCollider muneCollider;

        //　Chu-B Lip / VR
        private bool bChuBLip;
        private bool bVR;
        private bool bOculusVR;

        //VR初期位置の高さ補正用 ずれている環境のみcfgwの値を設定
        float vrBaseHeadHeightGap = 0f;

        //VRショートカット用コントローラー config読み込み後に初期化する
        VRShortCutController vrShortCutController = null;

        private int vSceneLevel = 0;
        //private bool SceneLevelEnable = false;
        private bool isEditScene = false;

        //DanceMain取得用FieldInfo
        FieldInfo danceMainInfo = typeof(RhythmAction_Mgr).GetField("m_DanceMain", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.GetField);

        #if DOF
        //被写界深度設定用
        DepthOfFieldDistance depthOfField;
        #endif

        //ステータス表示用
        private string[] SucoreText1 = new string[] { "☆ ☆ ☆" , "★ ☆ ☆" , "★ ★ ☆" , "★ ★ ★" };
        private string[] SucoreText2 = new string[] { "☆ ☆ ☆" , "★ ☆ ☆" , "★ ★ ☆" , "★ ★ ★" };
        private string[] SucoreText3 = new string[] { "☆ ☆ ☆" , "★ ☆ ☆" , "★ ★ ☆" , "★ ★ ★" };

        #if COM3D2_5
        //胸変形用
        static FieldInfo MunePropValueDicInfo;
        #endif

        #if DCM
        //DCMクラスとカメラ無効プロパティの有無
        bool hasDcmIgnoreCameraMotion = false;
        #endif

        //--------------------------------------------

        //ゲーム起動時の処理--------------------------
        public void Awake() {

          API.setInstance(this);

          // フォルダ確認
          if (!System.IO.Directory.Exists(@"Sybaris\UnityInjector\Config\VibeYourMaid\")) {
            System.IO.DirectoryInfo di = System.IO.Directory.CreateDirectory(@"Sybaris\UnityInjector\Config\VibeYourMaid"); //ない場合はフォルダ作成
          }
          if (!System.IO.Directory.Exists(@"Sybaris\UnityInjector\Config\VibeYourMaid\BasicVoiseSet\")) {
            System.IO.DirectoryInfo di = System.IO.Directory.CreateDirectory(@"Sybaris\UnityInjector\Config\VibeYourMaid\BasicVoiseSet"); //ない場合はフォルダ作成
          }
          if (!System.IO.Directory.Exists(@"Sybaris\UnityInjector\Config\VibeYourMaid\CommonDressSet\")) {
            System.IO.DirectoryInfo di = System.IO.Directory.CreateDirectory(@"Sybaris\UnityInjector\Config\VibeYourMaid\CommonDressSet"); //ない場合はフォルダ作成
          }

          //if (!File.Exists(@"Sybaris\UnityInjector\Config\VibeYourMaid\MList.txt")) {
            //StreamWriter sw = File.CreateText(@"Sybaris\UnityInjector\Config\VibeYourMaid\MList.txt");
            //sw.Close();
          //}


          GameObject.DontDestroyOnLoad(this);
          string path = UnityEngine.Application.dataPath;

          /*
          // Iniファイル読み込み
          cfg = ReadConfig<VibeYourMaidConfig>("Config");
          // Iniファイル書き出し
          SaveConfig(cfg, "Config");
          */

          //Configファイルのロード
          ConfigFileLoad();
          //Configファイルのセーブ ファイルががない場合のみ
          ConfigFileSave();

          //言語ファイル読み込み
          if (System.IO.File.Exists(langFile)) loadLanguage();
          #if DEBUG
          //ファイルがなければ生成 DEBUGのみ
          if (!System.IO.File.Exists(langFile)) saveLanguage();
          #endif

          // ChuBLip判別
          bChuBLip = path.Contains("COM3D2OHx64") || path.Contains("COM3D2OHx86") || path.Contains("COM3D2OHVRx64");
          // VR判別
          bVR = path.Contains("COM3D2OHVRx64") || path.Contains("COM3D2VRx64") || Environment.CommandLine.ToLower().Contains("/vr");

          XmlFilesCheck();

          //モーション読み込みと夜伽リスト作成は別スレッドで実行
          if (cfgw.initialLoadThreading) {
            Thread loadThread = new Thread(new ThreadStart(LoadInitialData));
            loadThread.Start();
          } else {
            LoadInitialData();
          }

          //胸コライダーオブジェクト生成 (cfgwのセットのみ)
          muneCollider = new MuneCollider(cfgw);
          //カメラ位置のコライダー初期設定
          if (cfgw.camColliderEnabled) muneCollider.setCamColliderEnabled(true);

          //configからデフォルト値を設定
          //メイド固定の注視点
          lookPoint = cfgw.maidFollowLookPoint;
          if (lookPoint != 1 && lookPoint != 2) lookPoint = 0; //1と2以外は無効
          //興奮値
          if (cfgw.yotogiExciteLinkValue == null || cfgw.yotogiExciteLinkValue.Length < 5) {
            cfgw.yotogiExciteLinkValue = new int[]{0, 100, 150, 200, 300}; //配列チェック
          }
          //移動量初期値
          moveValue = cfgw.moveValueDefault;
          //キスボイスと連動するならキスボイスを初期表示
          //vsNormalMode = cfgw.camCheckVoiceEnabled;

          #if COM3D2_5
          try {
            MunePropValueDicInfo = typeof(DynamicMuneBone).GetField("MunePropValueDic", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.GetField);
          } catch (Exception e) { UnityEngine.Debug.LogError(e); }
          #endif

          #if DCM
          //DCM対応済みかのチェック
          try {
            Type dcmType = Type.GetType("COM3D2.DanceCameraMotion.Plugin.MyHelper, COM3D2.DanceCameraMotion.Plugin");
            if (dcmType == null) {
              UnityEngine.Debug.Log("[VibeYourMaid] DCM not found");
            } else if (dcmType.GetProperty("ignoreCameraMotion") != null) {
              UnityEngine.Debug.Log("[VibeYourMaid] DCM MyHelper.ignoreCameraMotion found");
              hasDcmIgnoreCameraMotion = true;
            }
          } catch (Exception e) { UnityEngine.Debug.LogError(e); }
          #endif

        }

        private void LoadInitialData()
        {
          System.Diagnostics.Stopwatch sw = new System.Diagnostics.Stopwatch();
          sw.Start();

          //ボイスセットサイズは性格数に合わせる
          bvs = new BasicVoiceSet[personalList[1].Length];
          //ボイスセット読み込み
          BvsFileLoad();
          //ロードされていないものはデフォルト 派生クラスだとXML保存できないのでBasicVoiceSetにする
          //性格追加時に更新
          if (bvs[0]  == null) bvs[0]  = new BasicVoicePride().getBase();
          if (bvs[1]  == null) bvs[1]  = new BasicVoiceCool().getBase();
          if (bvs[2]  == null) bvs[2]  = new BasicVoicePure().getBase();
          if (bvs[3]  == null) bvs[3]  = new BasicVoiceYandere().getBase();
          if (bvs[4]  == null) bvs[4]  = new BasicVoiceAnesan().getBase();
          if (bvs[5]  == null) bvs[5]  = new BasicVoiceGenki().getBase();
          if (bvs[6]  == null) bvs[6]  = new BasicVoiceSadist().getBase();
          if (bvs[7]  == null) bvs[7]  = new BasicVoiceMuku().getBase();
          if (bvs[8]  == null) bvs[8]  = new BasicVoiceMajime().getBase();
          if (bvs[9]  == null) bvs[9]  = new BasicVoiceRindere().getBase();
          if (bvs[10] == null) bvs[10] = new BasicVoiceSilent().getBase();
          if (bvs[11] == null) bvs[11] = new BasicVoiceDevilish().getBase();
          if (bvs[12] == null) bvs[12] = new BasicVoiceLadylike().getBase();
          if (bvs[13] == null) bvs[13] = new BasicVoiceSecretary().getBase();
          if (bvs[14] == null) bvs[14] = new BasicVoiceSister().getBase();
          if (bvs[15] == null) bvs[15] = new BasicVoiceCurtness().getBase();
          if (bvs[16] == null) bvs[16] = new BasicVoiceMissy().getBase();
          if (bvs[17] == null) bvs[17] = new BasicVoiceChildhood().getBase();
          if (bvs[18] == null) bvs[18] = new BasicVoiceMasochist().getBase();
          if (bvs[19] == null) bvs[19] = new BasicVoiceCrafty().getBase();
          if (bvs[20] == null) bvs[20] = new BasicVoiceFriendly().getBase();
          if (bvs[21] == null) bvs[21] = new BasicVoiceDame().getBase();
          if (bvs[22] == null) bvs[22] = new BasicVoiceGal().getBase();

          BvsFileSave(); //保存 ファイルがない場合のみ
          BvsCheck(); //存在しないファイルをチェック

          //脱衣設定読み込み ファイルがなければデフォルトを保存
          if (UndressingVoiceLoad()) UndressingVoiceSave();
          
          Console.WriteLine("[VibeYourMaid] BasicVoiceSet Loaded : "+(sw.ElapsedMilliseconds)+"ms");

          //モーション名置換設定ファイル読み込み
          MotionNameReplaceListLoad();

          //重い読み込み処理は指定秒数遅らせる 別スレッド時のみ
          if (cfgw.initialLoadThreading && cfgw.initialMotionLoadWait > 0) Thread.Sleep(cfgw.initialMotionLoadWait);

          //UNZIP用モーションリスト作成
          MajFileLoad();
          UnzipMotionLoad();
          MajFileSave(false); //ファイルがない場合のみ

          //イタズラ用モーションリスト読み込み 口モード、パイズリモードもここで読み込み
          ItazuraMotionLoad();
        }

        //--------------------------------------------


        public void Start() {

          //GUIサイズ デフォルト位置は右下から X:-250 Y:-370
          int orgX = cfgw.guiOffsetX; //左原点
          int orgY = cfgw.guiOffsetY; //上原点
          if (cfgw.guiOrigin == "RT" || cfgw.guiOrigin == "RB") orgX = UnityEngine.Screen.width-250 + cfgw.guiOffsetX;  //右原点
          if (cfgw.guiOrigin == "LB" || cfgw.guiOrigin == "RB") orgY = UnityEngine.Screen.height-370 + cfgw.guiOffsetY; //下原点
          //メインパネルは画面からはみ出さない
          orgX = Math.Max(0, Math.Min(orgX, UnityEngine.Screen.width-220));
          orgY = Math.Max(0, Math.Min(orgY, UnityEngine.Screen.height-220));

          node = new Rect( orgX , orgY , 220 , 220 );
          node2 = new Rect( orgX  + cfgw.guiOffsetXSub, orgY - 450 + cfgw.guiOffsetYSub , 220 , 450 );
          node3 = new Rect( orgX - 620 + cfgw.guiOffsetXConfig, orgY - 450 + cfgw.guiOffsetYConfig , 620 , 450 );
          node4 = new Rect( orgX - 620 + cfgw.guiOffsetXUnzip , orgY + cfgw.guiOffsetYUnzip , 620 , cfgw.guiHeightUnzip );
          //node4a = new Rect( orgX - 840 , orgY , 220 , 220 );
          node5 = new Rect( orgX - 520 , orgY - 190 , 740 , 190 );

#if !UNITY_2022_3
          //GUI Style初期化
          initGUIStyle();
#endif

          //Questかどうか判定
          if (bVR) {
            //bOculusVR = GameObject.Find("TrackingSpace") != null;
      			bOculusVR = GameMain.Instance.VRFamily == GameMain.VRFamilyType.Oculus;
            //if (bOculusVR) vrCameraTransform = GameObject.Find("TrackingSpace/CenterEyeAnchor").transform;
            //else vrCameraTransform = GameObject.Find("Main Camera (eye)").transform;
            
            //高さ補正設定 OpenXRはQuestでも補正が必要
#if UNITY_2022_3
            this.vrBaseHeadHeightGap = cfgw.vrBaseHeadHeightGap;
#else
            if (!bOculusVR) this.vrBaseHeadHeightGap = cfgw.vrBaseHeadHeightGap;
#endif

            //VRショートカット用コントローラー初期化
            if (bOculusVR) vrShortCutController = new VRShortCutControllerQuest(cfgw); //Quest用
            else vrShortCutController = new VRShortCutControllerVive(cfgw); //SteamVR用
          } else {
            vrShortCutController = new VRShortCutControllerNone(); //VR以外のダミー
          }
          UnityEngine.Debug.Log("[VibeYourMaid] bChuBLip="+bChuBLip+" bVR="+bVR+" bOculusVR="+bOculusVR);

          //おさわり機能初期化
          initOsawari();
        }

        /*public void OnDestroy () {

        }*/


        //--------------------------------------------
        //シーン開始時の処理--------------------------
        void OnLevelWasLoaded(int level) {
          try {

          //レベルの取得
          vSceneLevel = level;

          //有効シーンにある場合プラグインを有効化（現在は基本的に、メイドさんがいれば全てのシーンで有効）
          //SceneLevelEnable = true;

          isEditScene = GameMain.Instance.GetNowSceneName() == "SceneEdit";

          //SEの再生をストップ
          GameMain.Instance.SoundMgr.StopSe();

          //メインカメラの取得
          mainCamera = GameMain.Instance.MainCamera;

          //メイドさんの取得
          GetStockMaids();

          //アクティブなメイドさんのIDを取得 初期化処理はフェード終了後に実行
          VisibleMaidCheck(false);

          #if EmpiresLife
          //エンパイアズライフのフラグ初期化
          lifeStart = 0;
          if (vSceneLevel == 3) gameObject_ui = GameObject.Find("UI Root"); //UIオブジェクトの取得
          #endif

          //男モデル取得
          for (int i = 0; i < SubMans.Length; i++) {
            SubMans[i] = GameMain.Instance.CharacterMgr.GetMan(i);
          }
          //男Body取得のため、一度呼び出しておく → 遅延実行で取得するようにしたので不要
          /*if (vSceneLevel == 15 && MansFGet < 2) {
            ++MansFGet;
            foreach (Maid m in SubMans) {
              if (!m.Visible) {
                m.Visible = true;
                m.transform.position = new Vector3(0f, -10f, 0f);
              }
            }
          }*/
          //股間のチェック有効/無効
          if (cfgw.muneHitChinkoEnabled) {
            chinkoCheckTime = Time.time + cfgw.muneHitChinkoCheckInterval; //インターバル秒数後
          } else {
            muneCollider.destroyChinkoColliderAll(); //すべて破棄
            chinkoCheckTime = float.PositiveInfinity; //チェック無効
          }

          //メイド固定の調整値は戻す
          maidFollowHeightOffset = 0f; //高さのずれを0
          bFollowLimitY = false;     //メイド固定で高さ戻り制限初期化
          bFollowLimitAngle = false; //メイド固定でアングル戻り制限初期化
          followReturnSpeedY = -1f; //縦移動速度は標準に戻す

          //カラオケ開始時はメイド固定解除
          if (vSceneLevel == 36) maidFollowEnabled = false;

          //ダンスシーンかどうか カラオケはfalse
          bool isDance = GameMain.Instance.GetNowSceneName().StartsWith("SceneDance_");

          //一人称用男設定
          checkFpsMan();
          if (fpsModeEnabled && fpsMan && !fpsMan.Visible) setFpsModeEnabled(false); //男非表示なら無効化

          //ダンス開始時にメイド固定解除
          if (cfgw.maidFollowDisabledDanceStart && isDance && maidFollowEnabled) {
            maidFollowEnabled = false;
          }
          setDanceCameraDisabled(maidFollowEnabled); //ダンスカメラ有効無効切り替え
          
          //ダンス開始時に竿のコライダーを解除して男表示チェックを無効化
          if (cfgw.muneHitChinkoDisabledDanceStart) {
            if (isDance) {
              muneCollider.muneHitChinkoEnabledBak = cfgw.muneHitChinkoEnabled;
              muneCollider.setChinkoColliderEnabledAll(false);
              chinkoCheckTime = float.PositiveInfinity; //無効ならチェックさせない
              cfgw.muneHitChinkoEnabled = false;

            } else {
              if (muneCollider.muneHitChinkoEnabledBak) {
                muneCollider.setChinkoColliderEnabledAll(true);
                chinkoCheckTime = 0;
                cfgw.muneHitChinkoEnabled = true;
              }
            }
          }
          //ダンス開始時に手のコライダー解除
          if (bVR && cfgw.muneTouchColliderDisabledDanceStart) {
            if (isDance) {
              if (cfgw.muneTouchColliderEnabled) {
                muneCollider.muneTouchColliderEnabledBak = cfgw.muneTouchColliderEnabled;
                osawari.setTouchColliderEnabled(false);
                cfgw.muneTouchColliderEnabled = false;
              }
              //スカートのつかみ判定無効化はDynamicSkirtBoneが取得できない？
            } else{
              if (muneCollider.muneTouchColliderEnabledBak) {
                osawari.setTouchColliderEnabled(true);
                cfgw.muneTouchColliderEnabled = true;
              }
            }
          }
          //ダンス開始時にカメラのコライダー解除
          if (bVR && cfgw.camColliderDisabledDanceStart) {
            if (isDance) {
              if (cfgw.camColliderEnabled) {
                muneCollider.camColliderEnabledBak = cfgw.camColliderEnabled;
                muneCollider.setCamColliderEnabled(false);
                cfgw.camColliderEnabled = false;
              }
              //スカートのつかみ判定無効化はDynamicSkirtBoneが取得できない？
            } else{
              if (muneCollider.camColliderEnabledBak) {
                muneCollider.setCamColliderEnabled(true);
                cfgw.camColliderEnabled = true;
              }
            }
          }

          //スクリプト入れ替え 別プラグインですでに置き換えられている場合は考慮していない
          string tagName = "addprefabchara";
          //夜伽の放尿と潮
          if (cfgw.ScriptReplaceNyoSioPrefabMotion) {
            if (GameMain.Instance.ScriptMgr.kag_mot_dic != null) {
              foreach (KeyValuePair<int, MotionKagManager> item in GameMain.Instance.ScriptMgr.kag_mot_dic) {
                BaseKagManager baseKag = item.Value;
                if (baseKag != null && baseKag.kag != null) {
                  try {
                    baseKag.kag.RemoveTagCallBack(tagName); //登録済みのcallbackは削除
                    baseKag.kag.AddTagCallBack(tagName, (KagTagSupport tag_data) => DummyAddPrefabChara(tag_data, baseKag));
                    Debug.Log("[VibeYourMaid] kag_mot_dic Replaced : "+baseKag);
                  } catch {}
                }
              }
            }
          }
          //その他のスクリプトの尿と潮の入れ替え
          if (cfgw.ScriptReplaceNyoSioPrefabYotogiKag) {
            BaseKagManager baseKag = GameMain.Instance.ScriptMgr.yotogi_kag;
            if (baseKag != null && baseKag.kag != null) {
              try {
                baseKag.kag.RemoveTagCallBack(tagName);
                baseKag.kag.AddTagCallBack(tagName, (KagTagSupport tag_data) => DummyAddPrefabChara(tag_data, baseKag));
                Debug.Log("[VibeYourMaid] yotogi_kag Replaced : "+baseKag);
              } catch {}
            }
          }
          if (cfgw.ScriptReplaceNyoSioPrefabAdvKag) {
            BaseKagManager baseKag = GameMain.Instance.ScriptMgr.adv_kag;
            if (baseKag != null && baseKag.kag != null) {
              try {
                baseKag.kag.RemoveTagCallBack(tagName);
                baseKag.kag.AddTagCallBack(tagName, (KagTagSupport tag_data) => DummyAddPrefabChara(tag_data, baseKag));
                Debug.Log("[VibeYourMaid] adv_kag Replaced : "+baseKag);
              } catch {}
            }
          }
          if (cfgw.ScriptReplaceNyoSioPrefabTmpKag) {
            BaseKagManager baseKag = GameMain.Instance.ScriptMgr.tmp_kag;
            if (baseKag != null && baseKag.kag != null) {
              try {
                baseKag.kag.RemoveTagCallBack(tagName);
                baseKag.kag.AddTagCallBack(tagName, (KagTagSupport tag_data) => DummyAddPrefabChara(tag_data, baseKag));
                Debug.Log("[VibeYourMaid] tmp_kag Replaced : "+baseKag);
              } catch {}
            }
          }
          if (cfgw.ScriptReplaceNyoSioPrefabPrivateKag) {
            BaseKagManager baseKag = GameMain.Instance.ScriptMgr.privatemode_touch_kag;
            if (baseKag != null && baseKag.kag != null) {
              try {
                baseKag.kag.RemoveTagCallBack(tagName);
                baseKag.kag.AddTagCallBack(tagName, (KagTagSupport tag_data) => DummyAddPrefabChara(tag_data, baseKag));
                Debug.Log("[VibeYourMaid] tmp_kag Replaced : "+baseKag);
              } catch {}
            }
          }

#if UNITY_2022_3
          //再設定
          if (bVR) {
            vrShortCutController.init(cfgw);
          }
#endif

          } catch (Exception e) { Debug.LogError("[VibeYourMaid] OnLevelWasLoaded : "+e.StackTrace); }
        }
        //--------------------------------------------


        //--------------------------------------------
        //フレーム毎の処理----------------------------
        
        bool isPreFade = true; //前フレームのフェード状態 フェードして完全に黒い画面(FadeState.Out)ならtrue
        bool isFade = true;
        float updateTimer = 0f; //0.1秒間隔で実行する共通処理用タイマー

        void Update() {

          //プラグインの有効無効切替
          if (Input.GetKeyDown(cfgw.keyPluginToggleV0) && !scKeyOff && AndKey()) {
            cfgw.bPluginEnabledV = !cfgw.bPluginEnabledV;
            //有効無効切り替え時の処理
            if (cfgw.bPluginEnabledV) {
              Console.WriteLine("VibeYourMaid Plugin 有効化");
              checkGUIPos();
              reGetMaid = true;
            } else {
              Console.WriteLine("VibeYourMaid Plugin 無効化");
              #if DOF
              if (depthOfField) depthOfField.enabled = false; //被写界深度表示無効化
              #endif
            }
            //このフレームでの処理は終了
            return;
          }

          //無効化時は終了
          if (!cfgw.bPluginEnabledV) return;

          //フェードして黒い画面ならtrue
          isFade = GameMain.Instance.MainCamera.GetFadeState() == CameraMain.FadeState.Out;

          //フェード中なら終了
          if (isFade) {
            isPreFade = isFade;

            //フェード中でも実行する処理
            if (Input.anyKey) {
              //VRショートカット
              ShortCutVR(vrShortCutController);
            }

            #if EmpiresLife
            if (vSceneLevel == 3 && lifeStart != 0) StartCoroutine("EmpiresLife");
            #endif

            //ここで終了
            return;
          }

          //画面がフェードから抜けたら
          if (isPreFade) {
            //メイド情報の再取得フラグを立てる
            reGetMaid = true;

            //おさわり中なら終了状態に戻す フェード中は動かないのでフェード解除時に実行
            osawari.endOsawari();

            //ポールダンスのポールにコライダー設定
            muneCollider.addPoleDanceCollider();

            //前フレームのフェード状態入れ替え
            isPreFade = isFade;
          }

          //メイドを再取得
          if (reGetMaid) {
            GetStockMaids(); //メイドさんの取得
            VisibleMaidCheck(true); //アクティブなメイドさんのIDを取得
            reGetMaid = false;

            //カメラのターゲットが距離が近すぎる場合は現在のメイドに位置に修正
            if (cfgw.onloadAdjustCameraDistance) adjustCameraDistance();

            checkFpsMan(); //1人称用の男も再取得
            if (fpsModeEnabled && fpsMan && !fpsMan.Visible) setFpsModeEnabled(false); //男非表示なら無効化

            #if DOF
            initDepthOfFieldMaid(tgID); //被写界深度 設定と対象メイド初期化
            #endif
          }

          //メイン処理 メイドなし ----------------------------
          //メイドがいなくても実行する処理
          if (tgID == -1) {
            if (Input.anyKey) {
              //VRショートカット
              ShortCutVR(vrShortCutController);
            }
            //フェードなしでメイドが表示されたかチェック
            if (visibleCheckTime < Time.time) {
              VisibleMaidCheck(true);
              visibleCheckTime = Time.time + 1.0f; //1秒後
            }

            //エンパイアズライフ開始チェック
            #if EmpiresLife
            checkEmpiresLife();
            #endif

            return;
          }

          //メイン処理 ダンス軽量モード ----------------------------
          //ダンス向け軽量モード UIが非表示か最小化の場合のみ
          //メイドの追加チェック、胸の動き、ショートカット操作、メイド固定のみ
          if (cfgw.DanceLightweightMode && cfgw.mainGuiFlag != 1) {

            int vmLength = vmId.Count();
            for (int i=0; i<vmLength; i++) {
              int maidID = vmId[i];
              MaidState mState = maidsState[maidID];
              Maid maid = mState.maid;

              if (!maid.Visible) {
                reGetMaid = true;
                continue;
              }

              //胸と腕の衝突判定 オフセットを調整してosawariのmuneMorphを利用して変形
              //初期化前 または 無効時
              if (mState.muneParam != null) checkMuneYori(maid, mState);
              //胸のコライダー判定 衝突で移動したm_trHitChildLの位置にあわせてm_trsMuneLsubを移動
              if (mState.muneColliderInfo != null) mState.muneColliderInfo.Update(maid);
            }

            if (Input.anyKey) {
              //　GUI表示の切り替え
              if (Input.GetKeyDown(cfgw.keyPluginToggleV1) && AndKey()) {
                cfgw.mainGuiFlag = cfgw.mainGuiFlag + 1;
                if (cfgw.mainGuiFlag > 2) cfgw.mainGuiFlag = 0;
                checkGUIPos();
              }
              if (!(cfgw.ShortCutKeyMouseDisabled)) {
                //ショートカットキー
                ShortCutKey();
              }
              //VRショートカット
              ShortCutVR(vrShortCutController);
            }
            //カメラのメイド追従処理
            MaidFollowingCamera(tgID);

            return;
          }

          //メイン処理 ----------------------------
          //メイド選択中のメイン処理
          bool onWindowClick = false; //マウスがGUIウィンドウ上でクリックされたか

          { //&& SceneLevelEnable は常にtrueなので不要

            timerRate = Time.deltaTime * 60;

            int vmLength = vmId.Count();
            for (int i=0; i<vmLength; i++) {
              int maidID = vmId[i];

              //Maid maid = stockMaids[maidID].mem;
              MaidState mState = maidsState[maidID];
              Maid maid = mState.maid;

              //非表示のメイドがいたらスキップしてアクティブメイドをチェックし直す
              //スタジオで配置解除した等でフェードしない場合
              if (!maid.Visible) {
                Debug.Log("[VibeYourMaid] Maid invisible : "+maidID+" "+maid.body0);
                //次フレームで再取得
                reGetMaid = true;
                continue;
              }

              //オートモード処理
              PowerAutoChange(maidID, mState);

              StateMajorCheck(maidID, mState);  //バイブステート変更処理実行

              ExciteCheck(mState);  //メイドの興奮判定

              StatusFluctuation(maidID, mState);  //メイドのステータス変更処理実行

              //絶頂音声が終わった時の処理
              if (mState.orgasmVoice == 2 && !maid.AudioMan.audiosource.isPlaying) {
                mState.orgasmVoice = 0;          //絶頂時音声フラグOFF
                mState.voiceHoldTime = 0;       //音声をすぐ再生するため、タイマーリセット
                mState.faceHoldTime = 0;
                if (mState.vStateMajor == 40) mState.vStateMajorOld = 30;  //再生中にバイブ停止していた場合に、余韻状態に移行させるため
              }

              //ボイスセット再生処理
              VoiceSetPlay(maidID, maid, mState);

              //モーションセット処理
              MotionSetChange(maidID, maid, mState);

              //カメラ位置取得 キス判定
              CameraPosCheck(maid, mState);

              //目線と顔の自動変更
              EyeAutoChange(maid, mState);

              //乳首設定処理
              if (mState.chikubiEnabled) {
                int cv = ChikubiCheck(maid);
                if (mState.chikubi_View != cv || mState.vStateMajor != 10) {
                  ChikubiSet(maid, mState, cv);
                  mState.chikubi_View = cv;
                }
              }

              //胸と腕の衝突判定 オフセットを調整してosawariのmuneMorphを利用して変形
              //初期化前 または 無効時
              if (mState.muneParam != null) checkMuneYori(maid, mState);
              //胸のコライダー判定 衝突で移動したm_trHitChildLの位置にあわせてm_trsMuneLsubを移動
              if (mState.muneColliderInfo != null) mState.muneColliderInfo.Update(maid);
              
              //おさわりコライダー位置移動
              if (cfgw.osawariEnabled) targetUpdate(maidID, mState);

              //ステート10が継続している場合はここで処理終了
              if (mState.vStateMajor == 10 && mState.vStateMajorOld == 10) continue;

              //----------------------------------------------------------------
              // バイブ動作または余韻時なら以下も実行
              //----------------------------------------------------------------

              //各メイドの興奮値を連動
              ChangeYotogiParamSlider(maidID, mState);

              if (mState.orgasmStart) {
                //絶頂していた場合の処理実行
                OrgasmProcess(maidID, maid, mState);
              } else {
                //絶頂スタートフラグのチェック
                if (OrgasmCheck(maidID, maid, mState)) {
                  foreach (int ID in vmId) {
                    if (ID != maidID && !LinkMaidCheck(maidID, ID)) continue;
                    maidsState[ID].orgasmStart = true;
                  }
                }
              }
              OrgasmBonus(mState);  //絶頂後ボーナスタイム中の処理


              //射精値MAX時の処理
              //外出しは抜くモーションから再生されるので抜いた状態では非対応
              if (mState.syaseiMotion != "Non" && SyaseiCheck(maidID, maid, 100f) && mState.orgasmCmb <= 3) {
                string lastMotion = maid.body0.LastAnimeFN;  //現在のモーションを取得

                //メインメイドのモーション変更
                MotionChange(maid, mState.syaseiMotion, false, 0.7f, 1f);
                MotionChangeAf(maid, lastMotion, true, 0.5f, 1f); // 次に再生

                //男のモーション変更 精液処理はManMotionChangeで実行される
                ManMotionChange(mState.syaseiMotion, maidID, false, 0.7f, 1f);
                ManMotionChangeAf(lastMotion, maidID, true, 0.5f, 1f); // 次に再生

                //サブメイドのモーションも変更
                foreach (int subID in getMotionLinkedMaidID(maidID)) {
                  MaidState subState = maidsState[subID];
                  string subLastMotion = subState.maid.body0.LastAnimeFN;  //現在のモーションを取得
                  MotionChange(subState.maid, subState.syaseiMotion, false, 0.7f, 1f);
                  MotionChangeAf(subState.maid, subLastMotion, true, 0.5f, 1f); // 次に再生
                }

                ReactionPlay(maidID);
              }

              StunCheck(maidID, maid, mState);  //メイドの放心判定

              //演出関係
              mState.kaikanLevel = kaikanLevelCheck(maidID, mState);  //フェイスブレンドレベルチェック
              EffectToiki(maid, mState);  //吐息
              EffectAieki(maid, mState);  //愛液

              mState.continuationTime += timerRate;  //バイブ責めの継続時間加算
              if (mState.faceHoldTime > 0) mState.faceHoldTime -= timerRate;  //表情変更タイマー減少
              if (mState.motionHoldTime > 0) mState.motionHoldTime -= timerRate;  //モーション変更タイマー減少
              if (mState.yoinHoldTime > 0) mState.yoinHoldTime -= timerRate;  //余韻タイマー減少
              if (mState.orgasmHoldTime > 0 && mState.orgasmValue < 100) mState.orgasmHoldTime -= timerRate;  //絶頂後のボーナスタイマー減少


              //モーション変更処理
              if (mState.motionHoldTime <= 0) {
                //モーションアジャスト アイテムセット（双頭バイブのみ）
                if (mState.sVibeFlag) {
                  maid.SetProp("handitem" , "HandItemH_SoutouVibe_I_.menu", 0, true, false);
                  maid.body0.SetMask(TBody.SlotID.HandItemR, true);
                  maid.AllProcPropSeqStart();
                  mState.sVibeFlag = false;
                }

                MotionAdjustPsv(maidID, maid, mState);

                mState.motionHoldTime = UnityEngine.Random.Range(200f,600f);  //次のモーション変更タイマーセット
                
                if (mState.orgasmVoice == 1 || mState.orgasmVoice == 3) {  //絶頂時モーション変更実行
                  ZeccyoMotionSelect(maidID, maid, mState);
                  if (mState.orgasmVoice == 3) mState.orgasmVoice = 2;

                } else {  //通常時モーション変更実行
                  //バイブ変更で挿入モーションが上書きされないように指定時間までスキップ
                  if (mState.skipMotionChange <= Time.time) {
                    MaidMotionChange(maidID, maid, mState, cfgw.motionChangeFade, true);
                  } else {
                    mState.motionHoldTime = 60f; //1秒後に再チェック
                  }
                }
              }


              //表情の変更処理
              if (mState.faceHoldTime <= 0) {
                ChangeFaceAnime(maidID, maid, mState);  //表情変更実行
                ChangeFaceBlend(maidID, maid, mState);  //フェイスブレンド変更実行
                mState.faceHoldTime = cfgw.vStateAltTimeVBase + UnityEngine.Random.Range(0f , cfgw.vStateAltTimeVRandomExtend); //次の表情変更タイマーセット
              }


              //音声の変更処理
              if (mState.voiceHoldTime <= 0) {
                if ((mState.orgasmVoice != 2 || !cfgw.zViceWaitEnabled) && (maid.AudioMan.audiosource.loop || !maid.AudioMan.audiosource.isPlaying
                  #if EmpiresLife
                  || lifeStart != 0
                  #endif
                )) {
                  MaidVoicePlay(maidID, maid, mState);  //ループ音声または絶頂ボイス変更実行
                  mState.voiceHoldTime = cfgw.voiceHoldTimeBase + UnityEngine.Random.Range(0f , cfgw.voiceHoldTimeRandomExtend); //次の音声変更タイマーセット
                }
              }
              //音声変更の前に1フレームだけ一時停止する
              else {
                if (mState.vsFlag != 2) mState.voiceHoldTime -= timerRate;  //音声変更タイマー減少
                //次フレームで音声変更するタイミングでループボイスは一時停止
                if (mState.voiceHoldTime <= 0 && maid.AudioMan.audiosource.loop && maid.AudioMan.audiosource.isPlaying) {
                  if (mState.vStateMajor == 20 || mState.vStateMajor == 30 || mState.vStateMajor == 40) {
                    maid.AudioMan.Stop(0f);  //ADVのオートモードが機能するよう、ループ音声を切り替える前に1フレーム止める ループ音声が変わらない場合はそのまま再開
                  }
                }
              }

              //余韻状態の処理
              if (mState.yoinHoldTime <= 0) {
                if (mState.vStateMajor == 40) {
                  if (mState.vStateMajorOld != 40) {  //余韻状態開始時の場合は、感度や連続絶頂回数によって余韻時間増加させる
                    //mState.yoinHoldTime = cfgw.voiceHoldTimeBase + UnityEngine.Random.Range(0f , cfgw.vStateAltTimeVRandomExtend) + Mathf.CeilToInt(mState.boostValue * 20) + Mathf.CeilToInt(Mathf.Sqrt((float)mState.orgasmCmb)) * 60 + Mathf.CeilToInt(mState.orgasmValue) + Mathf.CeilToInt(mState.exciteValue / 120) ;
                    mState.yoinHoldTime = 300f + Mathf.CeilToInt(mState.boostValue * 20) + (float)mState.orgasmCmb * 100 + Mathf.CeilToInt(mState.orgasmValue) * 5 + Mathf.CeilToInt(mState.exciteValue / 30);
                    if (mState.yoinHoldTime > 5000f ) mState.yoinHoldTime = 5000f;

                  } else if (mState.kaikanLevel <= 1) {  //前回も余韻状態だった場合かつ、勃起値とスタミナが正常値なら完全停止
                    mState.vStateMajor = 50;

                    //各種タイマーも同時にリセット
                    mState.motionHoldTime = 0;
                    mState.faceHoldTime = 0;
                    mState.voiceHoldTime = 0;

                  }
                }
              }
            } //for vmId


            if (Input.anyKey) {
              //　GUI表示の切り替え
              if (Input.GetKeyDown(cfgw.keyPluginToggleV1) && AndKey()) {
                cfgw.mainGuiFlag = cfgw.mainGuiFlag + 1;
                if (cfgw.mainGuiFlag > 2) cfgw.mainGuiFlag = 0;
              }

              if (!(cfgw.ShortCutKeyMouseDisabled)) {
                //ダブルクリック判定
                DClicCheck();

                //ショートカットキー
                ShortCutKey();
              }

              //VRショートカット
              ShortCutVR(vrShortCutController);

              //マウス押下イベントがウィンドウ上かをチェック
              if (cfgw.mainGuiFlag == 1 && cfgw.guiStopPropagation) { //リモコン展開時のみ
                if ((Input.GetMouseButton(0) && !Input.GetMouseButtonUp(0)) || Input.touchCount >= 1) { //左クリックとタッチはイベント無効
                  Vector2 pos = new Vector2(Input.mousePosition.x, UnityEngine.Screen.height - Input.mousePosition.y);
                  if (node.Contains(pos) || node2.Contains(pos) || cfgw.configGuiFlag && node3.Contains(pos) || cfgw.unzipGuiFlag && node4.Contains(pos)) {
                    onWindowClick = true;
                  }
                }
              }

            }

            if (fpsModeEnabled) {
              //一人称視点処理
              FpsModeChange();
            } else {
              //カメラのメイド追従処理
              MaidFollowingCamera(tgID);
            }

            //おさわり処理 (ウィンドウ上にある場合は処理しない)
            if (cfgw.osawariEnabled && !onWindowClick) osawari.osawariHand();


            //0.1秒間隔で実行でよい処理はここで実行
            if (updateTimer < Time.time) {
              float rate = (Time.time - updateTimer + 0.1f) * 60; //timerRateと同等の値
              updateTimer = Time.time + 0.1f; //0.1秒後

              //男の射精値増加処理 見えていなければスキップ
              for (int im = 0; im < SubMans.Length; im++) {
                if (isSubManVisible(im)) {
                  if (syaseiLock[im]) continue;
                  if (mansLevel[im] == 0 || MansTg[im] == -1) {
                    mansLevel[im] = 0;
                    syaseiValue[im] =  Math.Max(0f, syaseiValue[im] - 0.02f * rate);
                  } else if (mansLevel[im] == 1) {
                    syaseiValue[im] = Math.Min(100f, syaseiValue[im] + 0.01f * rate);
                  } else {
                    syaseiValue[im] = Math.Min(100f, syaseiValue[im] + 0.017f * rate);
                  }
                }
              }

              //男の表示状態を定期的にチェックしてコライダーを設定
              if (chinkoCheckTime < Time.time) {
                chinkoCheckTime = Time.time + cfgw.muneHitChinkoCheckInterval; //デフォルトは1秒後
                if (cfgw.muneHitChinkoEnabled) {
                  muneCollider.checkChinkoColliderAll();
                }
              }
              #if DOF
              //被写界深度一時無効化  コントローラーがタブレット範囲内かチェック
              checkTempDepthOfField();
              #endif
            }

          }
          //メイン処理終了 ----------------------------

          //エンパイアズライフ開始チェック
          #if EmpiresLife
          checkEmpiresLife();
          #endif

          //マウスがウィンドウ上のクリックならキー以外のイベントはキャンセルして伝播させない
          if (onWindowClick) {
            Input.ResetInputAxes();
          }
        }
        //--------------------------------------------


        //--------------------------------------------
        //フレーム終了時の処理------------------------
        void LateUpdate() {

          //VR移動
          if (cfgw.vrShortCut) ShortCutVRMove(vrShortCutController);

          if (cfgw.DanceLightweightMode && cfgw.mainGuiFlag != 1) {
            //何もしない

          } else {

          //フェード中は処理をスキップ
          if (isFade) return;

          if (tgID != -1) { //&& SceneLevelEnable は常にtrueなので不要

            //処理フレーム分割数 2～4
            int vmLength = vmId.Count();

            int mc = Math.Min(4, vmLength+1);
            int shapeTgNum1 = 0;

            for (int i=0; i<vmLength; i++) {
              int maidID = vmId[i];

              //Maid maid = stockMaids[maidID].mem;
              MaidState mState = maidsState[maidID];
              Maid maid = mState.maid;
              
              //口元の変更処理
              MouthChange(maid, mState);

              //シェイプキー操作
              if (maidID == tgID) EffectGakupiku(maid, mState);  //痙攣操作

              if (mState.vStateMajor == 20) {
                ShapeKeyRandam(maidID, maid, mState, cfgw.ShapeListR , cfgw.RandamMin1 , cfgw.RandamMax1 );
                ShapeKeyWave(maid, mState, cfgw.ShapeListW , cfgw.ShapeListW2 , cfgw.WaveMin1 , cfgw.WaveMax1 , cfgw.WaveSpead1 );
                ShapeKeyIncrease(maid, mState, cfgw.ShapeListI , cfgw.IncreaseMax1 , cfgw.IncreaseSpead1 );
              }
              else if (mState.vStateMajor == 30) {
                ShapeKeyRandam(maidID, maid, mState, cfgw.ShapeListR , cfgw.RandamMin2 , cfgw.RandamMax2 );
                ShapeKeyWave(maid, mState, cfgw.ShapeListW , cfgw.ShapeListW2 , cfgw.WaveMin2 , cfgw.WaveMax2 , cfgw.WaveSpead2 );
                ShapeKeyIncrease(maid, mState, cfgw.ShapeListI , cfgw.IncreaseMax2 , cfgw.IncreaseSpead2 );
              }

              EffectHibuAnime(maidID, maid, mState);  //秘部アニメ操作

              //以下の処理はメイドが複数いた場合、処理するフレームを分割する（最大8分割）
              if (shapeTgNum1 == shapeTgNum2) {
                EffectAse(maid, mState);  //汗
                EffectBokki(maid, mState, mc);  //勃起操作
                EffectAhe(maid, mState, mc);  //瞳操作
                EffectUterusDatsu(maidID, maid, mState); //子宮脱操作
                EffectSio(maid, mState);  //潮吹き (複数回対応)
                EffectNyodo(maid, mState);  //尿道 (0.1秒間隔)

                if (mState.vStateMajor == 20) {
                  ShapeKeyKupaWave(mState, cfgw.WaveMin1 , cfgw.WaveMax1 , cfgw.WaveSpead1 * mc * 0.5f );
                }
                else if (mState.vStateMajor == 30) {
                  ShapeKeyKupaWave(mState, cfgw.WaveMin2 , cfgw.WaveMax2 , cfgw.WaveSpead2 * mc * 0.5f );
                }
              }

              shapeTgNum1++;
              if (shapeTgNum1 >= mc) shapeTgNum1 = 0;

              //バイブステートのバックアップ
              mState.vStateMajorOld = mState.vStateMajor;

            }


            //変更シェイプキーの適用
            VertexMorph_FixBlendValues();

            shapeTgNum2++; //毎フレーム1人ずらす
            if (shapeTgNum2 >= mc) shapeTgNum2 = 0;

            //メインメイドが変わったときの処理
            if (tgID != tgIDBack) {
              MaidState tgMaidState = maidsState[tgID];
              if (cfgw.autoMoveEnabled && isSubManVisible(0)) {
                MansTg[0] = tgID;
                Maid subMan = getSubMan(0);
                if (subMan && subMan.transform) {
                  subMan.transform.position = tgMaidState.maid.transform.position;
                  subMan.transform.eulerAngles = tgMaidState.maid.transform.eulerAngles;
                }
                ManMotionChange(tgID, true, 0.5f, 1.0f);
              }

              #if DOF
              //フェードなしで表示された場合
              if (tgIDBack == -1) {
                initDepthOfFieldMaid(tgID); //被写界深度 設定と対象メイド初期化
              }
              #endif

              ChangeSE(tgID, tgMaidState, true);
            }
          }

          }

          if (tgID != tgIDBack) tgIDBack = tgID;

        }
        //--------------------------------------------

        #if EmpiresLife
        void checkEmpiresLife()
        {
          //エンパイアズライフ開始
          if (vSceneLevel == 3) {
            if (Input.GetKeyDown(cfgw.keyPluginToggleV11) && !scKeyOff && AndKey()) {
            //背景が存在するかどうかチェック
            UnityEngine.Object @object = GameMain.Instance.BgMgr.CreateAssetBundle("Shitsumu_ChairRot");
            if (@object == null) {
              @object = Resources.Load("BG/Shitsumu_ChairRot");
              if (@object == null) {
                @object = Resources.Load("BG/2_0/Shitsumu_ChairRot");
              }
            }
            if (@object != null) {
              if (lifeStart == 0) {
                if (!bVR) Camera.main.fieldOfView = 50.0f;
                gameObject_ui.SetActive(false);
                flagN = GameMain.Instance.CharacterMgr.status.GetFlag("時間帯") == 3;
                ElStart();
                if (!flagN) StartCoroutine("ElChange", 0);
                if (flagN) StartCoroutine("ElChange", 1);
              } else {
                gameObject_ui.SetActive(true);
                ElEnd();
              }
            }
            }
            //エンパイアズライフモードの処理
            if (lifeStart != 0) StartCoroutine("EmpiresLife");
          }
        }
        #endif

        //--------------------------------------------
        //GUI表示処理---------------------------------
        Rect node;
        Rect node2;
        Rect node3;
        Rect node4;
        //Rect node4a;
        Rect node5;

        GUIStyle gsWin;
        GUIStyle gsLabel;
        GUIStyle gsLabelB;
        GUIStyle gsLabelY;
        GUIStyle gsLabelYB;
        GUIStyle gsLabel2;
        GUIStyle gsLabel2Y;
        GUIStyle gsLabel3;
        GUIStyle gsLabelR;
        GUIStyle gsLabelErr;
        GUIStyle gsButton;
        GUIStyle gsButtonB; //太字
        GUIStyle gsButtonY;
        GUIStyle gsButtonYB;
        GUIStyle gsButton2;
        GUIStyle gsButtonLock;
        GUIStyle gsToggle;
        Texture2D guiBgTexture; //背景色
        Texture2D guiLineTexture;

        private void initGUIStyle()
        {
          gsWin = getGUIStyle("box", 12, TextAnchor.UpperLeft);

          gsLabel = getGUIStyle("label", 12, TextAnchor.MiddleLeft);
          gsLabelB = getGUIStyle("label", 12, TextAnchor.MiddleLeft);
          gsLabelB.fontStyle  = FontStyle.Bold;
          gsLabelY = getGUIStyle("label", 12, TextAnchor.MiddleLeft);
          gsLabelY.normal = new GUIStyleState();
          gsLabelY.normal.textColor = Color.yellow;
          gsLabelYB = getGUIStyle("label", 12, TextAnchor.MiddleLeft);
          gsLabelYB.normal = new GUIStyleState();
          gsLabelYB.normal.textColor = Color.yellow;
          gsLabelYB.fontStyle  = FontStyle.Bold;
          gsLabel2 = getGUIStyle("label", 12, TextAnchor.MiddleCenter);
          gsLabel2Y = getGUIStyle("label", 12, TextAnchor.MiddleCenter);
          gsLabel2Y.normal = new GUIStyleState();
          gsLabel2Y.normal.textColor = Color.yellow;
          gsLabel3 = getGUIStyle("label", 12, TextAnchor.MiddleLeft);
          gsLabel3.fontStyle  = FontStyle.Bold;
          gsLabelR = getGUIStyle("label", 12, TextAnchor.MiddleRight);
          gsLabelErr = getGUIStyle("label", 12, TextAnchor.UpperLeft);
          gsLabelErr.normal = new GUIStyleState();
          gsLabelErr.normal.textColor = Color.red;

          gsButton = getGUIStyle("button", 12, TextAnchor.MiddleCenter);
          gsButtonB = getGUIStyle("button", 12, TextAnchor.MiddleCenter);
          gsButtonB.fontStyle  = FontStyle.Bold;
          gsButtonY = getGUIStyle("button", 12, TextAnchor.MiddleCenter);
          gsButtonY.normal.textColor = Color.yellow;
          gsButtonY.hover.textColor = Color.yellow;
          gsButtonYB = getGUIStyle("button", 12, TextAnchor.MiddleCenter);
          gsButtonYB.normal.textColor = Color.yellow;
          gsButtonYB.hover.textColor = Color.yellow;
          gsButtonYB.fontStyle  = FontStyle.Bold;
          gsButton2 = getGUIStyle("button", 10, TextAnchor.MiddleCenter);
          gsButtonLock = getGUIStyle("button", 10, TextAnchor.MiddleCenter);
          gsButtonLock.fontStyle  = FontStyle.Bold;

          gsToggle = getGUIStyle("toggle", 12, TextAnchor.MiddleLeft);

          //GUI背景テクスチャ
          Color pixel = new Color32(48, 48, 48, 224);
          try {
            pixel = new Color32((byte)cfgw.guiHoverColor[0], (byte)cfgw.guiHoverColor[1], (byte)cfgw.guiHoverColor[2], (byte)cfgw.guiHoverColor[3]);
          } catch {
            UnityEngine.Debug.LogError("[VibeYourMaid] config.xml Error : guiHoverColor");
          }
          guiBgTexture = new Texture2D(1, 1);
          guiBgTexture.SetPixel(0, 0, pixel);
          guiBgTexture.Apply();

          guiLineTexture = new Texture2D(1, 1);
          guiLineTexture.SetPixel(0, 0, new Color32(255, 255, 255, 128));
          guiLineTexture.Apply();

          //背景色設定
          gsWin.onHover.background = guiBgTexture;
          gsWin.hover.background = guiBgTexture;
          gsWin.onFocused.background = guiBgTexture;
          gsWin.focused.background = guiBgTexture;
          gsWin.onHover.textColor = Color.white;
          gsWin.hover.textColor = Color.white;
          gsWin.onFocused.textColor = Color.white;
          gsWin.focused.textColor = Color.white;
        }
        private GUIStyle getGUIStyle(string type, int fontSize, TextAnchor alignment)
        {
          GUIStyle gs = new GUIStyle(type);
          gs.fontSize = fontSize;
          gs.alignment = alignment;
          return gs;
        }

        //言語設定クラス
        Language lang = new Language();
        const string langFile = @"Sybaris\UnityInjector\Config\VibeYourMaid\Language.xml";

        //音声設定ファイル読み込み
        private void loadLanguage()
        {
          try {
            System.Xml.Serialization.XmlSerializer serializer = new System.Xml.Serialization.XmlSerializer(typeof(Language));
            using (System.IO.StreamReader sr = new System.IO.StreamReader(langFile, new System.Text.UTF8Encoding(false))) {
              this.lang = (Language)serializer.Deserialize(sr);
            }
            //配列設定
            autoSelectList = new string[]{ lang.VIBE_AUTO_0, lang.VIBE_AUTO_1, lang.VIBE_AUTO_2, lang.VIBE_AUTO_3 };
            SubMansName = new string[]{ lang.SUBMAN_NAME_0, lang.SUBMAN_NAME_1, lang.SUBMAN_NAME_2, lang.SUBMAN_NAME_3, lang.SUBMAN_NAME_4 };
            lookList = new string[]{ lang.LOOK_POINT_CHEST, lang.LOOK_POINT_HEAD, lang.LOOK_POINT_CROTCH };
            cliModeText = new string[]{ lang.CLI_TYPE_NORMAL, lang.CLI_TYPE_LARGE, lang.CLI_TYPE_FUTANARI };
            SeFileList[0] = new string[] { lang.SE_VIBE, lang.SE_WET, lang.SE_AUTO };

            Debug.Log("[VibeYourMaid] Language.xml Loaded");
          } catch (Exception e) {
            Debug.LogError("[VibeYourMaid] Language.xml Error : "+e);
          }
        }
        //音声設定ファイル保存 DEBUGでファイルがない場合のみ出力
        private void saveLanguage()
        {
          System.Xml.Serialization.XmlSerializer serializer = new System.Xml.Serialization.XmlSerializer(typeof(Language));
          using (System.IO.StreamWriter sw = new System.IO.StreamWriter(langFile, false, new System.Text.UTF8Encoding(false))) {
            serializer.Serialize(sw, this.lang); //XMLファイルに保存
          }
          Debug.Log("[VibeYourMaid] Language.xml Created");
        }

        //GUIが画面外なら位置を修正
        private void checkGUIPos()
        {
          //展開時以外は処理しない
          if (cfgw.mainGuiFlag != 1) return;

          if (node.x < 0) node.x = 0;
          if (node.x > UnityEngine.Screen.width-220) node.x = UnityEngine.Screen.width-220;
          if (node.y < 0) node.y = 0;
          if (node.y > UnityEngine.Screen.height-220) node.y = UnityEngine.Screen.height-220;
          //サブキャラウィンドウは再表示できなくなるので位置修正
          if (cfgw. subGuiFlag != 0) {
            if (node2.x < 0) node2.x = 0;
            if (node2.x > UnityEngine.Screen.width-220) node2.x = UnityEngine.Screen.width-220;
            if (node2.y < 0) node2.y = 0;
            if (node2.y > UnityEngine.Screen.height-450) node2.y = UnityEngine.Screen.height-450;
          }
          #if EmpiresLife
          //エンパイアズライフ画面
          if (ElGuiFlag == 0) {
            if (node5.x < 0) node5.x = 0;
            if (node5.x > UnityEngine.Screen.width-740) node5.x = UnityEngine.Screen.width-740;
            if (node5.y < 0) node5.y = 0;
            if (node5.y > UnityEngine.Screen.height-190) node5.y = UnityEngine.Screen.height-190;
          }
          #endif
        }

        void OnGUI() {
          if (!cfgw.bPluginEnabledV || cfgw.mainGuiFlag == 0) return;
          //フェード中も非表示
          //if (GameMain.Instance.MainCamera.IsFadeProc()) return;

            //メイドがいなかったらリモコンは非表示
            if (tgID != -1) {

#if UNITY_2022_3
          //GUI Style初期化
          initGUIStyle();
#endif

              //if (SceneLevelEnable){
                //if (vSceneLevel == 15 && WaitTime < 120 ){
                  //WaitTime += timerRate;
                //} else {

                node = GUI.Window(324101, node, WindowCallback, lang.TITLE + PluginVersion, gsWin);

                if (cfgw.mainGuiFlag == 2) {
                  //最小化
                  node.height = 20;
                } else if (cfgw.mainGuiFlag == 1){
                  node.height = 220;

                  if (cfgw.configGuiFlag) {
                    string configTitle;
                    switch (ConfigFlag) {
                      case 1: configTitle = lang.TITLE_CONFIG_1; break;
                      case 3: configTitle = lang.TITLE_CONFIG_3; break;
                      case 4: configTitle = lang.TITLE_CONFIG_4; break;
                      case 5: configTitle = lang.TITLE_CONFIG_5; break;
                      case 6: configTitle = lang.TITLE_CONFIG_6; break;
                      case 8: configTitle = lang.TITLE_CONFIG_8; break;
                      case 9: configTitle = lang.TITLE_CONFIG_9; break;
                      case 10: configTitle = lang.TITLE_CONFIG_10; break;
                      default: configTitle = lang.TITLE_CONFIG; break;
                    }
                    node3 = GUI.Window(324103, node3, WindowCallback3, configTitle, gsWin);
                  }

                  if (cfgw.unzipGuiFlag) {
                    node4.height = cfgw.guiHeightUnzip; //高さ可変
                    node4 = GUI.Window(324104, node4, WindowCallback4, lang.TITLE_UNZIP, gsWin);

                    /*調整中
                    if (maidsState[tgID].senyouTokusyuMotion.Count > 0) {
                      node4a = new Rect( node4.x - 220 , node4.y , 220 , 220 );
                      node4a = GUI.Window(3241042, node4a, WindowCallback4a, "特殊モーション", gsWin);
                    }*/
                  }
                }
                //}
              //}
            }

            if (cfgw.mainGuiFlag == 1) { //リモコン展開時のみ
              #if EmpiresLife
              if (tgID != -1 || (lifeStart > 0 && !elFade)) {
              #else
              if (tgID != -1) {
              #endif
                if (cfgw.subGuiFlag == 2 || tgID == -1) {
                  node2 = GUI.Window(324102, node2, WindowCallback2b, lang.TITLE_CONFIG_2B, gsWin);
                } else {
                  node2 = GUI.Window(324102, node2, WindowCallback2a, lang.TITLE_CONFIG_2A, gsWin);
                }
              }
              #if EmpiresLife
              if (lifeStart > 0 && !elFade) node5 = GUI.Window(324105, node5, WindowCallback5, lang.TITLE_EL, gsWin);
              #endif
            }

        }
        //--------------------------------------------


        //---------------------------------------------------
        //メイドのデータ取得関連-----------------------------
        public List<MaidInfo> stockMaids = new List<MaidInfo>();
        public List<MaidState> maidsState = new List<MaidState>();
        public List<int> vmId = new List<int>();
        public int tgID = -1;
        public int tgIDBack = -1;

        public float visibleCheckTime = 0f;

        /// <summary>
        /// メイド情報格納クラス
        /// メンバ変数 stockMaids のListにすべてのメイドが格納される
        /// </summary>
        public class MaidInfo
        {
          public MaidInfo(Maid m, int n, string fn, string ln, string ps, int ips, string con)
          {
            mem = m;
            id = n;
            name = ln + " " + fn;
            personal = ps;
            iPersonal = ips;
            contract = con;
          }

          public Maid mem = null;
          public int id = 0;
          public string name = "";
          public string personal = ""; //性格
          public int iPersonal = -1; //性格配列IDX
          public string contract = ""; //契約
        }

        /// <summary>
        /// メイドの状態格納クラス
        /// メンバ変数 maidsState のListにすべてのメイドが格納される
        /// </summary>
        public class MaidState
        {
          //メイド stackMaidsのmemと同じ
          public Maid maid;

          public Transform maidHead = null;  //メイドの頭位置取得用
          public Transform maidNeck = null;  //メイドの首取得用
          public Transform maidMune = null;  //メイドの胸位置取得用
          //public Transform maidHara = null;  //メイドの腹位置取得用
          public Transform maidXxx = null;  //メイドの股間位置取得用

          //メイドの胸寄り距離判定用
          public Transform maidMuneA = null; //無効化したいときにnullにする
          //メイドの胸寄り調整用
          public MuneValue muneValue = null;
          public MuneOffset muneOffsetL = new MuneOffset();
          public MuneOffset muneOffsetR = new MuneOffset();
          public MuneParam muneParam;

          //胸のコライダーUpdate処理用 前腕やポール等との衝突判定用
          public MuneColliderInfo muneColliderInfo = null;

          public int vStateMajor = 10;        //強弱によるステート
          public int vStateMajorOld = 10;     //強弱によるステート（前回値）
          public int vLevel = 0;              //バイブレベル 1=弱 2=強

          public bool linkEnabled = false;  //ご主人様をメインメイドとリンクさせる
          public int linkID = -1;           //リンクメイドのID
          public bool visibleBack = false;  //メイドがもともと表示されていたかのチェック

          public bool sVibeFlag = false;

          //ボイスモードのセレクト用
          public int voiceMode = 0;
          //public int voiceMode2 = 0; //カスタムボイスで利用 未使用
          public bool autoVoiceEnabled = true;
          public int iRandomVoiceBackup = 0;

          //オートモード用
          public int pAutoSelect = 0;
          public float pAutoTime = 0f;  //責めのオート変更時間
          public bool eAutoSelect = false;
          public float eAutoTime = 0f;  //目線のオート変更時間
          public float mAutoTimeL = 0f;  //大カテゴリモーションのオート変更時間
          public float mAutoTimeS = 0f;  //小カテゴリモーションのオート変更時間

          //表情・音声管理
          public float voiceHoldTime;
          public float faceHoldTime;
          public float yoinHoldTime;
          public int stateAltTime1;
          public int stateAltTime2;
          public string faceAnimeBackup = "";
          public string faceBlendBackup = "";
          public float sekimenValue = 0f;
          public int kaikanLevel;

          //ボイスセット用
          public string editVoiceSetName = "";
          public List<string[]> editVoiceSet = new List<string[]>(); //通常音声
          public string kissVoiceSetName = "None"; //初期化していない状態
          public List<string[]> kissVoiceSet = null; //キス音声
          public string sotodashiVoiceSetName = "";
          public List<string[]> sotodashiVoiceSet = null; //外出し音声
          public string kaodashiVoiceSetName = "";
          public List<string[]> kaodashiVoiceSet = null;  //顔射音声
          public float vsTime = 0f;
          public float vsKissTime = 0f;
          public int vsFlag = 0;
          public string playedVoiceName = ""; //再生されたボイス
          //public float vsInterval = 10f;

          //瞳操作関連
          public float aheValue = 0f;
          public float aheValue2 = 0f;
          public float fAheDefEyeL = -9999f;
          public float fAheDefEyeR = -9999f;
          public bool aheResetFlag = false;


          //興奮度管理
          public int exciteLevel = 1;         //0～300の興奮度を、1～4の興奮レベルに変換した値
          public float exciteValue = 0f;      //現在興奮値

          public float resistBase = 0f;       //抵抗値のベース値
          public float resistBonus = 0f;      //抵抗の特別加算値
          public float resistValue = 0f;      //現在抵抗値

          public float boostBase = 0.5f;      //感度のベース値
          public float boostBonus = 0f;       //感度の特別加算値
          public float boostValue = 0f;       //現在感度
          public float jirashi = 0;           //焦らし度

          public float maidStamina = 3000f;   //スタミナ
          public bool stunFlag = false;

          public float orgasmValue = 0f;            //現在絶頂値　100になると絶頂
          public int orgasmLevel  = 0;              //夜伽スライダー反映に利用
          public int orgasmCount = 0;               //絶頂回数
          public int orgasmCmb = 0;                 //連続絶頂回数
          public float orgasmHoldTime = 0f;         //絶頂後のボーナスタイム
          public int orgasmVoice = 0;               //絶頂時音声フラグ
          public bool orgasmStart = false;          //絶頂開始フラグ
          public float continuationTime;            //バイブ責めの継続時間

          //汗変更チェック用
          public float ase1 = 0f;
          public float ase2 = 0f;
          public float ase3 = 0f;
          public float aseTempValue = 0f;  //一時変更設定

          //フェラ状態チェック
          public int bIsBlowjobing = 0;
          public string zAnimeFileName = "";

          //モーション変更関連
          public float motionHoldTime = 0f;
          public float skipMotionChange = 0;
          public int motionAltTime = 0;
          public int mcFlag = -1;
          public string maidMotionBackup = "";
          public int motionID = -1;
          public int motionLinkID = -1;  //2人目のサブモーションが連携している場合
          public bool isSumata = false;   //素股モーションならtrueにする
          public bool insertable = false; //挿入ボタン表示
          public bool removable = false;  //抜くボタン表示
          public string baceMotion = "";
          public string taikiMotion = "Non";
          public string inMotion = "Non";
          public string outMotion = "Non";
          public string syaseigoMotion = "Non";
          public string sumataMotion = "Non";
          public string syaseiMotion = "Non";
          public string analMotion = "Non";
          public string motionSissinMove = "Non";
          public string motionSissinTaiki = "Non";
          public HashSet<string> removedMotionFN = new HashSet<string>();
          public HashSet<string> sumataMotionFN = new HashSet<string>();
          public List<string> senyouTokusyuMotion = new List<string>();
          public bool analMode = false;
          public Vector3 majPositionBak = new Vector3(0, 0, 0);
          public float majAngleYBak = 0f;
          public int[] syaseiMarks = new int[]{0, 0, 0, 0, 0};
          public bool[] giveSexual = new bool[]{true, false, false, false, false, false, false, false, false, false};
          public bool elItazuraFlag = false;

          //モーションセット関連
          public string editMotionSetName = "";
          public List<List<string>> editMotionSet = new List<List<string>>();
          public float msTime1 = 0f;
          public float msTime2 = 0f;
          public int msCategory = 0;
          public bool mOnceFlag = false;
          public string mOnceBack = "";

          //秘部操作関連
          public float bokkiValue1 = 0f;              //クリ勃起値
          public float bokkiCliValue = 0;             //一時変更も反映したクリの勃起値
          public int cliMode = 0;                     //クリモード(1:通常、2:巨クリ、3:ふたなり)
          public float cliScale = 1f;                 //クリ縮小率
          public int uDatsu = 0;                      //子宮脱フラグ
          public bool bokkiResetFlag = false;
          public float labiaValue = 0;
          public bool pikuFlag = false;
          public float pikuTime = 0;
          public float pikuTime2 = 0;
          public float hibuValue = 0;
          public float analValue = 0;
          public float uDatsuValue1 = 0;
          public float uDatsuValue2 = 0;
          public float uDatsuStock = 0;
          public float uDatsuWait = 90f;
          public float hibuSlider1Value = 10f;
          public float analSlider1Value = 10f;
          public float hibuSlider2Value = 3f;
          public float analSlider2Value = 3f;
          //一時変更
          public float hibuTempValue = 0f;
          public float analTempValue = 0f;
          public float bokkiTempValue = 0f;

          public float kupaOpenTime = 0; //これより前の時間はあそこを拡げない
          public float analOpenTime = 0; //これより前の時間はアナルを拡げない

          //コライダー有効状態一時変更
          public bool colliderEnabledHairR = true;
          public bool colliderEnabledHairT = true;

          //痙攣関係
          public bool gakupikuResetFlag= false;
          public float gakupikuTime = 0;            //痙攣時間判定
          public bool gakupikuFlag = true;          //痙攣動作フラグ
          public bool gakupikuOn = false;
          public float gakupikuValue = 0f;

          //ちんぽ操作関連
          public float chinpoValue1 = 0f;           //　ちんぽ勃起値
          public float soriValue1 = 0f;             //　ちんぽ反り値

          //汗関連
          public bool aseResetFlag = true;  //無効時もdryを1にする
          public float aseTime = 0f;        //汗変更タイミング調整に利用

          //カメラが顔に近づいているかどうか
          public float cameraCheckTime = 0f;
          public bool cameraCheck = false;
          public bool cameraCheckVoice = false;
          public bool eyeToCamOld = false;
          public bool headToCamOld = false;

          //メイドの口元変更
          public float MouthHoldTime = 0f;
          public int MouthMode = 0;
          public int OldMode = 0;
          public float MaValue = 0f;
          public float MiValue = 0f;
          public float MdwValue = 0f;
          public float TupValue = 0f;
          public float ToutValue = 0f;
          public float TopenValue = 0f;
          public float TupValue2 = 0.3f;
          public float ToutValue2 = 0.3f;
          public float TopenValue2 = 0.4f;
          public float maVBack = 1f;
          public float miVBack = 1f;
          public float mdwVBack = 1f;

          //演出関係
          public bool fToiki1 = false;
          public bool fToiki2 = false;
          public bool fAieki1 = false;
          public bool fAieki2 = false;
          public bool fAieki3 = false;
          public bool fSio = false;
          public float sioTime = 0;
          public float sioTime2 = 0;
          public float sioTimeLast = 0;
          public float sioVolume = 0f;
          public int sioCount = 0;
          public float nyoVolume = 0f;
          public float nyodoTime = 0f;
          public float nyodoKeepTime = 0f;
          public float nyodoValue = 0f;

          //シェイプキー関連
          public float kupaWaveValue = 0f;
          public float kupaWaveRe = 1f;
          public float shapeKeyWaveValue = 0f;
          public float shapeKeyWaveRe = 1f;
          public float shapeKeyIncreaseValue = 0f;
          public float shapeKeyRandomInterval = 0.01f; // 動作間隔(秒)
          public float shapeKeyRandomDelta = 0f;       // 前回動作からの経過時間

          //アイテム関連
          public string itemV = "";
          public string itemA = "";

          //エロステータス・経験値関連
          public float cliHidai = 0f; //クリトリス肥大度
          public float chikubiHidai = 0.2f; //乳首肥大度

          public int orgTotal = 0; //トータル絶頂数
          public int orgMax = 0;   //最大連続絶頂数

          public int orgTotalChitsu = 0; //トータル絶頂数（膣）
          public int orgTotalAnal = 0;   //トータル絶頂数（アナル）
          public int orgTotalEtc = 0;    //トータル絶頂数（その他）

          public int[] syaseiTotal1 = new int[]{0, 0, 0, 0};         //射精回数（膣、アナル、口、外）
          public float[] syaseiTotal2 = new float[]{0f, 0f, 0f, 0f}; //射精量（膣、アナル、口、外）

          public int sioTotal1 = 0;    //潮吹き回数
          public int nyoTotal1 = 0;    //放尿回数
          public float sioTotal2 = 0f; //潮吹き量
          public float nyoTotal2 = 0f; //放尿量

          public int stanTotal = 0;    //失神回数
          public int uDatsuTotal = 0;  //子宮脱回数

          //おさわり関連
          public string bodyName = "";
          public GameObject targetSphere_mouth = null;
          public GameObject targetSphere_muneR = null;
          public GameObject targetSphere_muneL = null;
          public GameObject targetSphere_vagina = null;
          public GameObject targetSphere_hipL = null;
          public GameObject targetSphere_hipR = null;
          public GameObject targetSphere_anal = null;
          public Transform IK_mouth = null;
          public Transform IK_muneR = null;
          public Transform IK_muneL = null;
          public Transform IK_vagina = null;
          public Transform IK_hipL = null;
          public Transform Hip_L = null;
          public Transform IK_hipR = null;
          public Transform Hip_R = null;
          public Transform IK_anal = null;

          //乳首関連
          public int chikubi_View = -1;
          public bool chikubiEnabled = false;
          public bool chikubiBokkiEnabled = true;
          public float[] tits_chikubi_def = new float[]{0f, 0f};  //デフォルト乳首と同じような形。先端だけ。
          public float[] tits_chikubi_perky = new float[]{0f, 0f};  //乳首が少し長くなる。ツンツン乳首
          public float[] tits_chikubi_cow = new float[]{0f, 0f};  //乳首が伸びる、うしちちっぽく。
          public float[] tits_chikubi_observe = new float[]{0f, 0f};  //乳首周囲がへこむ。服と胸との隙間を作るキー。
          public float[] tits_chikubi_wide = new float[]{0f, 0f};  //乳首が少し広がる。
          public float[] tits_chikubi_ultralong = new float[]{0f, 0f};  //乳首がすごく長くなるキー。
          public float[] tits_chikubi_ultrawide = new float[]{0f, 0f};  //乳首がすごく膨らむキー。
          public float[] tits_chikubi_ultratare = new float[]{0f, 0f};  //乳首がすごく垂れるキー。
          public float[] tits_chikubi_kanbotsu_n = new float[]{0f, 0f};  //陥没乳首ノーマル。
          public float[] tits_chikubi_kanbotsu_s = new float[]{0f, 0f};  //陥没乳首、少し。
          public float[] tits_chikubi_kanbotsu_p = new float[]{0f, 0f};  //陥没乳首、ポンカン型、perkyキーですこし乳首が伸ばせるタイプ。
          public float[] tits_nipple_def = new float[]{0f, 0f};  //デフォルト乳首と同じような形を再現するキー。乳輪あたりも。
          public float[] tits_nipple_perky1 = new float[]{0f, 0f};  //ツンツン乳輪、乳首も少し出ます。
          public float[] tits_nipple_perky2 = new float[]{0f, 0f};  //ツンツン乳輪、乳首は出ないタイプ。
          public float[] tits_nipple_long1 = new float[]{0f, 0f};  //乳首周辺が伸びる。
          public float[] tits_nipple_long2 = new float[]{0f, 0f};  //乳首周辺が伸びる2。
          public float[] tits_nipple_wide = new float[]{0f, 0f};  //乳輪が広がる。
          public float[] tits_nipple_puffy = new float[]{0f, 0f};  //ぷっくり乳首。
          public float[] tits_nipple_kupa = new float[]{0f, 0f};  //乳首くぱ。
          public float[] tits_munel_chippai = new float[]{0f, 0f};  //ちっぱい

        }


        //メイドデータをストック
        void GetStockMaids()
        {
          stockMaids.Clear();
          for (int i = 0; i < GameMain.Instance.CharacterMgr.GetStockMaidCount(); i++) {
            Maid maid = GameMain.Instance.CharacterMgr.GetStockMaid(i);
            string personal = maid.status.personal.uniqueName;
            int iPersonal = Array.IndexOf(personalList[1], personal); //性格の配列インデックスはここで取得

            MaidInfo maidInfo = new MaidInfo(maid, i, maid.status.firstName, maid.status.lastName, personal, iPersonal, maid.status.contract.ToString());
            stockMaids.Add(maidInfo);

            //State枠がまだ作られていないメイドの場合は追加
            if (maidsState.Count <= i) maidsState.Add(new MaidState());
            //MaidState初期化
            maidsState[i].maid = maid; //メイド設定
            float vsTime = UnityEngine.Random.Range(cfgw.voiceSetInterval-cfgw.voiceSetIntervalRange*0.5f, cfgw.voiceSetInterval+cfgw.voiceSetIntervalRange*0.5f);
            maidsState[i].vsTime = vsTime;
            maidsState[i].vsKissTime = vsTime * 0.5f; //キスは半分にする
          }

          //おさわり機能のキャッシュ配列が足りなくならないように拡張
          osawari.setStockMaidsCount(stockMaids.Count);
        }

        //フェード終了時に1人称用の男を再取得 順番が前で表示されている男が設定される
        void checkFpsMan()
        {
          fpsMan = SubMans[0]; //ご主人様シルエットに戻す
          #if COM3D2_5
          //男エディットボディが表示されていたら入れ替え (ご主人様のみ)
          if (SubMans[0]) {
            if (SubMans[0].HasNewRealMan && SubMans[0].pairMan.Visible) {
              Debug.Log("SubMans[0].pairMan.Visible="+SubMans[0].pairMan.Visible);
              fpsMan = SubMans[0].pairMan; //入れ替え
            }
          }
          #endif
          //ご主人様が見えていれば終了
          if (fpsMan && fpsMan.Visible) return;

          if (cfgw.fpsManChange) {
            //すべての男キャラから見えている最初の男を取得 SubMansに入らない男にも対応
            int manCnt = GameMain.Instance.CharacterMgr.GetStockManCount();
            for (int i = 1; i < manCnt; i++) {
              Maid man = GameMain.Instance.CharacterMgr.GetStockMan(i);
              #if COM3D2_5
              //男エディットボディを優先
              if (man.HasNewRealMan && man.pairMan.Visible) {
                fpsMan = man.pairMan;
                return;
              }
              #endif
              if (man.Visible) {
                fpsMan = man;
                return;
              }
            }
          }
        }

        //アクティブメイドのIDをリスト化する
        void VisibleMaidCheck(bool checkActivate)
        {
          vmId.Clear();
          foreach (MaidInfo sm in stockMaids) {
            MaidState maidState = maidsState[sm.id];

            if (sm.mem.Visible && isNoDummyMaid(sm.mem)) {
              vmId.Add(sm.id); //メイドIDをリストに追加
              //汗は初期非表示に
              try { VertexMorph_FromProcItem(sm.mem.body0, "dry", 1f); } catch { /*LogError(ex);*/ }

              //if (!maidState.visibleBack) { //新たにメイドが表示されていた場合の処理 → スタジオの再読み込みで再初期化が必要

              //TBodyの各部位をmateStateに設定
              setTBodyTransform(maidState);

              if (checkActivate) { //シーンロード時以外は再初期化
                VisibleMaidCheckActivate(sm.id, sm.mem, maidState);
              }

            } else {
              if (maidState.visibleBack) { //表示されていたメイドが消えた場合の処理
                targetDestroy(maidState); //おさわり用ターゲット消去
                //胸コライダーを破棄
                if (maidState.muneColliderInfo != null) {
                  maidState.muneColliderInfo.destroyMuneCollider();
                  maidState.muneColliderInfo = null;
                }

                //リンク状態を解除
                foreach (int id in vmId) {
                  if (maidsState[id].linkID == sm.id) maidsState[id].linkID = -1;
                  if (maidsState[id].motionLinkID == sm.id) maidsState[id].motionLinkID = -1;
                }

                MaidState newMaidState =  new MaidState(); //初期化
                newMaidState.maid = sm.mem; //メイドはここで格納
                newMaidState.visibleBack = false;
                //維持する設定を復元 同じメイドの場合のみ
                if (maidsState[sm.id] != null && newMaidState.maid == maidsState[sm.id].maid) {
                  //if (cfgw.keepVoiceSet) newMaidState.editVoiceSetName = maidsState[sm.id].editVoiceSetName;
                  if (cfgw.keepKissVoiceSet) newMaidState.kissVoiceSetName = maidsState[sm.id].kissVoiceSetName; //キスボイス設定 xmlのロードは再生時
                }
                maidsState[sm.id] = newMaidState;

                //「VYMオリジナル」になっていたら元に戻す
                if (newMaidState.maid.FaceName3 == vymFaceBlendSetName) {
                  newMaidState.maid.FaceAnime(maidState.faceBlendBackup=="" ? "通常" : maidState.faceBlendBackup, 0 , 0);
                }
              }
            }
          }

          //メイドが存在する場合にフラグを有効化
          if (vmId.Count > 0) {
            if (vmId.IndexOf(tgID) == -1) tgID = vmId[0];
          } else {
            tgID = -1;
            GameMain.Instance.SoundMgr.StopSe();
          }
          
          if (cfgw.DanceLightweightMode && cfgw.mainGuiFlag != 1) VertexMorph_FixBlendValues(); //軽量モードはここでシェイプキー反映して汗を非表示
        }

        //アクティブなメイドを単体で再読み込み シーンロード時は実行しない
        void VisibleMaidCheckActivate(int maidID, Maid maid, MaidState maidState)
        {
          //読み込み済みフラグは先にON
          maidState.visibleBack = true;

          //地面判定を-10m以下は0に補正
          if (cfgw.fixBoneHitHeight && maid.body0.BoneHitHeightY < -999f) maid.body0.BoneHitHeightY = 0f;

          //胸コライダーと上腕衝突範囲初期化
          initVisibleMaidMune(maidState);

          //おさわり用ターゲットセット
          if (cfgw.osawariEnabled) {
            targetDestroy(maidState);
            targetSet(maidID, maid, maidState);
          }

          //エロステータス読み込み
          LoadEroState(maidID);

          //乳首設定読込
          ChikubiLoad(maidID, 0);
          ChikubiLoad(maidID, 1);

          if (maid.AudioMan && !maid.AudioMan.audiosource.isPlaying) {
            maid.AudioMan.audiosource.time = 0; //開始秒は0にリセット
          }

          //コライダー無効状態反映
          maidState.colliderEnabledHairR = isDynamicBoneColliderEnabled(maid, "hairR");
          maidState.colliderEnabledHairT = isDynamicBoneColliderEnabled(maid, "hairT");

          //キスボイスセット自動設定 初期状態の場合のみ設定
          if (maidState.kissVoiceSetName == "None") {
            maidState.kissVoiceSetName = ""; //設定前に解除状態にする
            bool skipAutoKiss = false;
            MaidStatus.Status status = maid.status;
            //メイド個別設定
            if (cfgw.autoKissVoiceSetMaid != null) {
              for (int i=0; i<cfgw.autoKissVoiceSetMaid.Length; i++) {
                if (cfgw.autoKissVoiceSetMaid[i].Length > 0 && status.lastName+status.firstName == cfgw.autoKissVoiceSetMaid[i][0]) {
                  if (cfgw.autoKissVoiceSetMaid[i].Length == 1) maidState.kissVoiceSetName = "";
                  else maidState.kissVoiceSetName = cfgw.autoKissVoiceSetMaid[i][1];
                  skipAutoKiss = true;
                  break;
                }
              }
            }
            //関係に応じた設定 NPC等のサブメイドは自動設定しない 空欄の場合はボイスを設定しない
            if (!skipAutoKiss && maidState.kissVoiceSetName == "" && status.heroineType != MaidStatus.HeroineType.Sub) {
              if (status.specialRelation == MaidStatus.SpecialRelation.Married) { //結婚
                if (isVoiceSetExist(cfgw.autoKissVoiceSetMarried)) maidState.kissVoiceSetName = cfgw.autoKissVoiceSetMarried;
              } else if (status.additionalRelation == MaidStatus.AdditionalRelation.Slave) { //愛奴
                if (isVoiceSetExist(cfgw.autoKissVoiceSetSlave)) maidState.kissVoiceSetName = cfgw.autoKissVoiceSetSlave;
              } else if (status.relation == MaidStatus.Relation.Lover) { //恋人
                if (status.seikeiken == MaidStatus.Seikeiken.No_No) {
                  if (isVoiceSetExist(cfgw.autoKissVoiceSetLoverVirgin)) maidState.kissVoiceSetName = cfgw.autoKissVoiceSetLoverVirgin; //処女
                } else {
                  if (isVoiceSetExist(cfgw.autoKissVoiceSetLover)) maidState.kissVoiceSetName = cfgw.autoKissVoiceSetLover; //非処女
                }
              } else if (status.relation == MaidStatus.Relation.Trust) { //信頼
                if (status.seikeiken == MaidStatus.Seikeiken.No_No) {
                  if (isVoiceSetExist(cfgw.autoKissVoiceSetTrustVirgin)) maidState.kissVoiceSetName = cfgw.autoKissVoiceSetTrustVirgin; //処女
                } else {
                  if (isVoiceSetExist(cfgw.autoKissVoiceSetTrust)) maidState.kissVoiceSetName = cfgw.autoKissVoiceSetTrust; //非処女
                }
              } else { //それ以外
                if (isVoiceSetExist(cfgw.autoKissVoiceSetInnocent)) maidState.kissVoiceSetName = cfgw.autoKissVoiceSetInnocent;
              }
            }
          }

        }

        private void setTBodyTransform(MaidState maidState)
        {
          TBody body0 = maidState.maid.body0;
          maidState.maidHead = body0.trsHead;
          maidState.maidNeck = body0.trsNeck;
          if (body0.m_trBones) maidState.maidMune = CMT.SearchObjName(body0.m_trBones, "Bip01 Spine1", true);
          //maidState.maidHara = body0.Spine;
          maidState.maidXxx = body0.Pelvis;
          //胸と上腕の衝突判定用
          maidState.maidMuneA = body0.Spine1a;
        }

        //胸衝突回りの初期化処理
        private void initVisibleMaidMune(MaidState maidState)
        {
          Maid maid = maidState.maid;
          //胸コライダーを初期化 VRは既存を破棄してから追加
          if (cfgw.muneColliderEnabled) {
            //初期化されていないか胸が消えていたら初期化実行
            if (maidState.muneColliderInfo == null || !maidState.muneColliderInfo.m_trsMuneL) {
              maidState.muneColliderInfo = this.muneCollider.initMuneCollider(maid, maidState);
              this.muneCollider.updateTouchCollider(osawari.getTouchCollider());
            }
            //竿のチェックタイマーを有効化
            if (cfgw.muneHitChinkoEnabled) chinkoCheckTime = 0;
          } else {
            //胸と前腕のコライダーを破棄
            if (maidState.muneColliderInfo != null) maidState.muneColliderInfo.destroyMuneCollider();
            maidState.muneColliderInfo = null;
            //竿コライダーを破棄してチェックタイマーを無効化
            muneCollider.destroyChinkoColliderAll();
            chinkoCheckTime = float.PositiveInfinity;
          }

          //胸と上腕の衝突判定 初期化
          //メイド個別の無効設定を優先
          bool muneYoriEnabled = ExSaveData.GetBool(maid, "CM3D2.VibeYourMaid.Plugin", "muneYoriEnabled", true);
          if (isEditScene) muneYoriEnabled = cfgw.muneYoriEditSecneEnabled; //エディット画面では無効  胸のパラメータ変更のチェックする余計な処理を組み込みたくないため非対応
          if (!cfgw.muneYoriEnabled) muneYoriEnabled = false;
          //胸の初期状態取得は無効でも取得
          maidState.muneValue = new MuneValue(maid);
          if (muneYoriEnabled) {
            //胸衝突判定用のパラメータを作成
            maidState.muneParam = new MuneParam(cfgw, maid);
            //胸は回転していない状態に戻す speedが残っていると胸が暴れるので注意
            resetMuneYori(maid, maidState);
          } else {
            if (maidState.muneParam != null) { 
              //先に位置をリセット
              resetMuneYori(maid, maidState);
            }
            //nullにして処理させない
            maidState.muneParam = null;
          }

          //胸衝突範囲ギズモ設定
          if (cfgw.muneDrawGizmo && (cfgw.muneColliderEnabled || muneYoriEnabled)) {
            MuneColliderRenderer muneColliderRenderer = maid.transform.gameObject.GetComponent<MuneColliderRenderer>();
            if (!muneColliderRenderer) {
              //ギズモ追加
              muneColliderRenderer = maid.transform.gameObject.AddComponent<MuneColliderRenderer>();
            }
            //有効なら毎回初期化
            muneColliderRenderer.init(maid, maidState, muneCollider.chinkoCollider, osawari.getTouchCollider(), muneCollider.camCollider);
          } else {
            //無効ならギズモ破棄
            MuneColliderRenderer muneColliderRenderer = maid.transform.gameObject.GetComponent<MuneColliderRenderer>();
            if (muneColliderRenderer) GameObject.Destroy(muneColliderRenderer);
          }
        }

        //コライダーが無効化されているか
        private bool isDynamicBoneColliderEnabled(Maid maid, string slotName)
        {
          if (maid.body0.IsSlotNo(slotName)) {
            TBodySkin skin = maid.body0.GetSlot(slotName);
            FieldInfo dynamicBoneInfo = typeof(BoneHair2).GetField("m_db", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.GetField);
            if (skin != null) {
              DynamicBone db = (DynamicBone)dynamicBoneInfo.GetValue(skin.bonehair2);
              if (db != null) {
                foreach (DynamicBoneColliderBase col in db.m_Colliders) {
                  if (!col.name.StartsWith("VR Hand")) {
                    //最初のコライダーの有効状態
                    return col.enabled;
                  }
                }
              }
            }
          }
          return false;
        }

        //コライダーを無効化
        private void setDynamicBoneColliderEnabled(Maid maid, string slotName, bool enabled)
        {
          if (!maid.body0.IsSlotNo(slotName)) {
            Debug.LogWarning("[VibeYourMaid] No slot : "+slotName);
            return;
          }
          TBodySkin skin = maid.body0.GetSlot(slotName);
          FieldInfo dynamicBoneInfo = typeof(BoneHair2).GetField("m_db", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.GetField);
          if (skin != null) {
            DynamicBone db = (DynamicBone)dynamicBoneInfo.GetValue(skin.bonehair2);
            if (db != null) {
              foreach (DynamicBoneColliderBase col in db.m_Colliders) {
                if (!col.name.StartsWith("VR Hand")) {
                  //コライダーの有効状態設定
                  col.enabled = enabled;
                }
              }
            }
          }
        }

        //エロステータスLOAD
        private void LoadEroState(int maidID) {
          MaidState maidState = maidsState[maidID];
          Maid maid = maidState.maid;
          maidState.cliMode = ExSaveData.GetInt(maid, "CM3D2.VibeYourMaid.Plugin", "cliMode", 0);
          maidState.cliScale = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "cliScale", 1f);

          if (ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "cliHidai", "0") != "") maidState.cliHidai = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "cliHidai", "0"));
          if (ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "chikubiHidai", "0") != "") maidState.chikubiHidai = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "chikubiHidai", "0"));

          if (ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "orgTotal", "0") != "") maidState.orgTotal = intCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "orgTotal", "0"));
          if (ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "orgMax", "0") != "") maidState.orgMax = intCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "orgMax", "0"));
          if (ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "orgTotalChitsu", "0") != "") maidState.orgTotalChitsu = intCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "orgTotalChitsu", "0"));
          if (ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "orgTotalAnal", "0") != "") maidState.orgTotalAnal = intCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "orgTotalAnal", "0"));
          if (ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "orgTotalEtc", "0") != "") maidState.orgTotalEtc = intCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "orgTotalEtc", "0"));

          if (ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "seiekiChitsu1", "0") != "") maidState.syaseiTotal1[0] = intCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "seiekiChitsu1", "0"));
          if (ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "seiekiAnal1", "0") != "") maidState.syaseiTotal1[1] = intCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "seiekiAnal1", "0"));
          if (ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "seiekiKuti1", "0") != "") maidState.syaseiTotal1[2] = intCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "seiekiKuti1", "0"));
          if (ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "seiekiSoto1", "0") != "") maidState.syaseiTotal1[3] = intCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "seiekiSoto1", "0"));
          if (ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "seiekiChitsu2", "0") != "") maidState.syaseiTotal2[0] = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "seiekiChitsu2", "0"));
          if (ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "seiekiAnal2", "0") != "") maidState.syaseiTotal2[1] = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "seiekiAnal2", "0"));
          if (ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "seiekiKuti2", "0") != "") maidState.syaseiTotal2[2] = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "seiekiKuti2", "0"));
          if (ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "seiekiSoto2", "0") != "") maidState.syaseiTotal2[3] = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "seiekiSoto2", "0"));

          if (ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "sioTotal1", "0") != "") maidState.sioTotal1 = intCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "sioTotal1", "0"));
          if (ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "nyoTotal1", "0") != "") maidState.nyoTotal1 = intCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "nyoTotal1", "0"));
          if (ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "sioTotal2", "0") != "") maidState.sioTotal2 = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "sioTotal2", "0"));
          if (ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "nyoTotal2", "0") != "") maidState.nyoTotal2 = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "nyoTotal2", "0"));

          if (ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "stanTotal", "0") != "") maidState.stanTotal = intCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "stanTotal", "0"));
          if (ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "uDatsuTotal", "0") != "") maidState.uDatsuTotal = intCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "uDatsuTotal", "0"));
        }

        //エロステータスSAVE
        private void SaveEroState(int maidID) {
          MaidState maidState = maidsState[maidID];
          Maid maid = maidState.maid;
          ExSaveData.SetInt(maid, "CM3D2.VibeYourMaid.Plugin", "cliMode", maidState.cliMode, true);
          ExSaveData.SetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "cliScale", maidState.cliScale, true);

          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "cliHidai", maidState.cliHidai.ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "chikubiHidai", maidState.chikubiHidai.ToString(), true);

          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "orgTotal", maidState.orgTotal.ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "orgMax", maidState.orgMax.ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "orgTotalChitsu", maidState.orgTotalChitsu.ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "orgTotalAnal", maidState.orgTotalAnal.ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "orgTotalEtc", maidState.orgTotalEtc.ToString(), true);

          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "seiekiChitsu1", maidState.syaseiTotal1[0].ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "seiekiAnal1", maidState.syaseiTotal1[1].ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "seiekiKuti1", maidState.syaseiTotal1[2].ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "seiekiSoto1", maidState.syaseiTotal1[3].ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "seiekiChitsu2", maidState.syaseiTotal2[0].ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "seiekiAnal2", maidState.syaseiTotal2[1].ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "seiekiKuti2", maidState.syaseiTotal2[2].ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "seiekiSoto2", maidState.syaseiTotal2[3].ToString(), true);

          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "sioTotal1", maidState.sioTotal1.ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "nyoTotal1", maidState.nyoTotal1.ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "sioTotal2", maidState.sioTotal2.ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "nyoTotal2", maidState.nyoTotal2.ToString(), true);

          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "stanTotal", maidState.stanTotal.ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "uDatsuTotal", maidState.uDatsuTotal.ToString(), true);
        }


        //メイド呼び出し（夜伽のサブメイド読み込み&PlacementWindowのActiveMaidを参考にした）
        private void LoadMaid(Maid newmaid) {
            int k = 0;
            while (k < GameMain.Instance.CharacterMgr.GetMaidCount()) {
                if (GameMain.Instance.CharacterMgr.GetMaid(k) == null || GameMain.Instance.CharacterMgr.GetMaid(k) == newmaid) {
                    break;
                }
                k++;
            }
            if (k > 20) //アクティブメイドの最大数は21
            {
                Console.WriteLine("[VibeYourMaid] アクティブメイド登録 インデックスエラー: " + k);
                return;
            }

            GameMain.Instance.CharacterMgr.SetActiveMaid(newmaid, k/*MaidList.Count+1*/);
            newmaid.Visible = true;
            newmaid.AllProcProp();
            newmaid.boMabataki = true;

            //再設定
            VisibleMaidCheck(true);
        }


        //メイドの衣装めくれ処理
        private void MekureChanged(int maidID, string mekure, bool autoMode) {
          Maid maid = stockMaids[maidID].mem;
          string skirt = isPropChanged(maid, "skirt");
          string onepiece = isPropChanged(maid, "onepiece");
          string panz = isPropChanged(maid, "panz");
          string mizugi = isPropChanged(maid, "mizugi");

          if (mekure == "前") {
            if (skirt == "本：めくれ前" || onepiece == "本：めくれ前") { //本衣装のめくれ（前）状態だった場合
              if (autoMode){
                if (maid.body0.GetMask(TBody.SlotID.skirt)) maid.ResetProp("skirt", false);
                if (maid.body0.GetMask(TBody.SlotID.onepiece)) maid.ResetProp("onepiece", false);
              }
            } else if (skirt == "仮：めくれ前" || onepiece == "仮：めくれ前") { //仮衣装のめくれ（前）状態だった場合
              if (autoMode) {
                if (maid.body0.GetMask(TBody.SlotID.skirt)) maid.SetProp(MPN.skirt, maid.GetProp(MPN.skirt).strTempFileName.Replace("_mekure", ""), 0, true, false);
                if (maid.body0.GetMask(TBody.SlotID.onepiece)) maid.SetProp(MPN.onepiece, maid.GetProp(MPN.onepiece).strTempFileName.Replace("_mekure", ""), 0, true, false);
              }
            } else if (skirt == "仮：めくれ後" || onepiece == "仮：めくれ後") { //仮衣装のめくれ（後）状態だった場合
              if (maid.body0.GetMask(TBody.SlotID.skirt)) ItemChangeTemp(maid, "skirt", "後");
              if (maid.body0.GetMask(TBody.SlotID.onepiece)) ItemChangeTemp(maid, "onepiece", "後");

            } else if (skirt == "仮：通常" || onepiece == "仮：通常") { //仮衣装の通常状態だった場合
              if (maid.body0.GetMask(TBody.SlotID.skirt)) ItemChangeTemp(maid, "skirt", "めくれスカート", true);
              if (maid.body0.GetMask(TBody.SlotID.onepiece)) ItemChangeTemp(maid, "onepiece", "めくれスカート", true);
            } else if (skirt != "無し" || onepiece != "無し") { //本衣装の通常状態だった場合
              if (maid.body0.GetMask(TBody.SlotID.skirt)) ItemChangeTemp(maid, "skirt", "めくれスカート", false);
              if (maid.body0.GetMask(TBody.SlotID.onepiece)) ItemChangeTemp(maid, "onepiece", "めくれスカート", false);
            }
          }

          if (mekure == "後") {
            if (skirt == "本：めくれ後" || onepiece == "本：めくれ後") { //本衣装のめくれ（後）状態だった場合
              if (autoMode) {
                if (maid.body0.GetMask(TBody.SlotID.skirt)) maid.ResetProp("skirt", false);
                if (maid.body0.GetMask(TBody.SlotID.onepiece)) maid.ResetProp("onepiece", false);
              }
            } else if (skirt == "仮：めくれ後" || onepiece == "仮：めくれ後") { //仮衣装のめくれ（後）状態だった場合
              if (autoMode){
                if (maid.body0.GetMask(TBody.SlotID.skirt)) maid.SetProp(MPN.skirt, maid.GetProp(MPN.skirt).strTempFileName.Replace("_mekure_back", ""), 0, true, false);
                if (maid.body0.GetMask(TBody.SlotID.onepiece)) maid.SetProp(MPN.onepiece, maid.GetProp(MPN.onepiece).strTempFileName.Replace("_mekure_back", ""), 0, true, false);
              }
            } else if (skirt == "仮：めくれ前" || onepiece == "仮：めくれ前") { //仮衣装のめくれ（前）状態だった場合
              if (maid.body0.GetMask(TBody.SlotID.skirt)) ItemChangeTemp(maid, "skirt", "前");
              if (maid.body0.GetMask(TBody.SlotID.onepiece)) ItemChangeTemp(maid, "onepiece", "前");

            } else if (skirt == "仮：通常" || onepiece == "仮：通常") { //仮衣装の通常状態だった場合
              if (maid.body0.GetMask(TBody.SlotID.skirt)) ItemChangeTemp(maid, "skirt", "めくれスカート後ろ", true);
              if (maid.body0.GetMask(TBody.SlotID.onepiece)) ItemChangeTemp(maid, "onepiece", "めくれスカート後ろ", true);
            } else if (skirt != "無し" || onepiece != "無し") { //本衣装の通常状態だった場合
              if (maid.body0.GetMask(TBody.SlotID.skirt)) ItemChangeTemp(maid, "skirt", "めくれスカート後ろ", false);
              if (maid.body0.GetMask(TBody.SlotID.onepiece)) ItemChangeTemp(maid, "onepiece", "めくれスカート後ろ", false);
            }
          }

          if (mekure == "ずらし") {

            if (panz == "本：ずらし" || mizugi == "本：ずらし") { //本衣装のずらし状態だった場合
              if (autoMode) {
                if (maid.body0.GetMask(TBody.SlotID.panz)) maid.ResetProp("panz", false);
                if (maid.body0.GetMask(TBody.SlotID.mizugi)) maid.ResetProp("mizugi", false);
              }
            } else if (panz == "仮：ずらし" || mizugi == "仮：ずらし") { //仮衣装のずらし状態だった場合
              if (autoMode) {
                if (maid.body0.GetMask(TBody.SlotID.panz)) maid.SetProp(MPN.panz, maid.GetProp(MPN.panz).strTempFileName.Replace("_zurashi", ""), 0, true, false);
                if (maid.body0.GetMask(TBody.SlotID.mizugi)) maid.SetProp(MPN.mizugi, maid.GetProp(MPN.mizugi).strTempFileName.Replace("_zurashi", ""), 0, true, false);
              }
            } else if (panz == "仮：通常" || mizugi == "仮：通常") { //仮衣装の通常状態だった場合
              if (maid.body0.GetMask(TBody.SlotID.panz)) ItemChangeTemp(maid, "panz", "パンツずらし", true);
              if (maid.body0.GetMask(TBody.SlotID.mizugi)) ItemChangeTemp(maid, "mizugi", "パンツずらし", true);
            } else if (panz != "無し" || mizugi != "無し") { //本衣装の通常状態だった場合
              if (maid.body0.GetMask(TBody.SlotID.panz)) ItemChangeTemp(maid, "panz", "パンツずらし", false);
              if (maid.body0.GetMask(TBody.SlotID.mizugi)) ItemChangeTemp(maid, "mizugi", "パンツずらし", false);
            }
          }

          maid.AllProcPropSeqStart();
          dCheck = true;
	      }

        private bool isPorori(Maid maid, string name)
        {
          MaidProp prop = maid.GetProp(name);
          return prop.strFileName.Contains("_porori") || prop.strTempFileName.Contains("_porori");
        }

        private bool PororiTop(Maid maid)
        {
          if (!isPorori(maid, "wear")) {
            if (PororiChange(maid, false, "wear", TBody.SlotID.wear, MPN.wear)) return true;
          }
          if (!isPorori(maid, "onepiece")) {
            if (PororiChange(maid, false, "onepiece", TBody.SlotID.onepiece, MPN.onepiece)) return true;
          }
          if (!isPorori(maid, "mizugi")) {
            if (PororiChange(maid, false, "mizugi", TBody.SlotID.mizugi, MPN.mizugi)) return true;
          }
          if (!isPorori(maid, "bra")) {
            if (PororiChange(maid, false, "bra", TBody.SlotID.bra, MPN.bra)) return true;
          }
          return false;
        }

        //ぽろり処理 単独の場合 @return ぽろししたらtrue
        private bool PororiChange(Maid maid, bool autoMode, string name, TBody.SlotID slotID, MPN mpn)
        {
          //非表示なら処理しない
          if (!maid.body0.GetSlotVisible(slotID)) return false;

          string state = isPropChanged(maid, name);
          if (state == "本：ぽろり") { //本衣装のぽろり状態だった場合
            if (autoMode) {
              maid.SetProp(mpn, maid.GetProp(mpn).strFileName.Replace("_porori", ""), 0, true, false);
              maid.AllProcPropSeqStart();
              dCheck = true;
            }
          } else if (state == "仮：ぽろり") { //仮衣装のぽろり状態だった場合
            if (autoMode) {
              maid.SetProp(mpn, maid.GetProp(mpn).strTempFileName.Replace("_porori", ""), 0, true, false);
              maid.AllProcPropSeqStart();
              dCheck = true;
            }
          } else if (state == "仮：通常") { //仮衣装の通常状態だった場合
            if (ItemChangeTempSuffix(maid, name, "_porori", true)) {
              maid.AllProcPropSeqStart();
              dCheck = true;
              return true;
            }
          } else if (state != "無し") { //本衣装の通常状態だった場合
            if (ItemChangeTempSuffix(maid, name, "_porori", false)) {
              maid.AllProcPropSeqStart();
              dCheck = true;
              return true;
            }
          }
          return false;
        }

        private bool PororiOff(Maid maid, string[] name, TBody.SlotID[] slotID, MPN[] mpn)
        {
          bool changed = false;

          for (int i=0; i<name.Length; i++) {
            //if (maid.body0.GetSlotVisible(slotID[i])) { //非表示でなければ
              MaidProp prop = maid.GetProp(name[i]);
              if (prop.strFileName.Contains("_porori")) {
                maid.SetProp(mpn[i], maid.GetProp(mpn[i]).strFileName.Replace("_porori", ""), 0, true, false);
                changed = true;
              } else if (prop.strTempFileName.Contains("_porori")) {
                maid.SetProp(mpn[i], maid.GetProp(mpn[i]).strTempFileName.Replace("_porori", ""), 0, true, false);
                changed = true;
              }
            //}
          }
          if (changed) {
            maid.AllProcPropSeqStart();
            dCheck = true;
          }
          return changed;
        }

        //メイドの衣装状態チェック（めくれ、パンツずらし）
        private string isPropChanged(Maid maid, string mpn) {
          MaidProp prop = maid.GetProp(mpn);
          SortedDictionary<string, string> sortedDictionary;
          string text;
          string result;

          if (prop.nFileNameRID != 0 && Menu.m_dicResourceRef.TryGetValue(prop.nFileNameRID, out sortedDictionary) && sortedDictionary.TryGetValue("めくれスカート", out text)){
            if (text.Equals(prop.strTempFileName)) {
              result = "本：めくれ前";
              Console.WriteLine(mpn + result);
              return result;
            }
          }
          if (prop.nFileNameRID != 0 && Menu.m_dicResourceRef.TryGetValue(prop.nFileNameRID, out sortedDictionary) && sortedDictionary.TryGetValue("めくれスカート後ろ", out text)){
            if (text.Equals(prop.strTempFileName)) {
              result = "本：めくれ後";
              Console.WriteLine(mpn + result);
              return result;
            }
          }
          if (prop.nFileNameRID != 0 && Menu.m_dicResourceRef.TryGetValue(prop.nFileNameRID, out sortedDictionary) && sortedDictionary.TryGetValue("パンツずらし", out text)) {
            if (text.Equals(prop.strTempFileName)) {
              result = "本：ずらし";
              Console.WriteLine(mpn + result);
              return result;
            }
          }
          if (prop.nFileNameRID != 0 && prop.strFileName.Contains("_porori")) {
            result = "本：ぽろり";
            Console.WriteLine(mpn + result);
            return result;
          }

          if (prop.nTempFileNameRID != 0){
            if (prop.strTempFileName.Contains("_mekure_back")) {
              result = "仮：めくれ後";
              Console.WriteLine(mpn + result);
              return result;
            }
            if (prop.strTempFileName.Contains("_mekure")) {
              result = "仮：めくれ前";
              Console.WriteLine(mpn + result);
              return result;
            }
            if (prop.strTempFileName.Contains("_zurashi")) {
              result = "仮：ずらし";
              Console.WriteLine(mpn + result);
              return result;
            }
            if (prop.strTempFileName.Contains("_porori")) {
              result = "仮：ぽろり";
              Console.WriteLine(mpn + result);
              return result;
            }

            if (prop.strTempFileName.Contains("del.menu")) {
              result = "無し";
              return result;
            }
            result = "仮：通常";
            Console.WriteLine(mpn + result);
            return result;
          }

          if (prop.strFileName.Contains("del.menu")) {
            result = "無し";
            return result;
          }

          result = "本：通常";  //本衣装の普通状態だった場合
          Console.WriteLine(mpn + result);
          return result;

        }

        //めくれ、ずらし処理
        public void ItemChangeTemp(Maid maid, string mpn, string name, bool temp) {
          MaidProp prop = maid.GetProp(mpn);
          SortedDictionary<string, string> sortedDictionary;
          string filename;
          if (temp) {
            if (prop.nTempFileNameRID != 0 && global::Menu.m_dicResourceRef.TryGetValue(prop.nTempFileNameRID, out sortedDictionary) && sortedDictionary.TryGetValue(name, out filename)) {
              maid.SetProp(mpn, filename, 0, true, false);
            }
          } else {
            if (prop.nFileNameRID != 0 && global::Menu.m_dicResourceRef.TryGetValue(prop.nFileNameRID, out sortedDictionary) && sortedDictionary.TryGetValue(name, out filename)) {
              maid.SetProp(mpn, filename, 0, true, false);
            }
          }
        }

        //.menuの前に _porori 等をつける場合
        /// <returns>差分があればtrue</returns>
        public bool ItemChangeTempSuffix(Maid maid, string mpn, string suffix, bool temp) {
          MaidProp prop = maid.GetProp(mpn);
          string filename = temp ?  prop.strTempFileName : prop.strFileName;
          filename = filename.Replace(suffix, "").Replace(".menu", suffix+".menu");
          //menuファイルがあれば変更
          if (GameUty.IsExistFile(filename, null)) {
            maid.SetProp(mpn, filename, 0, true, false);
            return true;
          }
          //ずらし等を解除してからmenuファイルがあるかチェック
          filename = temp ?  prop.strTempFileName : prop.strFileName;
          filename = filename.Replace("_zurashi", "").Replace("_mekure_back", "").Replace("_mekure", "");
          filename = filename.Replace(suffix, "").Replace(".menu", suffix+".menu");
          if (GameUty.IsExistFile(filename, null)) {
            maid.SetProp(mpn, filename, 0, true, false);
            return true;
          }
          return false;
        }
        public void ItemChangeTemp(Maid maid, string mpn, string temp) {
          MaidProp prop = maid.GetProp(mpn);
          if (temp == "前") {
            maid.SetProp(mpn, prop.strTempFileName.Replace("_mekure", "_mekure_back"), 0, true, false);
          }
          if (temp == "後") {
            maid.SetProp(mpn, prop.strTempFileName.Replace("_mekure_back", "_mekure"), 0, true, false);
          }
        }



        //フェラしてるかチェック
        private void checkBlowjobing(int maidID, Maid maid, MaidState maidState) {

          if (maidState.orgasmVoice == 0) {
            checkBlowjobing(maidID, maid, maidState, maid.body0.LastAnimeFN);
          } else {
            checkBlowjobing(maidID, maid, maidState, maidState.zAnimeFileName);
          }

        }

        private void checkBlowjobing(int maidID, Maid maid, MaidState maidState, string sLastAnimeFileName) {

          //メイドさんのモーションファイル名に含まれる文字列で判別させる
          if (sLastAnimeFileName != null) {

            maidState.bIsBlowjobing = CheckMouthMode(sLastAnimeFileName);

            //メインメイドの場合はマウスモードを切り替える
            if (maidState.bIsBlowjobing == 0 && maidState.orgasmCmb <= 3) {  //0の時は連続絶頂中じゃなければ切り替える
              int r = UnityEngine.Random.Range(0,10);
              if (maidState.boostBase > 40 && maidState.kaikanLevel > 4) {  //感度が40以上の時はランダムでアヘか食いしばり
                if (r < 4) {
                  maidState.MouthMode = UnityEngine.Random.Range(2,5);
                  if (maidState.MouthMode < 3) maidState.MouthMode = 0;
                }
              } else if (maidState.boostBase > 8 && maidState.kaikanLevel > 3) {  //感度が8以上の時はランダムで歯を食いしばる
                if (r < 4) {
                  maidState.MouthMode = 0;
                } else {
                  maidState.MouthMode = 4;
                }
              } else {
                maidState.MouthMode = maidState.bIsBlowjobing;
              }
            }

            if (maidState.bIsBlowjobing == 1 && cfgw.MouthKissEnabled) maidState.MouthMode = maidState.bIsBlowjobing; //1の時はキスが有効なら切り替える
            if (maidState.bIsBlowjobing == 2 && cfgw.MouthFeraEnabled) maidState.MouthMode = maidState.bIsBlowjobing; //2の時はフェラが有効なら切り替える

            if (maidState.stunFlag) maidState.MouthMode = 3;  //放心中は無条件でアヘらせる


            //カメラが顔に近づいている場合、キスに変更
            if (maidState.bIsBlowjobing == 0 && (maidState.cameraCheck || (osawari.isOsawari(maidID, "MO_")))) {
              maidState.bIsBlowjobing = 1;
              if (cfgw.MouthKissEnabled && !maidState.stunFlag) {
                maidState.MouthMode = 1;
              }
            }

            //フェラの時は顔をカメラに向けないようにする
            if (maidState.bIsBlowjobing == 2) {
              maid.body0.boHeadToCam = false;
            }

          }
        }

        //マウスモード判定用キャッシュ モーション名(".anm"含む)とマウスモード(0:口なし 1:キス 2:フェラ)  起動時にMList.txtの設定も追加される
        private Dictionary<string, byte> MouthModeDic = new Dictionary<string, byte>(1024);
        //マウスモードのチェック
        private int CheckMouthMode(string motion)
        {
          //キャッシュから取得
          if (MouthModeDic.ContainsKey(motion)) return MouthModeDic[motion];

          byte mm = 0;

          if (motion.Contains("fera")) { mm = 2; //フェラ
            if (motion.Contains("feranasi")) mm = 0; //フェラ無し
          }
          if (motion.Contains("sixnine")) mm = 2; //シックスナイン
          if (motion.Contains("_ir_")) mm = 2; //イラマ
          if (motion.Contains("_ir2_")) mm = 2; //イラマ
          if (motion.Contains("_ir2v_")) mm = 2; //イラマ
          if (motion.Contains("_irruma_")) mm = 2; //イラマ
          if (motion.Contains("_kuti")) { mm = 2; //乱交3Pくち
            if (motion.Contains("_kutiosae")) mm = 0; //口抑え
            if (motion.Contains("_kutioou")) mm = 0; //口覆う
            if (motion.Contains("_kutifusagu")) mm = 0; //乱交3P口塞ぎ
          }
          if (motion.Contains("housi")) { mm = 2; //奉仕
            if (motion.Contains("harem_housi_aibu")) mm = 0; //ハーレム奉仕愛撫
            if (motion.Contains("harem_housi_naburu")) mm = 0; //ハーレム奉仕嬲る
            if (motion.Contains("harem_housi2_naburu")) mm = 0; //ハーレム奉仕嬲る
          }
          if (motion.Contains("ran3p_bed_kouhaii")) mm = 2; //乱交3Pベッド後背位
          if (motion.Contains("ran3p_turusi_seijyoui")) mm = 2; //乱交3P吊るし正常位
          if (motion.Contains("ran4p")) { mm = 2; //乱交4P
            if (motion.Contains("ran4p_kijyoui")) mm = 0;
            if (motion.Contains("ran4p_dai_seijyoui")) mm = 0;
          }

          if (motion.Contains("kiss")) mm = 1; //キス
          if (motion.Contains("3ana")) mm = 2; //三つ穴

          if (motion.Contains("taiki")) { mm = 0; //待機中は含めない
            if (motion.Contains("ir_in_taiki")) mm = 2; //咥え始めはフェラに含める
            if (motion.Contains("dt_in_taiki")) mm = 2; //咥え始めはフェラに含める
            if (motion.Contains("kuti_in_taiki")) mm = 2; //咥え始めはフェラに含める
            if (motion.Contains("kutia_in_taiki")) mm = 2; //咥え始めはフェラに含める
          }
          if (motion.Contains("shaseigo")) mm = 0; //射精後は含めない
          if (motion.Contains("surituke")) mm = 1; //乱交３Ｐ擦り付け時は咥えないのでは含めない
          if (motion.Contains("siriname")) mm = 2; //尻舐めはフェラ扱い
          if (motion.Contains("asiname")) mm = 2; //足舐めはフェラ扱い
          if (motion.Contains("tikubiname")) mm = 2; //乳首舐めはフェラ扱い

          if (motion.Contains("yuri_kunni") && motion.Contains("f2")) mm = 2; //百合のクンニする側をフェラに
          if (motion.Contains("harem_haimenzai") && motion.Contains("f2")) mm = 1; //ハーレムのキス担当

          if (motion.Contains("2vibe_vibe")) mm = 0;
          if (motion.Contains("onani_ona_")) mm = 0;

          MouthModeDic.Add(motion, mm); //キャッシュに追加

          return mm;
        }

        //モーションに対応した胸の状態を取得 0:変更なし 1:アニメーションあり 他の指定を追加するときは2,4,8,16のビットを立てる(2:右のみ 4:左のみ)
        private int CheckPaizuriMode(string motion)
        {
          int mode = 0;
          //胸が動くパイズリ
          //追加
          foreach (string m in MotionList_paizuri) {
            if (motion.Contains(m)) mode = 1;
          }
          //除外
          foreach (string m in MotionList_paizuriNone) {
            if (motion.Contains(m)) mode = 0;
          }
          return mode;
        }

        private void setPaizuriEnable(Maid maid, bool left, bool right)
        {
            #if COM3D2_5
            maid.body0.SetMuneYureLWithEnable(!left);
            maid.body0.SetMuneYureRWithEnable(!right);
            #else
            maid.body0.MuneYureL((!left) ? 1 : 0);
            maid.body0.MuneYureR((!right) ? 1 : 0);
            maid.body0.jbMuneL.enabled = !left;
            maid.body0.jbMuneR.enabled = !right;
            #endif
        }



        //カメラとメイドさんの距離判定
        private void CameraPosCheck(Maid maid, MaidState maidState) {

          if (maidState.cameraCheckTime > Time.time) return;
          maidState.cameraCheckTime = Time.time + 0.2f; //0.2秒後

          if (!mainCamera) return;

          bool bInRange = DistanceToMaid(maidState, cfgw.camCheckRange);
          //ボイスセット連動
          maidState.cameraCheckVoice = bInRange && cfgw.camCheckVoiceEnabled;

          if (!cfgw.camCheckEnabled) {
            if (maidState.cameraCheck) {
              maidState.cameraCheck = false;
              maid.body0.boEyeToCam = maidState.eyeToCamOld;
              maid.body0.boHeadToCam = maidState.headToCamOld;
            }
            return;
          }
          if (maidState.bIsBlowjobing == 2) return;

          if (bInRange && !maidState.cameraCheck) {
            maidState.eyeToCamOld = maid.body0.boEyeToCam;
            maidState.headToCamOld = maid.body0.boHeadToCam;
            maidState.cameraCheck = true;

            if (!fpsModeEnabled) maid.EyeToCamera((Maid.EyeMoveType)5, 0.8f); //一人称視点でない場合のみ、顔と目の追従を自動で有効にする
            if (maidState.stunFlag) maid.body0.boEyeToCam = false;

            if (maidState.bIsBlowjobing != 1) {
              maid.AudioMan.Stop();     //現在の音声停止
              maidState.voiceHoldTime = 0;     //音声タイマーリセット
            }

          } else if (!bInRange && maidState.cameraCheck) {
            maid.body0.boEyeToCam = maidState.eyeToCamOld;
            maid.body0.boHeadToCam = maidState.headToCamOld;
            maidState.cameraCheck = false;
            maidState.voiceHoldTime = 0;
          }

        }

        private bool LinkMaidCheck(int maidID, int checkID) {
          if (checkID < 0) return false;
          if (maidsState[maidID].linkID == -1 && maidsState[checkID].linkID == -1) return false;
          if (maidID != maidsState[checkID].linkID && maidsState[maidID].linkID != checkID && maidsState[checkID].linkID != maidsState[maidID].linkID) return false;
          return true;
        }

        private bool DistanceToMaid(MaidState maidState,  float cr) {

          //メイドさんの顔情報がない場合、取得する
          if (!maidState.maidHead) {
            maidState.maidHead = maidState.maid.body0.trsHead;
            /*Transform[] objList = maidState.maid.transform.GetComponentsInChildren<Transform>();
            if (objList.Count() != 0) {
              maidState.maidHead = null;
              foreach (var gameobject in objList) {
                if (gameobject.name == "Bone_Face" && maidState.maidHead == null) maidState.maidHead = gameobject;
              }
            }*/
            if (!maidState.maidHead) return false; //取得できなかった場合
          }

          //カメラと近接判定対象（ターゲット）の距離取得
          if (bVR) {
            return Vector3.Distance(maidState.maidHead.transform.position, GameMain.Instance.OvrMgr.EyeAnchor.position) <= cr;
          } else {
            return Vector3.Distance(maidState.maidHead.transform.position, mainCamera.transform.position) <= cr * (35.0f / Camera.main.fieldOfView);
          }

        }

        //メイドのデータ取得関連終了-------------------------





        //-------------------------------------------------
        //ステータス変更関係-------------------------------


        //バイブステートの変更
        private void StateMajorCheck(int maidID, MaidState maidState) {

          //バイブレベル
          int level = maidState.vLevel;

          //おさわりレベル取得
          int osawariLevel = osawari.getOsawariLevel(maidID);
          if (osawariLevel > 0) {
            level = Math.Max(level, osawariLevel);
            if (maidState.linkID != -1) level = Math.Max(level, osawari.getOsawariLevel(maidState.linkID));
          }

          if (level == 2) { //　「バイブ強」
            if (maidState.vStateMajor != 30) {
              if (maidID == tgID) ChangeSE(tgID, maidState, true);
              maidState.vStateMajor = 30;
            }
          } else if (level == 1) { //　「バイブ弱」
            if (maidState.vStateMajor != 20) {
              if (maidID == tgID) ChangeSE(tgID, maidState, true);
              maidState.vStateMajor = 20;
            }
          } else if (level == 0) { //　「バイブ停止」
            if (osawari.isOsawari(maidID)) {
              if (maidID == tgID) GameMain.Instance.SoundMgr.StopSe();
              maidState.vStateMajor = 40;
              maidState.yoinHoldTime = 120f;
            } else if (maidState.vStateMajor == 50) {
              maidState.vStateMajor = 10;
              maidState.fToiki1 = true; //シーン切り替わりでfalseになる場合に吐息が残ってしまうのでtrueにして強制削除
              maidState.kaikanLevel = 1;
              EffectToiki(maidState.maid, maidState);  //吐息
            } else if (maidState.vStateMajor != 10 && maidState.vStateMajor != 40) {
              if (maidID == tgID) GameMain.Instance.SoundMgr.StopSe();
              maidState.vStateMajor = 40;
              maidState.yoinHoldTime = 0f;
            }
          }


          //バイブステートが変わったら、時間カウンタをリセットする。同時に男の責レベルも設定する
          if (maidState.vStateMajor != maidState.vStateMajorOld) {
            //時間カウンタのリセット
            maidState.voiceHoldTime = 0;
            maidState.faceHoldTime = 0;
            maidState.continuationTime = 0;
            maidState.motionHoldTime = 0;
            int im2 = 1;
            for (int im = 0; im < SubMans.Length; im++) {
              if (!SubMans[im].Visible || MansTg[im] != maidID) continue;
              float fDistance = Vector3.Distance(maidState.maid.transform.position, SubMans[im].transform.position);
              if (fDistance > 1f) continue;
              if (maidState.giveSexual[im2]) {
                mansLevel[im] = level;
              } else {
                mansLevel[im] = 0;
              }
              ++im2;
            }

            //UNZIP中でなければバイブ動作時のスライダー値をバイブ開始時のクパの値に合わせて閉じないようにする
            if (cfgw.kupaSliderSync && maidState.motionID == -1 && (maidState.vStateMajorOld != 20 || maidState.vStateMajorOld != 30) && (maidState.vStateMajor == 20 || maidState.vStateMajor == 30)) {
              float hValue = GetBlendValues(maidState.maid.body0, "body", "kupa") * 100;
              if (hValue > maidState.hibuSlider1Value) {
                maidState.hibuSlider1Value = hValue;
                maidState.hibuValue = hValue;
              }
              float aValue = GetBlendValues(maidState.maid.body0, "body", "anal") * 100;
              if (aValue > maidState.analSlider1Value) {
                maidState.analSlider1Value = aValue;
                maidState.analValue = aValue;
              }
            }

          }
        }


        //興奮度の判定
        private void ExciteCheck(MaidState maidState) {
          if (maidState.exciteValue < cfgw.vExciteLevelThresholdV1 * 60) {
            maidState.exciteLevel = 1;
          } else if (maidState.exciteValue < cfgw.vExciteLevelThresholdV2 * 60) {
            maidState.exciteLevel = 2;
          } else if (maidState.exciteValue < cfgw.vExciteLevelThresholdV3 * 60) {
            maidState.exciteLevel = 3;
          } else {
            maidState.exciteLevel = 4;
          }
        }


        //ステータスの変更処理
        private void StatusFluctuation(int maidID, MaidState maidState) {

          if (maidState.vStateMajor != maidState.vStateMajorOld) {
            //抵抗値変動処理（同じバイブの強度を続けると抵抗値が上がる）
            maidState.resistBonus = 0; //強度が変わった時はリセット

          } else if (maidState.vStateMajor != 10) { //強度が同じ時は、経過時間により加算
            if (maidState.continuationTime < 120) {  //開始2秒は減少
              maidState.resistBonus -= 0.02f * timerRate;
            } else {
              if (maidState.vStateMajor == 20) {
                maidState.resistBonus += 0.01f * maidState.exciteLevel * timerRate;
              } else if (maidState.vStateMajor == 30) {
                maidState.resistBonus += 0.03f * maidState.exciteLevel * timerRate;
              }
            }
          }

          //ベース感度の上限設定
          if (maidState.orgasmCount < 15) {
            if (maidState.boostBase > 15) maidState.boostBase = 15;
          } else {
            if (maidState.boostBase > 50) maidState.boostBase = 50;
          }
          maidState.boostValue = maidState.boostBase + maidState.boostBonus;   //現在感度を計算
          maidState.resistValue = maidState.resistBase + maidState.resistBonus + maidState.exciteLevel * maidState.exciteLevel - maidState.boostValue; //現在抵抗値を計算


          //興奮値、勃起値、変動処理
          if (maidState.vStateMajor == 10 || maidState.vStateMajor == 40  || (!maidState.giveSexual[0] && maidState.exciteValue > (cfgw.vExciteLevelThresholdV1 + 10) * 60) && maidState.itemV == "" && maidState.itemA == "" && osawari.isOsawari(maidID) ) { //　バイブ停止時　現在抵抗値に従って減少

            //興奮値を減算
            if (maidState.exciteValue > 0 && !ExciteLock) maidState.exciteValue -= 10 * maidState.exciteLevel * timerRate;
            if (maidState.exciteValue < 0) maidState.exciteValue = 0;

            //絶頂値を減算
            if (maidState.orgasmValue > 0 && !OrgasmLock) {
              if (maidState.stunFlag) maidState.orgasmValue -= 0.04f * timerRate;
              if (!maidState.stunFlag) maidState.orgasmValue -= 0.1f * timerRate;
            }

            //勃起値減算
            maidState.bokkiValue1 -= cfgw.bokkiShrinkSpeed * Time.deltaTime;
            if (maidState.bokkiValue1 < 0) maidState.bokkiValue1 = 0f;

            //スタミナ回復
            //if (maidState.stunFlag) maidState.maidStamina +=  25 * Time.deltaTime;
            //if (!maidState.stunFlag) maidState.maidStamina +=  15 * Time.deltaTime;
            //maidState.maidStamina += (3500 - maidState.maidStamina) * 0.008f * Time.deltaTime;
            maidState.maidStamina += (4500 - maidState.maidStamina) * 0.008f * Time.deltaTime;
            if (maidState.maidStamina > 3000) maidState.maidStamina = 3000;


          } else if (maidState.vStateMajor == 20) { //　バイブ弱時

            //興奮加算値を計算
            float excitePlusBase = 13;
            float excitePlus = (excitePlusBase - maidState.resistValue) * Mathf.Sqrt(maidState.boostValue);
            if (excitePlus < -1) excitePlus = -1;
            else if ( excitePlus > 10 && maidState.orgasmCmb == 0 ) excitePlus = 10;
            else if ( excitePlus > 20 && maidState.orgasmCmb >= 1 ) excitePlus = 20;
            else if ( excitePlus > 30 && maidState.orgasmCmb >= 5 ) excitePlus = 30;

            //興奮値を加算
            if (!ExciteLock) maidState.exciteValue += excitePlus * timerRate;
            if (maidState.exciteValue > 18000) maidState.exciteValue = 18000;
            if (maidState.exciteValue < 0) maidState.exciteValue = 0;

            //感度加算判定　300分の1の確率で加算（現在興奮度により上昇値変動）
            float randamValue = UnityEngine.Random.Range(0, (int)(300 / timerRate));
            if (randamValue < 1 && maidState.exciteValue > 0) {
              if (!ExciteLock && !OrgasmLock) maidState.boostBase = maidState.boostBase + 0.2f * maidState.exciteLevel;

              if (maidState.maid.body0.LastAnimeFN.Contains( "cli" )) maidState.cliHidai += (maidState.boostValue + maidState.bokkiValue1) / (15000f * (maidState.cliHidai / 2 + 1)); //クリ肥大値加算
              if (maidState.cliHidai > 100) maidState.cliHidai = 100;
              //if (maid.body0.LastAnimeFN.Contains( "tikubi" )) maidState.chikubiHidai += (Mathf.Sqrt(maidState.boostValue) + Mathf.Sqrt(maidState.orgasmValue)) / 2000f;
            }

            //絶頂値加算処理
            if (maidState.exciteLevel > 1 && maidState.orgasmValue > 30 && !OrgasmLock) {
              if (maidState.stunFlag) maidState.orgasmValue -= 0.02f * timerRate;
              if (!maidState.stunFlag) maidState.orgasmValue -= 0.05f * timerRate;
              maidState.jirashi += Mathf.Sqrt(maidState.boostValue) * maidState.orgasmValue * 0.001f * timerRate;
            }
            //勃起値加算
            maidState.bokkiValue1 += 0.02f * timerRate;

            //スタミナ回復
            //if (maidState.stunFlag) maidState.maidStamina +=  10 * Time.deltaTime;
            //if (!maidState.stunFlag) maidState.maidStamina +=  6 * Time.deltaTime;
            maidState.maidStamina += (3500 - maidState.maidStamina) * 0.003f * Time.deltaTime;
            if (maidState.maidStamina > 3000) maidState.maidStamina = 3000;


          } else if (maidState.vStateMajor == 30) { //　バイブ強時

            //興奮加算値を計算
            float excitePlusBase = 20;
            float excitePlus = (excitePlusBase - maidState.resistValue) * Mathf.Sqrt(maidState.boostValue);
            if (excitePlus < -1) excitePlus = -1;
            else if ( excitePlus > 10 && maidState.orgasmCmb == 0 ) excitePlus = 10;
            else if ( excitePlus > 20 && maidState.orgasmCmb >= 1 ) excitePlus = 20;
            else if ( excitePlus > 30 && maidState.orgasmCmb >= 5 ) excitePlus = 30;

            //興奮値を加算
            if (!ExciteLock) { maidState.exciteValue += excitePlus * timerRate; }
            if (maidState.exciteValue > 18000) { maidState.exciteValue = 18000; }
            if (maidState.exciteValue < 0) { maidState.exciteValue = 0; }


            //感度加算判定　300分の1の確率で0.1加算
            float randamValue = UnityEngine.Random.Range(0, (int)(300 / timerRate));
            if (randamValue < 1 && maidState.exciteValue > 0) {
              if (!ExciteLock && !OrgasmLock) maidState.boostBase = maidState.boostBase + 0.1f;

              if (maidState.maid.body0.LastAnimeFN.Contains( "cli" )) maidState.cliHidai += (maidState.boostValue + maidState.bokkiValue1) / (10000f * (maidState.cliHidai / 2 + 1)); //クリ肥大値加算
              if (maidState.cliHidai > 100) maidState.cliHidai = 100;
              //if (maid.body0.LastAnimeFN.Contains( "tikubi" )) maidState.chikubiHidai += (Mathf.Sqrt(maidState.boostValue) + Mathf.Sqrt(maidState.orgasmValue)) / 1000f;
              maidState.sioVolume += maidState.boostValue * maidState.orgasmValue * 0.002f;
              maidState.nyoVolume += maidState.boostValue * maidState.orgasmValue * 0.002f;
            }


            //絶頂値加算処理
            if (maidState.exciteLevel > 1 && !OrgasmLock && (maidState.giveSexual[0] || maidState.itemV != "" || maidState.itemA != "" || osawari.isOsawari(maidID)) ) {
              if (maidState.stunFlag) maidState.orgasmValue += Mathf.Sqrt(maidState.boostValue) * 0.012f * timerRate;
              if (!maidState.stunFlag) maidState.orgasmValue += Mathf.Sqrt(maidState.boostValue) * 0.03f * timerRate;
            }
            //勃起値加算
            maidState.bokkiValue1 += 0.03f * timerRate;

            //スタミナ減少
            maidState.maidStamina -= (excitePlus + maidState.resistBase) * 0.25f * Time.deltaTime;
            if (maidState.maidStamina > 3000) maidState.maidStamina = 3000;
            if (maidState.maidStamina < 0) maidState.maidStamina = 0;
          }

        }

        //夜伽シーンの興奮値と官能値を絶頂度にあわせて変更  100→150→200で上昇 絶頂時に300
        private void ChangeYotogiParamSlider(int maidID, MaidState maidState)
        {
          if (!cfgw.yotogiExciteLink) return;

          int oLevel = 0;

          //絶頂にあわせて絶頂レベルを変更 0～4
          if (maidState.orgasmValue >= 95 || maidState.orgasmHoldTime > 0) { //絶頂動作中も4
            oLevel = 4;
          } else if (maidState.orgasmValue >= 75) {
            oLevel = 3;
          } else if (maidState.orgasmValue >= 50) {
            oLevel = 2;
          } else if (maidState.orgasmValue >= 25) {
            oLevel = 1;
          }

          //kaikanLevel (1～12+1)/3 の方が大きければそちらのレベルに設定
          oLevel = (int)Math.Min(4, Math.Max(oLevel, (maidState.kaikanLevel+1)/3));

          //興奮値を設定し、夜伽ならスライダーを変更
          if (maidState.orgasmLevel != oLevel) { //レベルが変わったときのみ
            #if DEBUG
            Debug.Log("orgasmValue="+maidState.orgasmValue+" kaikanLevel="+maidState.kaikanLevel+" oLevel="+oLevel+" currentExcite="+cfgw.yotogiExciteLinkValue[oLevel]);
            #endif
            setExcite(maidID, maidState.maid, cfgw.yotogiExciteLinkValue[oLevel]);
            
            maidState.orgasmLevel = oLevel;
          }
        }

        // メイドの興奮値を設定 夜伽スライダーがあればそれも変更する
        private void setExcite(int maidID, Maid maid, int excite)
        {
          excite = Math.Max(-100, Math.Min(300, excite));

          //興奮値バーを変更 メインメイドのみ
          if (tgID == maidID) {
            YotogiParamBasicBar yotogiParamBasicBar = null;
            if (vSceneLevel == 14) { //夜伽
              yotogiParamBasicBar = UnityEngine.Object.FindObjectOfType(typeof(YotogiParamBasicBar)) as YotogiParamBasicBar;
            }
            else if (vSceneLevel == 24) { //回想
              yotogiParamBasicBar = UnityEngine.Object.FindObjectOfType(typeof(YotogiParamBasicBarPlusSlider)) as YotogiParamBasicBarPlusSlider;
            }
            if (yotogiParamBasicBar) {
              yotogiParamBasicBar.SetCurrentExcite(excite, true);
              yotogiParamBasicBar.SetCurrentSensual(excite, true);
            }
          }

          //メイドステータスの興奮値を変更
          maid.status.currentExcite = excite;
          maid.status.currentSensual = excite;
        }

        //絶頂スタートのチェック リンク中のメイドが1人でも絶頂していればtrue
        private bool OrgasmCheck(int maidID, Maid maid, MaidState maidState) {
          if (maidState.vStateMajor != 30) return false;  //バイブ強じゃない場合は不可
          foreach (int ID in vmId) {
            if (ID != maidID && !LinkMaidCheck(maidID, ID)) continue;
            //if ((maidState.orgasmVoice >= 2 || maidState.vsFlag == 2) && cfgw.zViceWaitEnabled) return false;  //音声フラグチェック
            if (!maid.AudioMan.audiosource.loop && maid.AudioMan.audiosource.isPlaying && cfgw.zViceWaitEnabled) return false;  //音声フラグチェック
            MaidState linkMaidState = maidsState[ID];
            if ((linkMaidState.orgasmValue < 100 || linkMaidState.exciteLevel < 2) && (linkMaidState.giveSexual[0] || linkMaidState.itemV != "" || linkMaidState.itemA != "")) return false;  //絶頂値と興奮値チェック

            if (linkMaidState.orgasmValue >= 100) return true; //絶頂値100超えがいるかどうか
          }
          return false;
        }


        //絶頂時の処理
        private void OrgasmProcess(int maidID, Maid maid, MaidState maidState) {

          maidState.orgasmStart = false;
          /*if (maidState.orgasmValue < 100 || (maidState.exciteLevel < 2 && maidState.giveSexual[0]) || maidState.vStateMajor != 30 || ((maidState.orgasmVoice >= 2 || maidState.vsFlag == 2) && cfgw.zViceWaitEnabled) ) return;
          if (tgID == maidID || maidState.linkEnabled){  //リンクメイドがいる場合は、全員が条件を満たしていないと絶頂しない
            foreach (int ID in vmId) {
              if (tgID != ID && !maidsState[ID].linkEnabled) continue;
              if (maidsState[ID].orgasmHoldTime > 590) continue;
              maidsState[ID].orgasmValue = 110;

              if ((maidsState[ID].orgasmVoice == 2 || maidsState[ID].vsFlag == 2) && cfgw.zViceWaitEnabled) {
                maidsState[ID].motionHoldTime = 0;
                maidsState[ID].orgasmVoice = 3;
              }
            }
          }*/

          //Debug.Log("OrgasmProcess maidID="+maidID+" giveSexual[0]="+maidState.giveSexual[0]+" sioVolume="+maidState.sioVolume+" nyoVolume="+maidState.nyoVolume);


          //絶頂時の音声処理
          maid.AudioMan.Stop();     //現在の音声停止
          maidState.orgasmVoice = 1;         //絶頂時音声フラグON
          maidState.voiceHoldTime = 0;       //音声・表情タイマーリセット（即再生のため）
          maidState.faceHoldTime = 0;
          maidState.motionHoldTime = 0;      //モーション用タイマーリセット（即再生のため）


          if (maidState.giveSexual[0] || maidState.itemV != "" || maidState.itemA != "" || osawari.isOsawari(maidID)) {
            maidState.orgasmCount += 1;  //絶頂カウント加算
            maidState.orgasmCmb += 1;      //連続絶頂数加算
            maidState.uDatsuStock += 1;   //子宮脱用
            maidState.resistBonus = 0;    //抵抗加算値初期化
            if (!ExciteLock && !OrgasmLock) maidState.boostBase += 1;  //感度加算

            //エロステータス加算
            maidState.orgTotal += 1;
            if (maidState.orgasmCmb > maidState.orgMax) maidState.orgMax = maidState.orgasmCmb;

            //スタミナ減少
            maidState.maidStamina -= maidState.boostValue;
            if (maidState.maidStamina < 0) maidState.maidStamina = 0;

            maidState.orgasmValue = 0f;  //絶頂値リセット
            maidState.orgasmHoldTime = 600;   //絶頂後のボーナスタイム設定

            //潮吹き
            float sr = UnityEngine.Random.Range(0, maidState.sioVolume);
            if (sr + cfgw.orgazmSioLowerLimit >= 30f) {
              maidState.fSio = true;
              maidState.sioTime = Time.time + (sr + cfgw.orgazmSioLowerLimit)/30f * cfgw.orgazmSioDuration; //潮吹き終了時間 3秒以上 2秒以上なら複数回吹く場合もある
              maidState.sioTime2 = Math.Max(maidState.sioTime2, Time.time + UnityEngine.Random.Range(cfgw.orgazmSioStartMin, cfgw.orgazmSioStartMax)); //0～1秒後までランダム 連続時は間隔に合わせる
              maidState.sioVolume -= sr; //0以上
            }
            //放尿 失神時は出やすくする
            float lowerLimit = maidState.stunFlag ? cfgw.orgazmNyoLowerLimit * 0.4f : cfgw.orgazmNyoLowerLimit;
            float nyoTh = maidState.stunFlag ? 50f : 120f;
            float nr = UnityEngine.Random.Range(0, maidState.nyoVolume);
            if (nr + lowerLimit >= nyoTh) {
              EffectNyo(maid, maidState, nr, false);
            }
          }

          //興奮値を削減
          if (!ExciteLock) {
            if (maidState.orgasmCmb > 3) {
              maidState.exciteValue = maidState.exciteValue * 0.8f;
            } else {
              maidState.exciteValue = maidState.exciteValue * 0.5f;
            }
          }


          //連続絶頂の場合マウスモードをランダム変更
          if (maidState.orgasmCmb > 3) {
            maidState.MouthMode = UnityEngine.Random.Range(2,5);
            if (maidState.MouthMode < 3) maidState.MouthMode = 0;
          }

          //アヘ値の変更
          maidState.aheValue2 = maidState.orgasmCmb * 10;
          if (maidState.aheValue2 > 60) maidState.aheValue2 = UnityEngine.Random.Range(0, 60);


          //オートモード時、絶頂後すぐにモーションが変わらないように時間追加
          if (maidState.pAutoSelect != 0 && maidState.pAutoTime < 200f) maidState.pAutoTime += 200f;
          if (maidState.eAutoSelect == true && maidState.eAutoTime < 200f) maidState.eAutoTime += 200f;
          if (maidState.editMotionSetName != "") {
            if (maidState.msTime1 < 300f) maidState.msTime1 += 300f;
            if (maidState.msTime2 < 300f) maidState.msTime2 += 300f;
          }

          //エロステータス更新
          SaveEroState(maidID);

        }


        //絶頂ボーナスタイムの処理
        private void OrgasmBonus(MaidState maidState) {
          if (maidState.orgasmHoldTime > 0) {
            maidState.boostBonus = maidState.jirashi / 20 + 3 * maidState.orgasmCmb ;  //感度ボーナス設定
            //if (maidState.boostBonus > 200) maidState.boostBonus = 200;

          } else if (maidState.orgasmCmb > 0) { //ボーナスタイム終了時の処理
            maidState.jirashi = 0;
            maidState.boostBonus = 0 ;
            maidState.orgasmCmb = 0;
            maidState.orgasmValue = maidState.orgasmValue / 3;

          }
        }


        //メイドの放心判定
        private void StunCheck(int maidID, Maid maid, MaidState maidState) {

          //放心から回復する
          if (maidState.stunFlag) {
            if (maidState.maidStamina > 1500) {
              maidState.stunFlag = false;
              maidState.voiceHoldTime = 0;  //音声・表情タイマーリセット（即再生のため）
              maidState.faceHoldTime = 0;
              maidState.vStateMajorOld = 30;  //バイブが停止していた場合に余韻状態に移行させるため

              maid.ResetProp("eye_hi", false);//ハイライトを戻す
              maid.ResetProp("eye_hi_r", false);
              maid.AllProcPropSeqStart();
            }
          } else {
            //放心状態にする
            if (maidState.maidStamina < 500) {
              maidState.stunFlag = true;
              maidState.orgasmValue = 0;  //絶頂値リセット
              maid.EyeToCamera((Maid.EyeMoveType)0, 0.8f);  //メイドの視線を外す
              maidState.stanTotal += 1; //失神回数
              //エロステータス更新
              SaveEroState(maidID);

              maid.SetProp("eye_hi", "_I_SkinHi002.menu", 0, true, false); //ハイライトを消す
              maid.SetProp("eye_hi_r", "_I_SkinHi002.menu", 0, true, false);
              maid.AllProcPropSeqStart();
            }
          }

        }


        //フェイスブレンド等のレベルチェック
        private int kaikanLevelCheck(int maidID, MaidState maidState) {

          //クリ勃起値、スタミナ、連続絶頂数によってフェイスブレンドレベルを変更
          int kaikanLevel = 1;
          if (maidState.bokkiValue1 > 30) {
            if (maidState.bokkiValue1 <= 50) kaikanLevel = 2;
            else if (maidState.bokkiValue1 <= 70) kaikanLevel = 3;
            else if (maidState.bokkiValue1 <= 90) kaikanLevel = 4;
            else kaikanLevel = 5;
          }
          if (maidState.maidStamina < 2700) {
            if (maidState.maidStamina >= 2400) kaikanLevel += 1;
            else if (maidState.maidStamina >= 2100) kaikanLevel += 2;
            else if (maidState.maidStamina >= 1800) kaikanLevel += 3;
            else if (maidState.maidStamina >= 1500) kaikanLevel += 4;
            else {
              kaikanLevel += 5;
              //スタミナ1500以上は失神から回復するのでここで加算
              if (maidState.stunFlag) kaikanLevel += 2;
            }
          }

          return kaikanLevel + maidState.orgasmCmb; //絶頂コンボを加算
        }


        //ステータス変更関係終了---------------------------





        //-------------------------------------------------
        //表情変更関係-------------------------------------

        //フェイスアニメ変更処理
        private void ChangeFaceAnime(int maidID, Maid maid, MaidState maidState) {

          int iRandomFace = 0;
          string faceAnimeName = "";

          //「バイブ停止」から遷移してくる時には、その時点での表情をバックアップしておく
          if (maidState.vStateMajor != 10 && maidState.vStateMajorOld == 10) maidState.faceAnimeBackup = maid.ActiveFace;

          //変更するフェイスアニメを決定
          if (maidState.stunFlag) {
            iRandomFace = UnityEngine.Random.Range(0 , cfgw.sFaceAnimeStun.Length);
            faceAnimeName = cfgw.sFaceAnimeStun[iRandomFace];

          } else if (maidState.vStateMajor == 20) {
            iRandomFace = UnityEngine.Random.Range(0 , cfgw.sFaceAnime20Vibe[maidState.exciteLevel - 1].Length);
            faceAnimeName = cfgw.sFaceAnime20Vibe[maidState.exciteLevel - 1][iRandomFace];

          } else if (maidState.vStateMajor == 40) {
            if (maidState.orgasmCmb > 0){
              faceAnimeName = cfgw.sFaceAnime40Vibe[3];
            } else {
              faceAnimeName = cfgw.sFaceAnime40Vibe[maidState.exciteLevel - 1];
            }

          } else if (maidState.vStateMajor == 30) {
            iRandomFace = UnityEngine.Random.Range(0 , cfgw.sFaceAnime30Vibe[maidState.exciteLevel - 1].Length);
            faceAnimeName = cfgw.sFaceAnime30Vibe[maidState.exciteLevel - 1][iRandomFace];

          } else if (maidState.vStateMajor == 10 && maidState.vStateMajorOld == 50) {
            faceAnimeName = maidState.faceAnimeBackup;
            maidState.faceAnimeBackup = "";

          }

          //""か"変更しない"でなければ、フェイスアニメを適用する
          if (faceAnimeName != "" && faceAnimeName != "変更しない") maid.FaceAnime(faceAnimeName , cfgw.fAnimeFadeTimeV , 0);

        }



        //フェイスブレンド変更処理
        private void ChangeFaceBlend(int maidID, Maid maid, MaidState maidState) {

          //「バイブ停止」から遷移してくる時には、その時点でのブレンドをバックアップしておく
          if (maidState.vStateMajor != 10 && maidState.vStateMajorOld == 10) {
            //「VYMオリジナル」以外はバックアップ
            if (maid.FaceName3 != vymFaceBlendSetName) maidState.faceBlendBackup = maid.FaceName3;
          }

          string faceBlendCurrent = maidState.faceBlendBackup;
          string sChangeCheek = "";
          string sChangeTears = "";
          int iChangeCheek = 0;
          int iChangeTears = 0;
          string sChangeYodare = "";
          string sChangeBlend = "";

          int iOverrideCheek = 0;
          int iOverrideTears = 0;
          bool bOverrideYodare = false;

          if (maidState.kaikanLevel > 9) {
            iOverrideCheek = 3;       //"頬３"
            iOverrideTears = 3;       //"涙３"
            bOverrideYodare = true;   //よだれ
          } else if (maidState.kaikanLevel > 6) {
            iOverrideCheek = 3;       //"頬３"
            iOverrideTears = 3;       //"涙３"
            bOverrideYodare = true;   //よだれ
          } else if (maidState.kaikanLevel > 5) {
            iOverrideCheek = 3;       //"頬３"
            iOverrideTears = 3;       //"涙３"
          } else if (maidState.kaikanLevel > 4) {
            iOverrideCheek = 3;       //"頬３"
            iOverrideTears = 2;       //"涙２"
          } else if (maidState.kaikanLevel > 3) {
            iOverrideCheek = 3;       //"頬３"
            iOverrideTears = 1;       //"涙１"
          } else if (maidState.kaikanLevel > 2) {
            iOverrideCheek = 2;       //"頬２"
            iOverrideTears = 1;       //"涙１"
          } else if (maidState.kaikanLevel > 1) {
            iOverrideCheek = 2;       //"頬１"
            iOverrideTears = 0;       //"涙１"
          } else {
            iOverrideCheek = 1;       //"頬１"
            iOverrideTears = 0;       //"涙０"
          }

          //「VYMオリジナル」になっていたら元に戻す
          if (faceBlendCurrent == vymFaceBlendSetName) {
            faceBlendCurrent = maidState.faceBlendBackup=="" ? "通常" : maidState.faceBlendBackup;
          }
          faceBlendCurrent = faceBlendCurrent.Replace("オリジナル", ""); //取得したフェイスブレンド情報から「オリジナル」の記述を削除
          if (faceBlendCurrent == "") faceBlendCurrent = "頬０涙０";  // 背景選択時、スキル選択時は、"" が返ってきてエラーが出るため

          sChangeCheek = faceBlendCurrent.Substring(0 , 2);
          sChangeTears = faceBlendCurrent.Substring(2 , 2);
          if (faceBlendCurrent.Length == 7) sChangeYodare = "よだれ";

          //元々のフェイスブレンドと比較する
          if (cfgw.HohoEnabled) {
            if (sChangeCheek == "頬０") iChangeCheek = 0;
            if (sChangeCheek == "頬１") iChangeCheek = 1;
            if (sChangeCheek == "頬２") iChangeCheek = 2;
            if (sChangeCheek == "頬３") iChangeCheek = 3;
            if (iOverrideCheek > iChangeCheek) iChangeCheek = iOverrideCheek;
            if (iChangeCheek == 0) sChangeCheek = "頬０";
            if (iChangeCheek == 1) sChangeCheek = "頬１";
            if (iChangeCheek == 2) sChangeCheek = "頬２";
            if (iChangeCheek == 3) sChangeCheek = "頬３";
          }
          if (cfgw.NamidaEnabled) {
            if (sChangeTears == "涙０") iChangeTears = 0;
            if (sChangeTears == "涙１") iChangeTears = 1;
            if (sChangeTears == "涙２") iChangeTears = 2;
            if (sChangeTears == "涙３") iChangeTears = 3;
            if (iOverrideTears > iChangeTears) iChangeTears = iOverrideTears;
            if (iChangeTears == 0) sChangeTears = "涙０";
            if (iChangeTears == 1) sChangeTears = "涙１";
            if (iChangeTears == 2) sChangeTears = "涙２";
            if (iChangeTears == 3) sChangeTears = "涙３";
          }
          if (cfgw.YodareEnabled && bOverrideYodare) sChangeYodare = "よだれ";

          //赤面処理
          float oldSekimenValue = maidState.sekimenValue;
          if (cfgw.HohoEnabled && cfgw.sekimenKey != "") {
            if (maidState.kaikanLevel >= cfgw.sekimenEnableLevel) maidState.sekimenValue = 1f;
            else if (maidState.kaikanLevel <= cfgw.sekimenDisableLevel) maidState.sekimenValue = 0f;
            if (maidState.sekimenValue != oldSekimenValue) {
              //シェイプキー変更
              try { VertexMorph_FromProcItem(maid.body0, cfgw.sekimenKey, maidState.sekimenValue); } catch { /*LogError(ex);*/ }
            }
          }

          //フェイスブレンドを適用
          sChangeBlend = sChangeCheek + sChangeTears + sChangeYodare;
          maid.FaceBlend(sChangeBlend);

        }


        //表情変更関係終了---------------------------------





        //-------------------------------------------------
        //サウンド処理関係---------------------------------

        //メイドの音声再生処理  ループボイスはAUTOモード用に1フレーム停止されている
        private void MaidVoicePlay(int maidID, Maid maid, MaidState maidState) {

          //フェラしているかのチェック
          checkBlowjobing(maidID, maid, maidState);

          if (maidState.autoVoiceEnabled) {
            if (maidState.bIsBlowjobing > 0) {
              maidState.voiceMode = 1;
            } else {
              maidState.voiceMode = 0;
            }
          }

          int iPersonal = stockMaids[maidID].iPersonal;
          if (iPersonal < 0) iPersonal = 0;
          //if (maidState.voiceMode2 > 0) iPersonal = maidState.voiceMode2 - 1;
          string[] VoiceList = new string[1];
          int vi = 0;

          //バイブ弱の音声
          if (maidState.vStateMajor == 20) {
                if (maidState.stunFlag) {
                  vi = 4;
                } else {
                  vi = maidState.exciteLevel - 1;
                }

                if (maidState.voiceMode == 0) { //通常音声
                  VoiceList = bvs[iPersonal].sLoopVoice20Vibe[vi];
                  //リップシンク有効化
                  if (cfgw.voiceSetPlayLipSync) maid.LipSyncEnabled(true);

                } else if (maidState.voiceMode == 1) { //フェラ音声
                  VoiceList = bvs[iPersonal].sLoopVoice20Fera[vi];
                }
                /*else if (maidState.voiceMode == 2) { //カスタム音声１
                    VoiceList = sLoopVoice20Custom1[vi];
                } else if (maidState.voiceMode == 3) { //カスタム音声２
                    VoiceList = sLoopVoice20Custom2[vi];
                } else if (maidState.voiceMode == 4) { //カスタム音声３
                    VoiceList = sLoopVoice20Custom3[vi];
                } else if (maidState.voiceMode == 5) { //カスタム音声４
                    VoiceList = sLoopVoice20Custom4[vi];
                }*/
          }

          //バイブ強の音声
          else if (maidState.vStateMajor == 30) {
                if (maidState.orgasmVoice == 0) {

                    if (maidState.stunFlag) {
                      vi = 4;
                    } else {
                      vi = maidState.exciteLevel - 1;
                    }

                    if (maidState.voiceMode == 0) { //通常音声
                      VoiceList = bvs[iPersonal].sLoopVoice30Vibe[vi];
                      //リップシンク有効化
                      if (cfgw.voiceSetPlayLipSync) maid.LipSyncEnabled(true);

                    } else if (maidState.voiceMode == 1) { //フェラ音声
                      VoiceList = bvs[iPersonal].sLoopVoice30Fera[vi];

                    }
                    /*else if (maidState.voiceMode == 2) { //カスタム音声１
                        VoiceList = sLoopVoice30Custom1[vi];
                    } else if (maidState.voiceMode == 3) { //カスタム音声２
                        VoiceList = sLoopVoice30Custom2[vi];
                    } else if (maidState.voiceMode == 4) { //カスタム音声３
                        VoiceList = sLoopVoice30Custom3[vi];
                    } else if (maidState.voiceMode == 5) { //カスタム音声４
                        VoiceList = sLoopVoice30Custom4[vi];
                    }*/

                } else {  //絶頂時音声
                    #if DEBUG
                    Debug.Log("exciteLevel="+maidState.exciteLevel+" kaikanLevel="+maidState.kaikanLevel+" orgasmCmb="+maidState.orgasmCmb+" orgasmCount="+maidState.orgasmCount);
                    #endif

                    if (maidState.stunFlag) {
                      //放心状態 0と同じ喘ぎ声
                      vi = 4;
                    } else {
                      //連続絶頂3回以上 か 絶頂6回以上 0～3
                      if (maidState.kaikanLevel >= 5 && (maidState.orgasmCmb >= 3 || maidState.orgasmCount >= 6)) vi = maidState.exciteLevel - 1;
                      //0～2
                      else vi = maidState.exciteLevel - 2;
                      if (vi < 0) vi = 0;
                    }

                    if (maidState.voiceMode == 0) { //通常音声
                      VoiceList = bvs[iPersonal].sOrgasmVoice30Vibe[vi];
                      //リップシンク有効化
                      if (cfgw.voiceSetPlayLipSync) maid.LipSyncEnabled(true);
                      //舌を引っ込める
                      if (cfgw.voiceSetPlayTangOff) setTangOff(maidState);

                    } else if (maidState.voiceMode == 1) { //フェラ音声
                      VoiceList = bvs[iPersonal].sOrgasmVoice30Fera[vi];

                    }
                    /*else if (maidState.voiceMode == 2) { //カスタム音声１
                        VoiceList = sOrgasmVoice30Custom1[vi];
                    } else if (maidState.voiceMode == 3) { //カスタム音声２
                        VoiceList = sOrgasmVoice30Custom2[vi];
                    } else if (maidState.voiceMode == 4) { //カスタム音声３
                        VoiceList = sOrgasmVoice30Custom3[vi];
                    } else if (maidState.voiceMode == 5) { //カスタム音声４
                        VoiceList = sOrgasmVoice30Custom4[vi];
                    }*/
                }
          }


          int iRandomVoice = UnityEngine.Random.Range(0, VoiceList.Length);

          //絶頂音声が重複しないようにする
          if (maidState.orgasmVoice != 0) {
              while (iRandomVoice == maidState.iRandomVoiceBackup && VoiceList.Length > 1) {
                  iRandomVoice = UnityEngine.Random.Range(0, VoiceList.Length);
              }
              maidState.iRandomVoiceBackup = iRandomVoice;
          }


          //バイブ動作時の音声を実際に再生する
          if (maidState.vStateMajor == 30 || maidState.vStateMajor == 20) {
            string voiceFile = VoiceList[iRandomVoice];
            if (maidState.orgasmVoice == 0) {
              if (!maid.AudioMan.audiosource.loop || voiceFile != maid.AudioMan.FileName) maid.AudioMan.audiosource.time = 0; //ループでないか音声が変わる場合は0にする
              maid.AudioMan.LoadPlay(voiceFile, 0f, false, true);
              Console.WriteLine(stockMaids[maidID].personal +" [L"+maidState.vStateMajor+":"+vi+":"+iRandomVoice+"] "+voiceFile);
            } else {
              maid.AudioMan.audiosource.time = 0; //先に0にする
              maid.AudioMan.LoadPlay(voiceFile, 0f, false, false);
              maidState.orgasmVoice = 2;   //絶頂音声再生中のフラグ
              Console.WriteLine(stockMaids[maidID].personal +" [O"+maidState.vStateMajor+":"+vi+":"+iRandomVoice+"] "+voiceFile);
            }
          }

          //バイブ停止時の音声
          else if (maidState.vStateMajor == 40) {
                int VoiceValue;

                if (maidState.stunFlag) {
                  vi = 1;
                } else{
                  vi = 0;
                }

                if (maidState.orgasmCmb > 0) {
                    VoiceValue = 3 + vi;
                } else {
                    //VoiceValue = maidState.exciteLevel - 1 + vi;
                    //kaikanLevel 1～12 1以下になったらボイス終了
                    int kaikan = maidState.kaikanLevel;
                    if (kaikan >= 6) {
                      if (kaikan <= 8) kaikan = 4; //6-8
                      else if (kaikan <= 10) kaikan = 5; //9-10
                      else kaikan = 6; //11-12
                    }
                    VoiceValue = Math.Min(4, Math.Max(maidState.exciteLevel, kaikan-1) - 1 + vi);
                    #if DEBUG
                    Debug.Log("exciteLevel="+maidState.exciteLevel+" kaikanLevel="+maidState.kaikanLevel+" motionHoldTime="+maidState.motionHoldTime);
                    #endif
                }

                /*if (maidState.voiceMode == 2) {
                    VoiceList = sLoopVoice40Custom1;
                } else if (maidState.voiceMode == 3) {
                    VoiceList = sLoopVoice40Custom2;
                } else if (maidState.voiceMode == 4) {
                    VoiceList = sLoopVoice40Custom3;
                } else if (maidState.voiceMode == 5) {
                    VoiceList = sLoopVoice40Custom4;
                } else {
                    VoiceList = bvs[iPersonal].sLoopVoice40Vibe;
                }*/
                VoiceList = bvs[iPersonal].sLoopVoice40Vibe;
                string voiceFile = VoiceList[VoiceValue];
                if (!maid.AudioMan.audiosource.loop && voiceFile != maid.AudioMan.FileName) maid.AudioMan.audiosource.time = 0; //ループでないか音声が変わる場合は0にする
                maid.AudioMan.LoadPlay(voiceFile, 0f, false, true);
                Console.WriteLine(stockMaids[maidID].personal +" ["+maidState.vStateMajor+":"+VoiceValue+"] "+voiceFile);
          }

          //余韻終了時
          else if (maidState.vStateMajor == 10 && maidState.vStateMajorOld == 50) {
            maid.AudioMan.Stop(1.5f);
          }

        }

        //リアクション音声・表情の再生
        private void ReactionPlay(int maidID)
        {
          Maid maid = stockMaids[maidID].mem;
          MaidState maidState = maidsState[maidID];
          
          int iPersonal = stockMaids[maidID].iPersonal;
          //if (maidState.voiceMode2 > 0) iPersonal = maidState.voiceMode2 - 1;
          if (iPersonal == -1) return;
          string[] VoiceList = reactionVoice[iPersonal];
          int iRandom = UnityEngine.Random.Range(0, VoiceList.Length);

          string voiceFile = VoiceList[iRandom];
          maid.AudioMan.audiosource.time = 0; //先に0に戻す
          maid.AudioMan.LoadPlay(voiceFile, 0f, false, false);
          //maidState.vsFlag = 2;
          maidState.orgasmVoice = 2;

          Console.WriteLine("[VibeYourMaid] リアクションボイス: "+voiceFile);

          iRandom = UnityEngine.Random.Range(0 , cfgw.sFaceAnime30Vibe[3].Length);
          maid.FaceAnime(cfgw.sFaceAnime30Vibe[3][iRandom] , 0.5f , 0);
          maidState.faceHoldTime = cfgw.vStateAltTimeVBase + UnityEngine.Random.Range(0f , cfgw.vStateAltTimeVRandomExtend); //次の表情変更タイマーセット
        }

        //射精用のボイスセット再生処理 即時再生する
        private bool SyaseiReactionPlay(int maidID, MaidState maidState, List<string[]> syaseiVoiceSet)
        {
          //音声再生
          string[][] vsList = VoiceSetCheck(maidID, maidState.maid, maidState, syaseiVoiceSet);
          if (vsList.Length == 0) {
            Debug.Log("[VibeYourMaid] 射精ボイスが取得できませんでした");
            return false;
          }
          //ボイスセットを再生 再生されるとvsFlag=2になる
          VoicePlay(maidID, maidState.maid, maidState, vsList);

          Console.WriteLine("[VibeYourMaid] 射精リアクションボイス: "+maidState.playedVoiceName);

          //表情変更
          int iRandom = UnityEngine.Random.Range(0 , cfgw.sFaceAnime30Vibe[3].Length);
          maidState.maid.FaceAnime(cfgw.sFaceAnime30Vibe[3][iRandom] , 0.5f , 0);
          maidsState[maidID].faceHoldTime = cfgw.vStateAltTimeVBase + UnityEngine.Random.Range(0f , cfgw.vStateAltTimeVRandomExtend); //次の表情変更タイマーセット

          return true;
        }

        //脱衣音声再生 0:トップ 1:ボトム 2:ブラ 3:パンツ 4:ずらし 5:ぽろり上
        private void UndressingReaction(int maidID, int pos)
        {
          if (!cfgw.UndressingReaction) return;

          MaidState maidState = maidsState[maidID];
          Maid maid = maidState.maid;

          if (maid.AudioMan.audiosource.isPlaying && !maid.AudioMan.audiosource.loop) return; //ループ以外の音声再生中は再生しない

          //サブヒロインは除外
          if (maid.status.heroineType == MaidStatus.HeroineType.Sub) return;

          int iPersonal = stockMaids[maidID].iPersonal;
          if (iPersonal == -1) return;

          int idx = 3;
          if (pos == 5) idx = 8; //ぽろり → ブラのcurrentExcite200のボイス
          else if (pos <= 4) { //ずらしも対応
            int excite = 3;
            if (maid.status.currentExcite >= 250) excite = 0;
            else if (maid.status.currentExcite >= 150) excite = 1;
            else if (maid.status.currentExcite >= 50) excite = 2;
            idx = 4*pos + excite;
          }
          if (iPersonal < UndressingVoice.Length && idx < UndressingVoice[iPersonal].Length) {
            string voiceFile = UndressingVoice[iPersonal][idx]+".ogg";
            maid.AudioMan.audiosource.time = 0; //先に0に戻す
            maid.AudioMan.LoadPlay(voiceFile, 0f, false, false);
            maidState.orgasmVoice = 2; //ループ音をキャンセルして再生させるため絶頂ボイス扱い
            maidState.zAnimeFileName = maidState.maid.body0.LastAnimeFN; //フェラ判定用モーション保存

            Console.WriteLine("[VibeYourMaid] 脱衣ボイス: "+voiceFile);
          }

          //バイブ停止時は表情変更
          if (maidState.vStateMajor == 10) {
            maidState.vStateMajor = 40; //余韻状態
            ChangeFaceAnime(maidID, maid, maidState);  //表情変更実行
            //ChangeFaceBlend(maidID, maid, maidState);  //フェイスブレンド変更実行
            //ここで戻すと表情はバックアップから戻らない
            maidState.vStateMajor = 10;
          }
        }

        //SE変更処理
        private string seFileBack = "";
        private void ChangeSE(int maidID, MaidState maidState, bool mode)
        {
          int iSE1 = maidState.vLevel;
          //if (osawari.isOsawari(maidID)) {
          int osawariLevel = osawari.getOsawariLevel(maidID);
          //バイブまたはで股間のおさわりの場合のみ
          if (iSE1 < osawariLevel && (iSE1 != 0 || osawari.isOsawari(maidID, "VA_") || osawari.isOsawari(maidID, "AN_"))) iSE1 = osawariLevel;
          //}

          if (iSE1 != 0) {
            bool vibe = false;
            string motion = maidState.maid.body0.LastAnimeFN;
            string seFile = "";

            if (cfgw.SelectSE != 2) {
              seFile = SeFileList[iSE1][cfgw.SelectSE];
            } else {
              seFile = SeFileList[iSE1][1];
              if (maidState.itemV !="" || maidState.itemA != "") vibe = true;
            }

            if (seFile != seFileBack || mode) {
              GameMain.Instance.SoundMgr.StopSe();
              GameMain.Instance.SoundMgr.PlaySe(seFile , true);
              int iSE2 = maidState.vLevel;
              if (vibe && iSE2 > 0) GameMain.Instance.SoundMgr.PlaySe(SeFileList[iSE2][0] , true);
              seFileBack = seFile;
            }

          }
        }



        //サウンド処理関係了-------------------------------





        //-------------------------------------------------
        //モーションファイルの読み込み関係-----------------

        //チェック用モーションリスト変数
        private HashSet<string> MotionList_tati = new HashSet<string>();
        private HashSet<string> MotionList_suwari = new HashSet<string>();
        private HashSet<string> MotionList_zoukin = new HashSet<string>();
        private HashSet<string> MotionList_kyuuzi = new HashSet<string>();
        private HashSet<string> MotionList_fukisouji = new HashSet<string>();
        private HashSet<string> MotionList_mop = new HashSet<string>();
        private HashSet<string> MotionList_vibe = new HashSet<string>();
        
        //パイズリモーションチェック用リスト
        private List<string> MotionList_paizuri;
        private List<string> MotionList_paizuriNone;

        private HashSet<string> allFilesSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);    //検索用
        private HashSet<string> allFilesOldSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase); //検索用
        //有効なモーションアジャストのファイル名(～_f.anm)を格納 選択可能かの存在チェック用
        private HashSet<string> majValidNameSet = new HashSet<string>();

        private List<List<string>> YotogiList = new List<List<string>>();
        private List<List<string>> YotogiListName = new List<List<string>>();
        //private List<string> YotogiListBase = new List<string>();
        private Dictionary<string, List<string>> YotogiListSabun = new Dictionary<string, List<string>>();
        private List<string> YotogiGroup = new List<string>();
        private int YotogiMenu = 0;


        //UNZIP用のモーションリスト作成
        void UnzipMotionLoad()
        {
          //Console.WriteLine("[VibeYourMaid] モーションファイル読み込み開始");
          System.Diagnostics.Stopwatch sw = new System.Diagnostics.Stopwatch();
          sw.Start();

          //全ファイルの中から.anmファイルの抜き出す
          {
          string[] Files = GameUty.FileSystem.GetList("motion", AFileSystemBase.ListType.AllFile);
          for (int i=0; i<Files.Length; i++) {
            string file = Files[i];
            if (file.EndsWith(".anm", StringComparison.Ordinal)) {
              allFilesSet.Add(Path.GetFileNameWithoutExtension(file)); //重複除外
            }
          }
          Files = null;
          }
          {
          string[] FilesOld = GameUty.FileSystemOld.GetList("motion", AFileSystemBase.ListType.AllFile);
          for (int i=0; i<FilesOld.Length; i++) {
            string file = FilesOld[i];
            if (file.EndsWith(".anm", StringComparison.Ordinal)) {
              string motionName = Path.GetFileNameWithoutExtension(file);
              if (!allFilesSet.Contains(motionName)) allFilesOldSet.Add(motionName); //重複除外 Newにあれば追加しない
            }
          }
          FilesOld = null;
          }
          try {
          string[] FilesMod = GameUty.FileSystemMod.GetList("", AFileSystemBase.ListType.AllFile);
          for (int i=0; i<FilesMod.Length; i++) {
            string file = FilesMod[i];
            if (file.EndsWith(".anm", StringComparison.Ordinal)) {
              allFilesSet.Add(Path.GetFileNameWithoutExtension(file)); //重複除外
            }
          }
          FilesMod = null;
          } catch { UnityEngine.Debug.LogError("'Mod' folder not exist"); }

          sw.Stop();
          Console.WriteLine("[VibeYourMaid] モーションファイル読み込み終了 : "+(sw.ElapsedMilliseconds)+"ms");


          //モーションファイル一覧を出力
          if (cfgw.outputMotionList) {
            if (File.Exists(@"Sybaris\UnityInjector\Config\VibeYourMaid\モーションリスト.csv")) {
              Debug.LogError("[VibeYourMaid] MotionList output file already exists :");
              Debug.LogError("[VibeYourMaid]   "+@"Sybaris\UnityInjector\Config\VibeYourMaid\モーションリスト.csv");
            } else {
              //出力前にファイル名でソート
              List<string> allFiles = new List<string>();
              List<string> allFilesOld = new List<string>();
              foreach (string file in allFilesSet) {
                allFiles.Add(file);
              }
              foreach (string file in allFilesOldSet) {
                allFilesOld.Add(file);
              }
              allFiles.Sort();
              allFilesOld.Sort();
              Debug.Log("[VibeYourMaid] モーション一覧出力 : "+@"Sybaris\UnityInjector\Config\VibeYourMaid\モーションリスト.csv , モーションリストOLD.csv");
              foreach (string file in allFiles) {
                File.AppendAllText(@"Sybaris\UnityInjector\Config\VibeYourMaid\モーションリスト.csv", file + Environment.NewLine);
              }
              foreach (string file in allFilesOld) {
                File.AppendAllText(@"Sybaris\UnityInjector\Config\VibeYourMaid\モーションリストOLD.csv", file + Environment.NewLine);
              }
            }
          }


          //読み込んだモーションファイルの中からモーション変更可能なものを抽出
            //Console.WriteLine("[VibeYourMaid] 夜伽リスト抽出開始");
            sw.Reset();
            sw.Start();

            //List<string> ListF = new List<string>();
            //List<string> ListF2 = new List<string>();
            //List<string> ListN = new List<string>();

            List<string> YotogiList0 = new List<string>();
            List<string> YotogiList1 = new List<string>();
            List<string> YotogiList2 = new List<string>();
            List<string> YotogiList3 = new List<string>();
            List<string> YotogiList4 = new List<string>();
            List<string> YotogiList5 = new List<string>();
            List<string> YotogiList6 = new List<string>();
            List<string> YotogiList7 = new List<string>();
            List<string> YotogiList8 = new List<string>();
            List<string> YotogiList9 = new List<string>();
            List<string> YotogiList10 = new List<string>();
            List<string> YotogiList11 = new List<string>();
            List<string> YotogiList12 = new List<string>();

            List<string> YotogiListName0 = new List<string>();
            List<string> YotogiListName1 = new List<string>();
            List<string> YotogiListName2 = new List<string>();
            List<string> YotogiListName3 = new List<string>();
            List<string> YotogiListName4 = new List<string>();
            List<string> YotogiListName5 = new List<string>();
            List<string> YotogiListName6 = new List<string>();
            List<string> YotogiListName7 = new List<string>();
            List<string> YotogiListName8 = new List<string>();
            List<string> YotogiListName9 = new List<string>();
            List<string> YotogiListName10 = new List<string>();
            List<string> YotogiListName11 = new List<string>();
            List<string> YotogiListName12 = new List<string>();

            List<string> _YotogiListSabun = new List<string>(); //一時格納用
            HashSet<string> _YotogiListBase = new HashSet<string>(); //一時格納用

            Regex regExcludeMotion = null;
            if (cfgw.excludeMotion != null && cfgw.excludeMotion != "") regExcludeMotion = new Regex(cfgw.excludeMotion, RegexOptions.Compiled);


            SortedList<string, string> ListNF = new SortedList<string, string>();

            foreach (string file in allFilesSet) {

              if (regExcludeMotion != null && regExcludeMotion.IsMatch(file)) continue; //除外モーション

              if (Regex.IsMatch(file,"_[1234]") && ((Regex.IsMatch(file,@"^[a-zA-Z]_") && !Regex.IsMatch(file,"m_")) || Regex.IsMatch(file,@"[a-zA-Z][0-9][0-9]")) && (file.EndsWith( "_f" ) || file.EndsWith( "_f2" ) || file.EndsWith( "_f3" ))) {

                string basefile = file + ".anm";
                if (!Regex.IsMatch(basefile,"m_")) basefile = Regex.Replace(basefile, @"^[a-zA-Z]_", "");
                basefile = Regex.Replace(basefile, @"[a-zA-Z][0-9][0-9]", "");

                //int i = _YotogiListBase.IndexOf(basefile);
                if (!_YotogiListBase.Contains(basefile)) {
                  _YotogiListBase.Add(basefile);
                  _YotogiListSabun.Add(basefile);
                  _YotogiListSabun.Add(file + ".anm");
                } else {
                  _YotogiListSabun.Add(file + ".anm");
                }
              }

              if (file.Contains( "_1" ) && (!Regex.IsMatch(file,@"^[a-zA-Z]_") || Regex.IsMatch(file,"x_manguri") || Regex.IsMatch(file,"m_") ) && !Regex.IsMatch(file,@"[a-zA-Z][0-9][0-9]") && (file.EndsWith( "_f" ) || file.EndsWith( "_f2" ) || file.EndsWith( "_f3" ))) {
                if (allFilesSet.Contains(file.Replace("_1", "_2")) && allFilesSet.Contains(file.Replace("_1", "_3"))) {
                  if (!majValidNameSet.Contains(file)) majValidNameSet.Add(file);
                  string name = MotionNameChange(file);
                  string hatu = file.Replace("_1", "_hatu_3");
                  if (allFilesSet.Contains(hatu) || allFilesOldSet.Contains(hatu)) name = name + " "+lang.UNZIP_ESTRUS;
                  int mid = maj.motionName.IndexOf(file);
                  if (mid == -1 || maj.hkupa1[mid] == -1) name = "★" + name;
                  if (!ListNF.ContainsKey(name)) ListNF.Add(name, file);
                }
              }
              //数字を含まない単一モーションの素股を追加
              else if (file.Contains( "_sumata_f") || file.Contains( "_sumata_ryoumomi_f")) {
                if (!majValidNameSet.Contains(file)) majValidNameSet.Add(file);
                string name = MotionNameChange(file)+ " "+lang.UNZIP_SINGLE;
                  int mid = maj.motionName.IndexOf(file);
                if (mid == -1 || maj.hkupa1[mid] == -1) name = "★" + name;
                if (!ListNF.ContainsKey(name)) ListNF.Add(name, file);
              }
            }

            foreach (string file in allFilesOldSet) {

              if (regExcludeMotion != null && regExcludeMotion.IsMatch(file)) continue; //除外モーション

              if (Regex.IsMatch(file,"_[1234]") && ((Regex.IsMatch(file,@"^[a-zA-Z]_") && !Regex.IsMatch(file,"m_"))  || Regex.IsMatch(file,@"[a-zA-Z][0-9][0-9]")) && (file.EndsWith( "_f" ) || file.EndsWith( "_f2" ) || file.EndsWith( "_f3" ))) {

                string basefile = file + ".anm";
                if (!Regex.IsMatch(basefile,"m_")) basefile = Regex.Replace(basefile, @"^[a-zA-Z]_", "");
                basefile = Regex.Replace(basefile, @"[a-zA-Z][0-9][0-9]", "");

                //int i = _YotogiListBase.IndexOf(basefile);
                if (!_YotogiListBase.Contains(basefile)) {
                  _YotogiListBase.Add(basefile);
                  _YotogiListSabun.Add(basefile);
                  _YotogiListSabun.Add(file + ".anm");
                } else {
                  _YotogiListSabun.Add(file + ".anm");
                }
              }

              if (file.Contains( "_1" ) && (!Regex.IsMatch(file,@"^[a-zA-Z]_") || Regex.IsMatch(file,"x_manguri") || Regex.IsMatch(file,"m_") ) && !Regex.IsMatch(file,@"[a-zA-Z][0-9][0-9]") && (file.EndsWith( "_f" ) || file.EndsWith( "_f2" ) || file.EndsWith( "_f3" ))) {
                //hatu = file.Replace("_1", "_hatu_3");
                if (allFilesOldSet.Contains(file.Replace("_1", "_2")) && allFilesOldSet.Contains(file.Replace("_1", "_3"))) {
                  if (!majValidNameSet.Contains(file)) majValidNameSet.Add(file);
                  string name = MotionNameChange(file);
                  int mid = maj.motionName.IndexOf(file);
                  if (mid == -1 || maj.hkupa1[mid] == -1) name = "★" + name;
                  if (!ListNF.ContainsKey(name)) ListNF.Add(name, file);
                }
              }
            }

            foreach (KeyValuePair<string, string> kvp in ListNF) {
               string file = kvp.Value;
               string name = kvp.Key;

              if (file.Contains( "ganmenkijyoui" )) {//１１：その他
                YotogiList11.Add(file);
                YotogiListName11.Add(name);
                //Console.WriteLine(file);

              } else if (file.Contains( "yuri" )) {//８：百合
                YotogiList8.Add(file);
                YotogiListName8.Add(name);
                //Console.WriteLine(file);

              } else if (file.Contains( "harem" ) || file.Contains( "wfera" ) || file.Contains( "wasikoki" )) {//９：ハーレム
                YotogiList9.Add(file);
                YotogiListName9.Add(name);
                //Console.WriteLine(file);

              } else if (file.Contains( "ran" ) || file.Contains( "3p_" ) || file.Contains( "6p_" )) {//１０：乱交
                YotogiList10.Add(file);
                YotogiListName10.Add(name);
                //Console.WriteLine(file);

               } else if (file.Contains( "kijyoui_sumata_" ) || file.Contains( "osaetuke_seijyoui_" ) || file.Contains( "manguri_douzi_" )) {//１：挿入 前 (優先)
                YotogiList1.Add(file);
                YotogiListName1.Add(name);
                //Console.WriteLine(file);

              } else if (file.Contains( "kousoku" ) || file.Contains( "mokuba" ) || file.Contains( "harituke" ) || file.Contains( "turusi" ) || file.Contains( "poseizi" ) //７：ＳＭ
                || file.StartsWith( "inu_" ) || file.Contains( "_inu_" ) || file.StartsWith( "m_" ) || file.Contains( "_m_" )) {
                YotogiList7.Add(file);
                YotogiListName7.Add(name);
                //Console.WriteLine(file);

              } else if (file.Contains("fera") || file.Contains("paizuri") || file.Contains("tekoki") || file.Contains("arai") || file.Contains("asiname") || file.Contains("siriname")
                || file.Contains("asikoki") || file.StartsWith("mp2_") || file.StartsWith("self_ir_")) {//６：奉仕
                YotogiList6.Add(file);
                YotogiListName6.Add(name);
                //Console.WriteLine(file);

              } else if (file.Contains( "daijyou" ) || file.Contains( "kyousitu" ) || file.Contains( "atama" ) || file.Contains( "table" ) || file.Contains( "toilet" ) || file.Contains( "sexsofa" )
                || file.Contains( "isutaimenzai" ) ) {//４：台上
                YotogiList4.Add(file);
                YotogiListName4.Add(name);
                //Console.WriteLine(file);

              } else if (file.Contains( "ritui" ) || file.Contains( "tati" ) || file.Contains( "hekimen" ) || file.Contains( "tikan" ) || file.Contains( "ekiben" ) || file.Contains( "poseizi" )) {//３：立ち・壁面
                YotogiList3.Add(file);
                YotogiListName3.Add(name);
                //Console.WriteLine(file);

              } else if (file.Contains( "tinguri" ) || file.Contains( "manguri" )) {//１１：その他 (チングリとまんぐり) ソファと拘束以外
                YotogiList11.Add(file);
                YotogiListName11.Add(name);
                //Console.WriteLine(file);

              } else if (file.Contains( "haimen" ) || file.Contains( "kouhaii" ) || file.Contains( "sokui" ) || file.Contains( "sukebeisu_sex" ) || file.Contains( "kakaemzi" ) || file.Contains( "misetuke" )) {//２：挿入 後
                YotogiList2.Add(file);
                YotogiListName2.Add(name);
                //Console.WriteLine(file);

              } else if (file.Contains( "sex" ) || file.Contains( "manguri" ) || file.Contains( "seijyoui" ) || file.Contains( "kijyoui" ) || file.Contains( "taimenzai" ) || file.Contains( "matuba" ) || file.Contains( "kakaekomizai" )) {//１：挿入 前
                YotogiList1.Add(file);
                YotogiListName1.Add(name);
                //Console.WriteLine(file);

              } else if (file.Contains("sumata")) {//６：奉仕 素股 (他カテゴリ優先)
                YotogiList6.Add(file);
                YotogiListName6.Add(name);
                //Console.WriteLine(file);

              } else if (file.Contains( "onani" )){//５：オナニー (体位のオナニーバリエーションは含めない)
                YotogiList5.Add(file);
                YotogiListName5.Add(name);
                //Console.WriteLine(file);

              } else if ((file.Contains( "aibu" ) && !file.Contains( "seijyoui" )) || file.Contains( "vibe" ) || file.Contains( "kunni" )) {//０：愛撫
                YotogiList0.Add(file);
                YotogiListName0.Add(name);
                //Console.WriteLine(file);

              } else {//１１：その他
                YotogiList11.Add(file);
                YotogiListName11.Add(name);
                //Console.WriteLine(file);

              }

              if (name.Contains( lang.UNZIP_ESTRUS )) {//１２：発情有り
                YotogiList12.Add(file);
                YotogiListName12.Add(name);
              }

              //モーションアジャスト用の初期値設定
              if (!maj.motionName.Contains(file)) {
                maj.motionName.Add(file);
                maj.baceMotion.Add("");
                maj.outMotionFlag.Add(0);
                maj.basicHeight.Add(0f);
                maj.basicForward.Add(0f);
                maj.basicRight.Add(0f);
                maj.basicAngleY.Add(0f);
                maj.submanHeight.Add(0f);
                maj.submanForward.Add(0f);
                maj.submanRight.Add(0f);
                maj.submanAngleY.Add(0f);
                maj.mansHeight.Add(0f);
                maj.mansForward.Add(0f);
                maj.mansRight.Add(0f);
                maj.analEnabled.Add(false);
                maj.analHeight.Add(0f);
                maj.analForward.Add(0f);
                maj.analRight.Add(0f);

                maj.kupaDelay.Add(-1f);
                maj.hkupa1.Add(-1f);
                maj.akupa1.Add(-1f);
                maj.hkupa2.Add(-1f);
                maj.akupa2.Add(-1f);
                maj.mVoiceSet.Add("");
                //maj.iTargetLH.Add(0);
                //maj.iTargetRH.Add(0);

                maj.syaseiMarks.Add(new int[]{0, 0, 0, 0, 0});

                maj.giveSexual.Add(GiveSexualSet(file));

                maj.itemSet.Add(new bool[]{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false});
                maj.prefabSet.Add(0);
                maj.prefabSetX.Add(0);
                maj.prefabSetY.Add(0);
                maj.prefabSetZ.Add(0);
                maj.prefabSetR.Add(0);

                maj.maidToCam.Add(-1);
              }
            }


            YotogiList.Add(YotogiList0);
            YotogiList.Add(YotogiList1);
            YotogiList.Add(YotogiList2);
            YotogiList.Add(YotogiList3);
            YotogiList.Add(YotogiList4);
            YotogiList.Add(YotogiList5);
            YotogiList.Add(YotogiList6);
            YotogiList.Add(YotogiList7);
            YotogiList.Add(YotogiList8);
            YotogiList.Add(YotogiList9);
            YotogiList.Add(YotogiList10);
            YotogiList.Add(YotogiList11);
            YotogiList.Add(YotogiList12);

            YotogiListName.Add(YotogiListName0);
            YotogiListName.Add(YotogiListName1);
            YotogiListName.Add(YotogiListName2);
            YotogiListName.Add(YotogiListName3);
            YotogiListName.Add(YotogiListName4);
            YotogiListName.Add(YotogiListName5);
            YotogiListName.Add(YotogiListName6);
            YotogiListName.Add(YotogiListName7);
            YotogiListName.Add(YotogiListName8);
            YotogiListName.Add(YotogiListName9);
            YotogiListName.Add(YotogiListName10);
            YotogiListName.Add(YotogiListName11);
            YotogiListName.Add(YotogiListName12);

            YotogiGroup.Add(lang.YOTOGI_GROUP_0);  //"愛撫"
            YotogiGroup.Add(lang.YOTOGI_GROUP_1);  //"挿入 前");
            YotogiGroup.Add(lang.YOTOGI_GROUP_2);  //"挿入 後");
            YotogiGroup.Add(lang.YOTOGI_GROUP_3);  //"立ち/壁面");
            YotogiGroup.Add(lang.YOTOGI_GROUP_4);  //"台上");
            YotogiGroup.Add(lang.YOTOGI_GROUP_5);  //"オナニー");
            YotogiGroup.Add(lang.YOTOGI_GROUP_6);  //"奉仕");
            YotogiGroup.Add(lang.YOTOGI_GROUP_7);  //"ＳＭ");
            YotogiGroup.Add(lang.YOTOGI_GROUP_8);  //"百合");
            YotogiGroup.Add(lang.YOTOGI_GROUP_9);  //"ハーレム");
            YotogiGroup.Add(lang.YOTOGI_GROUP_10); //"乱交");
            YotogiGroup.Add(lang.YOTOGI_GROUP_11); //"その他");
            YotogiGroup.Add(lang.YOTOGI_GROUP_12); //"発情有り");
            YotogiGroup.Add(lang.YOTOGI_GROUP_13); //"ランダム");


            //差分ファイル振り分け
            foreach (string file in _YotogiListBase) {
              List<string> list = new List<string>();

              foreach (string sabun in _YotogiListSabun) {

                string basefile = sabun;
                if (!Regex.IsMatch(basefile,"m_")) basefile = Regex.Replace(basefile, @"^[a-zA-Z]_", "");
                basefile = Regex.Replace(basefile, @"[a-zA-Z][0-9][0-9]", "");

                if (file == basefile && !Regex.IsMatch(sabun,"b[0-9][0-9]")) {
                  list.Add(sabun);
                }
              }

              YotogiListSabun.Add(file, list);
            }

            sw.Stop();
            Console.WriteLine("[VibeYourMaid] 夜伽リスト抽出終了 : "+(sw.ElapsedMilliseconds)+"ms");

        }


        //イタズラ用モーションリストの読み込み
        void ItazuraMotionLoad()
        {
          //Console.WriteLine("[VibeYourMaid] イタズラモーションリスト結合開始");

          MotionList_tati.Clear();
          MotionList_suwari.Clear();
          MotionList_zoukin.Clear();
          MotionList_kyuuzi.Clear();
          MotionList_fukisouji.Clear();
          MotionList_mop.Clear();
          MotionList_vibe.Clear();

          string file = @"Sybaris\UnityInjector\Config\VibeYourMaid\MList.txt";
          //ファイルチェック
          FileInfo fileInfo = new FileInfo(file);
          if (!fileInfo.Exists) {
            Debug.LogError("[VibeYourMaid] "+file+" ファイルがありません");
          } else if (fileInfo.Length == 0) {
            Debug.LogError("[VibeYourMaid] "+file+" に設定がありません");
          }

          List<string>[] motionList = ReadListFile(file,
            new string[]{
              "tati_list", "suwari_list", "zoukin_list", "kyuuzi_list", "fukisouji_list", "mop_list", //いたずらモーション 0～5
              "MouseMode_None", "MouseMode_Kiss", "MouseMode_Fera", //口モード 6～8
              "PaizuriMode", "PaizuriMode_None" //パイズリモード 9,10
            });
          foreach (string m in motionList[0]) { MotionList_tati.Add(m); } //立ちモーション
          foreach (string m in motionList[1]) { MotionList_suwari.Add(m); } //座りモーション
          foreach (string m in motionList[2]) { MotionList_zoukin.Add(m); } //雑巾がけモーション
          foreach (string m in motionList[3]) { MotionList_kyuuzi.Add(m); } //給仕モーション
          foreach (string m in motionList[4]) { MotionList_fukisouji.Add(m); } //拭き掃除モーション
          foreach (string m in motionList[5]) { MotionList_mop.Add(m); } //モップ掛けモーション
          #if DEBUG
          Console.WriteLine("立ち : "+string.Join(",", motionList[0].ToArray()));
          Console.WriteLine("座り : "+string.Join(",", motionList[1].ToArray()));
          Console.WriteLine("雑巾 : "+string.Join(",", motionList[2].ToArray()));
          Console.WriteLine("給仕 : "+string.Join(",", motionList[3].ToArray()));
          Console.WriteLine("拭き : "+string.Join(",", motionList[4].ToArray()));
          Console.WriteLine("モップ : "+string.Join(",", motionList[5].ToArray()));
          #endif

          //口モード
          for (int i = 0; i < 3; i++) {
            List<string> list = motionList[i+6];
            if (list.Count() > 0) {
              foreach (string motion in list) {
                //キャッシュに追加
                if (!MouthModeDic.ContainsKey(motion)) MouthModeDic.Add(motion, (byte)i);
              }
              #if DEBUG
              Console.WriteLine("口モード["+i+"] "+string.Join(",", list.ToArray()));
              #endif
            }
          }

          //パイズリモード
          MotionList_paizuri = motionList[9];
          MotionList_paizuriNone = motionList[10];

          //チェック用にイタズラモーションをひとまとめにする
          foreach (string[] x in MotionList20) {
            foreach (string xx in x) {
              MotionList_vibe.Add(xx);
            }
          }
          foreach (string[] x in MotionList30) {
            foreach (string xx in x) {
              MotionList_vibe.Add(xx);
            }
          }
          foreach (string[] x in MotionList40) {
            foreach (string xx in x) {
              MotionList_vibe.Add(xx);
            }
          }
          Console.WriteLine("[VibeYourMaid] イタズラモーションリスト結合終了");
        }

        //派生モーション抽出
        /*public List<string[]> haseiMotionList = new List<string[]>();
        private void HaseiMotionCheck(string motion){
          haseiMotionList.Clear();
          Match match = regZeccyou.Match(motion);
          string kihonMotion = match.Groups[2].Value;

          List<string> files;
          if (MotionOldCheckB(motion)) {
            files = allFiles;
          } else {
            files = allFilesOld;
          }

          foreach (string file in files) {
            if (file.Contains(kihonMotion)) {
              string[] m = new string[] { file, MotionNameChange(file) };
              haseiMotionList.Add(m);
            }
          }
        }*/


        //モーションの日本語名をキャッシュ
        private Dictionary<string, string> motionNameDic = new Dictionary<string, string>();
        private List<string[]> motionNameReplaceList = null;

        //モーション名変換テーブル読み込み
        private void MotionNameReplaceListLoad()
        {
          string file = @"Sybaris\UnityInjector\Config\VibeYourMaid\MotionNameReplace.txt";
          //ファイルチェック
          FileInfo fileInfo = new FileInfo(file);
          if (fileInfo.Exists) {
            Console.WriteLine("MotionNameReplaceListLoad : File Exists="+file);
            motionNameReplaceList = new List<string[]>();
            System.IO.StreamReader sr = new System.IO.StreamReader(file);
            while (sr.Peek() > -1) {
              string line = sr.ReadLine();
              if (!line.StartsWith("#") && line.Contains('\t')) {
                string[] kv = line.Split('\t');
                if (kv[0] != "") {
                  //多重変換されないように文字の間にタブを入れる 置換後にタブだけ削除する
                  char[] c = kv[1].ToCharArray();
                  char[] c2 = new char[c.Length*2+1];
                  c2[0] = '\t'; //1文字目はタブ
                  for (int i=0; i<c.Length; i++) {
                    c2[i*2+1] = c[i];
                    c2[i*2+2] = '\t';
                  }
                  kv[1] = new String(c2);
                  motionNameReplaceList.Add(kv);
                }
              }
            }
          }
        }

        //モーション名の日本語変換
        private string MotionNameChange(string motion)
        {
          //キャッシュに追加済みならその値を返却
          if (motionNameDic.ContainsKey(motion)) return motionNameDic[motion];

          string name = motion;

          //変換ファイルがあればそちらを利用
          if (motionNameReplaceList != null) {
            for (int i=0; i<motionNameReplaceList.Count; i++) {
              name = name.Replace(motionNameReplaceList[i][0], motionNameReplaceList[i][1]);
            }
            name = name.Replace("\t", ""); //タブが間に入っているので除去
          } else {

          //既存の変換
          name = name
          .Replace("itya_fera", "イチャフェラ")
          .Replace("kousokui", "拘束衣").Replace("kaikyaku", "開脚").Replace("mittyaku", "密着").Replace("izirazu", "弄らず").Replace("noridasu", "乗り出す").Replace("humituke", "踏みつけ")
          .Replace("seijyoui", "正常位").Replace("sexsofa", "ソファ").Replace("kyousitu", "教室").Replace("poseizi", "ポーズ維持").Replace("yorisoi", "寄添い").Replace("hizadati", "膝立ち")
          .Replace("hasamikomi", "挟み込み").Replace("ryoutenaburi", "両手").Replace("kakaekomi", "抱え込み").Replace("tetunagi", "手繋ぎ").Replace("ryoumomi", "両揉み")
          .Replace("kijyoui", "騎乗位").Replace("kijoui", "騎乗位").Replace("manguri", "まんぐり").Replace("tinguri", "チングリ").Replace("guriguri", "グリグリ")
          .Replace("pantskoki", "ぱんつコキ").Replace("kouhaii", "後背位").Replace("kubisime", "首絞め").Replace("zikkyou", "実況").Replace("asiname", "足舐め").Replace("paizuri", "パイズリ")
          .Replace("sukebeisu", "スケベ椅子").Replace("udemoti", "腕持ち").Replace("utubuse", "俯せ").Replace("kotikake", "腰掛け").Replace("yotunbai", "四つん這い").Replace("amayakasi", "甘やかし")
          .Replace("siriname", "尻舐め").Replace("siriyubi", "尻指").Replace("umanori", "馬乗り").Replace("harituke", "磔").Replace("nonosiru", "罵り")
          .Replace("baramuti", "バラ鞭")
          .Replace("tekoona", "手コキオナニー").Replace("rosyutu", "露出").Replace("kaiawase", "貝合せ").Replace("osaetuke", "押え付け").Replace("mitumeau", "見合う").Replace("onahokoki", "オナホこき")
          .Replace("yukadon", "床ドン").Replace("maeyubi", "前指").Replace("misetuke", "見せつけ").Replace("onedari", "おねだり").Replace("sixnine", "シックスナイン").Replace("asikoki", "足コキ")
          .Replace("siriage", "尻上げ").Replace("hekimen", "壁面").Replace("daijyou", "台上").Replace("kousoku", "拘束").Replace("kantyogo", "浣腸後")
          .Replace("muri_3p", "無理やり3P").Replace("muri_6p", "無理やり6P")
          //6文字以下
          .Replace("settai", "接待").Replace("turusi", "吊し").Replace("taimen", "対面").Replace("haimen", "背面").Replace("tekoki", "手コキ").Replace("toilet", "トイレ").Replace("tukamu", "掴む")
          .Replace("ekiben", "駅弁").Replace("kasane", "重ね").Replace("ryoute", "両手").Replace("sakate", "逆手").Replace("mokuba", "木馬").Replace("naburu", "嬲る").Replace("matuba", "松葉崩し")
          .Replace("ganmen", "顔面").Replace("omocya", "玩具").Replace("tikubi", "乳首").Replace("sumata", "素股").Replace("bedside", "ベッドサイド").Replace("satuei", "撮影").Replace("kosikake", "腰掛け")
          .Replace("fusagu", "塞ぎ").Replace("hiraki", "開き").Replace("soutou", "双頭").Replace("jyouou", "女王").Replace("hasami", "挟み").Replace("irruma", "イラマ").Replace("tawasi", "タワシ")
          .Replace("ran3p", "乱交3P").Replace("ran4p", "乱交4P")
          .Replace("tikan", "痴漢").Replace("table", "テーブル").Replace("kaiwa", "会話").Replace("ritui", "立位").Replace("dildo", "ディルド").Replace("peace", "ピース").Replace("harem", "ハーレム")
          .Replace("iziri", "弄り").Replace("houti", "放置").Replace("denma", "電マ").Replace("atama", "頭掴み")
          .Replace("onani_ona", "オナニー").Replace("onani2a", "アナルオナニー2").Replace("onania", "アナルオナニー").Replace("onani", "オナニー")
          .Replace("sokui", "側位").Replace("kakae", "抱え").Replace("kunni", "クンニ").Replace("kougo", "交互").Replace("housi", "奉仕").Replace("naziri", "詰り").Replace("otoko", "男")
          .Replace("douzi", "同時").Replace("taiki", "待機")
          .Replace("2ana", "二穴").Replace("yubi", "指").Replace("mune", "胸").Replace("cosi", "腰").Replace("aibu", "愛撫").Replace("vibe", "バイブ").Replace("furo", "風呂").Replace("deep", "ディープ")
          .Replace("fera_dt", "ディープフェラ").Replace("fera", "フェラ").Replace("arai", "洗い").Replace("daki", "抱き").Replace("momi", "揉み").Replace("hibu", "秘部").Replace("hold", "ホールド").Replace("kuti", "くち").Replace("sita", "舌")
          .Replace("yuri", "百合").Replace("kiss", "キス").Replace("osae", "押え").Replace("itya", "イチャ").Replace("name", "舐め").Replace("siri", "尻").Replace("tati", "立ち").Replace("tubo", "壺")
          .Replace("nasi", "無し").Replace("pose", "ポーズ").Replace("onna", "女").Replace("lead", "リード").Replace("kyou", "強").Replace("self", "セルフ").Replace("anal", "アナル")
          .Replace("sofa", "ソファ").Replace("muri", "無理やり").Replace("bote", "腹ボテ")
          .Replace("cli", "クリ").Replace("sex", "SEX").Replace("zai", "座位").Replace("mzi", "M字").Replace("uma", "馬乗").Replace("isu", "椅子").Replace("ude", "腕").Replace("inu", "犬")
          .Replace("iya", "嫌").Replace("oku", "最奥").Replace("ana", "穴").Replace("ubi", "指").Replace("pai", "パイズリ").Replace("bed", "ベッド").Replace("dai", "台").Replace("oou", "覆う")
          .Replace("ir", "イラマ").Replace("gr", "ｸﾞﾗｲﾝﾄﾞ").Replace("mp", "MP").Replace("le", "左").Replace("ri", "右").Replace("wp", "Wピース").Replace("bg", "ブリッジ")
          .Replace("_1_f2", "_女B").Replace("_f2", "_女B").Replace("_1_f3", "_女C").Replace("_f3", "_女C").Replace("_1_f", "").Replace("_f", "").Replace("_m2", "_男B")
          .Replace("x_", "").Replace("om_", "").Replace("m_", "M豚");

          }

          name = name.Replace(".anm", "");

          if (motion.StartsWith("om_")) name = name + " "+lang.UNZIP_NEW;
          if (motion.StartsWith("crc_")) name = name.Replace("crc_", lang.UNZIP_CRC);

          motionNameDic.Add(motion, name);

          return name;
        }


        //モーションアジャスト関係
        private string[][] boneList = new string[][] {
          new string[] { "" , "無し" },
          new string[] { "_IK_muneL" , "左胸" },
          new string[] { "_IK_muneR" , "右胸" },
          new string[] { "_IK_vagina" , "あそこ" },
          new string[] { "_IK_hipL" , "お尻左" },
          new string[] { "_IK_hipR" , "お尻右" },
          new string[] { "_IK_anal" , "アナル" },
        };
        private string[] marksList = new string[] { "指定無し" , "挿入 前" , "挿入 後" , "フェラ" , "手コキ" , "足コキ" , "射精しない" , "アナル 前" , "アナル 後"};
        private string[][] prefabList = new string[][] {
          new string[] {
            "無し", "スケベ椅子", "拘束騎乗位椅子", "椅子拘束台", "ラブソファ",
            "マット", "ギロチン台01", "ギロチン台02", "ディルド＆台", "拘束台",
            "拘束台座H型", "三角木馬", "座位椅子", "足コキ台", "シンプルテーブル", "教室机" },
          new string[] {
            "", "Odogu_Sukebeisu", "Odogu_KousokuKijyouiChair", "Odogu_KousokuKijyouiChair", "Odogu_LoveSofa",
            "Odogu_Mat", "Odogu_Girochin_A", "Odogu_Girochin_B", "Odogu_DildoBox", "Odogu_Kousokudai",
            "Odogu_KousokudaiHgata", "Odogu_Sankakumokuba", "Odogu_Sexisu", "Odogu_ashikokidai", "Odogu_SimpleTable", "Mrc_ClassRoom_desk" }
        };
        private float[] prefabAdjust = new float[] { 0f, 0f, 0f, 0f, 0.0011f, 0f, 0f, 0f, 0.0008f, 0.00105f, 0.00105f, 0.00185f, 0f, 0f, 0f, 0f};

        public MotionAdjust maj = new MotionAdjust();
        /// <summary>
        /// モーションアジャスト設定クラス XML保存用
        /// 種別ごとに配列になっているのは直接編集しにくいので直したい
        /// </summary>
        public class MotionAdjust{
          public MotionAdjust(){
            motionName = new List<string>();
            //iTargetLH = new List<int>();
            //iTargetRH = new List<int>();
            syaseiMarks = new List<int[]>();
            giveSexual = new List<bool[]>();
            itemSet = new List<bool[]>();
            prefabSet = new List<int>();
            prefabSetX = new List<float>();
            prefabSetY = new List<float>();
            prefabSetZ = new List<float>();
            prefabSetR = new List<float>();
            baceMotion = new List<string>();
            outMotionFlag = new List<int>();
            mVoiceSet = new List<string>();
            kupaDelay = new List<float>();
            hkupa1 = new List<float>();
            akupa1 = new List<float>();
            hkupa2 = new List<float>();
            akupa2 = new List<float>();
            basicHeight = new List<float>();
            basicForward = new List<float>();
            basicRight = new List<float>();
            basicAngleY = new List<float>();
            submanHeight = new List<float>();
            submanForward = new List<float>();
            submanRight = new List<float>();
            submanAngleY = new List<float>();
            mansHeight = new List<float>();
            mansForward = new List<float>();
            mansRight = new List<float>();
            analEnabled = new List<bool>();
            analHeight = new List<float>();
            analForward = new List<float>();
            analRight = new List<float>();
            maidToCam = new List<int>();
          }

          public List<string> motionName;
          //public List<int> iTargetLH;
          //public List<int> iTargetRH;
          public List<int[]> syaseiMarks;
          public List<bool[]> giveSexual;
          public List<bool[]> itemSet;
          public List<int> prefabSet;
          public List<float> prefabSetX;
          public List<float> prefabSetY;
          public List<float> prefabSetZ;
          public List<float> prefabSetR;
          public List<string> mVoiceSet;
          public List<string> baceMotion;
          public List<int> outMotionFlag;
          public List<float> kupaDelay;
          public List<float> hkupa1;
          public List<float> akupa1;
          public List<float> hkupa2;
          public List<float> akupa2;
          public List<float> basicHeight;
          public List<float> basicForward;
          public List<float> basicRight;
          public List<float> basicAngleY;
          public List<float> submanHeight;
          public List<float> submanForward;
          public List<float> submanRight;
          public List<float> submanAngleY;
          public List<float> mansHeight;
          public List<float> mansForward;
          public List<float> mansRight;
          public List<bool> analEnabled;
          public List<float> analHeight;
          public List<float> analForward;
          public List<float> analRight;
          public List<int> maidToCam;
        }

        private bool[] GiveSexualSet(string motion) {
          bool[] nb = new bool[]{false, false, false, false, false, false, false, false, false, false};
          string manMotion = Regex.Replace(motion, @"_f\d?$", "_m");
          manMotion = Regex.Replace(manMotion, @"_f\d?_", "_m_");
          if (motion.Contains( "aibu" ) || motion.Contains( "vibe" ) || motion.Contains( "kunni" ) || motion.Contains( "ganmenkijyoui" ) || motion.Contains( "denma" )) {
            nb[0] = true;

          } else if (motion.Contains( "fera" ) || motion.Contains( "paizuri" ) || motion.Contains( "tekoki" ) || motion.Contains( "arai" ) || motion.Contains( "asiname" ) || motion.Contains( "onahokoki" ) || motion.Contains( "pantskoki" ) || motion.Contains( "asikoki" )) {
            int im2 = 1;
            for (int im = 0; im < SubMans.Length; im++) {
              if (allFilesSet.Contains(manMotion) || allFilesOldSet.Contains(manMotion)) {
                nb[im2] = true;

                ++im2;
                manMotion = Regex.Replace(manMotion, @"_m\d?$", "_m" + im2);
                manMotion = Regex.Replace(manMotion, @"_m\d?_", "_m" + im2 + "_");

              } else {
                break;
              }
            }

          } else {
            nb[0] = true;
            int im2 = 1;
            for (int im = 0; im < SubMans.Length; im++) {
              if (allFilesSet.Contains(manMotion) || allFilesOldSet.Contains(manMotion)) {
                nb[im2] = true;

                ++im2;
                manMotion = Regex.Replace(manMotion, @"_m\d?$", "_m" + im2);
                manMotion = Regex.Replace(manMotion, @"_m\d?_", "_m" + im2 + "_");

              } else {
                break;
              }
            }
          }
          nb[9] = true;  //9は初期設定がされているかどうかのフラグ
          return nb;
        }


        private int MotionIdCheck(string motion) {
          motion = motion.Replace(".anm", "");
          motion = Regex.Replace(motion, "_[23](?!ana)(?!p_)(?!vibe)", "_1");
          motion = Regex.Replace(motion, "_hatu_", "_");
          //if (!Regex.IsMatch(motion, "m_")) motion = Regex.Replace(motion, @"^[a-zA-Z]_", "");
          motion = Regex.Replace(motion, @"[a-zA-Z][0-9][0-9]", "");

          return maj.motionName.IndexOf(motion.ToLower());
        }

        //MotionAdjustDo と MotionAdjustPsv でモーション変化させるための特殊モーションを取得してmadeStateに格納
        private void setMotionAdjustMotion(MaidState maidState)
        {
          //ベースモーション取得
          string motion = maj.motionName[maidState.motionID];

          maidState.analMotion = MotionCheckTokusyu(motion, sInAnalMotion); //アナル挿入モーションがあるかチェック
          maidState.motionSissinMove = MotionCheckTokusyu(motion, sMotionSissinMove);   //失神モーションがあるかチェック
          maidState.motionSissinTaiki = MotionCheckTokusyu(motion, sMotionSissinTaiki);
          maidState.senyouTokusyuMotion = MotionCheckTokusyuList(motion, sSenyouTokusyuMotion);  //特殊モーションがあるかチェック
          maidState.syaseiMotion = MotionCheckTokusyu(motion, syaseiMaidMotion); //射精モーションがあるかチェック

          //待機モーション 失神が入っていたら除外
          maidState.taikiMotion = MotionCheckTokusyu(motion, sTaikiMaidMotion).Replace("_sissin_taiki_f", "_taiki_f");

          //抜くモーション 射精後モーション 素股モーション設定  待機モーションは置換
          if (motion.Contains("_sumata_")) {
            maidState.isSumata = true;
            maidState.outMotion = "Non";
            maidState.syaseigoMotion = "Non";
            //挿入モーション 素股なら置換先からinMotion取得
            maidState.inMotion = "Non";
            string sumataInsertedMotion = getSumataInsertedMotion(motion); //素股からの挿入後の通常モーション majになければnull
            if (sumataInsertedMotion != null) {
              maidState.inMotion = MotionCheckTokusyu(sumataInsertedMotion, sInMaidMotion); //素股からの挿入モーション取得 取れなければベースモーションからも取得される
              maidState.insertable = true; //挿入後の通常モーションがある
            }
            //素股モーション 待機時に素股ボタンを表示させるために必要
            maidState.sumataMotion = motion;
            //待機モーション 取得できなければ sumata を除去
            if (maidState.taikiMotion == "Non" || MotionOldCheck(maidState.taikiMotion) == -1) {
              maidState.taikiMotion = maidState.sumataMotion.Replace("_sumata_f", "_taiki_f").Replace("_sumata_1_f", "_taiki_f");
              if (maidState.taikiMotion == maidState.sumataMotion) maidState.taikiMotion = "Non"; //変わっていなければNon
              else if (MotionOldCheck(maidState.taikiMotion) == -1) maidState.taikiMotion = "Non"; //モーションが存在しなければNon
            }
          } else { //素股以外
            maidState.isSumata = false;
            maidState.insertable = true;
            //外だしモーションがあるかチェック
            maidState.outMotion = MotionCheckTokusyu(motion, sOutMaidMotion);
            maidState.syaseigoMotion = getSyaseigoMotion(maidState.motionID, maidState.outMotion); //射精後モーション outMotionから置換
            if (MotionOldCheck(maidState.syaseigoMotion) == -1) maidState.syaseigoMotion = "Non";
            //挿入モーション
            maidState.inMotion = MotionCheckTokusyu(motion, sInMaidMotion);
            //素股モーション  素股の例外設定の逆変換 抜いた後に素股に切り替える
            maidState.sumataMotion = "Non";
            foreach (string[] replace in cfgw.sumataInsertedMotionReplace) {
              //ベースモーションでもチェック
              if (motion == replace[1] || maj.baceMotion[maidState.motionID] == replace[1] || maj.baceMotion[maidState.motionID]+"_1_f" == replace[1]) {
                maidState.sumataMotion = replace[0];
                break;
              }
            }
            if (MotionOldCheck(maidState.sumataMotion) == -1) maidState.sumataMotion = MotionCheckTokusyu(motion, sSumataMaidMotion); //例外がなければ普通に素股モーション取得
          }
          //抜くのボタン表示用フラグ
          maidState.removable = (maidState.inMotion != "Non" || maidState.outMotion != "Non") && (maidState.syaseigoMotion != "Non" || maidState.taikiMotion != "Non");

          if (MotionOldCheck(maidState.taikiMotion) == -1) maidState.taikiMotion = "Non"; //モーションがなければNon

          //抜いた状態チェック用のHashSet更新 lastAnimeFNと比較するので.anmをつける
          maidState.removedMotionFN.Clear();
          maidState.sumataMotionFN.Clear();
          if (maidState.outMotion != "Non") maidState.removedMotionFN.Add(maidState.outMotion + ".anm");
          if (maidState.taikiMotion != "Non") maidState.removedMotionFN.Add(maidState.taikiMotion + ".anm");
          if (maidState.syaseigoMotion != "Non") maidState.removedMotionFN.Add(maidState.syaseigoMotion + ".anm");
          if (maidState.sumataMotion != "Non") {
            maidState.removedMotionFN.Add(maidState.sumataMotion + ".anm");
            maidState.sumataMotionFN.Add(maidState.sumataMotion + ".anm");
            //_sumata_1_fの可変素股
            if (maidState.isSumata && motion.EndsWith("_1_f", StringComparison.Ordinal)) {
              maidState.removedMotionFN.Add(motion.Replace("_1_f", "_2_f") + ".anm");
              maidState.removedMotionFN.Add(motion.Replace("_1_f", "_3_f") + ".anm");
              maidState.sumataMotionFN.Add(motion.Replace("_1_f", "_2_f") + ".anm");
              maidState.sumataMotionFN.Add(motion.Replace("_1_f", "_3_f") + ".anm");
            }
          }

          #if DEBUG
          Debug.Log("  inMotion="+maidState.inMotion);
          Debug.Log("  outMotion="+maidState.outMotion);
          Debug.Log("  syaseiMotion="+maidState.syaseiMotion);
          Debug.Log("  syaseigoMotion="+maidState.syaseigoMotion);
          Debug.Log("  analMotion="+maidState.analMotion);
          Debug.Log("  motionSissinMove="+maidState.motionSissinMove);
          Debug.Log("  motionSissinTaiki="+maidState.motionSissinTaiki);
          Debug.Log("  taikiMotion="+maidState.taikiMotion);
          Debug.Log("  sumataMotion="+maidState.sumataMotion);
          Debug.Log("  senyouTokusyuMotion="+String.Join(",", maidState.senyouTokusyuMotion.ToArray()));
          #endif
        }

        //射精後モーションをoutMotionから置換 なければbaceMotionもチェック
        private string getSyaseigoMotion(int motionID, string outMotion)
        {
            string syaseigoMotion = replaceSyaseigoMotion(outMotion);
            if (MotionOldCheck(syaseigoMotion) != -1) return syaseigoMotion;

            //baceMotionから射精後を取得
            if (maj.baceMotion[motionID] != "") syaseigoMotion = replaceSyaseigoMotion(MotionCheckTokusyu(maj.baceMotion[motionID], sOutMaidMotion));
            if (MotionOldCheck(syaseigoMotion) != -1) return syaseigoMotion;

            //例外置換
            //foreach (string[] replace in cfgw.syaseigoMotionReplace) { syaseigoMotion = syaseigoMotion.Replace(replace[0], replace[1]); }
            //if (MotionOldCheck(syaseigoMotion) != -1) return syaseigoMotion;

            return "Non";
        }
        private string replaceSyaseigoMotion(string outMotion)
        {
            //sixnine_name_shasei_kao_f_once_
            string syaseigoMotion = outMotion.Replace("_once_", "").Replace("_shasei_soto_f", "_shaseigo_soto_f").Replace("_shasei_kao_f", "_shaseigo_kao_f");
            if (MotionOldCheck(syaseigoMotion) == -1) syaseigoMotion = syaseigoMotion.Replace("_shaseigo_soto_f", "_shaseigo_f").Replace("_shaseigo_kao_f", "_shaseigo_f"); //_soto や _kao がない場合
            return syaseigoMotion;
        }

        //素股後に切り替える通常モーション 置換されなかったらnull maj内になければnull
        string getSumataInsertedMotion(string motion)
        {
          //例外置換
          foreach (string[] replace in cfgw.sumataInsertedMotionReplace) {
            if (motion == replace[0]) {
              if (majValidNameSet.Contains(replace[1])) return replace[1];
              break;
            }
          }
          //汎用置換
          string sumataInsertedMotion = motion.Replace("_sumata_f", "_1_f").Replace("_sumata_", "_");
          if (motion == sumataInsertedMotion) return null; //置換されなかった
          if (majValidNameSet.Contains(sumataInsertedMotion)) return sumataInsertedMotion;
          return null;
        }

        //抜いた後のモーションならtrue
        private bool isRemovedMotion(MaidState maidState)
        {
          return maidState.removedMotionFN.Contains(maidState.maid.body0.LastAnimeFN);
        }
        //抜いた後のモーションならtrue
        private bool isSumataMotion(MaidState maidState)
        {
          return maidState.sumataMotionFN.Contains(maidState.maid.body0.LastAnimeFN);
        }
        //モーションアジャスト開始時に呼び出す
        //メイドの位置や設置アイテムを調整する モーションの変更は行わない
        private void MotionAdjustDo(int maidID, string motion, bool item, int mainID)
        {
          Console.WriteLine("MotionAdjustDo( "+maidID+", "+motion+", "+item+", "+mainID+" )");

          motion = motion.ToLower();

          if (motion.EndsWith(".anm", StringComparison.Ordinal)) motion = motion.Replace(".anm", "");

          MaidState maidState = maidsState[maidID];

          //string motionMan = Regex.Replace(motion, @"_f\d?$", "_m");
          //motionMan = Regex.Replace(motionMan, @"_f\d?_", "_m_");
          motion = Regex.Replace(motion, "_[23](?!ana)(?!p_)(?!vibe)", "_1"); //強度
          motion = Regex.Replace(motion, "_hatu_", "_");
          //if (!Regex.IsMatch(motion, "m_")) motion = Regex.Replace(motion, @"^[a-zA-Z]_", "");
          motion = Regex.Replace(motion, @"[a-zA-Z][0-9][0-9]", "");

          //有効なモーションでなければ終了
          if (!majValidNameSet.Contains(motion)) {
            Debug.LogError("MotionAdjustDo invalid motion : "+motion);
            return;
          }

          maidState.motionID = maj.motionName.IndexOf(motion);
          #if DEBUG
          Debug.Log("  maidState.motionID="+maidState.motionID);
          #endif

          int mid = maidState.motionID;
          if (mid < 0) return;

          maidState.baceMotion = maj.baceMotion[mid]; //ベースモーションの指定があれば取得
          //他の派生モーションをmaidStateに設定
          setMotionAdjustMotion(maidState);

          //通常モーションのバックアップはベースモーションに変更
          if (maidState.motionID >= 0) {
            maidState.maidMotionBackup = maj.motionName[maidState.motionID];
          }

          if (!maj.analEnabled[mid]) maidState.analMode = false;

          //射精設定と快感上昇設定を取得する
          maidState.syaseiMarks = maj.syaseiMarks[mid];
          maidState.giveSexual = maj.giveSexual[mid];

          if (!cfgw.majEnabled) return;

          //射精外出し音声をロードしてメイドにセット
          if (!string.IsNullOrEmpty(cfgw.sotodashiVoiceSet) && maidState.sotodashiVoiceSet == null) sotodashiVoiceSetLoad("evs_"+cfgw.sotodashiVoiceSet+".xml", maidID);
          if (!string.IsNullOrEmpty(cfgw.kaodashiVoiceSet) && maidState.kaodashiVoiceSet == null) kaodashiVoiceSetLoad("evs_"+cfgw.kaodashiVoiceSet+".xml", maidID);

          Maid maid = stockMaids[maidID].mem;
          //基準点
          Vector3 baseMaidPos = maid.transform.position - maidState.majPositionBak;
          float baseMaidAngleY = (maid.transform.eulerAngles.y - maidState.majAngleYBak) % 360;

          if (mainID == -1) {
            float majHeight = (maj.basicHeight[mid]) * maid.status.body.height;
            float majForward = (maj.basicForward[mid]) * maid.status.body.height;
            float majRight = (maj.basicRight[mid]) * maid.status.body.height;
            float majAngleY = (maj.basicAngleY[mid]) % 360;

            //基準点の回転前のメインメイドの向きからの移動量
            Vector3 move = Quaternion.Euler(0, baseMaidAngleY, 0) * new Vector3(majRight, majHeight, majForward);
            //メインメイドの位置調整
            maid.transform.position = baseMaidPos + move;
            //メイドを回転
            maid.transform.eulerAngles = new Vector3(maid.transform.eulerAngles.x, baseMaidAngleY + majAngleY, maid.transform.eulerAngles.z);

            //移動量のバックアップを保存
            maidState.majPositionBak = move;
            maidState.majAngleYBak = majAngleY;
          } else {
            //サブメイドの位置調整 回転前の移動量を取得
            setSubMotionPosition(maidID, mainID);
          }
          //胸の稼働有効 アニメーションがある場合は物理無効化
          if (!maid.boMAN) {
            bool useMuneAnime = (CheckPaizuriMode(motion) & 1) == 1;
            setPaizuriEnable(maid, useMuneAnime, useMuneAnime);
          }

          //男の高さと向きをメイドに合わせる
          setManMotionPosition(maidID, -1);
          //男のアイテム装備
          setManMotionItem(maidID);

          //kupa値適用
          if (cfgw.majKupaEnabled) {
            setMajKupaValue(maidID, maid, maidState, mid);
            //kupa変更のため余韻状態にする
            if (maidState.vStateMajor == 10) {
              maidState.vStateMajor = 40;
              maidState.yoinHoldTime = 120f;
            }
          }

          //ボイスセット適用 空欄は変更なし VSXがnullになってエラーになるため
          if (maj.mVoiceSet.Count > mid &&  maj.mVoiceSet[mid] != "") {
            //オリジナルボイスセット設定画面表示中はロードしない
            if (cfgw.configGuiFlag && ConfigFlag != 3) {
              voiceSetLoad("evs_" + maj.mVoiceSet[mid] + ".xml", maidID);
            }
          }

          //メイドのアイテム装備
          if (item) {
            //メイドアイテム
            setMotionItem(maidID);
            //設置アイテム
            addMotionPrefab(maidID, mid);
          }

          //目と顔の向き -1なら変更なし
          if (maj.maidToCam.Count > mid) {
            switch (maj.maidToCam[mid]) {
              case 0: maid.body0.boEyeToCam = false; maid.body0.boHeadToCam = false; break;
              case 1: maid.body0.boEyeToCam = true; maid.body0.boHeadToCam = false; break;
              case 2: maid.body0.boEyeToCam = false; maid.body0.boHeadToCam = true; break;
              case 3: maid.body0.boEyeToCam = true; maid.body0.boHeadToCam = true;  break;
            }
          }

          //IKアタッチ適用
          /*if (SubMans[0].Visible) {
            if (maj.iTargetLH[mid] == 0) {
              SubMans[0].IKTargetToBone("左手", null, "無し", Vector3.zero, IKCtrlData.IKAttachType.Point, false, false, IKCtrlData.IKExecTiming.Normal);
            } else {
              SubMans[0].IKTargetToBone("左手", maid, boneList[maj.iTargetLH[mid]][0], new Vector3(0f, 0f, 0f), IKCtrlData.IKAttachType.Point, false, false, IKCtrlData.IKExecTiming.Normal);
            }
            if (maj.iTargetRH[mid] == 0) {
              SubMans[0].IKTargetToBone("右手", null, "無し", Vector3.zero, IKCtrlData.IKAttachType.Point, false, false, IKCtrlData.IKExecTiming.Normal);
            } else {
              SubMans[0].IKTargetToBone("右手", maid, boneList[maj.iTargetRH[mid]][0], new Vector3(0f, 0f, 0f), IKCtrlData.IKAttachType.Point, false, false, IKCtrlData.IKExecTiming.Normal);
            }
          }*/
          //if (maj.hkupa1[mid] >= 60f) SubMans[0].IKTargetToBone("_IK_chinko1", maid, "_IK_vagina", new Vector3(0f, 0f, 0f), IKCtrlData.IKAttachType.Point, false, false, IKCtrlData.IKExecTiming.Normal);

        }

        //Update内のモーション変更処理内から呼ばれる サブメイドも呼ばれる
        void MotionAdjustPsv(int maidID, Maid maid, MaidState maidState) {

          Console.WriteLine("MotionAdjustPsv( "+maidID+" ) motionID="+maidState.motionID);
          
          string motion = maid.body0.LastAnimeFN.ToLower();
          motion = motion.Replace(".anm", "");
          motion = regZeccyouBackup.Match(motion).Groups[1].Value;  // 「 - Que…」を除く

          motion = Regex.Replace(motion, "_[23](?!ana)(?!p_)(?!vibe)", "_1");
          motion = Regex.Replace(motion, "_hatu_", "_");
          //if (!Regex.IsMatch(motion, "m_")) motion = Regex.Replace(motion, @"^[a-zA-Z]_", "");
          motion = Regex.Replace(motion, @"[a-zA-Z][0-9][0-9]", "");
          /*Match match = regZeccyou.Match(motion);
          motion = match.Groups[2].Value;  //現在モーションファイル名の先頭部分取得
          motion = motion + "_1_f";*/

          //有効なモーションでなければ終了
          if (!majValidNameSet.Contains(motion)) {
            if (motion != "") Debug.LogError("MotionAdjustPsv invalid motion : "+motion);
            return;
          }

          int mid = maj.motionName.IndexOf(motion);
          if (mid < 0 || mid == maidState.motionID) return;  //モーションファイルがマッチしない、もしくは現在と同じなら終了

          maidState.motionID = mid;

          //他の派生モーションをmaidStateに設定
          setMotionAdjustMotion(maidState);

          if (!maj.analEnabled[mid]) maidState.analMode = false;

          //射精設定と快感上昇設定を取得する
          maidState.syaseiMarks = maj.syaseiMarks[mid];
          maidState.giveSexual = maj.giveSexual[mid];

          //kupa値適用
          if (cfgw.majKupaEnabled) {
            setMajKupaValue(maidID, maid, maidState, mid);
          }
        }

        private void setMajKupaValue(int maidID, Maid maid, MaidState maidState, int mid)
        {
          if (!osawari.isOsawari(maidID)) {
            if (!maidState.analMode) {
              if (cfgw.majDefaultKupa1 >= 0) maidState.hibuSlider1Value = maj.hkupa1[mid] >= 0 ? maj.hkupa1[mid] : cfgw.majDefaultKupa1;
              if (cfgw.majDefaultAnal1 >= 0) maidState.analSlider1Value = maj.akupa1[mid] >= 0 ? maj.akupa1[mid] : cfgw.majDefaultAnal1;
              if (cfgw.majDefaultKupa2 >= 0) maidState.hibuSlider2Value =  maj.hkupa2[mid] >= 0 ? maj.hkupa2[mid] : cfgw.majDefaultKupa2;
              if (cfgw.majDefaultAnal2 >= 0) maidState.analSlider2Value = maj.akupa2[mid] >= 0 ? maj.akupa2[mid] : cfgw.majDefaultAnal2;
            } else {
              if (cfgw.majDefaultAnal1 >= 0) if (maj.hkupa1[mid] >= 0) maidState.hibuSlider1Value = maj.akupa1[mid] >= 0 ? maj.akupa1[mid] : cfgw.majDefaultAnal1;
              if (cfgw.majDefaultKupa1 >= 0) maidState.analSlider1Value = Math.Min(100, (maj.hkupa1[mid] >= 0 ? maj.hkupa1[mid] : cfgw.majDefaultKupa1) + cfgw.majAnalModeExtend);
              if (cfgw.majDefaultAnal2 >= 0) if (maj.hkupa2[mid] >= 0) maidState.hibuSlider2Value =  maj.akupa2[mid] >= 0 ? maj.akupa2[mid] : cfgw.majDefaultAnal2;
              if (cfgw.majDefaultKupa2 >= 0) if (maj.akupa2[mid] >= 0) maidState.analSlider2Value = Math.Min(100, (maj.hkupa2[mid] >= 0 ? maj.hkupa2[mid] : cfgw.majDefaultKupa2) + cfgw.majAnalModeExtend);
            }
          }
          if (maid.GetProp(MPN.accvag).strTempFileName == "accVag_VibePink_I_.menu" || maid.GetProp(MPN.handitem).strTempFileName == "HandItemH_SoutouVibe_I_.menu") {
            if (maidState.hibuSlider1Value < 60f) maidState.hibuSlider1Value = 60f;
            if (maidState.hibuSlider2Value < 60f) maidState.hibuSlider2Value = 60f;
          }
          if (maid.GetProp(MPN.accanl).strTempFileName == "accAnl_AnalVibe_I_.menu") {
            if (maidState.analSlider1Value < 30f) maidState.analSlider1Value = 30f;
            if (maidState.analSlider2Value < 30f) maidState.analSlider2Value = 30f;
          }
        }

        //メイドを上下と前後にオフセット移動させる メインメイドなら他も追従させる
        void setBasicMotionPositionOffset(int maidID, Maid maid, float offsetHeight, float offsetForward, float offsetRight, float offsetAngleY)
        {
          int mid = maidsState[maidID].motionID;
          if (mid < 0) return;
          float majHeight = offsetHeight * maid.status.body.height;
          float majForward = offsetForward * maid.status.body.height;
          float majRight = offsetRight * maid.status.body.height;
          float majAngleY = offsetAngleY % 360;

          //基準点の回転前のメインメイドの向きからの移動量
          Vector3 move = Quaternion.Euler(0, maid.transform.eulerAngles.y - maidsState[maidID].majAngleYBak, 0) * new Vector3(majRight, majHeight, majForward);
          //メイドの位置調整
          maid.transform.position += move;
          //メイドの回転
          maid.transform.eulerAngles = new Vector3(maid.transform.eulerAngles.x, (maid.transform.eulerAngles.y + majAngleY) % 360, maid.transform.eulerAngles.z);

          //バックアップを変更
          maidsState[maidID].majPositionBak += move;
          maidsState[maidID].majAngleYBak += majAngleY;

          int subID = maidsState[maidID].motionLinkID; //リンクしているサブメイド
          if (subID > -1) {
            //サブメイドの位置を連動
            int subMid = maidsState[subID].motionID;
            maj.basicHeight[subMid] += offsetHeight;
            maj.basicForward[subMid] += offsetForward;
            maj.basicRight[subMid] += offsetRight;
            //回転の場合は既存のXZも変わる
            if (offsetAngleY != 0) {
              maj.basicAngleY[subMid] += offsetAngleY;
              //メインメイドの位置を原点にサブメイドを回転したときの移動量
              Vector3 xy = Quaternion.Euler(0, offsetAngleY, 0) * new Vector3(maj.basicRight[subMid]-maj.basicRight[mid], 0, maj.basicForward[subMid]-maj.basicForward[mid]);
              maj.basicForward[subMid] = xy.z + maj.basicForward[mid];
              maj.basicRight[subMid] = xy.x + maj.basicRight[mid];
            }
            //位置調整
            setSubMotionPosition(subID, maidID);
            setMotionPrefabPosition(subID, subMid, false);
          }

          for (int im = 0; im < SubMans.Length; im++) {
            if (!isSubManVisible(im) || MansTg[im] != maidID) continue; //対象の男のみ
            //男の位置を連動
            getSubMan(im).transform.position += move;
            //男をメインメイドを起点に回転
            getSubMan(im).transform.RotateAround(maid.transform.position, Vector3.up, majAngleY);
          }

          setMotionPrefabPosition(maidID, mid, false);
        }

        //サブメイドの位置を調整 メインメイドからの相対位置ではなく基準点からの移動量
        //サブメイドにはメインメイドとは別のモーションIDが設定されている → そちらの位置情報は使わずにメインメイドのサブメイド位置情報を利用
        void setSubMotionPosition(int subID, int mainID)
        {
          //サブメイド以外は処理しない
          if (subID == -1 || mainID == -1) return;

          int subMotionID = maidsState[subID].motionID;
          if (subMotionID == -1) return;
          int mainMotionID = maidsState[mainID].motionID; //メインメイドのモーション
          if (mainMotionID == -1) return;

          Maid maid = stockMaids[subID].mem;
          Maid mainMaid = stockMaids[mainID].mem;
          //基準点はメインメイド
          Vector3 baseMaidPos = mainMaid.transform.position - maidsState[mainID].majPositionBak;
          float baseMaidAngleY = (mainMaid.transform.eulerAngles.y - maidsState[mainID].majAngleYBak) % 360;
          //基準点に戻す
          maid.transform.position = baseMaidPos;
          maid.transform.eulerAngles = new Vector3(mainMaid.transform.eulerAngles.x, baseMaidAngleY, mainMaid.transform.eulerAngles.z);

          int sintyou = maid.GetProp(MPN.sintyou).value;
          int mainSintyou = mainMaid.GetProp(MPN.sintyou).value; //メインメイドの身長

          //サブモーションの基本位置を利用
          float majHeight = (maj.basicHeight[subMotionID]) * maid.status.body.height;
          float majForward = (maj.basicForward[subMotionID]) * maid.status.body.height;
          float majRight = (maj.basicRight[subMotionID]) * maid.status.body.height;
          float majAngleY = (maj.basicAngleY[subMotionID]) % 360;
          //基準点からの移動量
          Vector3 move = Quaternion.Euler(0, maid.transform.eulerAngles.y, 0) * new Vector3(majRight, majHeight, majForward);

          //サブメイド回転後の向きに対してサブメイドの身長補正 maj.mansSub～を利用
          Vector3 maidForward = Vector3.Scale(maid.transform.forward, new Vector3(1, 1, 1)).normalized;
          Vector3 maidRight = Vector3.Scale(maid.transform.right, new Vector3(1, 1, 1)).normalized;
          float mansHeight = maj.mansHeight[mainMotionID] * (50 - mainSintyou) - maj.mansHeight[subMotionID] * (50 - sintyou);
          float mansForward = maj.mansForward[mainMotionID] * (50 - mainSintyou) - maj.mansForward[subMotionID] * (50 - sintyou);
          float mansRight = maj.mansRight[mainMotionID] * (50 - mainSintyou) - maj.mansRight[subMotionID] * (50 - sintyou);
          move = move + maidForward * mansForward + maidRight * mansRight;
          move.y += mansHeight;

          //サブメイドに移動量設定
          maid.transform.position += move;
          //サブメイドを回転
          maid.transform.eulerAngles = new Vector3(maid.transform.eulerAngles.x,  maid.transform.eulerAngles.y + majAngleY,  maid.transform.eulerAngles.z);

          //移動量のバックアップを保存
          maidsState[subID].majPositionBak = move;
          maidsState[subID].majAngleYBak = majAngleY;
        }


        //男のモーション設定 メインメイドの位置に合わせてからオフセット maid.status.body.heightには合わせていない
        /// <param name="maidID">メインメイド</param>
        /// <param name="manID">設定対象の男ID -1なら全員</param>
        void setManMotionPosition(int maidID, int manID)
        {
          MaidState maidState = maidsState[maidID];
          int mid = maidState.motionID;
          if (mid < 0) return;

          string motionMan = Regex.Replace(maj.motionName[mid], @"_f\d?$", "_m");
          motionMan = Regex.Replace(motionMan, @"_f\d?_", "_m_");
          if (MotionOldCheck(motionMan) == -1) return;

          Maid maid = stockMaids[maidID].mem;
          int sintyou = maid.GetProp(MPN.sintyou).value;
          Vector3 em = maid.transform.eulerAngles;

          float majAngleY = (maj.basicAngleY[mid] - maidState.majAngleYBak) % 360; //メインメイドの回転オフセット


          for (int im = 0; im < SubMans.Length; im++) {
            if (manID >= 0 && im != manID) continue; //1人だけ処理する場合
            if (!isSubManVisible(im) || MansTg[im] != maidID) continue; //対象メイドのみ
            //Vector3 vm2 = SubMans[im].transform.position;
            //if (Vector3.Distance(vm, vm2) > 1f) continue;

            Vector3 vm = maid.transform.position;
            //通常位置補正
            vm.y += maj.submanHeight[mid];
            vm += Quaternion.Euler(0, em.y, 0) * new Vector3(maj.submanRight[mid], 0, maj.submanForward[mid]); //回転後のメインメイドの向きからの移動量

            //身長位置補正
            Vector3 maidForward = Vector3.Scale(maid.transform.forward, new Vector3(1, 1, 1)).normalized;
            Vector3 maidRight = Vector3.Scale(maid.transform.right, new Vector3(1, 1, 1)).normalized;
            vm.y += maj.mansHeight[mid] * (50 - sintyou);
            vm += maidForward * maj.mansForward[mid] * (50 - sintyou) + maidRight * maj.mansRight[mid] * (50 - sintyou);

            //analモード時の調整
            if (maidState.analMode) {
              vm.y += maj.analHeight[mid];
              vm += maidForward * maj.analForward[mid] + maidRight * maj.analRight[mid];
            }

            //男位置設定
            Maid subMan = getSubMan(im);
            subMan.transform.position = vm;
            //男をメインメイドを起点に回転
            subMan.transform.RotateAround(maid.transform.position, Vector3.up, majAngleY);
            //男を回転 オフセットのみ
            subMan.transform.eulerAngles = new Vector3(em.x, (em.y + maj.submanAngleY[mid]) % 360, em.z);
          }
        }

        void setMotionItem(int maidID)
        {
          int mid = maidsState[maidID].motionID;
          Maid maid = stockMaids[maidID].mem;

          if (cfgw.majItemClear) {
            if (!maj.itemSet[mid][0] && maidsState[maidID].itemV == "") maid.DelProp(MPN.accvag, true);
            if (!maj.itemSet[mid][2] && maidsState[maidID].itemA == "") maid.DelProp(MPN.accanl, true);
            if (!maj.itemSet[mid][1] && !maj.itemSet[mid][3] && !maj.itemSet[mid][4]) maid.DelProp(MPN.handitem, true);
            maid.DelProp(MPN.kousoku_upper, true);
            maid.DelProp(MPN.kousoku_lower, true);
            maid.AllProcPropSeqStart();
          }

          if (maj.itemSet[mid][0]) { //バイブ
            maid.SetProp("accvag" , "accVag_VibePink_I_.menu", 0, true, false);
            maid.body0.SetMask(TBody.SlotID.accVag, true);
          }
          if (maj.itemSet[mid][2]) { //Aバイブ
            maid.SetProp("accanl" , "accAnl_AnalVibe_I_.menu", 0, true, false);
            maid.body0.SetMask(TBody.SlotID.accAnl, true);
          }

          if (maj.itemSet[mid][1]) { //手　バイブ
            maid.SetProp("handitem" , "HandItemR_VibePink_I_.menu", 0, true, false);
            maid.body0.SetMask(TBody.SlotID.HandItemR, true);

          } else if (maj.itemSet[mid][3]) {//手　Aバイブ
            maid.SetProp("handitem" , "HandItemR_AnalVibe_I_.menu", 0, true, false);
            maid.body0.SetMask(TBody.SlotID.HandItemR, true);

          } else if (maj.itemSet[mid][4]) {//双頭バイブ
            //maid.SetProp("handitem" , "HandItemH_SoutouVibe_I_.menu", 0, true, false);
            //maid.body0.SetMask(TBody.SlotID.HandItemR, true);
            maidsState[maidID].sVibeFlag = true;
          }

          if (maj.itemSet[mid][5]) {
            maid.SetProp("kousoku_upper" , "KousokuU_TekaseOne_I_.menu", 0, true, false);
            maid.body0.SetMask(TBody.SlotID.kousoku_upper, true);
          }
          if (maj.itemSet[mid][7]) {
            maid.SetProp("kousoku_upper" , "KousokuU_SMRoom_Haritsuke_I_.menu", 1, true, false);
            maid.body0.SetMask(TBody.SlotID.kousoku_upper, true);
          }
          if (maj.itemSet[mid][6]) {
            maid.SetProp("kousoku_lower" , "KousokuL_AshikaseUp_I_.menu", 0, true, false);
            maid.body0.SetMask(TBody.SlotID.kousoku_lower, true);
          }

          maid.AllProcPropSeqStart();

        }

        void setManMotionItem(int maidID)
        {
          int mid = maidsState[maidID].motionID;
          if (mid < 0) return;
          Maid maid = stockMaids[maidID].mem;
          if (cfgw.majItemClear) {
            for (int im = 0; im < SubMans.Length; im++) {
              if (!isSubManVisible(im) || MansTg[im] != maidID) continue; //対象メイドのみ
              Maid subMan = getSubMan(im);
              subMan.DelProp(MPN.handitem, true);
              subMan.AllProcPropSeqStart();
            }
          }

          //男の高さと向きをメイドに合わせる
          int im2 = 1;
          for (int im = 0; im < SubMans.Length; im++) {
            if (!isSubManVisible(im) || MansTg[im] != maidID) continue; //対象メイドのみ
            //男のアイテム装備
            if (im2 == 1) {
              Maid subMan = getSubMan(im);
              if (maj.itemSet[mid][10]) { //手　バイブ
                subMan.SetProp("handitem" , "HandItemR_VibePink_I_.menu", 0, true, false);
              } else if (maj.itemSet[mid][11]) {//手　Aバイブ
                subMan.SetProp("handitem" , "HandItemR_AnalVibe_I_.menu", 0, true, false);
              } else if (maj.itemSet[mid][12]) {//電マ
                subMan.SetProp("handitem" , "HandItemR_Denma_I_.menu", 0, true, false);
              }
              subMan.AllProcPropSeqStart();
            }
            if (im2 == 2) {
              Maid subMan = getSubMan(im);
              if (maj.itemSet[mid][15]) { //手　バイブ
                subMan.SetProp("handitem" , "HandItemR_VibePink_I_.menu", 0, true, false);
              } else if (maj.itemSet[mid][16]) {//手　Aバイブ
                subMan.SetProp("handitem" , "HandItemR_AnalVibe_I_.menu", 0, true, false);
              } else if (maj.itemSet[mid][17]) {//電マ
                subMan.SetProp("handitem" , "HandItemR_Denma_I_.menu", 0, true, false);
              }
              subMan.AllProcPropSeqStart();
            }

            ++im2;
            //motionMan = Regex.Replace(motionMan, @"_m\d?$", "_m" + im2);
            //motionMan = Regex.Replace(motionMan, @"_m\d?_", "_m" + im2 + "_");
          }
        }

        void addMotionPrefab(int maidID, int mid)
        {
          setMotionPrefabPosition(maidID, mid, true);
        }

        void setMotionPrefabPosition(int maidID, int mid, bool add)
        {
            Maid maid = stockMaids[maidID].mem;
            for (int si = 1; si < prefabList[0].Length; si++) {
              if (si == maj.prefabSet[mid]) {
                GameObject obj = GameMain.Instance.BgMgr.GetPrefabFromBg(prefabList[0][si] + maidID);
                if (add && !obj) { //追加されていない場合だけ追加
                  GameMain.Instance.BgMgr.AddPrefabToBg(prefabList[1][si], prefabList[0][si]+maidID, null, Vector3.zero, Vector3.zero);
                  obj = GameMain.Instance.BgMgr.GetPrefabFromBg(prefabList[0][si] + maidID);
                }
                if (obj) {
                  Vector3 zero = maid.transform.position;
                  float zeroOffsetY = 0;
                  if (cfgw.majPrefabOffset.Length > si) zeroOffsetY = cfgw.majPrefabOffset[si];
                  float adjust = 0;
                  if (prefabAdjust.Length > si) adjust = prefabAdjust[si];
                  zero.y = zero.y - (adjust * (50 - maid.GetProp(MPN.sintyou).value)) + zeroOffsetY;
                  Vector3 zero2 = maid.transform.eulerAngles;
                  zero2.x = -90f;
                  //オフセット+メイド回転 回転の影響でYとZは逆
                  Vector3 offset = Quaternion.Euler(zero2) * new Vector3(maj.prefabSetX[mid], maj.prefabSetZ[mid], maj.prefabSetY[mid]);
                  //位置変更
                  obj.transform.position = zero + offset;
                  obj.transform.rotation = Quaternion.Euler(zero2.x, zero2.y+maj.prefabSetR[mid], zero2.z);
                }
              } else {
                if (add) GameMain.Instance.BgMgr.DelPrefabFromBg(prefabList[0][si]+maidID);
              }
            }
        }

        //モーションファイルの読み込み関係終了-----------------





        //-------------------------------------------------
        //モーションチェンジ関係---------------------------

        private Regex regZeccyou = new Regex(@"^([jtk]_)?(.*)_[1234].*", RegexOptions.Compiled);  // モーション名から基本となる部分を取り出す（不安）
        private Regex regZeccyouBackup = new Regex(@"^(.*\.anm).*", RegexOptions.Compiled);  // たまにモーション名の後についてる「 - Queほにゃらら」を除く（適当）

        private string[] sZeccyouMaidMotion1 = new string[] { "_ryouhou_zeccyou_f_once_", "zeccyou_ryouhou_f_once_", "_seikantaizeccyou_f_once_", "_zeccyou_f_once_", "_shasei_kuti_f_once_", "_shasei_naka_f_once_", "_shasei_kao_f_once_", "_shasei_soto_f_once_" };
        private string[] sZeccyouMaidMotion2 = new string[] { "_shasei_kuti_f_once_", "_shasei_naka_f_once_", "_shasei_kao_f_once_", "_shasei_soto_f_once_", "_seikantaizeccyou_f_once_", "_zeccyou_f_once_" };
        private string[] syaseiMaidMotion = new string[] { "_shasei_kuti_f_once_", "_shasei_naka_f_once_", "_shasei_kao_f_once_", "_shasei_soto_f_once_" };
        private string[] sInMaidMotion = new string[] { "_in_f_once_" };
        private string[] sInAnalMotion = new string[] { "a_in_m_once_" };
        private string[] sOutMaidMotion = new string[] { "_shasei_kao_f_once_", "_shasei_soto_f_once_" };
        private string[] sShaseigoMaidMotion = new string[] { "_shaseigo_kao_f", "_shaseigo_soto_f" };
        private string[] sSumataMaidMotion  = new string[] { "_sumata_f", "_sumata_1_f" };
        private string[] sTaikiMaidMotion  = new string[] { "_taiki_f" };
        private string[] sMotionSissinMove   = new string[] { "_sissin_f", "_sissin_1_f", "_sissin_2_f" };
        private string[] sMotionSissinTaiki  = new string[] { "_sissin_taiki_f" };
        private string[] sHighExciteMaidMotion = new string[] { "_3_f", "_3a01_f", "_3b01_f", "_3b02_f" };
        private string[] sSenyouTokusyuMotion = new string[] {
					"3_down1_f", "3_down2_f",
					"_aibu_f", "_anal_f", "_cli_f", "_dk_f", "_dt_f", "_3_down1_f", "_3_down2_f", "_fukujyuu_f", "_fseme_f", "_gaman_f", "_ganmenkijyoui_f", "_gikotinai_f", "_gr_f", "_gr2_f", "_gr_momi_f",
					"_hagesiku_f", "_hentaipose_f", "_hibuhiroge_f", "_hibu_f", "_hibuhiraki_1_f", "_hiroge_f","_hounyou_f_once_", "_humituke_f",
					"_in_mae_aibu_f", "_izirase_f",
					"_kansou_f", "_kataosi_f", "_kakusu_taiki_f", "_kitou_f", "_kiss_f", "_kosurituke_f", "_kousoku_f", "_kougo_f", "_kunne_f", "_kunni_f", "_kusuguri_f", "_kuti_f","_kutihusagi_f", "_kutuname_f", "_kuwae_f", "_kuwaezu_f",
					"_mae_aibu_f", "_miage_1_kiss_f", "_miage_1_sentan_f", "_miccyaku_f", "_mitumeau_f", "_misetuke_f", "_momi_f", "_momikiss_1_f", "_momi_mune_f", "_momo_name_f", "_momi_siri_f", "_mseme_f", "_mseme2_f", "_munesirimomi_f", "_muti_hibu_f_once_", "_muti_mune_f_once_", "_mzi_f",
					"_nade_f", "_nade_1_f", "_name_f", "_name_ura_f", "_nazirare_f", "_nigirase_f", "_nodo_f", "_nodo_tome_f", "_nomasu_f_once_", "_nonosiru_f",
					"_oku_f", "_okuseme_f", "_onani_f", "_onani_syutyu_f", "_onedari_f",
					"_pose_f", "_pose01_f", "_pose02_f", "_pose03_f", "_pose04_f", "_pose05_f", "_pose06_f",
					"_ranbou_f", "_rou_hibu_f_once_", "_rou_mune_f_once_", "_rou_senaka_f_once_", "_rou_siri_f_once_", "_ryouasi_f", "_ryoute_f", "_ryoumomi_f",
					"_sakasaarai_f", "_sasayaku_f", "_seki_1_f_once_", "_sentan_f", "_siri_f", "_sirikoki_f", "_sirinade_f", "_siriyubi_f", "_siri_name_f", "_siri_nade_f", "_siri_seme_f", "_siriana_nade_f", "_suihei_f", "_sumata_f", "_surituke_f", "_shaseigo_naka_hounyou_f_once_", "_syutyu_f",
					"_taiki_kaisi_f", "_taiki_ikou_f_once_", "_taiki_kaisi_ikou_f_once_", "_tama_f", "_tamaizirifera_f", /*"_tataki_f_once_", "_tataki_hoho_f_once_", "_tataki_mune_f_once_", */"_tataki_siri_f_once_", "_tataki_siri_1_f_once_", "_tawasi_f", "_tati_f", "_tati_fumi_f", "_tekoki_f", "_teman_low_f", "_teman_high_f", "_tikubi_f", "_tintin_f", "_tintinpose_f", "_tubo_f", "_tuboarai_f",
					"_udemoti_f", "_uraname_f",
					"_vibe_kuwae_f", "_vibe_kuwaezu_f", "_in_hibumise_f_once_", "_in_hibumise_modori_f_once_",
					"_zeccyou_gaman_f", "_zikkyou_f", "_zirasu_f","_zirasi_taiki_f", "_zirasi_surituke_f", "_zirasi_surituke_in_f_once_",
					};

        //　バイブ弱時のモーションリスト
        private string[][] MotionList20 = new string[][] {
          new string[] { "rosyutu_omocya_1_f.anm" , "rosyutu_tati_vibe_onani_1_f.anm" }, //立ち
          new string[] { "settai_vibe_in_kaiwa_jaku_a01_f.anm" , "settai_vibe_in_kaiwa_jaku_f.anm" }, //椅子座り
          new string[] { "soji_zoukin_vibe.anm" }, //雑巾
          new string[] { "work_kyuuzi_vibe_b01.anm" , "work_kyuuzi_vibe_b02.anm" }, //給仕
          new string[] { "fukisouji1_vibe.anm" }, //拭き掃除
          new string[] { "soji_mop_vibe.anm" }, //モップ
          new string[] { "tati_kiss_loop_f.anm" }, //立ちキス
          new string[] { "k_aibu_kiss_2_f.anm" } //椅子座りキス
        };

        //　バイブ強時のモーションリスト
        private string[][] MotionList30 = new string[][] {
          new string[] { "rosyutu_omocya_2_f.anm" , "rosyutu_omocya_3_f.anm" , "rosyutu_tati_vibe_onani_2_f.anm" }, //立ち
          new string[] { "settai_vibe_in_kaiwa_kyou_a01_f.anm" , "settai_vibe_in_kaiwa_kyou_f.anm" }, //椅子座り
          new string[] { "soji_zoukin_vibe_a01.anm" }, //雑巾
          new string[] { "work_kyuuzi_vibe_a01.anm" }, //給仕
          new string[] { "fukisouji1_vibe_a01.anm" }, //拭き掃除
          new string[] { "soji_mop_vibe_a01.anm" }, //モップ
          new string[] { "tati_kiss_loop_f.anm" }, //立ちキス
          new string[] { "k_aibu_kiss_3_f.anm" } //椅子座りキス
        };

        //　バイブ停止時のモーションリスト
        private string[][] MotionList40 = new string[][] {
          new string[] { "rosyutu_omocya_taiki_f.anm" }, //立ち
          new string[] { "settai_vibe_in_taiki_f.anm" },  //椅子座り
          new string[] { "maid_orz.anm" }, //雑巾
          new string[] { "work_kyuuzi_vibe.anm" }, //給仕
          new string[] { "fukisouji1_vibe.anm" }, //拭き掃除
          new string[] { "soji_mop_vibe.anm" }, //モップ
          new string[] { "tati_kiss_taiki_f.anm" }, //立ちキス
          new string[] { "k_aibu_kiss_1_f.anm" } //椅子座りキス
        };

        Regex regSubMaidMotion = new Regex("(harem|yuri|wfera|wasikoki)", RegexOptions.Compiled);

        private string MotionCheckTokusyu(string motion, string[] list) {

          string t = motion;
          Match match = regZeccyou.Match(t);

          //現在モーションファイル名の先頭部分取得
          t = match.Groups[2].Value;

          //特殊モーションのファイル名が有るかどうかチェック
          string checkMotion = "";

          //Console.WriteLine("モーションチェック：" + motion);

          bool bSubMaidMotion = regSubMaidMotion.IsMatch(motion);

          int motionIdx = 0;
          if (motion.Contains( "_f_" ) || motion.EndsWith( "_f" )) motionIdx = 1;
          else if (motion.Contains( "_f2_" ) || motion.EndsWith( "_f2" )) motionIdx = 2;
          else if (motion.Contains( "_f3_" ) || motion.EndsWith( "_f3" )) motionIdx = 3;        

          foreach (string m in list) {
            checkMotion = t + m;
            if (bSubMaidMotion) {
              if (motionIdx == 1){
                checkMotion = t + m;
              } else if (motionIdx == 2) {
                checkMotion = t + m.Replace("_f_", "_f2_");
                checkMotion = Regex.Replace(checkMotion, "_f$", "_f2");
              } else if (motionIdx == 3) {
                checkMotion = t + m.Replace("_f_", "_f3_");
                checkMotion = Regex.Replace(checkMotion, "_f$", "_f3");
              }
            }

            if (MotionOldCheck(checkMotion) != -1) {
              #if DEBUG
              Debug.Log("MotionCheckTokusyu("+motion+") t="+t+" 【有り】" + checkMotion);
              #endif
              return checkMotion;
            }
            #if DEBUG
            Debug.Log("MotionCheckTokusyu("+motion+") t="+t+" 【無し】" + checkMotion);
            #endif
          }

          //上記チェックで引っかからなかった場合、「cli」や「kiss」などの文字列を除去してもう一度チェック
          string motion2 = "";
          int mid = MotionIdCheck(motion);
          if (mid != -1) motion2 = maj.baceMotion[mid];

          if (motion2 == "") {
            //t = t.Replace("_hibu", "").Replace("_kiss", "").Replace("_cli", "").Replace("_momi", "").Replace("_gr", "").Replace("_kuti", "").Replace("_kuti", "").Replace("_kuti", "").Replace("_kuti", "");
            t = Regex.Replace(t, @"_[^_]{1,}$", ""); //モーション名の最後尾の一節を削除
          } else {
            t = Regex.Replace(motion2, "_1_f$", ""); // 末尾の _1_f は除去
          }
          foreach (string m in list) {
            checkMotion = t + m;
            if (bSubMaidMotion) {
              if (motionIdx == 1){
                checkMotion = t + m;
              } else if (motionIdx == 2) {
                checkMotion = t + m.Replace("_f_", "_f2_");
                checkMotion = Regex.Replace(checkMotion, "_f$", "_f2");
              } else if (motionIdx == 3) {
                checkMotion = t + m.Replace("_f_", "_f3_");
                checkMotion = Regex.Replace(checkMotion, "_f$", "_f3");
              }
            }

            if (MotionOldCheck(checkMotion) != -1) {
              #if DEBUG
              Debug.Log("MotionCheckTokusyu("+motion+") t="+t+" 【有り】" + checkMotion);
              #endif
              return checkMotion;
            }
            #if DEBUG
            Debug.Log("MotionCheckTokusyu("+motion+") t="+t+" 【無し】" + checkMotion);
            #endif
          }

          return "Non";
        }


        private List<string> MotionCheckTokusyuList(string motion, string[] list) {

          string t = motion;
          Match match = regZeccyou.Match(t);

          //現在モーションファイル名の先頭部分取得
          t = match.Groups[2].Value;

          //特殊モーションのファイル名が有るかどうかチェック
          bool check = false;
          string checkMotion = "";
          List<string> motionList = new List<string>();

          //Console.WriteLine("モーションチェック：" + motion);

          int motionIdx = 0;
          if (motion.Contains( "_f_" ) || motion.EndsWith( "_f" )) motionIdx = 1;
          else if (motion.Contains( "_f2_" ) || motion.EndsWith( "_f2" )) motionIdx = 2;
          else if (motion.Contains( "_f3_" ) || motion.EndsWith( "_f3" )) motionIdx = 3;        

          foreach (string m in list) {
            checkMotion = t + m;
            if (regSubMaidMotion.IsMatch(motion)) {
              if (motionIdx == 1) {
                checkMotion = t + m;
                //Console.WriteLine("【f1】:" + checkMotion);

              } else if (motionIdx == 2) {
                checkMotion = t + m.Replace("_f_", "_f2_");
                checkMotion = Regex.Replace(checkMotion, "_f$", "_f2");
              } else if (motionIdx == 3) {
                checkMotion = t + m.Replace("_f_", "_f3_");
                checkMotion = Regex.Replace(checkMotion, "_f$", "_f3");
              }
            }

            if (MotionOldCheck(checkMotion) != -1) {
              check = true;
              motionList.Add(checkMotion);
            }
          }

          //上記チェックで引っかからなかった場合、「cli」や「kiss」などの文字列を除去してもう一度チェック
          if (!check) {
            string motion2 = "";
            int mid = MotionIdCheck(motion);
            if (mid != -1) motion2 = maj.baceMotion[mid];

            if (motion2 == "") {
              t = Regex.Replace(t, @"_[^_]{1,}$", ""); //モーション名の最後尾の一節を削除
            } else {
              t = Regex.Replace(motion2, "_1_f$", ""); // 末尾の _1_f は除去
            }
            foreach (string m in list) {
              checkMotion = t + m;
              if (regSubMaidMotion.IsMatch(motion)) {
                if (motion.Contains("_f.") || motion.EndsWith( "_f" )){
                  checkMotion = t + m;

                } else if (motion.Contains("_f2.") || motion.EndsWith( "_f2" )) {
                  checkMotion = t + m.Replace("_f_", "_f2_");
                  checkMotion = Regex.Replace(checkMotion, "_f$", "_f2");
                } else if (motion.Contains("_f3.") || motion.EndsWith( "_f3" )) {
                  checkMotion = t + m.Replace("_f", "_f3").Replace("_f_", "_f3_");
                  checkMotion = Regex.Replace(checkMotion, "_f$", "_f3");
                }
              }

              if (MotionOldCheck(checkMotion) != -1) {
                check = true;
                motionList.Add(checkMotion);
              }
            }
          }

          return motionList;
        }


        //メイドのモーション変更（通常時） メインメイドの変更タイミングでサブメイトと男をまとめて変更
        // abs: falseなら前のモーション後に再生
        private void MaidMotionChange(int maidID, Maid maid, MaidState maidState, float fade, bool abs) {

          #if DEBUG
          Debug.Log("MaidMotionChange("+maidID+") motionID="+maidState.motionID+" LastAnimeFN="+maid.body0.LastAnimeFN);
          #endif

          //モーションがリンクしているサブメイドならスキップ
          if (isSubMotionMaid(maidState)) return;

          float cs = fade;
          float ls = 1f;
          if (maidState.vStateMajor == 10 && maidState.vStateMajorOld == 50) cs = 1f;

          //現在のモーションを取得
          string motionFN = maid.body0.LastAnimeFN;
          motionFN = regZeccyouBackup.Match(motionFN).Groups[1].Value;  // 「 - Que…」を除く
          if (Regex.IsMatch(motionFN, "_sissin")) motionFN = maj.motionName[maidState.motionID] + "_1_f.anm"; //失神モーションから遷移させる場合は、基本モーションを取得する

          //モーションカテゴリのチェック
          int check = -1;
          //UUNZIP中は10のみチェック → maidMotionBackup が設定されてしまうため  おさわり中は変更モーションもチェック
          if (maidState.motionID != -1 && osawari.isOsawari(maidID)) {
            if (Regex.IsMatch(motionFN, "_[123]")) check = 10; //変更可能な夜伽モーションの場合
            else return;
          } else {
            check = MaidMotionCheck(maidID, maidState, motionFN);
            if (check == -1) return;
          }

          //変更モーションに変換
          motionFN = MaidMotionSelect(motionFN, check, maidID, maidState);

          //モーションが同じ場合は変更しない
          if (maid.body0.LastAnimeFN == motionFN) return;

          //実際にモーションを変更
          string motion = motionFN.Replace(".anm", ""); //.anmを削除
          bool bNew = MotionOldCheck(motion) == 1;
          if (abs) MotionChange(maid, motion, true, bNew, cs, ls);
          else MotionChangeAf(maid, motion, true, bNew, cs, ls);
          //男のモーションを変更
          ManMotionChange(motion, maidID, true, bNew, abs, cs, ls);

          //UNZIPでリンクしているサブメイドのモーションを変更
          if (maidState.motionLinkID != -1) {
            SubMotionChange(maidID, motion, null, true, cs, ls);
          }
        }

        //UNZIPのサブメイドならtrue リンクしているメイドがメインメイドならfalse
        private bool isSubMotionMaid(MaidState maidState)
        {
          if (maidState.motionLinkID == -1) return false;
          //１人目のモーションでない
          string baseMotion = maj.motionName[maidState.motionID];
          if (!baseMotion.EndsWith("_f")) {
            string linkMotion = maj.motionName[maidsState[maidState.motionLinkID].motionID];
            if (linkMotion.EndsWith("_f")) return true; //リンク先が１人目のモーション
            if (baseMotion.Substring(baseMotion.Length-3).CompareTo(linkMotion.Substring(linkMotion.Length-3)) > 0) return true; //リンク先より数字が大きい
          }
          return false;
        }



        //モーションカテゴリのチェック 口のチェックとおさわり制限も行う
        private int MaidMotionCheck(int maidID, MaidState maidState, string motion) {

          int check = -1;

          if (MotionList_tati.Contains(motion)) { //立ちモーションの場合
            if (osawari.getOsawariLevel(maidID) < cfgw.osawariGamanLevel && osawari.isOsawari(maidID)) return -1; //おさわり制限
            check = 0;
            if (osawari.isOsawari(maidID, "MO_") ? true : maidState.cameraCheck) check = 6; //口モード

          } else if (MotionList_suwari.Contains(motion)) { //座りモーションの場合
            if (osawari.getOsawariLevel(maidID) < cfgw.osawariGamanLevel && osawari.isOsawari(maidID)) return -1; //おさわり制限
            check = 1;
            if (osawari.isOsawari(maidID, "MO_") ? true : maidState.cameraCheck) check = 7; //口モード

          } else if (MotionList_zoukin.Contains(motion)) { //雑巾がけモーションの場合
            if (osawari.getOsawariLevel(maidID) < cfgw.osawariGamanLevel && osawari.isOsawari(maidID)) return -1; //おさわり制限
            check = 2;

          } else if (MotionList_kyuuzi.Contains(motion)) { //給仕モーションの場合
            if (osawari.getOsawariLevel(maidID) < cfgw.osawariGamanLevel && osawari.isOsawari(maidID)) return -1; //おさわり制限
            check = 3;

          } else if (MotionList_fukisouji.Contains(motion)) { //拭き掃除モーションの場合
            if (osawari.getOsawariLevel(maidID) < cfgw.osawariGamanLevel && osawari.isOsawari(maidID)) return -1; //おさわり制限
            check = 4;

          } else if (MotionList_mop.Contains(motion)) { //モップ掛けモーションの場合
            if (osawari.getOsawariLevel(maidID) < cfgw.osawariGamanLevel && osawari.isOsawari(maidID)) return -1; //おさわり制限
            check = 5;

          } else if (Regex.IsMatch(motion, "_[123]")) { //変更可能な夜伽モーションの場合
            check = 10;

          } else {
            check = -1;

          }

          return check;
        }



        //通常時の変更モーションを調べて返す
        private string MaidMotionSelect(string motion, int check, int maidID, MaidState maidState) {
          #if DEBUG
          Debug.Log("  MaidMotionSelect("+motion+", "+check+", "+maidID+")");
          #endif

          string t = motion;

          if (maidState.stunFlag && maidState.motionSissinMove != "Non") { //失神している場合は失神モーションに変更
            if (maidState.vStateMajor == 40 || maidState.vStateMajor == 10) {
              t = maidState.motionSissinTaiki + ".anm";
            } else {
              t = maidState.motionSissinMove + ".anm";
            }

          } else if (check == 10) {

            //一段階目のモーションをバックアップとして取る UNZIP中はMotionAdjustDoで設定済み
            if (maidState.motionID == -1) {
              string motionBack = Regex.Replace(t, "_[123](?!ana)(?!p_)(?!vibe)", "_1");
              motionBack = Regex.Replace(motionBack, "_hatu_", "_");
              if (!Regex.IsMatch(t, "m_")) motionBack = Regex.Replace(motionBack, @"^[a-zA-Z]_", "");
              maidState.maidMotionBackup = Regex.Replace(motionBack, @"[a-zA-Z][0-9][0-9]", "");
            }

            //バイブ強度に合わせてモーション名を変換
            if (maidState.vStateMajor == 20) {
              t = Regex.Replace(t, "_[13](?!ana)(?!p_)(?!vibe)", "_2");
              t = Regex.Replace(t, "_hatu_", "_");
              if (!Regex.IsMatch(t, "m_")) t = Regex.Replace(t, @"^[a-zA-Z]_", "");
              t = Regex.Replace(t, @"[a-zA-Z][0-9][0-9]", "");

            } else if (maidState.vStateMajor == 30) {
              if (maidState.orgasmCmb <= 3) {
                t = Regex.Replace(t, "_[12](?!ana)(?!p_)(?!vibe)", "_3");
                t = Regex.Replace(t, "_hatu_3", "_3");
              } else {
                t = Regex.Replace(t, "_[12](?!ana)(?!p_)(?!vibe)", "_3");
              }
              if (!Regex.IsMatch(t, "m_")) t = Regex.Replace(t, @"^[a-zA-Z]_", "");
              t = Regex.Replace(t, @"[a-zA-Z][0-9][0-9]", "");

            } else if (maidState.vStateMajor == 40 || maidState.vStateMajor == 10) {
              t = Regex.Replace(t, "_[23](?!ana)(?!p_)(?!vibe)", "_1");
              t = Regex.Replace(t, "_hatu_", "_");
              if (!Regex.IsMatch(t, "m_")) t = Regex.Replace(t, @"^[a-zA-Z]_", "");
              t = Regex.Replace(t, @"[a-zA-Z][0-9][0-9]", "");
            }

            //差分モーションが有るかどうかチェック
            if (!regSubMaidMotion.IsMatch(motion)) {
              //int i = YotogiListBase.IndexOf(t.ToLower());
              //if (i >= 0) {
              if (YotogiListSabun.ContainsKey(t.ToLower())) {
                List<string> list = YotogiListSabun[t.ToLower()];
                t = list[UnityEngine.Random.Range(0, list.Count)];
              }
            }

            //まんぐりバイブだけはファイルがおかしいため変更
            if (t.StartsWith("manguri_vibe_")) {
              if (t == "manguri_vibe_1_f.anm") t = "x_manguri_vibe_1_f.anm";
              else if (t == "manguri_vibe_2_f.anm") t = "x_manguri_vibe_2_f.anm";
              else if (t == "manguri_vibe_3_f.anm") t = "x_manguri_vibe_3_f.anm";
              else if (t == "manguri_vibe_oku_1_f.anm") t = "x_manguri_vibe_oku_1_f.anm";
              else if (t == "manguri_vibe_oku_2_f.anm") t = "x_manguri_vibe_oku_2_f.anm";
              else if (t == "manguri_vibe_oku_3_f.anm") t = "x_manguri_vibe_oku_3_f.anm";
            }

          } else if (check >= 0) {

              int i20 = UnityEngine.Random.Range(0, MotionList20[check].Length);
              int i30 = UnityEngine.Random.Range(0, MotionList30[check].Length);
              int i40 = UnityEngine.Random.Range(0, MotionList40[check].Length);

              //通常モーションから遷移する場合にバックアップを取る
              if (!MotionList_vibe.Contains(t) && !t.Contains("_once_")) {
                maidState.maidMotionBackup = t;
              }

              //変更モーションを決定
              if (maidState.vStateMajor == 20  && t != MotionList20[check][i20]) {
                t = MotionList20[check][i20];
              } else if (maidState.vStateMajor == 30  && t != MotionList30[check][i30]) {
                t = MotionList30[check][i30];
              } else if (maidState.vStateMajor == 40) {
                t = MotionList40[check][i40];
              } else if (maidState.vStateMajor == 10 && maidState.vStateMajorOld == 50) {
                t = maidState.maidMotionBackup;
              }

          }
          #if DEBUG
          Console.WriteLine("    newMotion="+t);
          Console.WriteLine("    maidMotionBackup="+maidState.maidMotionBackup);
          #endif

          return t;

        }

        //メイドのモーション変更（絶頂時） サブメイドも呼ばれる
        private void ZeccyoMotionSelect(int maidID, Maid maid, MaidState maidState) {

          //現在のモーションを取得
          string motion = maid.body0.LastAnimeFN;
          motion = regZeccyouBackup.Match(motion).Groups[1].Value;  // 「 - Que…」を除く

          ZeccyoMotionSelect(motion, maidID, maid, maidState);
        }

        private void ZeccyoMotionSelect(string motion, int maidID, Maid maid, MaidState maidState) {

          Debug.Log("ZeccyoMotionSelect(motion="+motion+" maidID="+maidID+") motionID="+maidState.motionID);

          string t = motion;

          Match match = regZeccyou.Match(t);
          string sHighExciteMotionBackup = regZeccyouBackup.Match(t).Groups[1].Value;  // 「 - Que…」を除く

          //連続絶頂中の場合、専用モーション（_hatu_3）があるかどうか調べて変更する
          if (Regex.IsMatch(t, "_hatu_3")) {
            if (SyaseiCheck(maidID, maid, 100f)) {
              t = Regex.Replace(t, "_hatu_3", "_3");
            } else {
              return;
            }
          } else if (maidState.orgasmCmb > 3) {
            t = Regex.Replace(t, "_[12](?!ana)(?!p_)(?!vibe)", "_3");
            if (!Regex.IsMatch(t, "m_") && !Regex.IsMatch(t, "x_manguri_vibe")) t = Regex.Replace(t, @"^[a-zA-Z]_", "");
            t = Regex.Replace(t, @"[a-zA-Z][0-9][0-9]", "");

            if (MotionOldCheck(t.Replace("_3", "_hatu_3")) != -1) {
              t = Regex.Replace(t, "_3", "_hatu_3");
              //MotionChange(maid, t, true, 0.5f, 1f);
              MotionChange(maid, t, false, 0.5f, 1f); //ループせさないように修正
              MotionChangeAf(maid, sHighExciteMotionBackup, true, 0.5f, 1f); // 終わったら変更前のモーションを再生する

              maidState.zAnimeFileName = t;

              ManMotionChange(t, maidID, true, 0.5f, 1f);

              return;
            }
          }

          //通常の絶頂モーション変更処理
          if (match.Success || sHighExciteMotionBackup == "settai_vibe_in_kaiwa_kyou_a01_f.anm" || sHighExciteMotionBackup == "settai_vibe_in_kaiwa_kyou_f.anm") {

            //現在モーションファイル名の先頭部分取得
            string sZeccyouMotion = match.Groups[2].Value;

            //ポーズ維持、接待バイブのモーション名の場合は変換
            if (sZeccyouMotion == "poseizi_hibu") {
              sZeccyouMotion = "poseizi";
            } else if (sZeccyouMotion == "poseizi2_hibu") {
              sZeccyouMotion = "poseizi2";
            } else if (sHighExciteMotionBackup == "settai_vibe_in_kaiwa_kyou_a01_f.anm" || sHighExciteMotionBackup == "settai_vibe_in_kaiwa_kyou_f.anm") {
              sZeccyouMotion = "settai_vibe_in";
            }


            //絶頂モーションのファイル名が有るかどうかチェック
            bool zf = false;
            string sZeccyouMotionMaid = "";
            string[] sZeccyouMaidMotion = sZeccyouMaidMotion1;
            if ((SyaseiCheck(maidID, maid, cfgw.syaseiLimit) && maidState.orgasmCmb <= 3) || (SyaseiCheck(maidID, maid, 100f) && maidState.orgasmCmb > 3)) sZeccyouMaidMotion = sZeccyouMaidMotion2;

            foreach (string z in sZeccyouMaidMotion) {
              sZeccyouMotionMaid = sZeccyouMotion + z;

              if (regSubMaidMotion.IsMatch(motion)) {
                if (sHighExciteMotionBackup.Contains("_f.")) {
                  sZeccyouMotionMaid = sZeccyouMotion + z;

                } else if (sHighExciteMotionBackup.Contains("_f2.")) {
                  sZeccyouMotionMaid = sZeccyouMotion + z.Replace("_f_", "_f2_");

                } else if (sHighExciteMotionBackup.Contains("_f3.")) {
                  sZeccyouMotionMaid = sZeccyouMotion + z.Replace("_f_", "_f3_");

                }
              }

              if (MotionOldCheck(sZeccyouMotionMaid) != -1) {
                zf = true;
                break;
              }
            }

            //上記チェックで引っかからなかった場合、「cli」や「kiss」などの文字列を除去してもう一度チェック
            if (!zf) {
              //string motion2 = "";
              int mid = MotionIdCheck(motion);

              if (maidState.baceMotion == "") {
                //sZeccyouMotion = sZeccyouMotion.Replace("_hibu", "").Replace("_kiss", "").Replace("_cli", "").Replace("_momi", "").Replace("_gr", "");
                sZeccyouMotion = Regex.Replace(sZeccyouMotion, @"_[^_]{1,}$", ""); //モーション名の最後尾の一節を削除
              } else {
                sZeccyouMotion = maidState.baceMotion;
                sZeccyouMotion = Regex.Replace(sZeccyouMotion, "_1_f$", ""); // 末尾の _1_f は除去
              }

              foreach (string z in sZeccyouMaidMotion) {
                sZeccyouMotionMaid = sZeccyouMotion + z;

                if (regSubMaidMotion.IsMatch(motion)) {
                  if (sHighExciteMotionBackup.Contains("_f.")) {
                    sZeccyouMotionMaid = sZeccyouMotion + z;
                  } else if (sHighExciteMotionBackup.Contains("_f2.")) {
                    sZeccyouMotionMaid = sZeccyouMotion + z.Replace("_f_", "_f2_");
                  } else if (sHighExciteMotionBackup.Contains("_f3.")) {
                    sZeccyouMotionMaid = sZeccyouMotion + z.Replace("_f_", "_f3_");
                  }
                }

                if (MotionOldCheck(sZeccyouMotionMaid) != -1) {
                  zf = true;
                  break;
                }
              }

            }


            //絶頂モーションに変更
            if (zf) {
              // 強制的に再生
              //メイドモーション変更
              MotionChange(maid, sZeccyouMotionMaid, false, 0.5f, 1f);
              maidState.zAnimeFileName = sZeccyouMotionMaid + ".anm";

              MotionChangeAf(maid, sHighExciteMotionBackup, true, 0.5f, 1f); // 終わったら再生する

              //男のモーション変更
              ManMotionChange(sZeccyouMotionMaid, maidID, false, 0.5f, 1f);
              ManMotionChangeAf(sHighExciteMotionBackup, maidID, true, 0.5f, 1f); // 終わったら再生する

            } else {
              //絶頂モーションがない場合は、現在モーションをフェラ判別用に挿入する
              maidState.zAnimeFileName = maid.body0.LastAnimeFN;
            }
          }
        }


        //抜くモーション再生 レベルも調整 サブメイドもモーション再生
        /// <param name="syasei">trueなら射精値を制限値以上にして射精処理を実行</param>
        private bool removeMotionChange(int maidID, MaidState maidState, bool syasei)
        {
          Maid maid = maidState.maid;

          if (maidState.motionID == -1) return false; //UNZIP中でない
          //if (!maidState.removable) return false; //該当モーションがない 素股の待機はfalseなのでチェックしない
          if (maid.body0.LastAnimeFN == maidState.taikiMotion+".anm") return false; //抜いた後のモーション
          if (maid.body0.LastAnimeFN == maidState.syaseigoMotion+".anm") return false; //抜いた後のモーション

          int outMotionFlag = maj.outMotionFlag[maidState.motionID];
          if (outMotionFlag == 0) outMotionFlag = cfgw.majOutMotionFlag; //0なら共通設定利用 設定されていない
          bool bShasei = syasei || (outMotionFlag & 8) == 8;
          bool bShaseiTaiki = (outMotionFlag & 16) == 16;

          //SE停止
          if (maidID == tgID ) GameMain.Instance.SoundMgr.StopSe();

          //メインメイドとサブメイドに連携している男の射精値を制限値まで上げる
          if (syasei) {
            bShasei = true;
            for (int im=0; im<SubMans.Length; im++) {
              if (isSubManVisible(im)) {
                if (MansTg[im] == maidID || (maidState.motionLinkID != -1 && MansTg[im] == maidState.motionLinkID)) syaseiValue[im] = cfgw.syaseiLimit;
              }
            }
          }

          List<int> subMaidIdList = getMotionLinkedMaidID(maidID);

          //射精レベルが高ければ射精を実行して射精後モーションに変更 抜き終わったら再生する
          if (maidState.removable && maidState.outMotion != "Non" && (bShasei || SyaseiCheck(maidID, maid, cfgw.syaseiLimit))) {
            //遅延実行 バイブ強でない場合
            if (maidState.vLevel != 2 && cfgw.sotodashiDelay > 0) {
              maidState.skipMotionChange = Time.time + 0.1f+cfgw.sotodashiDelay;
              maidState.vLevel = 2;
              string motion = maidState.maid.body0.LastAnimeFN.Replace(".anm", "");
              if (motion.Contains("_2_")) {
                motion = motion.Replace("_2_", "_3_");
                MotionChange(maid, motion, true, 0.4f, 1f);
                ManMotionChange(motion, maidID, true, 0.4f, 1f);
                foreach (int subID in subMaidIdList) { //サブメイド
                  MaidState subState = maidsState[subID];
                  subState.skipMotionChange = Time.time +0.1f+ cfgw.sotodashiDelay;
                  subState.vLevel = 2;
                  motion = subState.maid.body0.LastAnimeFN.Replace(".anm", "");
                  if (motion.Contains("_2_")) {
                    motion = motion.Replace("_2_", "_3_");
                    MotionChange(subState.maid, motion, true, 0.4f, 1f);
                  }
                }
                //MaidMotionChange(maidID, maid, maidState, 0.4f, true); //fadeは短め
              }
              //コルーチンで遅延実行
              StartCoroutine(removeSyaseiMotionChangeCoroutine(maidID, maidState, subMaidIdList, bShaseiTaiki));
            } else {
              removeSyaseiMotionChange(maidID, maidState, subMaidIdList, bShaseiTaiki);
            }
            return true;
          }

          //射精モーションなし 射精後か待機モーションがあれば移行する なければ再生しない
            outMotionFlag = outMotionFlag & 7; //下3ビット
            if (outMotionFlag == 0) outMotionFlag = cfgw.majOutMotionFlag; //0なら共通設定利用 下位3ビットのみ
            //モーションの有無で調整
            if (maidState.taikiMotion == "Non" && maidState.syaseigoMotion == "Non") outMotionFlag = 0; //再生しない
            else if (maidState.taikiMotion == "Non") outMotionFlag = 1;
            else if (maidState.syaseigoMotion == "Non") outMotionFlag = 2;
            if (outMotionFlag == 1) {
              //射精後モーション
              MotionChange(maid, maidState.syaseigoMotion, true, cfgw.majOutFade, 1f);
              ManMotionChange(maidState.syaseigoMotion, maidID, true, cfgw.majOutFade, 1f);
            foreach (int subID in subMaidIdList) { //サブメイド
              MaidState subState = maidsState[subID];
                MotionChange(subState.maid, subState.syaseigoMotion, true, cfgw.majOutFade, 1f);
              }
            } else if (outMotionFlag == 2) {
              //待機モーション
              MotionChange(maid, maidState.taikiMotion, true, cfgw.majOutFade, 1f);
              ManMotionChange(maidState.taikiMotion, maidID, true, cfgw.majOutFade, 1f);
            foreach (int subID in subMaidIdList) { //サブメイド
              MaidState subState = maidsState[subID];
                MotionChange(subState.maid, subState.taikiMotion, true, cfgw.majOutFade, 1f);
              }
            } else if (outMotionFlag == 3) {
              //射精後→待機モーション
              MotionChange(maid, maidState.syaseigoMotion, false, cfgw.majOutFade, 1f);
              MotionChangeAf(maid, maidState.taikiMotion, true, cfgw.majOutFadeAf, 1f);
              ManMotionChange(maidState.syaseigoMotion, maidID, false, cfgw.majOutFade, 1f);
              ManMotionChangeAf(maidState.taikiMotion, maidID, true, cfgw.majOutFadeAf, 1f);
              foreach (int subID in subMaidIdList) { //サブメイド
                MaidState subState = maidsState[subID];
                MotionChange(subState.maid, subState.syaseigoMotion, false, cfgw.majOutFade, 1f);
                MotionChangeAf(subState.maid, subState.taikiMotion, true, cfgw.majOutFadeAf, 1f);
              }
            } else if (outMotionFlag == 4) {
              //待機→射精後モーション
              MotionChange(maid, maidState.taikiMotion, false, cfgw.majOutFade, 1f);
              MotionChangeAf(maid, maidState.syaseigoMotion, true, cfgw.majOutFadeAf, 1f);
              ManMotionChange(maidState.taikiMotion, maidID, false, cfgw.majOutFade, 1f);
              ManMotionChangeAf(maidState.syaseigoMotion, maidID, true, cfgw.majOutFadeAf, 1f);
              foreach (int subID in subMaidIdList) { //サブメイド
                MaidState subState = maidsState[subID];
                MotionChange(subState.maid, subState.taikiMotion, false, cfgw.majOutFade, 1f);
                MotionChangeAf(subState.maid, subState.syaseigoMotion, true, cfgw.majOutFadeAf, 1f);
              }
            }

          ReactionPlay(maidID);

          //バイブは停止 モーションも2秒間は変更しない
          maidState.vLevel = 0;
          maidState.pAutoSelect = 0;
          maidState.skipMotionChange = Time.time + 2f;
          foreach (int subID in subMaidIdList) { //サブメイド
            MaidState subState = maidsState[subID];
            subState.vLevel = 0;
            subState.pAutoSelect = 0;
            subState.skipMotionChange = Time.time + 2f;
          }
          //子宮脱判定
          if (maidState.analMode) maidState.uDatsu = 1;

          return true;
        }

        //外出しの遅延実行
        private IEnumerator removeSyaseiMotionChangeCoroutine(int maidID, MaidState maidState, List<int> subMaidIdList, bool bShaseiTaiki)
        {
          yield return new WaitForSeconds(cfgw.sotodashiDelay);  //待機
          removeSyaseiMotionChange(maidID, maidState, subMaidIdList, bShaseiTaiki);
        }
        private void removeSyaseiMotionChange(int maidID, MaidState maidState, List<int> subMaidIdList, bool bShaseiTaiki)
        {
          Maid maid = maidState.maid;

            //射精モーション
            MotionChange(maid, maidState.outMotion, false, cfgw.majOutSyaseiFade, 1f);
            ManMotionChange(maidState.outMotion, maidID, false, cfgw.majOutSyaseiFade, 1f);
            foreach (int subID in subMaidIdList) { //サブメイド
              MaidState subState = maidsState[subID];
              MotionChange(subState.maid, subState.outMotion, false, cfgw.majOutSyaseiFade, 1f);
            }
            if (bShaseiTaiki && maidState.taikiMotion != "Non") {
              //射精後に待機モーション
              if (maidState.syaseigoMotion != "Non") {
                MotionChangeAf(maid, maidState.syaseigoMotion, false, cfgw.majOutFade, 1f);
                ManMotionChangeAf(maidState.syaseigoMotion, maidID, false, cfgw.majOutFade, 1f);
              foreach (int subID in subMaidIdList) { //サブメイド
                MaidState subState = maidsState[subID];
                  MotionChangeAf(subState.maid, subState.syaseigoMotion, false, cfgw.majOutFade, 1f);
                }
              }
              MotionChangeAf(maid, maidState.taikiMotion, true, cfgw.majOutFadeAf, 1f);
              ManMotionChangeAf(maidState.taikiMotion, maidID, true, cfgw.majOutFadeAf, 1f);
              foreach (int subID in subMaidIdList) { //サブメイド
                MaidState subState = maidsState[subID];
                MotionChangeAf(subState.maid, subState.taikiMotion, true, cfgw.majOutFadeAf, 1f);
              }
            } else {
              if (maidState.syaseigoMotion != "Non") {
                //射精後モーション
                MotionChangeAf(maid, maidState.syaseigoMotion, true, cfgw.majOutFade, 1f);
                ManMotionChangeAf(maidState.syaseigoMotion, maidID, true, cfgw.majOutFade, 1f);
              foreach (int subID in subMaidIdList) { //サブメイド
                MaidState subState = maidsState[subID];
                  MotionChangeAf(subState.maid, subState.syaseigoMotion, true, cfgw.majOutFade, 1f);
                }
              } else {
                //射精後モーションがないなら待機
                MotionChangeAf(maid, maidState.taikiMotion, true, cfgw.majOutFadeAf, 1f);
                ManMotionChangeAf(maidState.taikiMotion, maidID, true, cfgw.majOutFadeAf, 1f);
                foreach (int subID in subMaidIdList) { //サブメイド
                  MaidState subState = maidsState[subID];
                  MotionChangeAf(subState.maid, subState.taikiMotion, true, cfgw.majOutFadeAf, 1f);
                }
              }
            }

          //リアクション バイブ停止前に実行 (外出しボイス設定のバイブ強度での振り分けも可能にする)
          //marksList = new string[] { "指定無し" , "挿入 前" , "挿入 後" , "フェラ" , "手コキ" , "足コキ" , "射精しない" , "アナル 前" , "アナル 後"};
          if (cfgw.sotodashiReactionPlay) {
            bool played = false;
            //男はメイド（メインか自分)とリンクしている最初の男
            int manID = getMotionLinkedManID(maidID, subMaidIdList);
            if (manID > -1) {
              int syaseiMark = maidState.syaseiMarks[manID];
              //"手コキ" , "足コキ" , "射精しない" 以外
              if (syaseiMark != 4 && syaseiMark != 5 && syaseiMark != 6) {
                if (syaseiMark == 3 || maidState.bIsBlowjobing == 2) {
                  if (maidState.kaodashiVoiceSet != null) played = SyaseiReactionPlay(maidID, maidState, maidState.kaodashiVoiceSet); //フェラ後の顔射
                } else {
                  if (maidState.sotodashiVoiceSet != null) played = SyaseiReactionPlay(maidID, maidState, maidState.sotodashiVoiceSet); //挿入後の外出し キス中も含む
                }
              }
          }
            //ボイスがなかったら通常のリアクション
            if (!played) ReactionPlay(maidID);
          } else {
            ReactionPlay(maidID);
          }

          //バイブは停止 モーションも3秒間は変更しない
          maidState.vLevel = 0;
          maidState.pAutoSelect = 0;
          maidState.skipMotionChange = Time.time + 3f;
          foreach (int subID in subMaidIdList) { //サブメイド
            MaidState subState = maidsState[subID];
            subState.vLevel = 0;
            subState.pAutoSelect = 0;
            subState.skipMotionChange = Time.time + 3f;
          }
          //子宮脱判定
          if (maidState.analMode) maidState.uDatsu = 1;
        }

        private int getMotionLinkedManID(int maidID, List<int> subMaidIdList)
        {
            for (int im = 0; im < SubMans.Length; im++) {
              if (isSubManVisible(im) && MansTg[im] != -1) {
                if (MansTg[im] == maidID) return im;
                foreach (int subID in subMaidIdList) { //サブメイド
                  if (MansTg[im] == subID) return im;
                }
              }
            }
            return -1;
        }

        //再挿入モーション再生 UNZIPのモーションIDも切り替わる サブメイドもモーション再生
        private bool insertMotionChange(int maidID, MaidState maidState)
        {
          if (maidState.motionID == -1) return false; //UNZIP中でない
          if (!isRemovedMotion(maidState)) return false; //抜いた後のモーションでない
          if (!maidState.insertable) return false; //該当モーションがない

          Maid maid = maidState.maid;

          //停止モーション バイブを弱にするので状態変更処理でモーションは変更される
          string motion = maj.motionName[maidState.motionID];

          //挿入後の基本モーションに例外置換
          bool bChanged = false;
          foreach (string[] replace in cfgw.sumataInsertedMotionReplace) {
            if (motion == replace[0]) { motion = replace[1]; bChanged = true; break; }
          }
          //例外設定以外の素股は強制変換
          if (!bChanged) motion = motion.Replace("_sumata_f", "_1_f").Replace("_sumata_", "_");

          //有効なモーションでなければ終了
          if (!majValidNameSet.Contains(motion)) {
            Debug.LogError("insertMotionChange invalid motion : "+motion);
            return false;
          }

          //挿入モーションの設定は素股側から取得
          bool skipInsertMotion = (maj.outMotionFlag[maidState.motionID] & 32) == 32; //再挿入モーションなし

          //モーションID変更  モーション置換を反映
          int mid = maj.motionName.IndexOf(motion);
          if (mid < 0) return false;

          //モーションアジャスト設定変更 挿入モーションに切り替わる
          if (maidState.motionID != mid) MotionAdjustDo(maidID, motion, false, -1);
          //パネルのスクロール変更
          unzipPanelScroll = true;

          //バイブが停止していたら弱にする
          if (maidState.vLevel == 0 && maidState.pAutoSelect == 0) maidState.vLevel = 1;

          if (maidState.inMotion == "Non" || skipInsertMotion) {
            #if DEBUG
            Debug.Log("挿入モーションスキップ : " +maj.motionName[maidState.motionID] );
            #endif
            MotionChange(maid, motion, true, cfgw.majFadeTime, 1f);
            foreach (int subID in getMotionLinkedMaidID(maidID)) { //サブメイドのモーションも変更
              MaidState subState = maidsState[subID];
              MotionChange(subState.maid, maj.motionName[subState.motionID], true, cfgw.majFadeTime, 1f);
              maidState.skipMotionChange = Time.time + 1f; //通常モーションに戻す間はモーション変更をスキップ
              subState.vLevel = maidState.vLevel; //バイブも変更
            }
            //男のモーション変更
            ManMotionChange(maidID, true, cfgw.majFadeTime, 1.0f);
          } else {
            MotionChange(maid, maidState.inMotion, false, cfgw.majFadeTime, 1f);
            MotionChangeAf(maid, motion, true, cfgw.majFadeTime, 1f); // 終わったら再生する
            maidState.skipMotionChange = Time.time + 2f; //挿入モーション中はモーション変更をスキップ
            //クパ開始時間を設定
            float kupaDelay = maj.kupaDelay[maidState.motionID];
            if (kupaDelay < 0) kupaDelay = cfgw.majKupaOpenDelay; //デフォルト 0.5秒後
            maidState.kupaOpenTime = Time.time + kupaDelay;

            foreach (int subID in getMotionLinkedMaidID(maidID)) { //サブメイドのモーションも変更
              MaidState subState = maidsState[subID];
              MotionChange(subState.maid, subState.inMotion, false, cfgw.majFadeTime, 1f);
              MotionChangeAf(subState.maid, maj.motionName[subState.motionID], true, cfgw.majFadeTime, 1f); // 終わったら再生する
              subState.vLevel = maidState.vLevel; //バイブも変更
              //クパ開始時間を設定
              kupaDelay = maj.kupaDelay[subState.motionID];
              if (kupaDelay < 0) kupaDelay = cfgw.majKupaOpenDelay; //デフォルト 0.5秒後
              subState.kupaOpenTime = Time.time + kupaDelay; //共通設定 0.5秒後
            }
            ManMotionChange(maidState.inMotion, maidID, false, cfgw.majFadeTime, 1f);
            ManMotionChangeAf(motion, maidID, true, cfgw.majFadeTime, 1f); // 終わったら再生する
          }

          //子宮脱リセット
          if (!maidState.analMode) {
            maidState.uDatsuValue1 = 0f;
            maidState.uDatsu = 0;
            try { VertexMorph_FromProcItem(maid.body0, "pussy_uterus_prolapse", 0f); } catch { /*LogError(ex);*/ }
          }

          return true;
        }

        //素股モーション再生 サブメイドは基本ないが一応対応
        private bool sumataMotionChange(int maidID, MaidState maidState)
        {
          if (maidState.motionID == -1) return false; //UNZIP中でない
          if (maidState.sumataMotion == "Non") return false; //素股モーションがない
          if (!isRemovedMotion(maidState)) return false; //抜いた後のモーションでない

          //有効なモーションでなければ終了
          if (!majValidNameSet.Contains(maidState.sumataMotion)) {
            Debug.LogError("sumataMotionChange invalid motion : "+maidState.sumataMotion);
            return false;
          }
          //モーションID変更 モーションがなければ終了
          int mid = maj.motionName.IndexOf(maidState.sumataMotion);
          if (mid < 0) return false;
          //モーションアジャスト設定変更
          if (maidState.motionID != mid) MotionAdjustDo(maidID, maidState.sumataMotion, false, -1);
          //パネルのスクロール変更
          unzipPanelScroll = true;

          Maid maid = maidState.maid;

          //バイブが停止していたら弱にする
          if (maidState.vLevel == 0 && maidState.pAutoSelect == 0) maidState.vLevel = 1;

          MotionChange(maid, maidState.sumataMotion, true, cfgw.majFadeTime, 1f);
          foreach (int subID in getMotionLinkedMaidID(maidID)) { //サブメイドのモーションも変更 素股はモーションなし
            MaidState subState = maidsState[subID];
            if (subState.sumataMotion != "Non") {
              MotionChange(subState.maid, subState.sumataMotion, true, cfgw.majFadeTime, 1f);
              subState.vLevel = maidState.vLevel; //バイブも変更
              //モーションID変更
              mid = maj.motionName.IndexOf(subState.sumataMotion);
              if (mid >= 0) maidState.motionID = mid;
            }
          }
          //男のモーション変更
          ManMotionChange(maidID, true, cfgw.majFadeTime, 1.0f);
          return true;
        }

        //モーションがリンクしているサブメイドのMaidState一覧を取得 3人以上も対応
        private List<int> getMotionLinkedMaidID(int maidID)
        {
          List<int> list = new List<int>();
          foreach (int subId in vmId) {
            if (subId != maidID) { //自分以外
              if (maidsState[subId].motionLinkID == maidID || subId == maidsState[maidID].motionLinkID) { //1:多のリンクにも対応
                list.Add(subId);
                //メインがサブモーションの場合
                foreach (int subId2 in vmId) {
                  if (subId2 != maidID) { //自分以外
                    if (maidsState[subId2].motionLinkID == subId) {
                      if (!list.Contains(subId2)) list.Add(subId2);
                    }
                  }
                }
              }
            }
          }
          return list;
        }

        //後ろを使う/前を使うの切り替え
        private void analMotionChange(int maidID, MaidState maidState)
        {
          Maid maid = maidState.maid;

          string baseMotion = maj.motionName[maidState.motionID];
          MotionAdjustDo(maidID, baseMotion, true, -1);

          if (maidState.inMotion == "Non") {
            MotionChange(maid, baseMotion, true, 0.7f, 1f);
          } else {
            MotionChange(maid, maidState.inMotion, false, 0.7f, 1f);
            MotionChangeAf(maid, baseMotion, true, 0.7f, 1f); // 終わったら再生する
            //クパ開始時間を設定
            float kupaDelay = maj.kupaDelay[maidState.motionID];
            if (kupaDelay < 0) kupaDelay = cfgw.majKupaOpenDelay; //デフォルト 0.5秒後
            maidState.kupaOpenTime = Time.time + kupaDelay; //共通設定 0.5秒後
          }

          //男のモーション変更
          if (maidState.inMotion == "Non") {
            ManMotionChange(maidID, true, 0.7f, 1.0f);
          } else {
            ManMotionChange(maidState.inMotion, maidID, false, 0.7f, 1f);
            ManMotionChangeAf(baseMotion, maidID, true, 0.7f, 1f); // 終わったら再生する
          }

          if (maidState.analMode) {
            maidState.pAutoSelect = 0;
            maidState.uDatsu = 1;
          } else {
            maidState.uDatsuValue1 = 0f;
            maidState.uDatsu = 0;
            try { VertexMorph_FromProcItem(maid.body0, "pussy_uterus_prolapse", 0f); } catch { /*LogError(ex);*/ }
          }

          //kupa変更のため余韻状態にする
          if (maidState.vStateMajor == 10) {
            maidState.vStateMajor = 40;
            maidState.yoinHoldTime = 120f;
          }
        }


        //複数・百合相手用モーション変更処理
        private void SubMotionChange(int mainID, string motion, string motionAf, bool loop, float cs, float ls) {

          if (motion.EndsWith(".anm", StringComparison.Ordinal)) motion = motion.Replace(".anm", "");

          int im = 1;
          int im2 = 1;
          if (motion.Contains("_f2")) im2 = 2;
          else if (motion.Contains("_f3")) im2 = 3;
          else if (motion.Contains("_f4")) im2 = 4;

          #if DEBUG
          Console.WriteLine("SubMotionChange : mainID="+mainID+" motion="+motion+" motionAf="+motionAf+" im2="+im2);
          #endif

          foreach (int subID in vmId) {

            if (mainID == subID || !LinkMaidCheck(mainID, subID)) continue;

            Maid maid = stockMaids[subID].mem;
            if (im == im2) ++im;
            string t = replaceSubMotion(motion, im);
            //モーションがなければ終了
            if (MotionOldCheck(t) == -1) {
              break;
            }
            // 次のモーションもチェック
            string t2 = null;
            if (motionAf != null) {
              t2 = replaceSubMotion(motionAf, im);
              if (MotionOldCheck(t2) == -1) motionAf = null;
            }

            string mainMotion = maj.motionName[maidsState[mainID].motionID]; //メインメイドのモーション

              MotionAdjustDo(subID, replaceSubMotion(mainMotion, im), true, mainID); //モーションアジャスト実行

              MotionChange(maid, t, (motionAf == null ? loop : false), cs, ls); //次のモーションがあればループしない

              //次のモーションがあれば再生
              if (motionAf != null) MotionChangeAf(maid, t2, loop, cs, ls);

              #if EmpiresLife
              if (lifeStart >= 5) maidsState[subID].elItazuraFlag = true;
              #endif
              //2人目のサブモーションならリンク情報を保存
              if (im == 2) {
                //メインとサブのリンクは一旦すべて解除
                foreach (int id in vmId) {
                  if (maidsState[id].motionLinkID == mainID || maidsState[id].motionLinkID == subID) maidsState[id].motionLinkID = -1;
                }
                //モーションリンク情報を設定
                maidsState[mainID].motionLinkID = subID;
                maidsState[subID].motionLinkID = mainID;
              } else {
                //3人目以降
                maidsState[subID].motionLinkID = mainID;
              }

            //タイマーリセット
            maidsState[subID].motionHoldTime = maidsState[mainID].motionHoldTime;
            maidsState[subID].voiceHoldTime = 0f;
            maidsState[subID].faceHoldTime = 0;
            maidsState[subID].MouthHoldTime = 0f;

            ++im;
          }
        }

        private string replaceSubMotion(string motion, int im)
        {
          string t = Regex.Replace(motion, @"_f\d?$", "_f" + im);
          t = Regex.Replace(t, @"_f\d?_once_", "_f" + im + "_once_");
          if (im == 1) t= t.Replace("_f1", "_f");

          if (MotionOldCheck(t) == -1) {
            t = Regex.Replace(t, "[a-zA-Z][0-9][0-9]", "");
          }
          return t;
        }


        //男通常モーション変更処理  アナルモードの切り替え 射精モーションなら精液処理も行う
        private void ManMotionChange(string motion, int maidID, bool loop, bool old, bool abs, float cs, float ls) {

          MaidState maidState = maidsState[maidID];
          Maid maid = maidState.maid;

          if (motion.EndsWith(".anm", StringComparison.Ordinal)) motion = motion.Replace(".anm", "");
          string t = motion;
          t = Regex.Replace(t, @"_f\d?$", "_m");
          t = Regex.Replace(t, @"_f\d?_", "_m_");

          //アナルモードの場合、男モーションをアナル用に変更
          if (maidState.analMode) {
            string bm = maidState.analMotion.Replace("a_in_m_once_", "");
            string am = maidState.analMotion.Replace("_in_m_once_", "");
            string analMotion = t.Replace(bm, am);
            if (MotionOldCheck(analMotion) != -1) {
              t = analMotion;
            } else {
              analMotion = Regex.Replace(analMotion, "[a-zA-Z][0-9][0-9]", "");
              if (MotionOldCheck(analMotion) != -1) t = analMotion;
            }
          }

          int im2 = 2;
          for (int im = 0; im < SubMans.Length; im++) {

            if (!isSubManVisible(im) || MansTg[im] != maidID) continue;
            Maid subMan = getSubMan(im);
            //1m以上離れていたらモーションは変えない ロード前はチェックしない
            if (subMan.body0.m_Bones) {
              float fDistance = Vector3.Distance(stockMaids[maidID].mem.transform.position, subMan.transform.position);
              if (fDistance > 1f) continue;
            }

            //ずれが発生するので男がロード済みならコルーチンは使わない
            if ((allFilesSet.Contains(t) && !old) || (allFilesOldSet.Contains(t) && old)) {
              if (subMan.body0 && subMan.body0.m_Bones != null) {
                if (abs) MotionChange(subMan, t, loop, old, cs, ls);
                else MotionChangeAf(subMan, t, loop, old, cs, ls);
              }
              else StartCoroutine(MotionChangeCoroutine(subMan, t, abs, loop, old, cs, ls));
            } else {
              t = Regex.Replace(t, "[a-zA-Z][0-9][0-9]", "");
              if ((allFilesSet.Contains(t) && !old) || (allFilesOldSet.Contains(t) && old)) {
                if (subMan.body0 && subMan.body0.m_Bones != null) {
                  if (abs) MotionChange(subMan, t, loop, old, cs, ls);
                  else MotionChangeAf(subMan, t, loop, old, cs, ls);
                }
                else StartCoroutine(MotionChangeCoroutine(subMan, t, abs, loop, old, cs, ls));
              } else {
                break;
              }
            }

            //射精処理
            if (syaseiValue[im] >= cfgw.syaseiLimit) {
              string[] marks = new string[] { "秘部", "秘部", "太股"};
              if (t.Contains("_shasei")) {
                bool naka = false;
                int marksInt = 0;
                if (t.Contains("_shasei_naka") || t.Contains("_shasei_kuti")) naka = true;
                if (maidState.motionID >= 0) marksInt = maj.syaseiMarks[maidState.motionID][im];
                if (marksInt == 0) {
                  if (t.Contains( "asikoki" )) {
                    marksInt = 5;
                  } else if (t.Contains( "fera" ) || t.Contains( "sixnine" )) {
                    marksInt = 3;
                  } else if (t.Contains( "tekoki" ) || t.Contains( "paizuri" )) {
                    marksInt = 4;
                  } else if (t.Contains( "haimen" ) || t.Contains( "kouhaii" ) || t.Contains( "sokui" ) || t.Contains( "sukebeisu_sex" ) || t.Contains( "kakaemzi" )) {
                    marksInt = 2;
                  } else {
                    marksInt = 1;
                  }
                }

                EffectSyasei(maidID, maidState, marksInt, naka);
                if (!syaseiLock[im]) syaseiValue[im] = 0f;
              }
            }

            t = Regex.Replace(t, @"_m\d?$", "_m" + im2);
            t = Regex.Replace(t, @"_m\d?_", "_m" + im2 + "_");
            ++im2;
          }

          //男の高さと向きをメイドに合わせる
          //setManMotionPosition(maidID, -1);
          //男のアイテム装備
          //setManMotionItem(maidID);
        }

        //男通常モーション変更処理（新旧自動判別）
        private void ManMotionChange(string motion, int maidID, bool loop, float cs, float ls) {

          bool old = MotionOldCheckB(motion);
          ManMotionChange(motion, maidID, loop, old, true, cs, ls);

        }

        //男通常モーション変更処理（メイドモーション自動取得）
        private void ManMotionChange(int maidID, bool loop, float cs, float ls) {

          Maid maid = stockMaids[maidID].mem;
          string motion = maid.body0.LastAnimeFN.Replace(".anm", "");
          ManMotionChange(motion, maidID, loop, cs, ls);

        }

        //男通常モーション変更処理（現在のモーション再生が終了したあと・新旧自動判別）
        private void ManMotionChangeAf(string motion, int maidID, bool loop, float cs, float ls) {

          if (motion.EndsWith(".anm", StringComparison.Ordinal)) motion = motion.Replace(".anm", "");
          bool old = !allFilesSet.Contains(motion);
          ManMotionChange(motion, maidID, loop, old, false, cs, ls);

        }

        //男通常モーション変更処理（現在のモーション再生が終了したあと・メイドモーション自動取得）
        private void ManMotionChangeAf(int maidID, bool loop, float cs, float ls) {

          Maid maid = stockMaids[maidID].mem;
          string motion = maid.body0.LastAnimeFN.Replace(".anm", "");
          ManMotionChangeAf(motion, maidID, loop, cs, ls);

        }


        //実際にモーションを変更する（新旧自動判断）
        private void MotionChange(Maid maid, string motion, bool loop, float cs, float ls)
        {
          if (motion.EndsWith(".anm", StringComparison.Ordinal)) motion = motion.Replace(".anm", "");

          if (allFilesSet.Contains(motion)) {
            maid.CrossFadeAbsolute( motion + ".anm", GameUty.FileSystem, false, loop, false, cs, ls );
            Console.WriteLine("オダメモーション：" + motion);
          } else if (allFilesOldSet.Contains(motion)) {
            maid.CrossFadeAbsolute( motion + ".anm", GameUty.FileSystemOld, false, loop, false, cs, ls );
            Console.WriteLine("カスメモーション：" + motion);
          } else {
            maid.CrossFadeAbsolute( motion + ".anm", GameUty.FileSystem, false, loop, false, cs, ls );
            Console.WriteLine("対応モーション無し：" + motion);
          }
        }
        //実際にモーションを変更する（新旧指定）
        private void MotionChange(Maid maid, string motion, bool loop, bool old, float cs, float ls)
        {
          if (motion.EndsWith(".anm", StringComparison.Ordinal)) motion = motion.Replace(".anm", "");

          if (!old) {
            maid.CrossFadeAbsolute( motion + ".anm", GameUty.FileSystem, false, loop, false, cs, ls );
            Console.WriteLine("オダメモーション：" + motion);
          } else {
            maid.CrossFadeAbsolute( motion + ".anm", GameUty.FileSystemOld, false, loop, false, cs, ls );
            Console.WriteLine("カスメモーション：" + motion);
          }
        }

        //現在のモーション再生が終了したあとにモーションを変更する（新旧自動判断）
        private void MotionChangeAf(Maid maid, string motion, bool loop, float cs, float ls)
        {
          if (motion.EndsWith(".anm", StringComparison.Ordinal)) motion = motion.Replace(".anm", "");

          if (allFilesSet.Contains(motion)) {
            maid.CrossFade( motion + ".anm", GameUty.FileSystem, false, loop, true, cs, ls );
          } else if (allFilesOldSet.Contains(motion)) {
            maid.CrossFade( motion + ".anm", GameUty.FileSystemOld, false, loop, true, cs, ls );
          }
        }
        //現在のモーション再生が終了したあとにモーションを変更する（新旧指定）
        private void MotionChangeAf(Maid maid, string motion, bool loop, bool old, float cs, float ls)
        {
          if (motion.EndsWith(".anm", StringComparison.Ordinal)) motion = motion.Replace(".anm", "");

          if (!old) {
            maid.CrossFade( motion + ".anm", GameUty.FileSystem, false, loop, true, cs, ls );
          } else {
            maid.CrossFade( motion + ".anm", GameUty.FileSystemOld, false, loop, true, cs, ls );
          }
        }

        //実際にモーションを変更する（新旧指定） 男モーション用コルーチン対応
        private IEnumerator MotionChangeCoroutine(Maid maid, string motion, bool abs, bool loop, bool old, float cs, float ls)
        {
          int cnt = 0;
          while (!maid.body0 || maid.body0.m_Bones == null) {
            yield return new WaitForSeconds (0.1f);  // 0.1秒待つ
            if (cnt++ > 50) yield break; //5秒たったら強制終了
          }
          if (abs) MotionChange(maid, motion, loop, old, cs, ls);
          else MotionChangeAf(maid, motion, loop, old, cs, ls);
        }

        //モーションの新旧をチェックする
        private int MotionOldCheck(string motion) {
          if (motion.EndsWith(".anm", StringComparison.Ordinal)) motion = motion.Replace(".anm", "");

          if (allFilesSet.Contains(motion)) {
            return 0;
          } else if (allFilesOldSet.Contains(motion)) {
            return 1;
          } else {
            return -1;
          }
        }
        private bool MotionOldCheckB(string motion) {
          if (motion.EndsWith(".anm", StringComparison.Ordinal)) motion = motion.Replace(".anm", "");

          if (allFilesSet.Contains(motion)) {
            return false;
          } else {
            return true;
          }
        }


        //アニメーションステータスを取得する
        private AnimationState GetCurrentAnimationState(Maid maid) {
          AnimationState state = null;

          // アニメーション取得
          Animation anime = maid.body0.GetAnimation();
          if (anime != null) {
            // アニメーション状態取得
            state = anime[ maid.body0.LastAnimeFN ];
          }
          return state;
        }

        //モーションの速度を変更する
        private bool AnimationSpeedChange(Maid maid, float changeSpeed) {

          AnimationState maidAniState = GetCurrentAnimationState(maid);
          if (maidAniState != null) {
            if (maidAniState.enabled && (maidAniState.wrapMode == WrapMode.Loop || maidAniState.wrapMode == WrapMode.Once || maidAniState.wrapMode == WrapMode.Default)) {
              maidAniState.speed = changeSpeed;
              return true;
            }
          }
          return false;
        }


        //モーションの開始時間を同期する start0:最初から再生 manSync:男も同期する
        private void syncMotionAnimeTime(int tgMaidID, bool start0, bool manSync)
        {
          float tgTime = 0;
          if (!start0) {
            tgTime = stockMaids[tgMaidID].mem.body0.GetAnimeTime();
          }
          foreach (int maidID in vmId) {
            //リンクしているメイド 最初から再生ならメインメイドも時間変更
            if ((maidID != tgMaidID && LinkMaidCheck(tgMaidID, maidID)) || (start0 && maidID == tgMaidID)) {
              Maid maid = stockMaids[maidID].mem;
              Animation animation = maid.body0.m_Animation;
              //アニメは再生状態にする
              animation.Play(maid.body0.LastAnimeFN.ToLower()); //TBody.GetAnimeTagのtag変換
              //配列から再生中アニメーションのstateを取得
              foreach (AnimationState state in animation) {
                if (animation.IsPlaying(state.name)) {
                  state.time = tgTime;
                }
              }
            }
          }
          //男も同期 メインメイドとリンクしている男のみ
          if (manSync) {
            for (int im = 0; im < SubMans.Length; im++) {
              Maid man = getSubMan(im);
              if (man.Visible && MansTg[im] == tgMaidID) {
                Animation animation = man.body0.m_Animation;
                foreach (AnimationState state in animation) {
                  if (start0 || animation.IsPlaying(state.name)) state.time = tgTime;
                }
              }
            }
          }
        }
        //モーションのループを設定 メインメイドとリンクメイド
        private void syncMotionLoop(int tgMaidID, bool loop)
        {
          foreach (int maidID in vmId) {
            //リンクしているメイド 最初から再生ならメインメイドも時間変更
            if (maidID == tgMaidID || LinkMaidCheck(tgMaidID, maidID)) {
              setMotionLoop(stockMaids[maidID].mem, loop);
            }
          }
        }
        private void setMotionLoop(Maid maid, bool loop)
        {
          Animation animation = maid.body0.m_Animation;
          //アニメは再生状態にする
          animation.Play(maid.body0.LastAnimeFN.ToLower()); //TBody.GetAnimeTagのtag変換
          //配列から再生中アニメーションのstateを取得
          foreach (AnimationState state in animation) {
            if (animation.IsPlaying(state.name)) {
              //ループ設定
              if (loop) state.wrapMode = WrapMode.Loop;
              else state.wrapMode = WrapMode.Once;
            }
          }
        }

        //モーション名に対応するマイポーズを取得
        static private PhotoMotionData getMyPoseId(string motion)
        {
          //なければ初期化
          if (PhotoMotionData.category_list == null) PhotoMotionData.Create();

          if (PhotoMotionData.category_list != null) {
            List<PhotoMotionData> list = PhotoMotionData.category_list["マイポーズ"];
            if (list != null) {
              for (int i = 0; i < list.Count; i++) {
                if (list[i].id.ToString() == motion) {
                  return list[i];
                }
              }
            }
          }
          return null;
        }
        static public PhotoMotionData getMyPoseName(string name)
        {
          //なければ初期化
          if (PhotoMotionData.category_list == null) PhotoMotionData.Create();

          if (PhotoMotionData.category_list != null) {
            List<PhotoMotionData> list = PhotoMotionData.category_list["マイポーズ"];
            if (list != null) {
              for (int i = 0; i < list.Count; i++) {
                if (list[i].name == name) {
                  return list[i];
                }
              }
            }
          }
          return null;
        }


        //モーションチェンジ関係終了-----------------------




        //-------------------------------------------------
        //モーションセット関係-----------------------------
        private bool ms_Overwrite = false;
        private int msCategory = 0;
        private int msErrer = 0;
        private string[] msErrerText = new string[] { "" , "モーションセット名が空白のため保存できません" , "上書きする場合は『上書／ｸﾘｱ』にチェックを入れて下さい" , "クリアする場合は『上書／ｸﾘｱ』にチェックを入れて下さい"};

        MotionSet_Xml MSX = new MotionSet_Xml();
        /// <summary>
        /// モーションセットクラス XML保存用
        /// </summary>
        public class MotionSet_Xml {
          public string saveMotionSetName = "";
          public List<List<string>> saveMotionSet = new List<List<string>>();

        }

        //モーションセットXMLファイルを読み込む
        private void MotionSetLoad(string xml, int maidID) {

          MotionSetLoad(xml);

          //読み込んだ情報を挿入
          maidsState[maidID].editMotionSetName = MSX.saveMotionSetName;
          maidsState[maidID].editMotionSet = new List<List<string>>(MSX.saveMotionSet);
        }

        private void MotionSetLoad(string xml) {

          //保存先のファイル名
          string fileName = @"Sybaris\UnityInjector\Config\VibeYourMaid\EditMotionSet\" + xml;
          Console.WriteLine(fileName);

          if (System.IO.File.Exists(fileName)) {
            //XmlSerializerオブジェクトを作成
            System.Xml.Serialization.XmlSerializer serializer = new System.Xml.Serialization.XmlSerializer(typeof(MotionSet_Xml));
            //読み込むファイルを開く
            System.IO.StreamReader sr = new System.IO.StreamReader(fileName, new System.Text.UTF8Encoding(false));

            //XMLファイルから読み込み、逆シリアル化する
            MSX = (MotionSet_Xml)serializer.Deserialize(sr);

            //ファイルを閉じる
            sr.Close();
            //Console.WriteLine("読み込み完了");
          }
        }

        //モーションセットをXMLファイルに保存する
        private void MotionSetSave() {

          // フォルダ確認
          if (!System.IO.Directory.Exists(@"Sybaris\UnityInjector\Config\VibeYourMaid\EditMotionSet\")) {
            //ない場合はフォルダ作成
            System.IO.DirectoryInfo di = System.IO.Directory.CreateDirectory(@"Sybaris\UnityInjector\Config\VibeYourMaid\EditMotionSet");
          }


          if (MSX.saveMotionSetName == "") {  //ボイスセット名が空白の場合保存しない
            msErrer = 1;

          } else {
            //保存先のファイル名
            string fileName = @"Sybaris\UnityInjector\Config\VibeYourMaid\EditMotionSet\ems_" + MSX.saveMotionSetName + @".xml";

            if (System.IO.File.Exists(fileName) && !ms_Overwrite) {  //上書きのチェック
              msErrer = 2;

            } else {

              //XmlSerializerオブジェクトを作成
              //オブジェクトの型を指定する
              System.Xml.Serialization.XmlSerializer serializer = new System.Xml.Serialization.XmlSerializer(typeof(MotionSet_Xml));

              //書き込むファイルを開く（UTF-8 BOM無し）
              System.IO.StreamWriter sw = new System.IO.StreamWriter(fileName, false, new System.Text.UTF8Encoding(false));

              //シリアル化し、XMLファイルに保存する
              serializer.Serialize(sw, MSX);
              //ファイルを閉じる
              sw.Close();

              ms_Overwrite = false;
              msErrer = 0;
            }
          }
        }

        //モーションセット再生処理 MotionSetChangeから呼ばれる
        private void MotionSetPlay(int maidID, Maid maid, MaidState maidState, string s, float t) {

          string motion = s.Replace("[S]", "").Replace("[L]", "").Replace("_ONCE_", "_once_");

          MotionAdjustDo(maidID, motion, true, -1);

          if (s.Contains("[S]") || motion.Contains("_once_")) {
            maidState.mOnceFlag = true;
            maidState.mOnceBack = motion;
            if (motion.Contains("_once_") && MotionOldCheck(motion.Replace("f_once_", "taiki_f")) != -1) {
              maidState.mOnceBack = motion.Replace("f_once_", "taiki_f");
            }
          } else {
            maidState.mOnceFlag = false;
            maidState.mOnceBack = "";
            if ( maidState.vStateMajor == 20 ) { //強度に合わせて変更
              motion = motion.Replace("_1", "_2");
            } else if ( maidState.vStateMajor == 30 ) {
              motion = motion.Replace("_1", "_3");
            }
          }

          MotionChange(maid, motion, !maidState.mOnceFlag, t, 1f);
          //サブメイドとのリンクは一旦解除 SubMotionChangeで設定される
          if (maidState.motionLinkID != -1) {
            foreach (int id in vmId) {
              if (maidsState[id].motionLinkID == maidID) maidsState[id].motionLinkID = -1;
            }
            maidState.motionLinkID = -1;
          }
          if (regSubMaidMotion.IsMatch(motion)) {
            SubMotionChange(maidID, motion, null, !maidState.mOnceFlag, t, 1f);
            if (maidState.motionLinkID != -1) {
              //サブメイドに前のUNZIPでリンクしていた男を削除
              if (cfgw.autoManEnabled) {
                for (int im = 0; im < SubMans.Length; im++) {
                  if (MansTg[im] == maidState.motionLinkID && isSubManVisible(im)) setSubManVisible(im, false);
                }
              }
            }
          }
          //男を自動表示
          AutoMansVisible(maidID, s);
          ManMotionChange(motion, maidID, !maidState.mOnceFlag, t, 1f);

          //タイマーリセット
          maidState.motionHoldTime = UnityEngine.Random.Range(200f,600f);
          maidState.voiceHoldTime = 0f;
          maidState.faceHoldTime = 0f;
          maidState.MouthHoldTime = 0f;

        }


        //Updadeから毎フレーム呼ばれる
        private void MotionSetChange(int maidID, Maid maid, MaidState maidState) {

          if (maidState.editMotionSetName == "") return;

          maidState.msTime1 -= timerRate;

          //シングルモーション後の処理 停止していたらループに戻す
          if (maidState.mOnceFlag) {
            Animation anim = maid.body0.GetAnimation();
            if (!anim.isPlaying) {
              maidState.msTime2 = 1f;
              maidState.mOnceFlag = false;
              if (maid.body0.m_Bones != null) { //エラー対策
                if (MotionOldCheckB(maidState.mOnceBack)) {
                  maid.CrossFadeAbsolute( maidState.mOnceBack, GameUty.FileSystemOld, false, true, false, 0f, 1f );
                } else {
                  maid.CrossFadeAbsolute( maidState.mOnceBack, GameUty.FileSystem, false, true, false, 0f, 1f );
                }
              }
            }
            return;
          }

          //カテゴリ変更 最初のモーションも再生
          if (maidState.msTime1 < 0) {

            //抜くを実行後は挿入するまで無効
            if (isRemovedMotion(maidState) && !isSumataMotion(maidState)) {
              maidState.msTime1 = 60f; //1秒後再チェック
              return;
            }

            //リンクしているサブメイドならスキップ
            if (isSubMotionMaid(maidState)) return;

            maidState.msCategory = UnityEngine.Random.Range(0, maidState.editMotionSet.Count);
            //タイマーセット
            maidState.msTime1 = UnityEngine.Random.Range(4000f, 6000f) + ((maidState.editMotionSet[maidState.msCategory].Count - 5) * 600);

            //強度に合わせてモーション名を変更
            string cMotion = maidState.editMotionSet[maidState.msCategory][0];
            if ( maidState.vStateMajor == 20 ) {
              cMotion = cMotion.Replace("_1", "_2");
            } else if ( maidState.vStateMajor == 30 ) {
              cMotion = cMotion.Replace("_1", "_3");
            }

            //モーションがないならモーション変更
            if (MotionOldCheck(cMotion) == -1) {
              Debug.LogError("  ランダムモーションなし : "+cMotion);
              maidState.msTime2 = 0;
              return;
            }

            string inMotion = MotionCheckTokusyu(maidState.editMotionSet[maidState.msCategory][0], sInMaidMotion); //挿入モーションがあるかチェック
            if (inMotion == "Non" || inMotion == maidState.inMotion) {
              //挿入モーションなし
              MotionSetPlay(maidID, maid, maidState, cMotion, cfgw.majFadeTime);
              maidState.msTime2 = 90f;

            } else {
              //挿入モーションあり
              maidState.motionHoldTime = UnityEngine.Random.Range(200f,600f);

              MotionAdjustDo(maidID, maidState.editMotionSet[maidState.msCategory][0], true, -1);

              MotionChange(maid, inMotion, false, cfgw.majFadeTime, 1f);
              // 終わったら再生する
              MotionChangeAf(maid, cMotion, true, cfgw.majFadeTime, 1f);

              //サブメイドとのリンクは一旦解除 SubMotionChangeで設定される
              if (maidState.motionLinkID != -1) {
                foreach (int id in vmId) {
                  if (maidsState[id].motionLinkID == maidID) maidsState[id].motionLinkID = -1;
                }
                maidState.motionLinkID = -1;
              }
              //百合・ハーレム相手のモーション変更
              if (regSubMaidMotion.IsMatch(inMotion)) {
                SubMotionChange(maidID, inMotion, cMotion, true, cfgw.majFadeTime, 1f);
                if (maidState.motionLinkID != -1) {
                  //サブメイドに前のUNZIPでリンクしていた男を削除
                  if (cfgw.autoManEnabled) {
                    for (int im = 0; im < SubMans.Length; im++) {
                      if (MansTg[im] == maidState.motionLinkID && isSubManVisible(im)) setSubManVisible(im, false);
                    }
                  }
                  //モーション変更時間をメインと合わせる
                  maidsState[maidState.motionLinkID].motionHoldTime = maidState.motionHoldTime;
                }
              }

              //男の自動表示
              AutoMansVisible(maidID, cMotion);
              ManMotionChange(inMotion, maidID, false,cfgw.majFadeTime, 1f);
              ManMotionChangeAf(cMotion, maidID, true, cfgw.majFadeTime, 1f);

              if (maidState.uDatsu == 2 && maj.hkupa1[maidState.motionID] > 50f) {
                maidState.uDatsuValue1 = 0f;
                maidState.uDatsu = 0;
                try { VertexMorph_FromProcItem(maid.body0, "pussy_uterus_prolapse", 0f); } catch { /*LogError(ex);*/ }
              }
              maidState.msTime2 = 600f;

              //タイマーリセット
              maidState.voiceHoldTime = 0f;
              maidState.faceHoldTime = 0f;
              maidState.MouthHoldTime = 0f;
            }
            maidState.inMotion = inMotion;
          }

          //カテゴリ内のモーション変更
          if (maidState.msTime2 < 0) {

            //抜くを実行後は挿入するまで無効 素股中は除く
            if (isRemovedMotion(maidState) && !isSumataMotion(maidState)) {
              maidState.msTime2 = 60f; //1秒後
              return;
            }

            //リンクしているサブメイドならスキップ
            if (isSubMotionMaid(maidState)) return;

            int i = UnityEngine.Random.Range(0, maidState.editMotionSet[maidState.msCategory].Count);
            string motion = maidState.editMotionSet[maidState.msCategory][i];
            //モーションがない
            if (MotionOldCheck(motion) == -1) {
              Debug.LogError("  ランダムモーションなし : "+motion);
              maidState.msTime2 = 60; //1秒後
              return;
            }
            MotionSetPlay(maidID, maid, maidState, motion, cfgw.majFadeTime);

            maidState.msTime2 = UnityEngine.Random.Range(1500f, 2000f);
            if (maidState.msTime1 < maidState.msTime2) maidState.msTime1 = maidState.msTime2 - 10f;
          }

          maidState.msTime2 -= timerRate;

        }

        private void MotionSetClear(int maidID) {
          MaidState maidState = maidsState[maidID];
          maidState.editMotionSetName = "";
          maidState.editMotionSet = new List<List<string>>();
          maidState.msTime1 = 0f;
          maidState.msTime2 = 0f;
          maidState.msCategory = 0;
          maidState.mOnceFlag = false;
          maidState.mOnceBack = "";
        }


      //モーションセット関係終了----------------------------




      //-------------------------------------------------
      //演出関係-----------------------------------------

        //スクリプトコールバックの入れ替え @AddPrefabChara 他への影響もあるので濫用しない
        //尿と潮を置き換えない場合はデフォルトのTagAddPrefabCharaを呼び出す (他のプラグインでも置き換えしている状況は想定していない)
        public bool DummyAddPrefabChara(KagTagSupport tag_data, BaseKagManager baseKag)
        {
          string name = tag_data.GetTagProperty("src").AsString();
          string bone = tag_data.GetTagProperty("bone").AsString();

          Debug.Log("[VibeYourMaid] DummyAddPrefabChara : "+name+" , "+bone);
          //尿入れ替え
          if (name == "Particle/pNyou_cm3D2") {
            MaidState maidState = getTagMaidState(tag_data);
            if (maidState != null) {
              float nr = UnityEngine.Random.Range(50f, maidState.nyoVolume);
              EffectNyo(maidState.maid, maidState, nr, true);
              return true;
            }
          }
          //潮入れ替え
          else if (name == "Particle/pSio2_cm3D2") {
            MaidState maidState = getTagMaidState(tag_data);
            if (maidState != null) {
              maidState.fSio = true;
              maidState.sioTime = Time.time + cfgw.orgazmSioNextMin; //潮吹き終了時間 2秒後
              maidState.sioTime2 = 0; //待ち時間なし
              maidState.sioVolume = 0;  //OrgasmProcessでの潮吹き判定はリセット
              maidState.sioCount = cfgw.ScriptReplaceSioCount; //連続で出す
              EffectSio(maidState.maid, maidState);
              return true;
            }
          }

          //デフォルトのCallbackを実行
          return baseKag.TagAddPrefabChara(tag_data);
        }

        MaidState getTagMaidState(KagTagSupport tag_data)
        {
          if (tag_data.IsValid("maid")) {
            int maid_no = tag_data.GetTagProperty("maid").AsInteger();
            Maid maid = GameMain.Instance.CharacterMgr.GetMaid(maid_no);
            foreach (MaidState maidState in maidsState) {
              if (maidState.maid == maid) return maidState;
            }
          }
          return null;
        }

        //吐息 夜伽では事前にYotogiPlayManager.breatheObjectsが生成される影響でコマンドが選択できなくなるので無効 → 標準の夜伽の機能で興奮値200以上で表示される
        private void EffectToiki(Maid maid, MaidState maidState) {

          if (!maidState.fToiki1) {
            if (maidState.kaikanLevel > 3) {
              //吐息無効なら非表示
              if (vSceneLevel == 14) { //夜伽ではエラーになるので無効
                GameObject obj = maid.GetPrefab("夜伽_吐息");
                if (obj) obj.SetActive(cfgw.ToikiEnabled);
              } else {
                if (cfgw.ToikiEnabled) maid.AddPrefab("Particle/pToiki", "夜伽_吐息", "Bip01 Head", new Vector3(0.042f, 0.076f, 0f), new Vector3(-90f, 90f, 0f));
              }
              maidState.fToiki1 = true;
            }
          } else {
            if (maidState.vStateMajor == 10) {
              if (vSceneLevel == 14) { //夜伽ではエラーになるので無効
                GameObject obj = maid.GetPrefab("夜伽_吐息");
                if (obj) obj.SetActive(false);
              } else {
                maid.DelPrefab("夜伽_吐息");
              }
              maidState.fToiki1 = false;
            }
          }

          if (vSceneLevel != 14) { //夜伽以外で追加
            if (!maidState.fToiki2) {
              if (maidState.kaikanLevel > 6) {
                //吐息無効なら非表示
                if (cfgw.ToikiEnabled) maid.AddPrefab("Particle/pToiki", "夜伽_吐息2", "Bip01 Head", new Vector3(0.042f, 0.076f, 0f), new Vector3(-90f, 90f, 0f));
                maidState.fToiki2 = true;
              }
            } else {
              maid.DelPrefab("夜伽_吐息2");
              maidState.fToiki2 = false;
            }
          }
        }


        //愛液 夜伽では事前にYotogiPlayManager.loveLiquidObjectsが生成される影響でコマンドが選択できなくなるので無効 → 標準の夜伽の機能で興奮値100以上で表示される
        private void EffectAieki(Maid maid, MaidState maidState) {

          if (!maidState.fAieki1) {
            if (maidState.exciteLevel > 1) {
              if (vSceneLevel == 14) { //夜伽ではエラーになるので無効
                GameObject obj = maid.GetPrefab("夜伽_愛液1");
                if (obj) obj.SetActive(cfgw.AiekiEnabled);
              } else {
                if (cfgw.AiekiEnabled) maid.AddPrefab("Particle/pPistonEasy_cm3D2", "夜伽_愛液1", "_IK_vagina", new Vector3(0f, 0f, 0.01f), new Vector3(0f, -180f, 90f));
              }
              setAiekiPrefab(maid.GetPrefab("夜伽_愛液1"));
              maidState.fAieki1 = true;
            }
          } else {
            if (maidState.exciteLevel <= 1 || maidState.vStateMajor == 10 || maidState.vStateMajor == 40) {
              if (vSceneLevel == 14) { //夜伽ではエラーになるので無効
                GameObject obj = maid.GetPrefab("夜伽_愛液1");
                if (obj) obj.SetActive(false);
              } else {
                maid.DelPrefab("夜伽_愛液1");
              }
              maidState.fAieki1 = false;
            }
          }

          if (!maidState.fAieki2) {
            if (maidState.exciteLevel > 2) {
              if (vSceneLevel == 14) { //夜伽ではエラーになるので無効
                GameObject obj = maid.GetPrefab("夜伽_愛液2");
                if (obj) obj.SetActive(cfgw.AiekiEnabled);
              } else {
                if (cfgw.AiekiEnabled) maid.AddPrefab("Particle/pPistonNormal_cm3D2", "夜伽_愛液2", "_IK_vagina", new Vector3(0f, 0f, 0.01f), new Vector3(0f, -180f, 90f));
              }
              setAiekiPrefab(maid.GetPrefab("夜伽_愛液2"));
              maidState.fAieki2 = true;
            }
          } else {
            if (maidState.exciteLevel <= 2 || maidState.vStateMajor == 10 || maidState.vStateMajor == 40) {
              if (vSceneLevel == 14) { //夜伽ではエラーになるので無効
                GameObject obj = maid.GetPrefab("夜伽_愛液2");
                if (obj) obj.SetActive(false);
              } else {
                maid.DelPrefab("夜伽_愛液2");
              }
              maidState.fAieki2 = false;
            }
          }

          if (!maidState.fAieki3) {
            if (maidState.exciteLevel > 3) {
              if (vSceneLevel == 14) { //夜伽ではエラーになるので無効
                GameObject obj = maid.GetPrefab("夜伽_愛液3");
                if (obj) obj.SetActive(cfgw.AiekiEnabled);
              } else {
                if (cfgw.AiekiEnabled) maid.AddPrefab("Particle/pPistonHard_cm3D2", "夜伽_愛液3", "_IK_vagina", new Vector3(0f, 0f, 0.01f), new Vector3(0f, -180f, 90f));
              }
              setAiekiPrefab(maid.GetPrefab("夜伽_愛液3"));
              maidState.fAieki3 = true;
            }
          } else {
            if (maidState.exciteLevel <= 3 || maidState.vStateMajor == 10 || maidState.vStateMajor == 40) {
              if (vSceneLevel == 14) { //夜伽ではエラーになるので無効
                GameObject obj = maid.GetPrefab("夜伽_愛液3");
                if (obj) obj.SetActive(false);
              } else {
                maid.DelPrefab("夜伽_愛液3");
              }
              maidState.fAieki3 = false;
            }
          }

        }
        //愛液のPrefabを調整
        private void setAiekiPrefab(GameObject prefab)
        {
          if (prefab) {
            float xyScale = UnityEngine.Random.Range(0.9f, 1.1f);
            prefab.transform.localScale = new Vector3(cfgw.AiekiScale[0]*xyScale, cfgw.AiekiScale[1]*xyScale, cfgw.AiekiScale[2]*UnityEngine.Random.Range(0.9f, 1.1f)); //スケール変更
            foreach (ParticleSystem particle in prefab.GetComponentsInChildren<ParticleSystem>()) {
              var main = particle.main;
              main.scalingMode = ParticleSystemScalingMode.Hierarchy; //スケールを親から引き継ぐ
              if (cfgw.AiekiGravity >= 0) main.gravityModifier = cfgw.AiekiGravity; //重力
              if (cfgw.AiekiDuration >= 0) main.duration = cfgw.AiekiDuration; //時間
            }
          }
        }

        //おしっこ volumeは判定用で噴出量には影響しない
        private void EffectNyo(Maid maid, MaidState maidState, float volume, bool force) {

          if (!cfgw.NyoEnabled) return;

          //尿が吹き終わるまで次の再生をしないなら終了
          if (!force && cfgw.NyoWaitPlaying) {
            if (maid.GetPrefab("pNyou_cm3D2")) return;
          }

          float hValue = GetBlendValues(maid.body0, "body", "kupa");
          //尿道が下にある場合の追加補正
          Vector3 vec = maid.body0.Pelvis.rotation * Vector3.up; //仰向 vec.y=1 俯せ vec.y=-1
          float yOffset = Math.Max(0, - vec.y * cfgw.NyoInvertOffsetY);

          //床に当たり判定を配置して有効化
          if (cfgw.NyoCollisionTypeWorld && cfgw.NyoHeightFix) addFloorCollider(maid, cfgw.NyoFloorColliderTime);

          maid.DelPrefab("pNyou_cm3D2");
          //maid.AddPrefab("Particle/pNyou_cm3D2", "pNyou_cm3D2", "_IK_vagina", new Vector3(0f, -0.047f, 0.011f), new Vector3(20.0f, -180.0f, 180.0f));
          maid.AddPrefab("Particle/pNyou_cm3D2", "pNyou_cm3D2", "_IK_vagina", new Vector3(0f, -(cfgw.NyoOffsetY + hValue*cfgw.NyoKupaMove + yOffset), cfgw.NyoOffsetZ), new Vector3(20.0f, -180.0f, 180.0f)); //仰向けでの右手座標(左後奥が正)
          GameMain.Instance.SoundMgr.PlaySe("SE011.ogg", false);
          if (cfgw.NyoHeightFix || cfgw.NyoCollisionTypeWorld) {
            GameObject prefab = maid.GetPrefab("pNyou_cm3D2");
            if (prefab) {
              Renderer r = prefab.GetComponent<Renderer>();
              if (r && r.material) r.material.renderQueue = cfgw.NyoRenderQueue;
              float floor = maid.body0.BoneHitHeightY;
              foreach (ParticleSystem particle in prefab.GetComponentsInChildren<ParticleSystem>()) {
                ParticleSystem.CollisionModule collision = particle.collision;
                if (cfgw.NyoCollisionTypeWorld) {
                  collision.type = ParticleSystemCollisionType.World;
                  collision.collidesWith = cfgw.NyoCollisionLayer; //胸用のコライダーのみに限定
                } else { //平面との衝突の場合は高さ設定
                  for (int j=0; j<collision.maxPlaneCount; j++) {
                    Transform plane = collision.GetPlane(j);
                    if (plane) {
                      //Debug.Log("Nyo plane["+j+"] pos=("+plane.position.x+","+plane.position.y+","+plane.position.z+") floor="+floor);
                      plane.position = new Vector3(plane.position.x, floor, plane.position.z);
                    }
                  }
                }
              }
            }
          }

          maidState.nyoTotal1 += 1;
          maidState.nyoTotal2 += volume;
          maidState.nyoVolume -= volume;

          maidState.nyodoValue = 1f;
          maidState.nyodoTime = Time.time + 0.4f; //0.4秒後から開く
          maidState.nyodoKeepTime = Time.time + 5f; //5秒後から閉じる
          EffectNyodo(maid, maidState);
        }


        //潮吹き
        private void EffectSio(Maid maid, MaidState maidState) {

          if (!maidState.fSio || !cfgw.SioEnabled) return;

          if (maidState.sioTime <= Time.time) {
            //Debug.Log("maidState.sioCount="+maidState.sioCount);
            //潮吹き終了
            if (maidState.sioCount <= 1) {
              maidState.fSio = false;
              maidState.sioTotal1 += 1; //エロステータス加算
            } else {
              //連続で出す
              maidState.sioCount--;
              maidState.sioTime = Time.time + cfgw.orgazmSioNextMin;
              maidState.sioTime2 = 0;
              EffectSio(maid, maidState);
            }
          } else if (maidState.sioTime2 <= Time.time) {
            //前回の潮削除
            maid.DelPrefab("pSio2_cm3D2");
            float duration = cfgw.SioDuration * UnityEngine.Random.Range(0.9f, 1.1f);  //噴出時間
            float hValue = GetBlendValues(maid.body0, "body", "kupa");
            string sioParticle = cfgw.SioParticle;
            
            //秒数に応じてランダムに変更
            float sioRandom = UnityEngine.Random.Range(0f, 100f);
            foreach (float[] timeRate in cfgw.SioTimeRate) { //小さい順 0は最初に設定してデフォルトとする
              if (timeRate[0] <= 0 || maidState.sioTimeLast > Time.time - timeRate[0]) {
                //乱数が指定%より小さければ変更
                if (cfgw.SioParticle3 != "" && sioRandom < timeRate[2]) sioParticle = cfgw.SioParticle3; //潮3
                else if (cfgw.SioParticle2 != "" && sioRandom < timeRate[1]+timeRate[2]) sioParticle = cfgw.SioParticle2; //潮2
                if (timeRate[0] > 0) break; //0以外なら終了
              }
            }
            maidState.sioTimeLast = Time.time; //前回の潮吹き時間更新
            Debug.Log("Sio Particle="+sioParticle);

            //潮追加 名前は"pSio2_cm3D2"で共通
            Vector3 sioOffset = new Vector3(0f, -(cfgw.SioOffsetY + hValue*cfgw.SioKupaMove), cfgw.SioOffsetZ);

            float radiusScale = cfgw.SioCollisionRadiusScale;

            //コライダーと衝突する場合は重なっていたら潮の原点を奥に下げる オフセット後の位置でも重なっていたら下げない
            if (cfgw.SioCollisionTypeWorld) {
              //床に当たり判定を配置して有効化
              if (cfgw.SioHeightFix) addFloorCollider(maid, cfgw.SioFloorColliderTime);

              if (cfgw.SioCollisionOffsetZ > 0) {
                Transform tr = CMT.SearchObjName(maid.body0.m_trBones, "_IK_vagina", false);
                if (tr) {
                  Vector3 sioPos = tr.position + sioOffset;
                  //竿コライダーと重なっていたら突き抜けないように奥に下げる
                  Collider[] colliders = Physics.OverlapSphere(sioPos, cfgw.SioCollisionOffsetZ, 1<<MuneCollider.LAYER_NO); //半径10㎝以内の胸用のコライダー取得
                  float minDist = float.MaxValue;
                  foreach (Collider col in colliders) {
                    minDist = Math.Min(minDist, Vector3.Distance(sioPos, col.ClosestPoint(sioPos)));
                    //Debug.Log("Sio Collider layer="+col.gameObject.layer+" ClosestPoint dist="+Vector3.Distance(sioPos, col.ClosestPoint(sioPos)));
                  }
                  //コライダー表面まで最短距離に応じて潮原点を調整
                  if (minDist < cfgw.SioCollisionOffsetZ) {
                    float offsetZ = cfgw.SioCollisionOffsetZ - minDist;
                    //調整した原点とコライダーの距離を取得
                    Vector3 newPos = sioPos - tr.forward * offsetZ;
                    float newDist = float.MaxValue;
                    foreach (Collider col in colliders) {
                      newDist = Math.Min(newDist, Vector3.Distance(newPos, col.ClosestPoint(newPos)));
                    }
                    //調整後の原点とコライダーの距離が調整量の50%以上離れているなら調整実行
                    Debug.Log("Sio Collider minDist="+minDist+" offsetDist="+newDist);
                    if (newDist - minDist > offsetZ * 0.5f) {
                      sioOffset.z += offsetZ;
                      radiusScale = cfgw.SioCollisionOffsetRadiusScale;
                    } else {
                      radiusScale = cfgw.SioCollisionOffsetCancelRadiusScale;
                    }
                  }
                }
              }
            }
            maid.AddPrefab("Particle/"+sioParticle, "pSio2_cm3D2", "_IK_vagina", sioOffset, new Vector3(0f, 180.0f, 0f)); //仰向けでの右手座標(左後奥が正)
            GameObject prefab = maid.GetPrefab("pSio2_cm3D2");
            if (prefab) {
              Renderer r = prefab.GetComponent<Renderer>();
              if (r && r.material) r.material.renderQueue = cfgw.SioRenderQueue;
              float xyScale = UnityEngine.Random.Range(0.9f, 1.1f);
              prefab.transform.localScale = new Vector3(cfgw.SioScale[0]*xyScale, cfgw.SioScale[1]*xyScale, cfgw.SioScale[2]*UnityEngine.Random.Range(0.9f, 1.1f)); //スケール変更
              float floor = maid.body0.BoneHitHeightY;
              /*Transform footTm = maid.body0.FootStep; //足
              if (footTm) floor = Math.Min(floor, footTm.position.y-0.05f);*/
              foreach (ParticleSystem particle in prefab.GetComponentsInChildren<ParticleSystem>()) {
                ParticleSystem.MainModule main = particle.main;
                main.scalingMode = ParticleSystemScalingMode.Hierarchy; //スケールを親から引き継ぐ
                main.gravityModifier = cfgw.SioGravity; //重力減少
                main.duration = duration;
                ParticleSystem.CollisionModule collision = particle.collision;
                if (cfgw.SioCollisionDisabled) collision.enabled = false; //潮のコライダー無効
                else if (cfgw.SioCollisionTypeWorld) {
                  collision.type = ParticleSystemCollisionType.World;
                  collision.collidesWith = cfgw.SioCollisionLayer; //胸用のコライダーのみに限定
                  collision.bounceMultiplier = cfgw.SioCollisionBounceRate;
                  collision.dampenMultiplier = cfgw.SioCollisionDampenRate;
                  collision.radiusScale = radiusScale;
                } else if (cfgw.SioHeightFix) { //平面との衝突の場合は高さ設定
                  for (int j=0; j<collision.maxPlaneCount; j++) {
                    Transform plane = collision.GetPlane(j);
                    if (plane) {
                      //Debug.Log("Sio plane["+j+"] pos=("+plane.position.x+","+plane.position.y+","+plane.position.z+") floor="+floor);
                      plane.position = new Vector3(plane.position.x, floor, plane.position.z);
                    }
                  }
                }
              }
            } else {
              //追加されなかったらデフォルト潮
              maid.AddPrefab("Particle/pSio2_cm3D2", "pSio2_cm3D2", "_IK_vagina", new Vector3(0.006f, 0f, 0.03f), new Vector3(0f, 180.0f, 0f)); //左 後 奥
            }
            maidState.sioTime2 = Time.time + UnityEngine.Random.Range(cfgw.orgazmSioNextMin, cfgw.orgazmSioNextMax); //次の潮吹までの待ち時間
            //GameMain.Instance.SoundMgr.PlaySe("se061.ogg", false);

            maidState.sioTotal2 += duration;

            maidState.nyodoValue = 1f;
            maidState.nyodoTime = Time.time;
            maidState.nyodoKeepTime = Math.Max(maidState.nyodoKeepTime, Time.time + duration - 1.25f); //放尿時間も考慮
            EffectNyodo(maid, maidState);
          }
        }

        //床に当たり判定を配置して有効化 終了時間に無効化 すでにあったら位置変更してコルーチン再実行
        BoxCollider floorCollider = null;
        string floorColliderName = "ParticleFloorCollider";
        Coroutine disableFloorColliderCoroutine;
        float floorColliderEndTime = 0;

        private void addFloorCollider(Maid maid, float wait)
        {
          if (!maid.body0.m_trBones) return;

          //なければ生成 10x10m高さ10cmの立方体 レイヤ番号(27)
          GameObject floorColliderObj = GameObject.Find(floorColliderName);
          if (floorColliderObj == null) {
            floorColliderObj = GameObject.CreatePrimitive(PrimitiveType.Cube);
            floorColliderObj.name = floorColliderName;
            floorColliderObj.layer = MuneCollider.LAYER_NO;
            floorColliderObj.GetComponent<Renderer>().enabled = false;
            floorColliderObj.transform.localScale = new Vector3(cfgw.FloorColliderSize, 0.01f, cfgw.FloorColliderSize);
            floorCollider = floorColliderObj.AddComponent<BoxCollider>();
          }
          //有効化して位置を調整
          floorCollider.gameObject.SetActive(true);
          floorCollider.enabled = true;
          Vector3 pos = maid.body0.m_trBones.position;
          float height = maid.body0.BoneHitHeightY;
          if (maid.body0.BoneHitHeightY < -999f) height = 0;
          pos.y = height + cfgw.FloorColliderOffsetY - 0.005f; //厚み分下げる
          floorColliderObj.transform.position = pos;

          //床コライダー無効化コルーチン実行中
          if (disableFloorColliderCoroutine != null) {
            //コルーチン終了が指定時間より後ならそのままにして終了
            if (floorColliderEndTime >= Time.time + wait) return;
            //コルーチン停止
            StopCoroutine(disableFloorColliderCoroutine);
            disableFloorColliderCoroutine = null;
          }
          //床コライダー無効化コルーチン開始
          disableFloorColliderCoroutine = StartCoroutine(disableFloorCollider(wait));
          floorColliderEndTime = Time.time + wait;
        }
        //床コライダー無効化コルーチン
        private IEnumerator disableFloorCollider(float wait)
        {
          yield return new WaitForSeconds(wait); //待機
          if (floorCollider) {
            floorCollider.enabled = false;
            floorCollider.gameObject.SetActive(false);
          }
          disableFloorColliderCoroutine = null;
        }

        //尿道開度チェック LateUpdateから呼ばれる
        private void EffectNyodo(Maid maid, MaidState maidState) {
          if (maidState.nyodoTime > Time.time || maidState.nyodoValue <= 0.01f) return;

          float randomValue = 1f;
          if (maidState.nyodoKeepTime > Time.time) {
            randomValue = UnityEngine.Random.Range(0.6f, 1.0f);
          } else {
            //縮小
            maidState.nyodoValue *= 0.75f;
            //尿道が閉じきったら尿と潮のPrefabも削除
            if (maidState.nyodoValue <= 0.01f) {
              maid.DelPrefab("pNyou_cm3D2");
              maid.DelPrefab("pSio2_cm3D2");
            }
            //閉じる処理は0.1秒間隔
            maidState.nyodoTime = Time.time + 0.1f;
          }
          try {
            VertexMorph_FromProcItem(maid.body0, "nyodokupa", maidState.nyodoValue * randomValue);
          } catch { /*LogError(ex);*/ }
        }

        //射精
        private void EffectSyasei(int maidID, MaidState maidState, int mode, bool naka) {

          if (mode == 6) return;
          string[] marks = new string[] { "", "", ""};
          int i = 3;

          switch (mode) {
              default: //指定無し
                  if (naka) {
                    if (!maidState.analMode) {
                      marks = new string[] { "", "秘部", "秘部"};
                      i = 0;
                    }
                    if (maidState.analMode) {
                      marks = new string[] { "", "尻", "尻"};
                      i = 1;
                    }
                  }
                  else marks = new string[] { "太股", "腹" ,"胸"};
                  break;

              case 1: //挿入 前
                  if (naka) {
                    if (!maidState.analMode) {
                      marks = new string[] { "", "秘部", "秘部"};
                      i = 0;
                    }
                    if (maidState.analMode) {
                      marks = new string[] { "", "尻", "尻"};
                      i = 1;
                    }
                  }
                  else marks = new string[] { "太股", "腹" ,"胸"};
                  break;

              case 2: //挿入 後
                  if (naka) {
                    if (!maidState.analMode) {
                      marks = new string[] { "", "秘部", "秘部"};
                      i = 0;
                    }
                    if (maidState.analMode) {
                      marks = new string[] { "", "尻", "尻"};
                      i = 1;
                    }
                  }
                  else marks = new string[] { "太股", "尻" ,"背中"};
                  break;

              case 3: //フェラ
                  if (naka) {
                    marks = new string[] { "", "口元", "口元"};
                    i = 2;
                  }
                  else marks = new string[] { "顔", "顔", "胸"};
                  break;

              case 4: //手コキ
                  marks = new string[] { "顔", "胸", "腹"};
                  break;

              case 5: //足コキ
                  marks = new string[] { "太股", "太股", ""};
                  break;

              case 7: //アナル 前
                  if (naka) {
                    marks = new string[] { "", "尻", "尻"};
                    i = 1;
                  }
                  else marks = new string[] { "太股", "腹" ,"胸"};
                  break;

              case 8: //アナル 後
                  if (naka) {
                    marks = new string[] { "", "尻", "尻"};
                    i = 1;
                  }
                  else marks = new string[] { "太股", "尻" ,"背中"};
                  break;
          }

          StartCoroutine(EffectSyasei(maidID, maidState, marks, i));
        }


        private IEnumerator EffectSyasei(int maidID, MaidState maidState, string[] marks, int i) {

          maidState.syaseiTotal1[i] += 1;
          foreach (string m in marks) {
            yield return new WaitForSeconds (1f);  // 1秒待つ

            GameMain.Instance.SoundMgr.PlaySe("se016.ogg" , false);
            maidState.syaseiTotal2[i] += UnityEngine.Random.Range(1f,2f);
            if (m == "太股") {
              EffectSeieki(maidID, m);
              EffectSeieki(maidID, m);
              EffectSeieki(maidID, m);
            } else if (m == "背中" || m == "尻" || m == "腹" || m == "胸") {
              EffectSeieki(maidID, m);
              EffectSeieki(maidID, m);
            } else {
              EffectSeieki(maidID, m);
            }
          }

          //エロステータス更新
          SaveEroState(maidID);
        }

        private bool SyaseiCheck(int maidID, Maid maid, float check) {
          for (int im = 0; im < SubMans.Length; im++) {
            if (isSubManVisible(im) && MansTg[im] == maidID) {
              if (syaseiValue[im] >= check) {
                //メイドから1m以内だったら
                if (Vector3.Distance(maid.transform.position, getSubMan(im).transform.position) <= 1f) return true;
              }
            }
          }
          return false;
        }


        /// <summary>
        /// 男射精時にセットするぶっかけ位置情報クラス
        /// </summary>
        public class SeiekiInfo
        {
          private String slotName;
          private int matNo;
          private int layer;
          private String res;
          private int minX;
          private int maxX;
          private int minY;
          private int maxY;
          private float minRot;
          private float maxRot;
          private float minScale;
          private float maxScale;

          public SeiekiInfo(String slotName, int matNo, int layer, String res, int minX, int maxX, int minY, int maxY, float minRot, float maxRot, float minScale, float maxScale) {
            this.slotName = slotName;
            this.matNo = matNo;
            this.layer = layer;
            this.res = res;
            this.minX = minX;
            this.maxX = maxX;
            this.minY = minY;
            this.maxY = maxY;
            this.minRot = minRot;
            this.maxRot = maxRot;
            this.minScale = minScale;
            this.maxScale = maxScale;
          }


          public String SlotName {
            get { return this.slotName; }
          }
          public int MatNo {
            get { return this.matNo; }
          }
          public int Layer {
            get { return this.layer; }
          }
          public String Res {
            get { return this.res; }
          }

          public String GetFilName() {
            string[] strArray = this.res.Split(':');
            return "res:" + strArray[UnityEngine.Random.Range(0, strArray.Length)];
          }

          public int MinX {
            get { return this.minX; }
          }

          public int MaxX {
            get { return this.maxX; }
          }

          public int GetX() {
            return UnityEngine.Random.Range(this.minX, this.maxX);
          }

          public int MinY {
            get { return this.minY; }
          }

          public int MaxY {
            get { return this.maxY; }
          }

          public int GetY() {
            return (int)UnityEngine.Random.Range(this.minY, this.maxY);
          }

          public float MinRot {
            get { return this.minRot; }
          }

          public float MaxRot {
            get { return this.maxRot; }
          }

          public float GetRot() {
            return UnityEngine.Random.Range(this.minRot, this.maxRot);
          }

          public float MinScale {
            get { return this.minScale; }
          }

          public float MaxScale {
            get { return this.maxScale; }
          }

          public float GetScale() {
            return UnityEngine.Random.Range(this.minScale, this.maxScale);
          }
        }

        private static readonly List<SeiekiInfo> KaoMarks = new List<SeiekiInfo>() {
            new SeiekiInfo("head", 5, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003", 378, 452, 628, 820, 330, 360, 1.5f, 1.5f),
            new SeiekiInfo("head", 5, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r", 572, 646, 628, 820, 0, 30, 1.5f, 1.5f),
            new SeiekiInfo("head", 5, 18, "Seieki/spe004:Seieki/spe005", 429, 593, 575, 672, 340, 380, 1.5f, 1.5f),
            new SeiekiInfo("head", 5, 18, "Seieki/spe006:Seieki/spe007", 452, 572, 414, 566, 340, 380, 1.5f, 1.5f),
            new SeiekiInfo("head", 5, 18, "Seieki/spe001:Seieki/spe001r:Seieki/spe002:Seieki/spe002R:Seieki/spe004", 469, 558, 706, 864, 340, 380, 1.5f, 1.5f),
            new SeiekiInfo("head", 5, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003", 378, 452, 628, 820, 315, 405, 1.5f, 1.5f),
            new SeiekiInfo("head", 5, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r", 572, 646, 628, 820, 315, 405, 1.5f, 1.5f),
        };

        private static readonly List<SeiekiInfo> MuneMarks = new List<SeiekiInfo>() {
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe007:Seieki/spe008:Seieki/spe009", 412, 449, 428, 470, 10, 20, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe007:Seieki/spe008:Seieki/spe009", 397, 404, 444, 487, 340, 350, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r", 455, 492, 428, 470, 340, 350, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe007:Seieki/spe008:Seieki/spe009", 532, 569, 428, 470, 10, 20, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r", 575, 612, 428, 470, 340, 350, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe007:Seieki/spe008:Seieki/spe009", 620, 627, 444, 487, 340, 350, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe004:Seieki/spe005:Seieki/spe008:Seieki/spe008r:Seieki/spe010:Seieki/spe012:Seieki/spe012r", 509, 515, 420, 479, 350, 370, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe004:Seieki/spe011:Seieki/spe014", 415, 443, 492, 517, 350, 360, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe004r:Seieki/spe011r:Seieki/spe014r", 461, 500, 492, 517, 0, 10, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe004:Seieki/spe011:Seieki/spe014", 524, 563, 492, 517, 350, 360, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe004r:Seieki/spe011r:Seieki/spe014r", 581, 609, 492, 517, 0, 10, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe007:Seieki/spe008:Seieki/spe009", 412, 449, 428, 470, 10, 20, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r", 455, 492, 428, 470, 340, 350, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe007:Seieki/spe008:Seieki/spe009", 532, 569, 428, 470, 10, 20, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r", 575, 612, 428, 470, 340, 350, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe004:Seieki/spe005:Seieki/spe008:Seieki/spe008r:Seieki/spe010:Seieki/spe012:Seieki/spe012r", 509, 515, 420, 479, 350, 370, 0.5f, 0.5f),
        };

        private static readonly List<SeiekiInfo> KuchimotoMarks = new List<SeiekiInfo>() {
            new SeiekiInfo("head", 5, 18, "Seieki/spe001:Seieki/spe008:Seieki/spe009", 438, 483, 742, 857, 350, 360, 1.5f, 1.5f),
            new SeiekiInfo("head", 5, 18, "Seieki/spe001:Seieki/spe008:Seieki/spe009", 398, 442, 768, 876, 350, 360, 1.5f, 1.5f),
            new SeiekiInfo("head", 5, 18, "Seieki/spe001r:Seieki/spe008r:Seieki/spe009r", 541, 586, 742, 857, 0, 10, 1.5f, 1.5f),
            new SeiekiInfo("head", 5, 18, "Seieki/spe001r:Seieki/spe008r:Seieki/spe009r", 582, 626, 768, 876, 0, 10, 1.5f, 1.5f),
            new SeiekiInfo("head", 5, 18, "Seieki/spe006:Seieki/spe007", 473, 550, 826, 861, 0, 0, 1.5f, 1.5f),
        };

        private static readonly List<SeiekiInfo> SenakaMarks = new List<SeiekiInfo>() {
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe006r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r:Seieki/spe014r", 424, 479, 183, 236, 170, 210, 0.7f, 0.7f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe006r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r:Seieki/spe014r", 414, 469, 256, 314, 170, 210, 0.7f, 0.7f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe006r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r:Seieki/spe014r", 483, 503, 248, 318, 170, 190, 0.7f, 0.7f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe006r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r:Seieki/spe014r", 429, 458, 77, 169, 170, 190, 0.7f, 0.7f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe006r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r:Seieki/spe014r", 470, 499, 77, 169, 170, 190, 0.7f, 0.7f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe006:Seieki/spe007:Seieki/spe008:Seieki/spe009:Seieki/spe014", 521, 541, 248, 318, 170, 190, 0.7f, 0.7f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe006:Seieki/spe007:Seieki/spe008:Seieki/spe009:Seieki/spe014", 555, 610, 256, 314, 150, 190, 0.7f, 0.7f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe006:Seieki/spe007:Seieki/spe008:Seieki/spe009:Seieki/spe014", 545, 600, 183, 236, 150, 190, 0.7f, 0.7f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe006:Seieki/spe007:Seieki/spe008:Seieki/spe009:Seieki/spe014", 525, 554, 77, 169, 170, 190, 0.7f, 0.7f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe006:Seieki/spe007:Seieki/spe008:Seieki/spe009:Seieki/spe014", 566, 595, 77, 169, 170, 190, 0.7f, 0.7f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe004:Seieki/spe004r:Seieki/spe013:Seieki/spe013r:Seieki/spe014:Seieki/spe014r", 498, 525, 174, 241, 180, 180, 0.7f, 0.7f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe006r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r:Seieki/spe014r", 483, 503, 248, 318, 170, 190, 0.7f, 0.7f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe006:Seieki/spe007:Seieki/spe008:Seieki/spe009:Seieki/spe014", 521, 541, 248, 318, 170, 190, 0.7f, 0.7f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe004:Seieki/spe004r:Seieki/spe013:Seieki/spe013r:Seieki/spe014:Seieki/spe014r", 498, 525, 174, 241, 180, 180, 0.7f, 0.7f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe006r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r:Seieki/spe014r", 470, 499, 77, 169, 170, 190, 0.7f, 0.7f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe006:Seieki/spe007:Seieki/spe008:Seieki/spe009:Seieki/spe014", 525, 554, 77, 169, 170, 190, 0.7f, 0.7f),
        };

        private static readonly List<SeiekiInfo> SiriMarks = new List<SeiekiInfo>() {
            new SeiekiInfo("body", 0, 18, "Seieki/spe004:Seieki/spe005:Seieki/spe010:Seieki/spe012:Seieki/spe013", 229, 240, 870, 877, 325, 345, 0.6f, 0.6f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe004:Seieki/spe005r:Seieki/spe010r:Seieki/spe012:Seieki/spe013:Seieki/spe014", 215, 243, 836, 847, 0, 30, 0.4f, 0.4f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe004r:Seieki/spe005r:Seieki/spe010r:Seieki/spe012r:Seieki/spe013r:Seieki/spe014r", 257, 285, 828, 839, 330, 360, 0.4f, 0.4f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe006r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r:Seieki/spe011r:Seieki/spe014r", 218, 254, 778, 823, 330, 360, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe007r:Seieki/spe013r:Seieki/spe015:Seieki/spe015:Seieki/spe015:Seieki/spe015:Seieki/spe015:Seieki/spe015:Seieki/spe015", 232, 258, 760, 768, 330, 360, 0.4f, 0.4f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe004r:Seieki/spe005r:Seieki/spe010r:Seieki/spe012r:Seieki/spe013r", 784, 795, 870, 877, 15, 35, 0.6f, 0.6f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe004r:Seieki/spe005:Seieki/spe010:Seieki/spe012r:Seieki/spe013r:Seieki/spe014r", 781, 809, 836, 847, 360, 330, 0.4f, 0.4f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe004:Seieki/spe005:Seieki/spe010:Seieki/spe012:Seieki/spe013:Seieki/spe014", 739, 767, 828, 839, 0, 30, 0.4f, 0.4f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe006:Seieki/spe007:Seieki/spe008:Seieki/spe009:Seieki/spe011:Seieki/spe014r", 733, 769, 778, 817, 0, 30, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe007:Seieki/spe013:Seieki/spe015:Seieki/spe015:Seieki/spe015:Seieki/spe015:Seieki/spe015:Seieki/spe015:Seieki/spe015", 766, 792, 760, 768, 0, 30, 0.4f, 0.4f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe006r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r:Seieki/spe011r:Seieki/spe014r", 255, 291, 778, 817, 330, 360, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe006:Seieki/spe007:Seieki/spe008:Seieki/spe009:Seieki/spe011:Seieki/spe014r", 771, 806, 778, 823, 0, 30, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe006r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r:Seieki/spe011r:Seieki/spe014r", 263, 275, 850, 860, 330, 360, 0.4f, 0.4f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe006:Seieki/spe007:Seieki/spe008:Seieki/spe009:Seieki/spe011:Seieki/spe014r", 749, 761, 850, 860, 0, 30, 0.4f, 0.4f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe004:Seieki/spe005r:Seieki/spe010r:Seieki/spe012:Seieki/spe013:Seieki/spe014", 215, 243, 836, 847, 0, 30, 0.4f, 0.4f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe004r:Seieki/spe005r:Seieki/spe010r:Seieki/spe012r:Seieki/spe013r:Seieki/spe014r", 257, 285, 828, 839, 330, 360, 0.4f, 0.4f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe006r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r:Seieki/spe011r:Seieki/spe014r", 218, 254, 778, 823, 330, 360, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe007r:Seieki/spe013r:Seieki/spe015:Seieki/spe015:Seieki/spe015:Seieki/spe015:Seieki/spe015:Seieki/spe015:Seieki/spe015", 232, 258, 760, 768, 330, 360, 0.4f, 0.4f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe004r:Seieki/spe005:Seieki/spe010:Seieki/spe012r:Seieki/spe013r:Seieki/spe014r", 781, 809, 836, 847, 360, 330, 0.4f, 0.4f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe004:Seieki/spe005:Seieki/spe010:Seieki/spe012:Seieki/spe013:Seieki/spe014", 739, 767, 828, 839, 0, 30, 0.4f, 0.4f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe006:Seieki/spe007:Seieki/spe008:Seieki/spe009:Seieki/spe011:Seieki/spe014r", 733, 769, 778, 817, 0, 30, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe007:Seieki/spe013:Seieki/spe015:Seieki/spe015:Seieki/spe015:Seieki/spe015:Seieki/spe015:Seieki/spe015:Seieki/spe015", 766, 792, 760, 768, 0, 30, 0.4f, 0.4f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe006r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r:Seieki/spe011r:Seieki/spe014r", 255, 291, 778, 817, 330, 360, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe006:Seieki/spe007:Seieki/spe008:Seieki/spe009:Seieki/spe011:Seieki/spe014r", 771, 806, 778, 823, 0, 30, 0.5f, 0.5f),
        };

        private static readonly List<SeiekiInfo> HaraMarks = new List<SeiekiInfo>() {
            new SeiekiInfo("body", 0, 18, "Seieki/spe004:Seieki/spe004r:Seieki/spe005:Seieki/spe005r:Seieki/spe010:Seieki/spe010r:Seieki/spe012:Seieki/spe012r:Seieki/spe013:Seieki/spe013r", 466, 558, 712, 774, 350, 370, 1.0f, 1.0f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe007:Seieki/spe008:Seieki/spe009:Seieki/spe011:Seieki/spe014", 458, 489, 735, 801, 350, 370, 0.7f, 0.7f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe007:Seieki/spe008:Seieki/spe009:Seieki/spe011:Seieki/spe014", 412, 441, 722, 774, 350, 370, 0.7f, 0.7f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe007:Seieki/spe008:Seieki/spe009:Seieki/spe011:Seieki/spe014", 455, 482, 663, 705, 350, 370, 0.7f, 0.7f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe002:Seieki/spe002r:Seieki/spe007:Seieki/spe007r:Seieki/spe013:Seieki/spe013r", 466, 558, 808, 821, 350, 370, 0.6f, 0.6f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r:Seieki/spe011r:Seieki/spe014r", 535, 566, 735, 801, 350, 370, 0.7f, 0.7f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r:Seieki/spe011r:Seieki/spe014r", 583, 612, 722, 774, 350, 370, 0.7f, 0.7f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r:Seieki/spe011r:Seieki/spe014r", 542, 569, 663, 705, 350, 370, 0.7f, 0.7f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe001r:Seieki/spe002:Seieki/spe002r:Seieki/spe007:Seieki/spe007r:Seieki/spe008:Seieki/spe008r:Seieki/spe009:Seieki/spe009r:Seieki/spe011:Seieki/spe011r:Seieki/spe014:Seieki/spe014r", 501, 523, 655, 694, 350, 370, 0.7f, 0.7f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe007:Seieki/spe008:Seieki/spe009:Seieki/spe011:Seieki/spe014", 472, 494, 609, 648, 350, 370, 0.7f, 0.7f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r:Seieki/spe011r:Seieki/spe014r", 530, 552, 609, 648, 350, 370, 0.7f, 0.7f),
        };

        private static readonly List<SeiekiInfo> HutomomoMarks = new List<SeiekiInfo>() {
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe007:Seieki/spe009:Seieki/spe014", 97, 110, 73, 124, 0, 10, 0.6f, 0.6f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe006:Seieki/spe007:Seieki/spe008:Seieki/spe009:Seieki/spe011:Seieki/spe013:Seieki/spe014", 117, 130, 68, 119, 350, 360, 0.6f, 0.6f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe006r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r:Seieki/spe011r:Seieki/spe013r:Seieki/spe014r", 137, 150, 68, 119, 350, 370, 0.6f, 0.6f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe006r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r:Seieki/spe011r:Seieki/spe013r:Seieki/spe014r", 159, 172, 75, 126, 0, 10, 0.6f, 0.6f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe007r:Seieki/spe009r:Seieki/spe014r", 179, 192, 65, 116, 0, 10, 0.6f, 0.6f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe007:Seieki/spe009:Seieki/spe014", 114, 127, 127, 178, 0, 10, 0.6f, 0.6f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe006:Seieki/spe007:Seieki/spe008:Seieki/spe009:Seieki/spe014", 137, 150, 136, 187, 355, 360, 0.7f, 0.7f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe006r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r:Seieki/spe011r:Seieki/spe013r:Seieki/spe014r", 157, 170, 134, 182, 0, 10, 0.6f, 0.6f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe007:Seieki/spe009:Seieki/spe014", 121, 134, 184, 235, 10, 25, 0.6f, 0.6f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe006:Seieki/spe007:Seieki/spe008:Seieki/spe009:Seieki/spe014", 148, 161, 190, 241, 10, 20, 0.6f, 0.6f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe006r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r:Seieki/spe011r:Seieki/spe013r:Seieki/spe014r", 173, 186, 178, 229, 10, 20, 0.6f, 0.6f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe007:Seieki/spe009:Seieki/spe014", 134, 147, 249, 287, 350, 360, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe006r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r:Seieki/spe014r", 163, 176, 249, 287, 10, 20, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe007r:Seieki/spe009r:Seieki/spe014r", 190, 201, 129, 170, 0, 10, 0.6f, 0.6f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe007:Seieki/spe008:Seieki/spe009:Seieki/spe014", 230, 243, 44, 95, 350, 370, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe007:Seieki/spe008:Seieki/spe014", 258, 277, 34, 74, 340, 360, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe007:Seieki/spe008:Seieki/spe014", 255, 268, 80, 122, 350, 370, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe007:Seieki/spe008:Seieki/spe014", 267, 280, 125, 152, 350, 370, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe007:Seieki/spe008:Seieki/spe009:Seieki/spe014", 239, 248, 113, 142, 350, 370, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe008:Seieki/spe009:Seieki/spe014", 253, 261, 151, 181, 350, 370, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe007:Seieki/spe008:Seieki/spe009:Seieki/spe014", 225, 231, 125, 147, 350, 370, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe008:Seieki/spe014", 266, 285, 175, 213, 350, 370, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe007:Seieki/spe008:Seieki/spe014", 246, 259, 211, 247, 350, 370, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe007:Seieki/spe008:Seieki/spe014", 22, 29, 66, 122, 340, 360, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe007r:Seieki/spe009r:Seieki/spe014r", 914, 927, 73, 124, 350, 360, 0.6f, 0.6f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe006r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r:Seieki/spe011r:Seieki/spe013r:Seieki/spe014r", 894, 907, 68, 119, 0, 10, 0.6f, 0.6f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe006:Seieki/spe007:Seieki/spe008:Seieki/spe009:Seieki/spe011:Seieki/spe013r:Seieki/spe014", 874, 887, 68, 119, 350, 370, 0.6f, 0.6f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe006:Seieki/spe007:Seieki/spe008:Seieki/spe009:Seieki/spe011:Seieki/spe013:Seieki/spe014", 852, 865, 75, 126, 350, 360, 0.6f, 0.6f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe007:Seieki/spe009:Seieki/spe014", 832, 845, 65, 116, 350, 360, 0.6f, 0.6f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe007r:Seieki/spe009r:Seieki/spe014r", 897, 910, 127, 178, 350, 360, 0.6f, 0.6f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe006r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r:Seieki/spe014r", 874, 887, 136, 187, 0, 5, 0.7f, 0.7f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe006:Seieki/spe007:Seieki/spe008:Seieki/spe009:Seieki/spe011:Seieki/spe013:Seieki/spe014", 854, 867, 134, 182, 350, 360, 0.6f, 0.6f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe007r:Seieki/spe009r:Seieki/spe014r", 890, 903, 184, 235, 335, 350, 0.6f, 0.6f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe006r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r:Seieki/spe014r", 863, 876, 190, 241, 340, 350, 0.6f, 0.6f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe006:Seieki/spe007:Seieki/spe008:Seieki/spe009:Seieki/spe011:Seieki/spe013:Seieki/spe014", 838, 851, 178, 229, 340, 350, 0.6f, 0.6f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe007r:Seieki/spe009r:Seieki/spe014r", 877, 890, 249, 287, 0, 10, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe006:Seieki/spe007:Seieki/spe008:Seieki/spe009:Seieki/spe014", 848, 861, 249, 287, 340, 350, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe003:Seieki/spe007:Seieki/spe009:Seieki/spe014", 823, 834, 129, 170, 350, 360, 0.6f, 0.6f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r:Seieki/spe014r", 781, 794, 44, 95, 350, 370, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe007r:Seieki/spe008r:Seieki/spe014r", 747, 766, 34, 74, 0, 20, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe007r:Seieki/spe008r:Seieki/spe014r", 756, 769, 80, 122, 350, 370, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe007r:Seieki/spe008r:Seieki/spe014r", 744, 757, 125, 152, 350, 370, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r:Seieki/spe014r", 776, 785, 113, 142, 350, 370, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe008r:Seieki/spe009r:Seieki/spe014r", 763, 771, 151, 181, 350, 370, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe003r:Seieki/spe007r:Seieki/spe008r:Seieki/spe009r:Seieki/spe014r", 793, 799, 125, 147, 350, 370, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe008r:Seieki/spe014r", 739, 785, 175, 213, 350, 370, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe007r:Seieki/spe008r:Seieki/spe014r", 765, 778, 211, 247, 350, 370, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe007r:Seieki/spe008r:Seieki/spe014r", 995, 1002, 66, 122, 0, 20, 0.5f, 0.5f),
        };

        private static readonly List<SeiekiInfo> HibuMarks = new List<SeiekiInfo>() {
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe002:Seieki/spe009:Seieki/spe014", 472, 497, 874, 921, 355, 365, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001r:Seieki/spe002r:Seieki/spe009r:Seieki/spe014r", 527, 552, 874, 921, 355, 365, 0.5f, 0.5f),
            new SeiekiInfo("body", 0, 18, "Seieki/spe001:Seieki/spe001r:Seieki/spe002:Seieki/spe002r:Seieki/spe009:Seieki/spe009r:Seieki/spe014:Seieki/spe014r", 503, 520, 866, 906, 355, 365, 0.5f, 0.5f),
        };

        private void EffectSeieki(int maidID, string marks) {

          int random;
          SeiekiInfo info = null;
          Maid maid = stockMaids[maidID].mem;

          switch (marks) {
              case "顔":
                   random = UnityEngine.Random.Range(0, KaoMarks.Count);
                   info = KaoMarks[random];
                   break;

              case "胸":
                   random = UnityEngine.Random.Range(0, MuneMarks.Count);
                   info = MuneMarks[random];
                   break;

              case "口元":
                   random = UnityEngine.Random.Range(0, KuchimotoMarks.Count);
                   info = KuchimotoMarks[random];
                   break;

              case "背中":
                   random = UnityEngine.Random.Range(0, SenakaMarks.Count);
                   info = SenakaMarks[random];
                   break;

              case "尻":
                   random = UnityEngine.Random.Range(0, SiriMarks.Count);
                   info = SiriMarks[random];
                   break;

              case "腹":
                   random = UnityEngine.Random.Range(0, HaraMarks.Count);
                   info = HaraMarks[random];
                   break;

              case "太股":
                   random = UnityEngine.Random.Range(0, HutomomoMarks.Count);
                   info = HutomomoMarks[random];
                   break;

              case "秘部":
                   random = UnityEngine.Random.Range(0, HibuMarks.Count);
                   info = HibuMarks[random];
                   break;

              default:
                   return;
          }


          int x = info.GetX();
          int y = info.GetY();
          float r = info.GetRot();
          float s = info.GetScale();
          String fileName = info.GetFilName();

          maid.body0.MulTexSet(
              info.SlotName,
              info.MatNo,
              "_MainTex",
              info.Layer,
              fileName,
              GameUty.SystemMaterial.Alpha,
              true,
              x, y, r, s,
              false,
              null,
              1f,
              1024);

          maid.body0.MulTexSet(
              info.SlotName,
              info.MatNo,
              "_ShadowTex",
              info.Layer,
              fileName,
              GameUty.SystemMaterial.Alpha,
              true,
              x, y, r, s,
              false,
              null,
              1f,
              1024);

          maid.body0.MulTexProc(info.SlotName);

        }

        //精液除去 顔
        private void RemoveSeiekiFace(Maid maid)
        {
          maid.body0.MulTexRemove("head", 5, "_MainTex", 18);
          maid.body0.MulTexRemove("head", 5, "_ShadowTex", 18);
          maid.body0.MulTexProc("head");
          maid.body0.MulTexRemove("head", 5, "_MainTex", 22);
          maid.body0.MulTexRemove("head", 5, "_ShadowTex", 22);
          maid.body0.MulTexProc("head");
          maid.body0.MulTexRemove("head", 5, "_MainTex", 23);
          maid.body0.MulTexRemove("head", 5, "_ShadowTex", 23);
          maid.body0.MulTexProc("head");
        }
        //精液除去 体
        private void RemoveSeiekiBody(Maid maid)
        {
          maid.body0.MulTexRemove("body", 0, "_MainTex", 18);
          maid.body0.MulTexRemove("body", 0, "_ShadowTex", 18);
          maid.body0.MulTexProc("body");
        }


        //瞳操作
        private void EffectAhe(Maid maid, MaidState maidState, float sp) {

          Vector3 vl;
          Vector3 vr;
          float aheValue3 = maidState.aheValue2;

          if (!cfgw.AheEnabled || maidState.vStateMajor == 10) {
            if (maidState.aheResetFlag) {
              vl = maid.body0.trsEyeL.localPosition;
              vr = maid.body0.trsEyeR.localPosition;
              maid.body0.trsEyeL.localPosition = new Vector3(vl.x, Math.Max((maidState.fAheDefEyeL + 0f)/fEyePosToSliderMul, 0f), vl.z);
              maid.body0.trsEyeR.localPosition = new Vector3(vr.x, Math.Min((maidState.fAheDefEyeR - 0f)/fEyePosToSliderMul, 0f), vr.z);
              maidState.fAheDefEyeL = -9999f;
              maidState.fAheDefEyeR = -9999f;
              maidState.aheResetFlag = false;
            }
            return;
          }

          if (maidState.fAheDefEyeL < -1000) maidState.fAheDefEyeL = maid.body0.trsEyeL.localPosition.y * fEyePosToSliderMul;
          if (maidState.fAheDefEyeR < -1000) maidState.fAheDefEyeR = maid.body0.trsEyeR.localPosition.y * fEyePosToSliderMul;

          if (maidState.orgasmCmb > 0) {
            if (maidState.boostValue - 15 > 0 && maidState.exciteLevel >= 2) {
              aheValue3 = maidState.aheValue2 + maidState.boostValue / 3;
              if (maidState.stunFlag) aheValue3 += 25;
            }
            if (aheValue3 > 60) aheValue3 = 60;

            if (maidState.aheValue < aheValue3) {
              maidState.aheValue += 0.1f * timerRate * sp;
            } else if (maidState.aheValue > aheValue3) {
              maidState.aheValue -= 0.1f * timerRate * sp;
            }
          } else if ((maidState.boostValue - 15 > 0 && maidState.exciteLevel >= 2) || maidState.stunFlag) {
            aheValue3 = maidState.boostValue / 2;
            if (maidState.stunFlag) aheValue3 += 25;

            if (maidState.aheValue < aheValue3) {
              maidState.aheValue += 0.1f * timerRate * sp;
            } else if (maidState.aheValue > aheValue3) {
              maidState.aheValue -= 0.1f * timerRate * sp;
            }
          } else if (maidState.aheValue > 0) {
            maidState.aheValue -= 0.05f * timerRate * sp;
          }

          if (maidState.aheValue < 0f) maidState.aheValue = 0f;

          vl = maid.body0.trsEyeL.localPosition;
          vr = maid.body0.trsEyeR.localPosition;
          maid.body0.trsEyeL.localPosition = new Vector3(vl.x, Math.Max((maidState.fAheDefEyeL + maidState.aheValue)/fEyePosToSliderMul, 0f), vl.z);
          maid.body0.trsEyeR.localPosition = new Vector3(vr.x, Math.Min((maidState.fAheDefEyeR - maidState.aheValue)/fEyePosToSliderMul, 0f), vr.z);

          if (!maidState.aheResetFlag) maidState.aheResetFlag = true;

        }


        //痙攣操作
        private void EffectGakupiku(Maid maid, MaidState maidState) {

          //リセットフラグが立っていて、痙攣中でなければ痙攣シェイプキーをリセット
          if (maidState.gakupikuResetFlag && (!maidState.gakupikuOn || !cfgw.OrgsmAnimeEnabled)) {
            try { VertexMorph_FromProcItem(maid.body0, "orgasm", 0f); } catch { /*LogError(ex);*/ }
            maidState.gakupikuResetFlag = false;
            maidState.gakupikuOn = false;
            maidState.gakupikuValue = 0f;
            return;
          }

          if (!cfgw.OrgsmAnimeEnabled) return;

          if (maidState.orgasmCmb > 3) { //絶頂痙攣 強
            if (!maidState.gakupikuOn) maidState.gakupikuOn = true;

            if (maidState.gakupikuTime <= 0){
              maidState.gakupikuFlag = !maidState.gakupikuFlag;
              if (maidState.gakupikuFlag) {
                maidState.gakupikuTime = UnityEngine.Random.Range(0, 120);
              } else {
                maidState.gakupikuTime = UnityEngine.Random.Range(0, 30);
              }

            } else {
              if (maidState.gakupikuFlag) {
                maidState.gakupikuValue = UnityEngine.Random.Range(-cfgw.orgasmValue3, cfgw.orgasmValue3);
              }
              maidState.gakupikuTime -= timerRate;
            }

          } else if (maidState.orgasmCmb > 0) { //絶頂痙攣 弱
            if (!maidState.gakupikuOn) maidState.gakupikuOn = true;

            if (maidState.gakupikuTime <= 0) {
              maidState.gakupikuFlag = !maidState.gakupikuFlag;
              if (maidState.gakupikuFlag) {
                maidState.gakupikuTime = UnityEngine.Random.Range(0, 120);
              } else {
                maidState.gakupikuTime = UnityEngine.Random.Range(0, 30);
              }

            } else {
              if (maidState.gakupikuFlag) {
                maidState.gakupikuValue = UnityEngine.Random.Range(-cfgw.orgasmValue2, cfgw.orgasmValue2);
              }
              maidState.gakupikuTime -= timerRate;
            }

          } else if (maidState.stunFlag) { //痙攣 放心中
            if (!maidState.gakupikuOn)maidState.gakupikuOn = true;

            if (maidState.gakupikuTime <= 0) {
              maidState.gakupikuFlag = !maidState.gakupikuFlag;
              if (maidState.gakupikuFlag) {
                maidState.gakupikuTime = UnityEngine.Random.Range(0, 40);
              } else {
                maidState.gakupikuTime = UnityEngine.Random.Range(0, 300);
              }

            } else {
              if (maidState.gakupikuFlag) {
                maidState.gakupikuValue = UnityEngine.Random.Range(-cfgw.orgasmValue3, cfgw.orgasmValue3);
              }
              maidState.gakupikuTime -= timerRate;
            }

          } else if (maidState.orgasmValue > 90) { //絶頂前痙攣
            if (!maidState.gakupikuOn) maidState.gakupikuOn = true;
            maidState.gakupikuValue = UnityEngine.Random.Range(-cfgw.orgasmValue1, cfgw.orgasmValue1);

          } else if (maidState.gakupikuOn) { //痙攣終了時の処理
            maidState.gakupikuOn = false;

          }

          //痙攣のシェイプキー操作を実行
          if (maidState.gakupikuOn) {
            try { VertexMorph_FromProcItem(maid.body0, "orgasm", maidState.gakupikuValue*0.01f); } catch { /*LogError(ex);*/ }
            if (!maidState.gakupikuResetFlag) maidState.gakupikuResetFlag = true;
          }

        }


        //勃起操作  mcは府k数メイドで分割処理している場合の分割数
        private void EffectBokki(Maid maid, MaidState maidState, int mc) {

          if (!cfgw.CliAnimeEnabled) {
            if (maidState.bokkiResetFlag) {
              try { VertexMorph_FromProcItem(maid.body0, "clitoris", 0f); } catch { /*LogError(ex);*/ }
              try { VertexMorph_FromProcItem(maid.body0, "pussy_clitoris_large", 0f); } catch { /*LogError(ex);*/ }
              try { VertexMorph_FromProcItem(maid.body0, "pussy_clitoris_penis", 0f); } catch { /*LogError(ex);*/ }

              try { VertexMorph_FromProcItem(maid.body0, "pussy_bira1", 0f); } catch { /*LogError(ex);*/ }
              try { VertexMorph_FromProcItem(maid.body0, "pussy_bira2", 0f); } catch { /*LogError(ex);*/ }
              try { VertexMorph_FromProcItem(maid.body0, "labiakupa", 0f); } catch { /*LogError(ex);*/ }
              try { VertexMorph_FromProcItem(maid.body0, "chikubi_bokki", 0f); } catch { /*LogError(ex);*/ }

              maidState.bokkiResetFlag = false;
            }
            return;
          }
          //if (maidState.vStateMajor == 10) return;
          if (maidState.bokkiValue1 == 0 && maidState.bokkiCliValue == 0) return; //bokkiValue1が時間経過で0になるまで動作させる

          float bokkiValueMax = Math.Min(100, 25 + maidState.boostValue * 3 + maidState.orgasmCount * 3);
          if (maidState.bokkiValue1 > bokkiValueMax) maidState.bokkiValue1 = bokkiValueMax;

          //クリ一時変更の値が大きければそちらに合わせて拡大
          if (maidState.bokkiValue1 < maidState.bokkiTempValue) {
            if (maidState.bokkiTempValue > maidState.bokkiCliValue) maidState.bokkiCliValue = Math.Min(maidState.bokkiTempValue, maidState.bokkiCliValue + cfgw.bokkiTempGrowSpeed * Time.deltaTime * mc);
          }
          //一時変更より大きくなっていたら縮小
          if (maidState.bokkiTempValue < maidState.bokkiCliValue) maidState.bokkiCliValue = Math.Max(0, maidState.bokkiCliValue - cfgw.bokkiTempGrowSpeed * Time.deltaTime * mc);
          //bokkiValue1より小さくはしない
          if (maidState.bokkiValue1 > maidState.bokkiCliValue) maidState.bokkiCliValue = maidState.bokkiValue1;
          
          float bokki = Math.Min(100f, maidState.bokkiCliValue * cfgw.clitorisMax * 0.01f);
          maidState.labiaValue = Math.Min(40f, bokki);

          try { 
          if (maidState.cliMode== 2) {
            float cliScale = maidState.cliScale + maidState.cliScale * cfgw.cliHidaiRate * maidState.cliHidai*0.01f;
            VertexMorph_FromProcItem(maid.body0, "pussy_clitoris_penis", Math.Min(1, (bokki*0.01f + maidState.gakupikuValue*0.0005f) * cliScale));
          } else if (maidState.cliMode== 1) {
            float cliScale = maidState.cliScale + maidState.cliScale * cfgw.cliHidaiRate * maidState.cliHidai*0.01f;
            VertexMorph_FromProcItem(maid.body0, "pussy_clitoris_large", Math.Min(1, (bokki*0.01f + maidState.gakupikuValue*0.001667f) * cliScale));
          } else {
            VertexMorph_FromProcItem(maid.body0, "clitoris", (bokki*0.01f * (1f - maidState.cliHidai*0.01f) + maidState.gakupikuValue*0.0025f) * maidState.cliScale);
            VertexMorph_FromProcItem(maid.body0, "pussy_clitoris_large", bokki*0.01f * maidState.cliHidai*0.01f * maidState.cliScale);
          }
          } catch { /*LogError(ex);*/ }

          try {
            VertexMorph_FromProcItem(maid.body0, "labiakupa", maidState.labiaValue*0.005f);
            VertexMorph_FromProcItem(maid.body0, "pussy_bira1", bokki*0.005f + maidState.gakupikuValue*0.0025f);
            VertexMorph_FromProcItem(maid.body0, "pussy_bira2", maidState.gakupikuValue*0.0025f + (1f + maidState.kupaWaveValue*0.0001f) * bokki*0.00333f);
           } catch { /*LogError(ex);*/ }

          if (maid.body0.GetMask(TBody.SlotID.bra)) {
            try { VertexMorph_FromProcItem(maid.body0, "chikubi_bokki", 0f); } catch { /*LogError(ex);*/ }
          } else {
            try { VertexMorph_FromProcItem(maid.body0, "chikubi_bokki", bokki*0.01f * maidState.chikubiHidai + maidState.gakupikuValue*0.0005f); } catch { /*LogError(ex);*/ }
          }
          if (!maidState.bokkiResetFlag) maidState.bokkiResetFlag = true;
        }

        //汗かき処理 1秒ごとに実行
        private void EffectAse(Maid maid, MaidState maidState) {

          if (maidState.aseTime >= Time.time) return;
          maidState.aseTime = Time.time + 1f; //1秒後

          if (!cfgw.aseAnimeEnabled) {
            if (maidState.aseResetFlag) {
              try { VertexMorph_FromProcItem(maid.body0, "dry", 1f); } catch { /*LogError(ex);*/ }
              try { VertexMorph_FromProcItem(maid.body0, "swet", 0f); } catch { /*LogError(ex);*/ }
              try { VertexMorph_FromProcItem(maid.body0, "swet_small", 0f); } catch { /*LogError(ex);*/ }
              try { VertexMorph_FromProcItem(maid.body0, "swet_tare", 0f); } catch { /*LogError(ex);*/ }
              try { VertexMorph_FromProcItem(maid.body0, "swet_big", 0f); } catch { /*LogError(ex);*/ }
              maidState.aseResetFlag = false;
            }
            return;
          }
          //if (maidState.vStateMajor == 10) return;

          //aseValue1 = (float)Math.Floor(110 - ((maidState.boostValue * 2) + (maidState.exciteValue / 360)));
          //dryが0だと大きすぎるので30程度になるように調整 boostValue:0～50 exciteValue:0～18000
          float aseValue1 = (float)Math.Floor(101 - ((maidState.boostValue * 0.6f) + (maidState.exciteValue * 0.002f)));
          float aseValue2 = (float)Math.Floor(Math.Sqrt((3000 - maidState.maidStamina) * 0.0333f)*10f); //スタミナが低い時の上昇量を上げる
          float aseValue3 = maidState.orgasmValue;
          #if EmpiresLife
          if (lifeStart > 0 && (bgID == 11 || bgID == 22 || bgID == 23) && aseValue1 > 20) aseValue1 = 20;
          #endif

          //一時変更の値が大きければそちらに合わせる
          aseValue1 = Math.Min(aseValue1, 100f-maidState.aseTempValue*0.7f); //100～30
          aseValue2 = Math.Max(aseValue2, maidState.aseTempValue);
          aseValue3 = Math.Max(aseValue3, maidState.aseTempValue);

          aseValue1 = Math.Min(100, Math.Max(cfgw.aseDryMin, aseValue1)); //dryの大きさを制限
          aseValue2 = Math.Min(100, Math.Max(0, aseValue2));
          aseValue3 = Math.Min(100, Math.Max(0, aseValue3));

          //変更がなければ処理しない
          if (maidState.ase1 == aseValue1 && maidState.ase2 == aseValue2 && maidState.ase3 == aseValue3) return;
          maidState.ase1 = aseValue1;
          maidState.ase2 = aseValue2;
          maidState.ase3 = aseValue3;

          #if DEBUG
          //Console.WriteLine("["+maid+"] aseValue1="+aseValue1+" aseValue2="+aseValue2+" aseValue3="+aseValue3);
          #endif
          try {
            VertexMorph_FromProcItem(maid.body0, "dry", aseValue1*0.01f);
            VertexMorph_FromProcItem(maid.body0, "swet", aseValue2*0.01f * cfgw.aseSwet);
            VertexMorph_FromProcItem(maid.body0, "swet_small", aseValue2*0.01f * cfgw.aseSwet); //swetに連動させる
            VertexMorph_FromProcItem(maid.body0, "swet_tare", aseValue3*0.01f * cfgw.aseSwetTare);
            VertexMorph_FromProcItem(maid.body0, "swet_big", aseValue3*0.01f * cfgw.aseSwetBig);
          } catch { /*LogError(ex);*/ }

          if (!maidState.aseResetFlag) maidState.aseResetFlag = true;
          //maidState.aseTime = UnityEngine.Random.Range(5, 10);
        }


        //秘部アニメ処理 アニメーションが有効ならfalse
        private bool EffectHibuAnime(int maidID, Maid maid, MaidState maidState) {

          bool disabled = false;
          if (!cfgw.hibuAnime1Enabled && (maidState.vStateMajor == 20 || maidState.vStateMajor == 30)) disabled = true;
          else if (!cfgw.hibuAnime2Enabled && maidState.vStateMajor == 40) disabled = true;
          else if (maidState.vStateMajor == 10 || maidState.vStateMajor == 50) disabled = true;

          //停止中だったら一時変更に合わせて変更 有効ならスライダーより大きい場合のみ広げる
          if (disabled) {
            //kupa
            if (maidState.hibuValue < maidState.hibuTempValue) {
              maidState.hibuValue = Math.Min(100f, maidState.hibuValue + cfgw.kupaTempOpenSpeed * Time.deltaTime);
              try { VertexMorph_FromProcItem(maid.body0, "kupa", maidState.hibuValue*0.01f); } catch { /*LogError(ex);*/ }
            } else if (maidState.hibuValue > maidState.hibuTempValue) {
              maidState.hibuValue = Math.Max(0f, maidState.hibuValue - cfgw.kupaTempCloseSpeed * Time.deltaTime);
              try { VertexMorph_FromProcItem(maid.body0, "kupa", maidState.hibuValue*0.01f); } catch { /*LogError(ex);*/ }
            }
            //anal
            if (maidState.analValue < maidState.analTempValue) {
              maidState.analValue = Math.Min(100f, maidState.analValue + cfgw.analTempOpenSpeed * Time.deltaTime);
              try { VertexMorph_FromProcItem(maid.body0, "analkupa", maidState.analValue*0.01f); } catch { /*LogError(ex);*/ }
            } else if (maidState.analValue > maidState.analTempValue) {
              maidState.analValue = Math.Max(0f, maidState.analValue - cfgw.analTempCloseSpeed * Time.deltaTime);
              try { VertexMorph_FromProcItem(maid.body0, "analkupa", maidState.analValue*0.01f); } catch { /*LogError(ex);*/ }
            }
            return false;
          }

          float hValue = maidState.hibuValue; //メイドの値を設定
          float aValue = maidState.analValue; //メイドの値を設定
          float uValue = 0f;
          float pikuValue = 0f;
          float pikuValue2 = 0f;

          float hibuSlider1Value = maidState.hibuSlider1Value;
          float analSlider1Value = maidState.analSlider1Value;
          float hibuSlider2Value = maidState.hibuSlider2Value;
          float analSlider2Value = maidState.analSlider2Value;

          
          bool bOsawariVA = false;
          bool bOsawariAN = false;
          if (cfgw.osawariEnabled) {
            bOsawariVA = osawari.isOsawari(maidID, "VA_");
            bOsawariAN = osawari.isOsawari(maidID, "AN_");
            if (bOsawariVA) {
                if (hibuSlider1Value < 20f) hibuSlider1Value = 20f;
                if (hibuSlider2Value < 20f) hibuSlider2Value = 20f;
            }
            if (bOsawariAN) {
                if (analSlider1Value < 10f) analSlider1Value = 10f;
                if (analSlider2Value < 10f) analSlider2Value = 10f;
            }
          }

          //一時変更の値が大きければそちらに合わせる
          if (!bOsawariVA) {
            hibuSlider1Value = Math.Max(hibuSlider1Value, maidState.hibuTempValue);
            hibuSlider2Value = Math.Max(hibuSlider2Value, maidState.hibuTempValue);
          }
          if (!bOsawariAN) {
            analSlider1Value = Math.Max(analSlider1Value, maidState.analTempValue);
            analSlider2Value = Math.Max(analSlider2Value, maidState.analTempValue);
          }

          if (maidState.pikuTime <= 0) {
            maidState.pikuFlag = !maidState.pikuFlag;
            if (maidState.pikuFlag) { //ピク実行時間設定
              if (maidState.vStateMajor == 20 || maidState.vStateMajor == 30) maidState.pikuTime = UnityEngine.Random.Range(0, 90);
              if (maidState.vStateMajor == 40) maidState.pikuTime = UnityEngine.Random.Range(0, 60);
            } else { //ピク待機時間設定
              if (maidState.vStateMajor == 20 || maidState.vStateMajor == 30) maidState.pikuTime = UnityEngine.Random.Range(30, 210);
              if (maidState.vStateMajor == 40) maidState.pikuTime = UnityEngine.Random.Range(30, 90);
            }
          } else {
            maidState.pikuTime -= timerRate;
          }

          if (cfgw.hibuAnime1Enabled && (maidState.vStateMajor == 20 || maidState.vStateMajor == 30)) {
            if (maidState.hibuValue < hibuSlider1Value) {
              if (maidState.kupaOpenTime < Time.time) { //待ち時間対応
                maidState.hibuValue += cfgw.kupaOpenSpeed * Time.deltaTime;
                if (maidState.hibuValue > hibuSlider1Value) maidState.hibuValue = hibuSlider1Value;
              }
            }
            if (maidState.hibuValue > hibuSlider1Value) {
              maidState.hibuValue -= cfgw.kupaCloseSpeed * Time.deltaTime;
              if (maidState.hibuValue < hibuSlider1Value) maidState.hibuValue = hibuSlider1Value;
            }

            if (maidState.uDatsu != 0) { //子宮脱時
              maidState.hibuValue -= maidState.uDatsuValue1;
              if (maidState.hibuValue < 0) maidState.hibuValue = 0;
            }
            hValue = maidState.hibuValue + maidState.kupaWaveValue*0.01f * cfgw.kupaWave;

            if (maidState.analValue < analSlider1Value) {
              if (maidState.analOpenTime < Time.time) { //待ち時間対応
                maidState.analValue += cfgw.analOpenSpeed * Time.deltaTime;
                if (maidState.analValue > analSlider1Value) maidState.analValue = analSlider1Value;
              }
            }
            if (!bOsawariAN) { //おさわり時はスライダーに併せて縮めない
            if (maidState.analValue > analSlider1Value) {
              maidState.analValue -= cfgw.analCloseSpeed * Time.deltaTime;
              if (maidState.analValue < analSlider1Value) maidState.analValue = analSlider1Value;
            }
            }
            aValue = maidState.analValue + maidState.kupaWaveValue*0.01f * cfgw.kupaWave;

            if (maidState.pikuFlag) pikuValue2 = UnityEngine.Random.Range(0, 20);
            uValue = maidState.hibuValue * 0.5f + maidState.kupaWaveValue*0.01f * cfgw.kupaWave + pikuValue2;


          } else if (cfgw.hibuAnime2Enabled && maidState.vStateMajor == 40) {
            if (maidState.uDatsu == 0) {
              if (maidState.hibuValue > hibuSlider2Value) {
                maidState.hibuValue -= cfgw.kupaCloseSpeed * Time.deltaTime;
                if (maidState.hibuValue < hibuSlider2Value) maidState.hibuValue = hibuSlider2Value;
              }
              if (maidState.hibuValue < hibuSlider2Value) {
                maidState.hibuValue += cfgw.kupaOpenSpeed * Time.deltaTime;
                if (maidState.hibuValue > hibuSlider2Value) maidState.hibuValue = hibuSlider2Value;
              }
            } else {
              if (maidState.hibuValue > 0f) maidState.hibuValue -= cfgw.kupaCloseSpeed;
              if (maidState.hibuValue < 0f) maidState.hibuValue = 0f;
            }
            if (!bOsawariAN) { //おさわり時はスライダーに併せて縮めない
            if (maidState.analValue > analSlider2Value) {
              maidState.analValue -= cfgw.analCloseSpeed * Time.deltaTime;
              if (maidState.analValue < analSlider2Value) maidState.analValue = analSlider2Value;
            }
            }
            if (maidState.analValue < analSlider2Value) {
              maidState.analValue += cfgw.analOpenSpeed * Time.deltaTime;
              if (maidState.analValue > analSlider2Value) maidState.analValue = analSlider2Value;
            }

            if (maidState.pikuFlag) {
              pikuValue = UnityEngine.Random.Range(0, 5);
              pikuValue2 = UnityEngine.Random.Range(0, 20);
            }
            hValue = maidState.hibuValue + pikuValue;
            aValue = maidState.analValue + pikuValue;

            uValue = maidState.hibuValue * 0.5f + pikuValue2;

          }

          if (cfgw.osawariEnabled) {
            hValue = maidState.hibuValue + Math.Max(0, osawari.getMoveAtpY_VA(maidID)) * 20f; //おさわり時の処理
            aValue = maidState.analValue + Math.Max(0, osawari.getMoveAtpY_AN(maidID)) * 30f; //おさわり時の処理 初期値-15f分を加算
          }

          try { VertexMorph_FromProcItem(maid.body0, "kupa", hValue*0.01f); } catch { /*LogError(ex);*/ }
          try { VertexMorph_FromProcItem(maid.body0, "analkupa", aValue*0.01f); } catch { /*LogError(ex);*/ }
          try { VertexMorph_FromProcItem(maid.body0, "pussy_uterus_piku", uValue*0.01f); } catch { /*LogError(ex);*/ }

          return true;
        }

        //子宮脱アニメ処理
        private void EffectUterusDatsu(int maidID, Maid maid, MaidState maidState) {
          if (maidState.uDatsu == 0) return;

          if (maidState.uDatsu == 1) { //子宮脱判定
            if (maidState.boostBase + maidState.uDatsuStock < 65 || !cfgw.uDatsuEnabled) { //65以下なら子宮脱しない
              maidState.uDatsu = 3;

            } else if (maidState.uDatsuWait < 0) { //子宮脱開始
              maidState.uDatsuValue2 = maidState.boostBase + maidState.uDatsuStock;
              if (maidState.uDatsuValue2 > 100f) maidState.uDatsuValue2 = 100f;
              maidState.uDatsuStock = 0;
              maidState.uDatsu = 2;
              maidState.uDatsuWait = 90f;
              maidState.uDatsuTotal += 1; //子宮脱回数

            } else {
              maidState.uDatsuWait -= timerRate;
            }
          }

          if (maidState.uDatsu == 2) { //子宮脱アニメ処理
            if (maidState.uDatsuValue1 < maidState.uDatsuValue2) {
              maidState.uDatsuValue1 += (maidState.uDatsuValue2 - maidState.uDatsuValue1) * 0.015f + 0.001f;
              if (maidState.uDatsuValue1 > 90f) maidState.uDatsuValue1 = 90f;
              try { VertexMorph_FromProcItem(maid.body0, "pussy_uterus_prolapse", maidState.uDatsuValue1*0.01f + maidState.kupaWaveValue/10000f * 3 - osawari.getMoveAtpY_VA(maidID) * 0.1f); } catch { /*LogError(ex);*/ }

              if (maidState.uDatsuValue1 >= maidState.uDatsuValue2) {
                if (maidState.uDatsuValue2 > 20f) {
                  maidState.uDatsuValue2 -= UnityEngine.Random.Range(5, 10);
                }
              }

            } else if (maidState.uDatsuValue1 > maidState.uDatsuValue2) {
              maidState.uDatsuValue1 -= (maidState.uDatsuValue1 - maidState.uDatsuValue2) * 0.015f + 0.001f;
              try { VertexMorph_FromProcItem(maid.body0, "pussy_uterus_prolapse", maidState.uDatsuValue1*0.01f + maidState.kupaWaveValue/10000f * 3 - osawari.getMoveAtpY_VA(maidID) * 0.1f); } catch { /*LogError(ex);*/ }

              if (maidState.uDatsuValue1 <= maidState.uDatsuValue2) {
                if (maidState.uDatsuValue2 > 20f) {
                  maidState.uDatsuValue2 += UnityEngine.Random.Range(5, 10);
                }
              }
            }
          }

        }



        //メイドの口元変更
        private void MouthChange(Maid maid, MaidState maidState) {

          if (cfgw.MouthNomalEnabled || cfgw.MouthKissEnabled || cfgw.MouthFeraEnabled || cfgw.MouthZeccyouEnabled) {
            if (maidState.vStateMajor == 20 || maidState.vStateMajor == 30) {
              if (!cfgw.MouthKissEnabled && maidState.MouthMode == 1) maidState.MouthMode = 0;
              if (!cfgw.MouthFeraEnabled && maidState.MouthMode == 2) maidState.MouthMode = 0;
              if (!cfgw.MouthZeccyouEnabled && maidState.MouthMode >= 3) maidState.MouthMode = 0;
            } else if (maidState.vStateMajor == 40 && cfgw.MouthNomalEnabled) {
              if (maidState.stunFlag) maidState.MouthMode = 3;
              if (!maidState.stunFlag) maidState.MouthMode = 5;
            } else {
              return;
            }
          } else {
            return;
          }

          if (maid.body0.Face.morph == null) return; //エラー対策

          if (maidState.MouthMode != maidState.OldMode) {
            maidState.MouthHoldTime = 0;
            maidState.OldMode = maidState.MouthMode;
          }

          float maV = maid.body0.Face.morph.GetBlendValues((int) maid.body0.Face.morph.hash[(object) "moutha"]); //口あ
          float miV = maid.body0.Face.morph.GetBlendValues((int) maid.body0.Face.morph.hash[(object) "mouthi"]); //口い
          float mcV; //口う
          float msV; //笑顔
          float mdwV = maid.body0.Face.morph.GetBlendValues((int) maid.body0.Face.morph.hash[(object) "mouthdw"]); //口角上げ
          float mupV; //口角下げ


          if (maidState.MouthHoldTime <= 0) {
            maidState.MouthHoldTime = UnityEngine.Random.Range(180f,360f);

            switch (maidState.MouthMode) {
            case 0 : {  //通常時
              maidState.MaValue = UnityEngine.Random.Range(0f,30f) * 0.01f;
              maidState.MdwValue = UnityEngine.Random.Range(0f,30f) * 0.01f;
            }
            break;
            case 1 : {  //キス時
              maidState.MaValue = UnityEngine.Random.Range(20f,60f) * 0.01f;
              maidState.MdwValue = UnityEngine.Random.Range(0f,50f) * 0.01f;
            }
            break;
            case 2 : {  //フェラ時
              maidState.MaValue = UnityEngine.Random.Range(80f,100f) * 0.01f;
            }
            break;
            case 3 : {  //連続絶頂時１
              maidState.MaValue = UnityEngine.Random.Range(70f,90f) * 0.01f;
              maidState.MdwValue = UnityEngine.Random.Range(30f,90f) * 0.01f;
            }
            break;
            case 4 : {  //連続絶頂時２
              maidState.MiValue = UnityEngine.Random.Range(40f,60f) * 0.01f;
              maidState.MdwValue = UnityEngine.Random.Range(20f,40f) * 0.01f;
            }
            break;
            case 5 : {  //余韻時
              maidState.MaValue = UnityEngine.Random.Range(10f,40f) * 0.01f;
              maidState.MdwValue = UnityEngine.Random.Range(0f,30f) * 0.01f;
            }
            break;
            }

          }

          maidState.MouthHoldTime -= timerRate;
          if (maidState.MouthMode == 0 && !cfgw.MouthNomalEnabled) return;

          if (maidState.maVBack > maV) {
            maV += maidState.MaValue;
            maidState.maVBack = maV;
          }
          if (maidState.miVBack > miV) {
            miV += maidState.MiValue;
            maidState.miVBack = miV;
          }

          mcV = maid.body0.Face.morph.GetBlendValues((int) maid.body0.Face.morph.hash[(object) "mouthc"]);
          msV = maid.body0.Face.morph.GetBlendValues((int) maid.body0.Face.morph.hash[(object) "mouths"]);
          if (maidState.mdwVBack > mdwV) {
            mdwV += maidState.MdwValue;
            maidState.mdwVBack = mdwV;
          }
          mupV = maid.body0.Face.morph.GetBlendValues((int) maid.body0.Face.morph.hash[(object) "mouthup"]);


          //舌の動き処理
          //キス時とフェラ時
          if (maidState.MouthMode == 1 || maidState.MouthMode == 2) {
            if (maidState.TupValue < maidState.TupValue2) {
              maidState.TupValue += Time.deltaTime * 0.5f;
              if (maidState.TupValue >= maidState.TupValue2) maidState.TupValue2 = UnityEngine.Random.Range(0f,60f) * 0.01f;
            } else {
              maidState.TupValue -= Time.deltaTime * 0.5f;
              if (maidState.TupValue <= maidState.TupValue2 ) maidState.TupValue2 = UnityEngine.Random.Range(0f,60f) * 0.01f;
            }

            if (maidState.ToutValue < maidState.ToutValue2) {
              maidState.ToutValue += Time.deltaTime * 0.8f;
              if (maidState.ToutValue >= maidState.ToutValue2) maidState.ToutValue2 = UnityEngine.Random.Range(-20f,70f) * 0.01f;
            } else {
              maidState.ToutValue -= Time.deltaTime * 0.8f;
              if (maidState.ToutValue <= maidState.ToutValue2) maidState.ToutValue2 = UnityEngine.Random.Range(-20f,70f) * 0.01f;
            }

            if (maidState.TopenValue < maidState.TopenValue2) {
              maidState.TopenValue += Time.deltaTime * 0.5f;
              if (maidState.TopenValue >= maidState.TopenValue2) maidState.TopenValue2 = UnityEngine.Random.Range(0f,40f) * 0.01f;
            } else {
              maidState.TopenValue -= Time.deltaTime * 0.5f;
              if (maidState.TopenValue <= maidState.TopenValue2) maidState.TopenValue2 = UnityEngine.Random.Range(0f,40f) * 0.01f;
            }
          }
          //連続絶頂時
          else if (maidState.MouthMode == 3) {
            if (maidState.TupValue < maidState.TupValue2){
              maidState.TupValue += Time.deltaTime * 0.5f;
              if (maidState.TupValue >= maidState.TupValue2) maidState.TupValue2 = UnityEngine.Random.Range(0f,40f) * 0.01f;
            } else {
              maidState.TupValue -= Time.deltaTime * 0.5f;
              if (maidState.TupValue <= maidState.TupValue2) maidState.TupValue2 = UnityEngine.Random.Range(0f,40f) * 0.01f;
            }

            if (maidState.ToutValue < maidState.ToutValue2) {
              maidState.ToutValue += Time.deltaTime * 0.5f;
              if (maidState.ToutValue >= maidState.ToutValue2) maidState.ToutValue2 = UnityEngine.Random.Range(60f,100f) * 0.01f;
            } else {
              maidState.ToutValue -= Time.deltaTime * 0.5f;
              if (maidState.ToutValue <= maidState.ToutValue2) maidState.ToutValue2 = UnityEngine.Random.Range(60f,100f) * 0.01f;
            }

            if (maidState.TopenValue < maidState.TopenValue2) {
              maidState.TopenValue += Time.deltaTime * 0.5f;
              if (maidState.TopenValue >= maidState.TopenValue2) maidState.TopenValue2 = UnityEngine.Random.Range(0f,60f) * 0.01f;
            } else {
              maidState.TopenValue -= Time.deltaTime * 0.5f;
              if (maidState.TopenValue <= maidState.TopenValue2) maidState.TopenValue2 = UnityEngine.Random.Range(0f,60f) * 0.01f;
            }
          }


          //口元破綻の抑制とシェイプキー操作
          switch (maidState.MouthMode) {
          case 0 : {  //通常時
            try { VertexMorph_FromProcItem(maid.body0, "moutha", maV); } catch { }
            try { VertexMorph_FromProcItem(maid.body0, "mouthdw", mdwV); } catch { }
          }
          break;
          case 1 : {  //キス時
            if (miV > 0.1f) try { VertexMorph_FromProcItem(maid.body0, "mouthi", 0.1f); } catch { }
            if (maV > 0.6f) maV = 0.6f;
              try { VertexMorph_FromProcItem(maid.body0, "moutha", maV); } catch { }
              try { VertexMorph_FromProcItem(maid.body0, "mouthdw", mdwV); } catch { }
              try { VertexMorph_FromProcItem(maid.body0, "tangup", maidState.TupValue); } catch { }
              try { VertexMorph_FromProcItem(maid.body0, "tangout", maidState.ToutValue); } catch { }
              try { VertexMorph_FromProcItem(maid.body0, "tangopen", maidState.TopenValue); } catch { }
          }
          break;
          case 2 : {  //フェラ時
            if (miV > 0.1f) try { VertexMorph_FromProcItem(maid.body0, "mouthi", 0.1f); } catch { }
            if (mcV > 0.2f) try { VertexMorph_FromProcItem(maid.body0, "mouthc", 0.2f); } catch { }
            if (msV > 0.1f) try { VertexMorph_FromProcItem(maid.body0, "mouths", 0.1f); } catch { }
            if (mupV > 0.1f) try { VertexMorph_FromProcItem(maid.body0, "mouthup", 0.1f); } catch { }
            if (maV > 1.0f) maV = 1.0f;
              try { VertexMorph_FromProcItem(maid.body0, "moutha", maV); } catch { }
              try { VertexMorph_FromProcItem(maid.body0, "mouthdw", mdwV); } catch { }
              try { VertexMorph_FromProcItem(maid.body0, "tangup", maidState.TupValue); } catch { }
              try { VertexMorph_FromProcItem(maid.body0, "tangout", maidState.ToutValue); } catch { }
              try { VertexMorph_FromProcItem(maid.body0, "tangopen", maidState.TopenValue); } catch { }
          }
          break;
          case 3 : {  //連続絶頂時１
            if (miV > 0.1f) try { VertexMorph_FromProcItem(maid.body0, "mouthi", 0.1f); } catch { }
            if (mcV > 0.2f) try { VertexMorph_FromProcItem(maid.body0, "mouthc", 0.2f); } catch { }
            if (msV > 0.1f) try { VertexMorph_FromProcItem(maid.body0, "mouths", 0.1f); } catch { }
            if (mupV > 0.1f) try { VertexMorph_FromProcItem(maid.body0, "mouthup", 0.1f); } catch { }
            if (maV > 1.0f) maV = 1.0f;
              try { VertexMorph_FromProcItem(maid.body0, "moutha", maV); } catch { }
              try { VertexMorph_FromProcItem(maid.body0, "mouthdw", mdwV); } catch { }
              try { VertexMorph_FromProcItem(maid.body0, "tangup", maidState.TupValue); } catch { }
              try { VertexMorph_FromProcItem(maid.body0, "tangout", maidState.ToutValue); } catch { }
              try { VertexMorph_FromProcItem(maid.body0, "tangopen", maidState.TopenValue); } catch { }
          }
          break;
          case 4 : {  //連続絶頂時２
            if (mupV > 0f) try { VertexMorph_FromProcItem(maid.body0, "mouthup", 0f); } catch { }
            if (msV > 0.1f) try { VertexMorph_FromProcItem(maid.body0, "mouths", 0f); } catch { }
              try { VertexMorph_FromProcItem(maid.body0, "moutha", maV * 0.25f + 0.05f); } catch { }
              try { VertexMorph_FromProcItem(maid.body0, "mouthc", mcV * 0.25f); } catch { }
              try { VertexMorph_FromProcItem(maid.body0, "mouthi", miV); } catch { }
              try { VertexMorph_FromProcItem(maid.body0, "mouthdw", mdwV); } catch { }
              try { VertexMorph_FromProcItem(maid.body0, "mouthhe", 0.3f); } catch { }
              try { VertexMorph_FromProcItem(maid.body0, "toothoff", 0f); } catch { }
          }
          break;
          case 5 : {  //余韻時
              try { VertexMorph_FromProcItem(maid.body0, "moutha", maV); } catch { }
              try { VertexMorph_FromProcItem(maid.body0, "mouthdw", mdwV); } catch { }
          }
          break;
          }
        }

        //舌を引っ込める
        private void setTangOff(MaidState maidState)
        {
          //MouthChangeで変わらないようにmaidStateも0に
          maidState.TupValue = 0f;
          maidState.ToutValue = 0f;
          maidState.TopenValue = 0f;
          try {
            VertexMorph_FromProcItem(maidState.maid.body0, "tangup", 0);
            VertexMorph_FromProcItem(maidState.maid.body0, "tangout", 0);
            VertexMorph_FromProcItem(maidState.maid.body0, "tangopen", 0);
          } catch { }
        }

      //演出関係終了-------------------------------------




      //-------------------------------------------------
      //乳首設定関係---------------------------------

        //服装と乳首のチェック
        private int ChikubiCheck(Maid maid) {
          bool isWear = true;
          bool isOnepiece = true;
          bool isMizugi = true;
          bool isBra = true;


          //服装の状態チェック
          if (!maid.body0.GetMask(TBody.SlotID.wear) || maid.GetProp(MPN.wear).strTempFileName == "_I_wear_del.menu" || ( maid.GetProp(MPN.wear).strTempFileName == "" && maid.GetProp(MPN.wear).strFileName == "_I_wear_del.menu") ) isWear = false;
          if (!maid.body0.GetMask(TBody.SlotID.onepiece) || maid.GetProp(MPN.onepiece).strTempFileName == "_I_onepiece_del.menu" || ( maid.GetProp(MPN.onepiece).strTempFileName == "" && maid.GetProp(MPN.onepiece).strFileName == "_I_onepiece_del.menu") ) isOnepiece = false;
          if (!maid.body0.GetMask(TBody.SlotID.mizugi) || maid.GetProp(MPN.mizugi).strTempFileName == "_I_mizugi_del.menu" || ( maid.GetProp(MPN.mizugi).strTempFileName == "" && maid.GetProp(MPN.mizugi).strFileName == "_I_mizugi_del.menu") ) isMizugi = false;
          if (!maid.body0.GetMask(TBody.SlotID.bra) || maid.GetProp(MPN.bra).strTempFileName == "_i_bra_del.menu" || ( maid.GetProp(MPN.bra).strTempFileName == "" && maid.GetProp(MPN.bra).strFileName == "_i_bra_del.menu") ) isBra = false;

          if (isWear || isOnepiece || isMizugi || isBra) {
            return 0;
          } else {
            return 1;
          }
        }

        // 乳首設定反映
        void ChikubiSet(Maid maid, MaidState maidState, int cv) {

          float n_def = maidState.tits_nipple_def[cv];
          float kanbotsu_n = maidState.tits_chikubi_kanbotsu_n[cv];
          float kanbotsu_s = maidState.tits_chikubi_kanbotsu_s[cv];
          float kanbotsu_p = maidState.tits_chikubi_kanbotsu_p[cv];
          float bokki2 = 1f;
          if (cv == 1 && maidState.chikubiBokkiEnabled) {
            float bokki = maidState.bokkiValue1 * 0.01f;
            bokki2 += bokki * 0.4f;
            n_def += bokki * 1.4f;
            kanbotsu_n -= bokki * maidState.tits_chikubi_kanbotsu_n[cv];
            kanbotsu_s -= bokki * maidState.tits_chikubi_kanbotsu_s[cv];
            kanbotsu_p -= bokki * maidState.tits_chikubi_kanbotsu_p[cv];
          }

          try { VertexMorph_FromProcItem(maid.body0, "tits_chikubi_cow", maidState.tits_chikubi_cow[cv]); } catch { /*LogError(ex);*/ }
          try { VertexMorph_FromProcItem(maid.body0, "tits_chikubi_observe", maidState.tits_chikubi_observe[cv]); } catch { /*LogError(ex);*/ }
          try { VertexMorph_FromProcItem(maid.body0, "tits_chikubi_wide", maidState.tits_chikubi_wide[cv]); } catch { /*LogError(ex);*/ }
          try { VertexMorph_FromProcItem(maid.body0, "tits_chikubi_ultralong", maidState.tits_chikubi_ultralong[cv]); } catch { /*LogError(ex);*/ }
          try { VertexMorph_FromProcItem(maid.body0, "tits_chikubi_ultrawide", maidState.tits_chikubi_ultrawide[cv]); } catch { /*LogError(ex);*/ }
          try { VertexMorph_FromProcItem(maid.body0, "tits_chikubi_ultratare", maidState.tits_chikubi_ultratare[cv]); } catch { /*LogError(ex);*/ }

          try { VertexMorph_FromProcItem(maid.body0, "tits_nipple_long1", maidState.tits_nipple_long1[cv]); } catch { /*LogError(ex);*/ }
          try { VertexMorph_FromProcItem(maid.body0, "tits_nipple_long2", maidState.tits_nipple_long2[cv]); } catch { /*LogError(ex);*/ }
          try { VertexMorph_FromProcItem(maid.body0, "tits_nipple_wide", maidState.tits_nipple_wide[cv]); } catch { /*LogError(ex);*/ }
          try { VertexMorph_FromProcItem(maid.body0, "tits_nipple_kupa", maidState.tits_nipple_kupa[cv]); } catch { /*LogError(ex);*/ }
          try { VertexMorph_FromProcItem(maid.body0, "tits_munel_chippai", maidState.tits_munel_chippai[cv]); } catch { /*LogError(ex);*/ }

          try { VertexMorph_FromProcItem(maid.body0, "tits_chikubi_kanbotsu_n", kanbotsu_n); } catch { /*LogError(ex);*/ }
          try { VertexMorph_FromProcItem(maid.body0, "tits_chikubi_kanbotsu_s", kanbotsu_s); } catch { /*LogError(ex);*/ }
          try { VertexMorph_FromProcItem(maid.body0, "tits_chikubi_kanbotsu_p", kanbotsu_p); } catch { /*LogError(ex);*/ }
          try { VertexMorph_FromProcItem(maid.body0, "tits_nipple_def", n_def); } catch { /*LogError(ex);*/ }

          try { VertexMorph_FromProcItem(maid.body0, "tits_chikubi_def", maidState.tits_chikubi_def[cv] * bokki2); } catch { /*LogError(ex);*/ }
          try { VertexMorph_FromProcItem(maid.body0, "tits_chikubi_perky", maidState.tits_chikubi_perky[cv] * bokki2); } catch { /*LogError(ex);*/ }
          try { VertexMorph_FromProcItem(maid.body0, "tits_nipple_perky1", maidState.tits_nipple_perky1[cv] * bokki2); } catch { /*LogError(ex);*/ }
          try { VertexMorph_FromProcItem(maid.body0, "tits_nipple_perky2", maidState.tits_nipple_perky2[cv] * bokki2); } catch { /*LogError(ex);*/ }
          try { VertexMorph_FromProcItem(maid.body0, "tits_nipple_puffy", maidState.tits_nipple_puffy[cv] * bokki2); } catch { /*LogError(ex);*/ }
        }

        // 乳首設定の保存
        void ChikubiSave(int maidID, int cv) {
          Maid maid = stockMaids[maidID].mem;
          MaidState maidState = maidsState[maidID];

          if (maidState.chikubiEnabled) {
            ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "chikubiEnabled", "1", true);
          } else {
            ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "chikubiEnabled", "0", true);
          }

          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "tits_chikubi_def[" + cv + "]" , maidState.tits_chikubi_def[cv].ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "tits_chikubi_perky[" + cv + "]" , maidState.tits_chikubi_perky[cv].ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "tits_chikubi_cow[" + cv + "]" , maidState.tits_chikubi_cow[cv].ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "tits_chikubi_observe[" + cv + "]" , maidState.tits_chikubi_observe[cv].ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "tits_chikubi_wide[" + cv + "]" , maidState.tits_chikubi_wide[cv].ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "tits_chikubi_ultralong[" + cv + "]" , maidState.tits_chikubi_ultralong[cv].ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "tits_chikubi_ultrawide[" + cv + "]" , maidState.tits_chikubi_ultrawide[cv].ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "tits_chikubi_ultratare[" + cv + "]" , maidState.tits_chikubi_ultratare[cv].ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "tits_chikubi_kanbotsu_n[" + cv + "]" , maidState.tits_chikubi_kanbotsu_n[cv].ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "tits_chikubi_kanbotsu_s[" + cv + "]" , maidState.tits_chikubi_kanbotsu_s[cv].ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "tits_chikubi_kanbotsu_p[" + cv + "]" , maidState.tits_chikubi_kanbotsu_p[cv].ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "tits_nipple_def[" + cv + "]" , maidState.tits_nipple_def[cv].ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "tits_nipple_perky1[" + cv + "]" , maidState.tits_nipple_perky1[cv].ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "tits_nipple_perky2[" + cv + "]" , maidState.tits_nipple_perky2[cv].ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "tits_nipple_long1[" + cv + "]" , maidState.tits_nipple_long1[cv].ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "tits_nipple_long2[" + cv + "]" , maidState.tits_nipple_long2[cv].ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "tits_nipple_wide[" + cv + "]" , maidState.tits_nipple_wide[cv].ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "tits_nipple_puffy[" + cv + "]" , maidState.tits_nipple_puffy[cv].ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "tits_nipple_kupa[" + cv + "]" , maidState.tits_nipple_kupa[cv].ToString(), true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", "tits_munel_chippai[" + cv + "]" , maidState.tits_munel_chippai[cv].ToString(), true);

        }

        // 乳首設定の読込
        void ChikubiLoad(int maidID, int cv) {
          Maid maid = stockMaids[maidID].mem;
          MaidState maidState = maidsState[maidID];

          if (ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "chikubiEnabled", "0") == "0") {
            maidState.chikubiEnabled = false;
          } else {
            maidState.chikubiEnabled = true;
          }

          if (ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "tits_chikubi_def[" + cv + "]", "0") != "") {

            maidState.tits_chikubi_def[cv] = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "tits_chikubi_def[" + cv + "]", "0"));
            maidState.tits_chikubi_perky[cv] = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "tits_chikubi_perky[" + cv + "]", "0"));
            maidState.tits_chikubi_cow[cv] = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "tits_chikubi_cow[" + cv + "]", "0"));
            maidState.tits_chikubi_observe[cv] = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "tits_chikubi_observe[" + cv + "]", "0"));
            maidState.tits_chikubi_wide[cv] = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "tits_chikubi_wide[" + cv + "]", "0"));
            maidState.tits_chikubi_ultralong[cv] = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "tits_chikubi_ultralong[" + cv + "]", "0"));
            maidState.tits_chikubi_ultrawide[cv] = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "tits_chikubi_ultrawide[" + cv + "]", "0"));
            maidState.tits_chikubi_ultratare[cv] = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "tits_chikubi_ultratare[" + cv + "]", "0"));
            maidState.tits_chikubi_kanbotsu_n[cv] = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "tits_chikubi_kanbotsu_n[" + cv + "]", "0"));
            maidState.tits_chikubi_kanbotsu_s[cv] = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "tits_chikubi_kanbotsu_s[" + cv + "]", "0"));
            maidState.tits_chikubi_kanbotsu_p[cv] = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "tits_chikubi_kanbotsu_p[" + cv + "]", "0"));
            maidState.tits_nipple_def[cv] = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "tits_nipple_def[" + cv + "]", "0"));
            maidState.tits_nipple_perky1[cv] = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "tits_nipple_perky1[" + cv + "]", "0"));
            maidState.tits_nipple_perky2[cv] = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "tits_nipple_perky2[" + cv + "]", "0"));
            maidState.tits_nipple_long1[cv] = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "tits_nipple_long1[" + cv + "]", "0"));
            maidState.tits_nipple_long2[cv] = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "tits_nipple_long2[" + cv + "]", "0"));
            maidState.tits_nipple_wide[cv] = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "tits_nipple_wide[" + cv + "]", "0"));
            maidState.tits_nipple_puffy[cv] = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "tits_nipple_puffy[" + cv + "]", "0"));
            maidState.tits_nipple_kupa[cv] = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "tits_nipple_kupa[" + cv + "]", "0"));
            maidState.tits_munel_chippai[cv] = floatCnv(ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", "tits_munel_chippai[" + cv + "]", "0"));

          }

        }


        // 乳首設定のリセット
        void ChikubiReset(int maidID, int cv) {
            MaidState maidState = maidsState[maidID];

            maidState.tits_chikubi_def[cv] = 0;
            maidState.tits_chikubi_perky[cv] = 0;
            maidState.tits_chikubi_cow[cv] = 0;
            maidState.tits_chikubi_observe[cv] = 0;
            maidState.tits_chikubi_wide[cv] = 0;
            maidState.tits_chikubi_ultralong[cv] = 0;
            maidState.tits_chikubi_ultrawide[cv] = 0;
            maidState.tits_chikubi_ultratare[cv] = 0;
            maidState.tits_chikubi_kanbotsu_n[cv] = 0;
            maidState.tits_chikubi_kanbotsu_s[cv] = 0;
            maidState.tits_chikubi_kanbotsu_p[cv] = 0;
            maidState.tits_nipple_def[cv] = 0;
            maidState.tits_nipple_perky1[cv] = 0;
            maidState.tits_nipple_perky2[cv] = 0;
            maidState.tits_nipple_long1[cv] = 0;
            maidState.tits_nipple_long2[cv] = 0;
            maidState.tits_nipple_wide[cv] = 0;
            maidState.tits_nipple_puffy[cv] = 0;
            maidState.tits_nipple_kupa[cv] = 0;
            maidState.tits_nipple_kupa[cv] = 0;

        }


        // 乳首設定のコピー
        void ChikubiCopy(int maidID, int a, int b) {
            MaidState maidState = maidsState[maidID];

            maidState.tits_chikubi_def[a] = maidState.tits_chikubi_def[b];
            maidState.tits_chikubi_perky[a] = maidState.tits_chikubi_perky[b];
            maidState.tits_chikubi_cow[a] = maidState.tits_chikubi_cow[b];
            maidState.tits_chikubi_observe[a] = maidState.tits_chikubi_observe[b];
            maidState.tits_chikubi_wide[a] = maidState.tits_chikubi_wide[b];
            maidState.tits_chikubi_ultralong[a] = maidState.tits_chikubi_ultralong[b];
            maidState.tits_chikubi_ultrawide[a] = maidState.tits_chikubi_ultrawide[b];
            maidState.tits_chikubi_ultratare[a] = maidState.tits_chikubi_ultratare[b];
            maidState.tits_chikubi_kanbotsu_n[a] = maidState.tits_chikubi_kanbotsu_n[b];
            maidState.tits_chikubi_kanbotsu_s[a] = maidState.tits_chikubi_kanbotsu_s[b];
            maidState.tits_chikubi_kanbotsu_p[a] = maidState.tits_chikubi_kanbotsu_p[b];
            maidState.tits_nipple_def[a] = maidState.tits_nipple_def[b];
            maidState.tits_nipple_perky1[a] = maidState.tits_nipple_perky1[b];
            maidState.tits_nipple_perky2[a] = maidState.tits_nipple_perky2[b];
            maidState.tits_nipple_long1[a] = maidState.tits_nipple_long1[b];
            maidState.tits_nipple_long2[a] = maidState.tits_nipple_long2[b];
            maidState.tits_nipple_wide[a] = maidState.tits_nipple_wide[b];
            maidState.tits_nipple_puffy[a] = maidState.tits_nipple_puffy[b];
            maidState.tits_nipple_kupa[a] = maidState.tits_nipple_kupa[b];
            maidState.tits_munel_chippai[a] = maidState.tits_munel_chippai[b];


        }


      //乳首関係終了-------------------------------------




      //-------------------------------------------------
      //シェイプキー関係---------------------------------

        static HashSet<TMorph> m_NeedFixTMorphs = new HashSet<TMorph>();

        //シェイプキー操作
        //戻り値はsTagの存在有無にしているので必要に応じて変更してください
        static public void VertexMorph_FromProcItem(TBody body, string sTag, float f)
        {
          //if (!body || sTag == null || sTag == "") return;
          if (!body) return;

          //bool result = false;
          for (int i = 0, cnt = body.goSlot.Count; i < cnt; i++) {
            TMorph morph = body.goSlot[i].morph;
            if (morph != null && morph.Contains(sTag)) {
              //result = true;
              morph.SetBlendValues((int)morph.hash[sTag], f);
              if (!VibeYourMaid.m_NeedFixTMorphs.Contains(morph)) {
                VibeYourMaid.m_NeedFixTMorphs.Add(morph);
              }
            }
          }
          //return result;
        }

        //シェイプキー操作Fix(基本はUpdate等の最後に一度呼ぶだけで良いはず）
        public void VertexMorph_FixBlendValues()
        {
          foreach (TMorph tm in m_NeedFixTMorphs) {
            tm.FixBlendValues();
          }
          m_NeedFixTMorphs.Clear();
        }

        //シェイプキー取得
        public float GetBlendValues(TBody body, string slot, string sTag)
        {
          TBodySkin skin = body.GetSlot(slot);
          if (skin != null) {
            TMorph morph = skin.morph;
            if (morph != null && morph.Contains(sTag)) {
              return morph.GetBlendValues((int)morph.hash[sTag]);
            }
          }
          return 0f;
        }

	      //シェイプキーが存在するかのチェック
        private bool isExistVertexMorph(TBody body, string sTag) {
            
          for (int i = 0, cnt = body.goSlot.Count; i < cnt; i++) {
            TMorph morph = body.goSlot[i].morph;
            if (morph != null) {
              if (morph.Contains(sTag)) {
                return true;
              }
            }
          }
          return false;
        }

        //kupaウェイブ
        private void ShapeKeyKupaWave(MaidState maidState, float min, float max, float sp) {

          sp *= Time.deltaTime * ShapeKeySpeedRate;

          if (maidState.kupaWaveValue > max) {
            maidState.kupaWaveRe = -1f;
          } else if (maidState.kupaWaveValue < min) {
            maidState.kupaWaveRe = 1f;
          }

          maidState.kupaWaveValue = maidState.kupaWaveValue + sp * maidState.kupaWaveRe;
        }

        //シェイプウェイブ
        private void ShapeKeyWave(Maid maid, MaidState maidState, string[] name, string[] name2, float min, float max, float sp) {

          sp *= Time.deltaTime * ShapeKeySpeedRate;

          if (maidState.shapeKeyWaveValue > max) {
            maidState.shapeKeyWaveRe = -1f;
          } else if (maidState.shapeKeyWaveValue < min) {
            maidState.shapeKeyWaveRe = 1f;
          }

          maidState.shapeKeyWaveValue = maidState.shapeKeyWaveValue + sp * maidState.shapeKeyWaveRe;

          foreach (string n in name) {
            try { VertexMorph_FromProcItem(maid.body0, n, maidState.shapeKeyWaveValue*0.01f); } catch { /*LogError(ex);*/ }
          }

          float rValue = max - maidState.shapeKeyWaveValue;
          foreach (string n2 in name2) {
            try { VertexMorph_FromProcItem(maid.body0, n2, rValue*0.01f); } catch { /*LogError(ex);*/ }
          }
        }

        //シェイプ増加
        private void ShapeKeyIncrease(Maid maid, MaidState maidState, string[] name, float max, float sp) {

          sp *= Time.deltaTime * ShapeKeySpeedRate;

          maidState.shapeKeyIncreaseValue = maidState.shapeKeyIncreaseValue + sp;

          if (maidState.shapeKeyIncreaseValue > max) {
            maidState.shapeKeyIncreaseValue = 0f;
          } else if (maidState.shapeKeyIncreaseValue < 0f) {
            maidState.shapeKeyIncreaseValue = max;
          }

          foreach (string n in name) {
            try { VertexMorph_FromProcItem(maid.body0, n, maidState.shapeKeyIncreaseValue*0.01f); } catch { /*LogError(ex);*/ }
          }
        }

        //シェイプランダム
        private void ShapeKeyRandam(int maidID, Maid maid, MaidState maidState, string[] name, float min, float max) {

          maidState.shapeKeyRandomDelta -= timerRate;

          if (maidState.shapeKeyRandomDelta > 0) return;
          maidState.shapeKeyRandomDelta = 0.1f;

          foreach (string n in name) {
            try { VertexMorph_FromProcItem(maid.body0, n, UnityEngine.Random.Range(min, max)*0.01f); } catch { /*LogError(ex);*/ }
          }
        }

      //シェイプキー関係終了------------------------------


      //--------------------------------------------------
      //オートモード関係----------------------------------

        //責めの激しさを自動で変える
        public string[] autoSelectList = new string[]{ "オート無効" , "じっくり" , "激しく" , "ほどほど"};

        private void PowerAutoChange(int maidID, MaidState maidState) {

          if (maidState.pAutoSelect == 0) return;
          if (maidState.pAutoTime > 0 || (maidState.orgasmCmb != 0 && maidState.pAutoSelect == 2)) {
            maidState.pAutoTime -= timerRate;
            return;
          }

          if (maidState.vLevel == 0 || maidState.vLevel == 2) {
            maidState.vLevel = 1;

            if (maidState.pAutoSelect == 1) { //じっくりモード
              maidState.pAutoTime = UnityEngine.Random.Range(600, 1000);
            }
            else if (maidState.pAutoSelect == 2) { //激しくモード
              maidState.pAutoTime = UnityEngine.Random.Range(250, 400);
            }
            else if (maidState.pAutoSelect == 3) { //ほどほどモード
              maidState.pAutoTime = UnityEngine.Random.Range(400, 700);
            }

          } else if (maidState.vLevel == 1) {
            maidState.vLevel = 2;

            if (maidState.pAutoSelect == 1) { //じっくりモード
              if (UnityEngine.Random.Range(0, 100) < 15) {
                maidState.vLevel = 0;
                maidState.pAutoTime = UnityEngine.Random.Range(250, 600);
              } else {
                maidState.pAutoTime = UnityEngine.Random.Range(300, 480);
              }
            }
            else if (maidState.pAutoSelect == 2) { //激しくモード
              maidState.pAutoTime = UnityEngine.Random.Range(600, 1000);
            }
            else if (maidState.pAutoSelect == 3) { //ほどほどモード
              if (UnityEngine.Random.Range(0, 100) < 15) {
                maidState.vLevel = 0;
              }
              maidState.pAutoTime = UnityEngine.Random.Range(400, 700);
            }
          }

          //各メイドで呼ばれるのでサブメイドは変更しない
          /*foreach (int id in vmId) {
            if (id == maidID || !LinkMaidCheck(maidID, id)) continue;
            maidsState[id].vLevel = maidState.vLevel;
            maidsState[id].pAutoTime = maidState.pAutoTime;
          }*/

        }

        //顔と目線の向きを自動で変える
        private void EyeAutoChange(Maid maid, MaidState maidState) {

          if (!maidState.eAutoSelect) return;
          if (maidState.eAutoTime > 0) {
            maidState.eAutoTime -=  timerRate;
            return;
          }

          if (!DistanceToMaid(maidState, 8f)) {
            maid.body0.boEyeToCam = false;
            maid.body0.boHeadToCam = false;
            return;
          }

          if (UnityEngine.Random.Range(0, 100) < 50) maid.body0.boEyeToCam = !maid.body0.boEyeToCam;
          if (maid.body0.boHeadToCam) {
            if (UnityEngine.Random.Range(0, 100) < 70) maid.body0.boHeadToCam = !maid.body0.boHeadToCam;
          } else {
            if (UnityEngine.Random.Range(0, 100) < 30) maid.body0.boHeadToCam = !maid.body0.boHeadToCam;
          }

          if (maidState.stunFlag) maid.body0.boEyeToCam = false;
          if (maidState.stunFlag || maidState.bIsBlowjobing == 2 || maidState.bIsBlowjobing == 1) maid.body0.boHeadToCam = false;

          maidState.eAutoTime = UnityEngine.Random.Range(400, 600);

        }

      //オートモード関係終了------------------------------


      //-------------------------------------------------
      //外部データ読み込み関係---------------------------------

        //XMLファイルのリストアップ処理
        private List<string> bvsFiles = new List<string>();
        private List<string> evsFiles = new List<string>();
        private List<string> emsFiles = new List<string>();
        private List<string> cdsFiles = new List<string>();
        private void XmlFilesCheck(){

          List<string> _files = new List<string>();
          string fileName = "";
          string[] files;

          //基本ボイスセットのフォルダ確認
          if (System.IO.Directory.Exists(@"Sybaris\UnityInjector\Config\VibeYourMaid\BasicVoiseSet\")) {
            _files.Clear();
            files = Directory.GetFiles(@"Sybaris\UnityInjector\Config\VibeYourMaid\BasicVoiseSet\", "*.xml");

            foreach (string file in files) {
              fileName = Path.GetFileName(file);
              if (Regex.IsMatch(fileName, "^bvs_")) _files.Add(fileName);
            }
            bvsFiles = new List<string>(_files);
          }

          //エディットボイスセットのフォルダ確認
          if (System.IO.Directory.Exists(@"Sybaris\UnityInjector\Config\VibeYourMaid\EditVoiseSet\")) {
            _files.Clear();
            files = Directory.GetFiles(@"Sybaris\UnityInjector\Config\VibeYourMaid\EditVoiseSet\", "*.xml");

            foreach (string file in files) {
              fileName = Path.GetFileName(file);
              if (Regex.IsMatch(fileName, "^evs_")) _files.Add(fileName);
            }
            evsFiles = new List<string>(_files);
          }

          //エディットモーションセットのフォルダ確認
          if (System.IO.Directory.Exists(@"Sybaris\UnityInjector\Config\VibeYourMaid\EditMotionSet\")) {
            _files.Clear();
            files = Directory.GetFiles(@"Sybaris\UnityInjector\Config\VibeYourMaid\EditMotionSet\", "*.xml");

            foreach (string file in files) {
              fileName = Path.GetFileName(file);
              if (Regex.IsMatch(fileName, "^ems_")) _files.Add(fileName);
            }
            emsFiles = new List<string>(_files);
          }

          //共通衣装セットのフォルダ確認
          if (System.IO.Directory.Exists(@"Sybaris\UnityInjector\Config\VibeYourMaid\CommonDressSet\")) {
            _files.Clear();
            files = Directory.GetFiles(@"Sybaris\UnityInjector\Config\VibeYourMaid\CommonDressSet\", "*.xml");

            foreach (string file in files) {
              fileName = Path.GetFileName(file);
              if (Regex.IsMatch(fileName, "^cds_")) _files.Add(fileName);
            }
            cdsFiles = new List<string>(_files);
          }

        }

        //テキストファイル読み込み処理
        /*private List<string> ReadTextFaile(string file , string section) {

            System.IO.StreamReader sr = new System.IO.StreamReader(file);
            bool ReadFlag = false;
            List<string> _ListData = new List<string>();

            while (sr.Peek() > -1) {
              string m = sr.ReadLine();

              if (!ReadFlag && m == "[" + section + "]"){
                ReadFlag = true;
                continue;
              }
              if (ReadFlag && m == "[end]") {
                ReadFlag = false;
                break;
              }

              if (ReadFlag) {
                _ListData.Add(m);
              }

            }
            return _ListData;
        }*/

        // MList.txt読み込み sectionsと同じ配列順で返す 設定がなくても空のListを返す
        private List<string>[] ReadListFile(string file , string[] sections)
        {
            List<string>[] motionList = new List<string>[sections.Length];
            for (int i=0; i<sections.Length; i++) {
              motionList[i] = new List<string>();
            }

            if (!System.IO.File.Exists(file)) return motionList;

            int readIdx = -1;

            System.IO.StreamReader sr = new System.IO.StreamReader(file);
            while (sr.Peek() > -1) {
              string m = sr.ReadLine();

              if (m == "" || m.StartsWith("//")) continue;

              if (readIdx == -1) {
                if (m.StartsWith("[")) {
                  for (int i=0; i<sections.Length; i++) {
                    if (m == "["+sections[i]+"]") {
                      readIdx = i;
                      break;
                    }
                  }
                }
              } else {
                if (m == "[end]") {
                  readIdx = -1;
                } else {
                  motionList[readIdx].Add(m);
                }
              }
            }

            return motionList;
        }

        //ConfigXMLファイルの保存・読み込み
        private void ConfigFileSave() {
          string fileName = @"Sybaris\UnityInjector\Config\VibeYourMaid\config.xml"; //保存先のファイル名
          System.Xml.Serialization.XmlSerializer serializer = new System.Xml.Serialization.XmlSerializer(typeof(VibeYourMaidCfgWriting)); //XmlSerializerオブジェクトを作成。オブジェクトの型を指定する
          System.IO.StreamWriter sw = new System.IO.StreamWriter(fileName, false, new System.Text.UTF8Encoding(false)); //書き込むファイルを開く（UTF-8 BOM無し）
          serializer.Serialize(sw, cfgw); //シリアル化し、XMLファイルに保存する
          sw.Close(); //ファイルを閉じる
          Console.WriteLine("[VibeYourMaid] 保存完了: "+fileName);
        }
        private bool ConfigFileLoad() {
          string fileName = @"Sybaris\UnityInjector\Config\VibeYourMaid\config.xml"; //保存先のファイル名
          if (!System.IO.File.Exists(fileName)) return false;
          System.Xml.Serialization.XmlSerializer serializer = new System.Xml.Serialization.XmlSerializer(typeof(VibeYourMaidCfgWriting)); //XmlSerializerオブジェクトを作成
          System.IO.StreamReader sr = new System.IO.StreamReader(fileName, new System.Text.UTF8Encoding(false)); //読み込むファイルを開く
          cfgw = (VibeYourMaidCfgWriting)serializer.Deserialize(sr); //XMLファイルから読み込み、逆シリアル化する
          sr.Close(); //ファイルを閉じる
          Console.WriteLine("[VibeYourMaid] 読込完了: "+fileName);
          return true;
        }
        //設定ファイル読み込み後の初期化処理
        private void initConfig()
        {
          vrShortCutController.init(cfgw); //再設定
          if (osawari != null) osawari.cfgw = cfgw; //参照が変わるので再設定

          //ボタン配列の長さ調整
          int[] cols = DefaultYotogiMenuColumns;
          int length = Math.Min(cols.Length, cfgw.YotogiMenuColumns.Count());
          for (int i=0; i<length; i++) {
            if (cfgw.YotogiMenuColumns[i] > 0) cols[i] = cfgw.YotogiMenuColumns[i];
          }
          cfgw.YotogiMenuColumns = cols;

          //胸のコライダーのオフセット等を更新
          muneCollider.updateMuneColliderParam(maidsState, cfgw, SubMans, osawari.getTouchCollider());

          //メイド表示状態再チェック メイドステータスや乳首設定のロードや胸の状態の初期化
          VisibleMaidCheck(true);

          #if DOF
          //被写界深度設定変更
          initDepthOfFieldMaid(tgID);
          #endif
        }

        //脱衣ボイスファイルの保存・読み込み
        private void UndressingVoiceSave()
        {
          string fileName = @"Sybaris\UnityInjector\Config\VibeYourMaid\UndressingVoice.xml"; //保存先のファイル名

          System.Xml.Serialization.XmlSerializer serializer = new System.Xml.Serialization.XmlSerializer(typeof(string[][])); //XmlSerializerオブジェクトを作成。オブジェクトの型を指定する
          System.IO.StreamWriter sw = new System.IO.StreamWriter(fileName, false, new System.Text.UTF8Encoding(false)); //書き込むファイルを開く（UTF-8 BOM無し）
          serializer.Serialize(sw, UndressingVoice); //シリアル化し、XMLファイルに保存する
          sw.Close(); //ファイルを閉じる
        }
        //セーブが必要ならtrue
        private bool UndressingVoiceLoad()
        {
          string fileName = @"Sybaris\UnityInjector\Config\VibeYourMaid\UndressingVoice.xml"; //保存先のファイル名
          if (!System.IO.File.Exists(fileName)) return true;
          System.Xml.Serialization.XmlSerializer serializer = new System.Xml.Serialization.XmlSerializer(typeof(string[][])); //XmlSerializerオブジェクトを作成
          System.IO.StreamReader sr = new System.IO.StreamReader(fileName, new System.Text.UTF8Encoding(false)); //読み込むファイルを開く
          string[][] loadedVoice = (string[][])serializer.Deserialize(sr); //XMLファイルから読み込み、逆シリアル化する
          sr.Close(); //ファイルを閉じる
          //既存キャラのみ更新
          bool changed = loadedVoice.Length != UndressingVoice.Length;
          for (int i=0; i<loadedVoice.Length; i++) {
            //ボイス設定ミス修正 2.0.5.6で発生 しばらく後のバージョンで削除する
            if (i==21 && loadedVoice[20].Length > 0 && loadedVoice[20][0].ToUpper().StartsWith("V0") && loadedVoice[21].Length > 0 && loadedVoice[21][0].ToUpper().StartsWith("V1")) {
              UndressingVoice[20] = loadedVoice[21];
              UndressingVoice[21] = loadedVoice[20];
              changed = true;
            } else {
              if (loadedVoice[i].Length == 1) { //設定が空文字1つの場合はデフォルト側を利用 2.0.5.8のパッチで発生 しばらく後のバージョンで削除する
                changed = true;
              } else {
                //設定ファイルを反映
                UndressingVoice[i] = loadedVoice[i];
              }
            }
          }
          return changed; //キャラが増えたか入れ替えたらロード
        }

        //基本ボイスセットの保存・読み込み
        //画面からの変更はないのでファイルが存在しない場合のみ保存
        private void BvsFileSave() {

          for (int i = 0; i < personalList[1].Length; i++) {
            string fileName = @"Sybaris\UnityInjector\Config\VibeYourMaid\BasicVoiseSet\bvs_" + i.ToString("d2") + personalList[1][i] + ".xml";  //保存先のファイル名
            //ファイルが存在したら書き込みしない
            if (System.IO.File.Exists(fileName)) continue;

            System.Xml.Serialization.XmlSerializer serializer = new System.Xml.Serialization.XmlSerializer(typeof(BasicVoiceSet));  //XmlSerializerオブジェクトを作成。オブジェクトの型を指定する

            System.IO.StreamWriter sw = new System.IO.StreamWriter(fileName, false, new System.Text.UTF8Encoding(false));  //書き込むファイルを開く（UTF-8 BOM無し）

            serializer.Serialize(sw, bvs[i]);  //シリアル化し、XMLファイルに保存する

            Console.WriteLine("[VibeYourMaid] ボイスセット保存完了: " + personalList[1][i]);
            sw.Close(); //ファイルを閉じる
          }
        }
        private void BvsFileLoad() {

          for (int i = 0; i < personalList[1].Length; i++) {
            string fileName = @"Sybaris\UnityInjector\Config\VibeYourMaid\BasicVoiseSet\bvs_" + i.ToString("d2") + personalList[1][i] + ".xml";  //保存先のファイル名
            if (!System.IO.File.Exists(fileName)) continue;

            System.Xml.Serialization.XmlSerializer serializer = new System.Xml.Serialization.XmlSerializer(typeof(BasicVoiceSet));  //XmlSerializerオブジェクトを作成。オブジェクトの型を指定する

            System.IO.StreamReader sr = new System.IO.StreamReader(fileName, new System.Text.UTF8Encoding(false));  //読み込むファイルを開く

            //XMLファイルから読み込み、逆シリアル化する
            bvs[i] = (BasicVoiceSet)serializer.Deserialize(sr);

            sr.Close(); //ファイルを閉じる
          }

        }

        //基本ボイスセットから、存在しないファイルを除外
        private void BvsCheck() {

          var _vf = new List<string>();
          for (int i = 0; i < bvs.Length; i++) {

            System.Text.StringBuilder buf = new System.Text.StringBuilder();

            for (int i2 = 0; i2 < 5; i2++) {
              _vf = new List<string>();
              _vf.AddRange(bvs[i].sLoopVoice20Vibe[i2]);
              for (int i3 = 0; i3 < _vf.Count; i3++) {
                if (!GameUty.FileSystem.IsExistentFile(_vf[i3]) && !GameUty.FileSystemOld.IsExistentFile(_vf[i3]) && _vf[i3] != "" && _vf[i3] != ".ogg") {
                  buf.Append(" " + _vf[i3]);
                  _vf.RemoveAt(i3);
                  i3--;
                }
              }
              bvs[i].sLoopVoice20Vibe[i2] = _vf.ToArray();
            }

            for (int i2 = 0; i2 < 5; i2++) {
              _vf = new List<string>();
              _vf.AddRange(bvs[i].sLoopVoice20Fera[i2]);
              for (int i3 = 0; i3 < _vf.Count; i3++) {
                if (!GameUty.FileSystem.IsExistentFile(_vf[i3]) && !GameUty.FileSystemOld.IsExistentFile(_vf[i3]) && _vf[i3] != "" && _vf[i3] != ".ogg") {
                  buf.Append(" " + _vf[i3]);
                  _vf.RemoveAt(i3);
                  i3--;
                }
              }
              bvs[i].sLoopVoice20Fera[i2] = _vf.ToArray();
            }

            for (int i2 = 0; i2 < 5; i2++) {
              _vf = new List<string>();
              _vf.AddRange(bvs[i].sLoopVoice30Vibe[i2]);
              for (int i3 = 0; i3 < _vf.Count; i3++) {
                if (!GameUty.FileSystem.IsExistentFile(_vf[i3]) && !GameUty.FileSystemOld.IsExistentFile(_vf[i3]) && _vf[i3] != "" && _vf[i3] != ".ogg") {
                  buf.Append(" " + _vf[i3]);
                  _vf.RemoveAt(i3);
                  i3--;
                }
              }
              bvs[i].sLoopVoice30Vibe[i2] = _vf.ToArray();
            }

            for (int i2 = 0; i2 < 5; i2++) {
              _vf = new List<string>();
              _vf.AddRange(bvs[i].sLoopVoice30Fera[i2]);
              for (int i3 = 0; i3 < _vf.Count; i3++) {
                if (!GameUty.FileSystem.IsExistentFile(_vf[i3]) && !GameUty.FileSystemOld.IsExistentFile(_vf[i3]) && _vf[i3] != "" && _vf[i3] != ".ogg") {
                  buf.Append(" " + _vf[i3]);
                  _vf.RemoveAt(i3);
                  i3--;
                }
              }
              bvs[i].sLoopVoice30Fera[i2] = _vf.ToArray();
            }

            for (int i2 = 0; i2 < 5; i2++) {
              _vf = new List<string>();
              _vf.AddRange(bvs[i].sOrgasmVoice30Vibe[i2]);
              for (int i3 = 0; i3 < _vf.Count; i3++) {
                if (!GameUty.FileSystem.IsExistentFile(_vf[i3]) && !GameUty.FileSystemOld.IsExistentFile(_vf[i3]) && _vf[i3] != "" && _vf[i3] != ".ogg") {
                  buf.Append(" " + _vf[i3]);
                  _vf.RemoveAt(i3);
                  i3--;
                }
              }
              bvs[i].sOrgasmVoice30Vibe[i2] = _vf.ToArray();
            }

            for (int i2 = 0; i2 < 5; i2++) {
              _vf = new List<string>();
              _vf.AddRange(bvs[i].sOrgasmVoice30Fera[i2]);
              for (int i3 = 0; i3 < _vf.Count; i3++) {
                if (!GameUty.FileSystem.IsExistentFile(_vf[i3]) && !GameUty.FileSystemOld.IsExistentFile(_vf[i3]) && _vf[i3] != "" && _vf[i3] != ".ogg") {
                  buf.Append(" " + _vf[i3]);
                  _vf.RemoveAt(i3);
                  i3--;
                }
              }
              bvs[i].sOrgasmVoice30Fera[i2] = _vf.ToArray();
            }


            _vf = new List<string>();
            _vf.AddRange(bvs[i].sLoopVoice40Vibe);
            for (int i3 = 0; i3 < _vf.Count; i3++) {
              if (!GameUty.FileSystem.IsExistentFile(_vf[i3]) && !GameUty.FileSystemOld.IsExistentFile(_vf[i3]) && _vf[i3] != "" && _vf[i3] != ".ogg") {
                buf.Append(" " + _vf[i3]);
                _vf.RemoveAt(i3);
                i3--;
              }
            }
            bvs[i].sLoopVoice40Vibe = _vf.ToArray();

            if (buf.Length > 0) {
              Console.WriteLine("[VibeYourMaid] 音声ファイルが存在しないため除外 :"+buf);

            }
          }

        }

        //MotionAdjustXMLファイルの保存・読み込み
        private void MajFileSave(bool overwrite) {

          string fileName = @"Sybaris\UnityInjector\Config\VibeYourMaid\MotionAdjust.xml"; //保存先のファイル名
          //上書きしない
          if (!overwrite && System.IO.File.Exists(fileName)) return;

          System.Xml.Serialization.XmlSerializer serializer = new System.Xml.Serialization.XmlSerializer(typeof(MotionAdjust)); //XmlSerializerオブジェクトを作成。オブジェクトの型を指定する

          System.IO.StreamWriter sw = new System.IO.StreamWriter(fileName, false, new System.Text.UTF8Encoding(false)); //書き込むファイルを開く（UTF-8 BOM無し）

          serializer.Serialize(sw, maj); //シリアル化し、XMLファイルに保存する

          sw.Close(); //ファイルを閉じる
        }

        private void MajFileLoad() {
          System.Diagnostics.Stopwatch sw = new System.Diagnostics.Stopwatch();
          sw.Start();

          string fileName = @"Sybaris\UnityInjector\Config\VibeYourMaid\MotionAdjust.xml"; //保存先のファイル名
          //Console.WriteLine(fileName);
          if (!System.IO.File.Exists(fileName)) return; 

          System.Xml.Serialization.XmlSerializer serializer = new System.Xml.Serialization.XmlSerializer(typeof(MotionAdjust)); //XmlSerializerオブジェクトを作成

          System.IO.StreamReader sr = new System.IO.StreamReader(fileName, new System.Text.UTF8Encoding(false)); //読み込むファイルを開く

          maj = (MotionAdjust)serializer.Deserialize(sr); //XMLファイルから読み込み、逆シリアル化する

          sr.Close(); //ファイルを閉じる
          sw.Stop();
          Console.WriteLine("[VibeYourMaid] MotionAdjust.xml 読み込み完了 : "+sw.ElapsedMilliseconds+"ms");

          //新規に追加された項目があれば初期値を設定
          int nameC = maj.motionName.Count;
          //for (int i = maj.iTargetLH.Count; i < nameC; i++) maj.iTargetLH.Add(0);
          //for (int i = maj.iTargetRH.Count; i < nameC; i++) maj.iTargetRH.Add(0);

          for (int i = maj.syaseiMarks.Count; i < nameC; i++) maj.syaseiMarks.Add(new int[]{0, 0, 0, 0, 0});
          for (int i = maj.giveSexual.Count; i < nameC; i++) maj.giveSexual.Add(new bool[]{true, false, false, false, false, false, false, false, false, false});
          for (int i = maj.itemSet.Count; i < nameC; i++) maj.itemSet.Add(new bool[]{false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false});

          for (int i = maj.prefabSet.Count; i < nameC; i++) maj.prefabSet.Add(0);
          for (int i = maj.prefabSetX.Count; i < nameC; i++) maj.prefabSetX.Add(0);
          for (int i = maj.prefabSetY.Count; i < nameC; i++) maj.prefabSetY.Add(0);
          for (int i = maj.prefabSetZ.Count; i < nameC; i++) maj.prefabSetZ.Add(0);
          for (int i = maj.prefabSetR.Count; i < nameC; i++) maj.prefabSetR.Add(0);

          for (int i = maj.mVoiceSet.Count; i < nameC; i++) maj.mVoiceSet.Add("");
          for (int i = maj.baceMotion.Count; i < nameC; i++) maj.baceMotion.Add("");
          for (int i = maj.outMotionFlag.Count; i < nameC; i++) maj.outMotionFlag.Add(0);

          for (int i = maj.kupaDelay.Count; i < nameC; i++) maj.kupaDelay.Add(-1f);
          for (int i = maj.hkupa1.Count; i < nameC; i++) maj.hkupa1.Add(-1f);
          for (int i = maj.akupa1.Count; i < nameC; i++) maj.akupa1.Add(-1f);
          for (int i = maj.hkupa2.Count; i < nameC; i++) maj.hkupa2.Add(-1f);
          for (int i = maj.akupa2.Count; i < nameC; i++) maj.akupa2.Add(-1f);

          for (int i = maj.basicHeight.Count; i < nameC; i++) maj.basicHeight.Add(0f);
          for (int i = maj.basicForward.Count; i < nameC; i++) maj.basicForward.Add(0f);
          for (int i = maj.basicRight.Count; i < nameC; i++) maj.basicRight.Add(0f);
          for (int i = maj.basicAngleY.Count; i < nameC; i++) maj.basicAngleY.Add(0);

          for (int i = maj.submanHeight.Count; i < nameC; i++) maj.submanHeight.Add(0f);
          for (int i = maj.submanForward.Count; i < nameC; i++) maj.submanForward.Add(0f);
          for (int i = maj.submanRight.Count; i < nameC; i++) maj.submanRight.Add(0f);
          for (int i = maj.submanAngleY.Count; i < nameC; i++) maj.submanAngleY.Add(0);

          for (int i = maj.mansHeight.Count; i < nameC; i++) maj.mansHeight.Add(0f);
          for (int i = maj.mansForward.Count; i < nameC; i++) maj.mansForward.Add(0f);
          for (int i = maj.mansRight.Count; i < nameC; i++) maj.mansRight.Add(0f);

          for (int i = maj.analEnabled.Count; i < nameC; i++) maj.analEnabled.Add(false);
          for (int i = maj.analHeight.Count; i < nameC; i++) maj.analHeight.Add(0f);
          for (int i = maj.analForward.Count; i < nameC; i++) maj.analForward.Add(0f);
          for (int i = maj.analRight.Count; i < nameC; i++) maj.analRight.Add(0f);

          for (int i = maj.maidToCam.Count; i < nameC; i++) maj.maidToCam.Add(-1);
        }

        //共通衣装データ
        public CommonDressSet cds = new CommonDressSet();
        /// <summary>
        /// 共通衣装データ設定クラス
        /// </summary>
        public class CommonDressSet
        {
          public string acchat = "";
          public string headset = "";
          public string wear = "";
          public string skirt = "";
          public string onepiece = "";
          public string mizugi = "";
          public string bra = "";
          public string panz = "";
          public string stkg = "";
          public string shoes = "";
          public string megane = "";
          public string acchead = "";
          public string glove = "";
          public string accude = "";
          public string acchana = "";
          public string accmimi = "";
          public string accnip = "";
          public string acckubi = "";
          public string acckubiwa = "";
          public string accheso = "";
          public string accashi = "";
          public string accsenaka = "";
          public string accshippo = "";
          public string accxxx = "";
        }

        //共通衣装XMLファイルの保存・読み込み
        private void CdsFileSave(string name) {

            Maid maid = stockMaids[tgID].mem;

            string fileName = @"Sybaris\UnityInjector\Config\VibeYourMaid\CommonDressSet\cds_" + name + ".xml";  //保存先のファイル名
            if (name == "") {
              dsErrer = 1;
              return;
            }
            if (System.IO.File.Exists(fileName) && !ds_Overwrite[4]) {
              dsErrer = 2;
              return;
            }

            //現在の衣装データを読み込み
            if (setAcchat) cds.acchat = maid.GetProp(MPN.acchat) .strFileName;
            if (setHeadset) cds.headset = maid.GetProp(MPN.headset) .strFileName;
            if (setWear) cds.wear = maid.GetProp(MPN.wear) .strFileName;
            if (setSkirt) cds.skirt = maid.GetProp(MPN.skirt) .strFileName;
            if (setOnepiece) cds.onepiece = maid.GetProp(MPN.onepiece) .strFileName;
            if (setMizugi) cds.mizugi = maid.GetProp(MPN.mizugi) .strFileName;
            if (setBra) cds.bra = maid.GetProp(MPN.bra) .strFileName;
            if (setPanz) cds.panz = maid.GetProp(MPN.panz) .strFileName;
            if (setStkg) cds.stkg = maid.GetProp(MPN.stkg) .strFileName;
            if (setShoes) cds.shoes = maid.GetProp(MPN.shoes) .strFileName;
            if (setMegane) cds.megane = maid.GetProp(MPN.megane) .strFileName;
            if (setAcchead) cds.acchead = maid.GetProp(MPN.acchead) .strFileName;
            if (setGlove) cds.glove = maid.GetProp(MPN.glove) .strFileName;
            if (setAccude) cds.accude = maid.GetProp(MPN.accude) .strFileName;
            if (setAcchana) cds.acchana = maid.GetProp(MPN.acchana) .strFileName;
            if (setAccmimi) cds.accmimi = maid.GetProp(MPN.accmimi) .strFileName;
            if (setAccnip) cds.accnip = maid.GetProp(MPN.accnip) .strFileName;
            if (setAcckubi) cds.acckubi = maid.GetProp(MPN.acckubi) .strFileName;
            if (setAcckubiwa) cds.acckubiwa = maid.GetProp(MPN.acckubiwa) .strFileName;
            if (setAccheso) cds.accheso = maid.GetProp(MPN.accheso) .strFileName;
            if (setAccashi) cds.accashi = maid.GetProp(MPN.accashi) .strFileName;
            if (setAccsenaka) cds.accsenaka = maid.GetProp(MPN.accsenaka) .strFileName;
            if (setAccshippo) cds.accshippo = maid.GetProp(MPN.accshippo) .strFileName;
            if (setAccxxx) cds.accxxx = maid.GetProp(MPN.accxxx) .strFileName;
            if (!setAcchat) cds.acchat = "";
            if (!setHeadset) cds.headset = "";
            if (!setWear) cds.wear = "";
            if (!setSkirt) cds.skirt = "";
            if (!setOnepiece) cds.onepiece = "";
            if (!setMizugi) cds.mizugi = "";
            if (!setBra) cds.bra = "";
            if (!setPanz) cds.panz = "";
            if (!setStkg) cds.stkg = "";
            if (!setShoes) cds.shoes = "";
            if (!setMegane) cds.megane = "";
            if (!setAcchead) cds.acchead = "";
            if (!setGlove) cds.glove = "";
            if (!setAccude) cds.accude = "";
            if (!setAcchana) cds.acchana = "";
            if (!setAccmimi) cds.accmimi = "";
            if (!setAccnip) cds.accnip = "";
            if (!setAcckubi) cds.acckubi = "";
            if (!setAcckubiwa) cds.acckubiwa = "";
            if (!setAccheso) cds.accheso = "";
            if (!setAccashi) cds.accashi = "";
            if (!setAccsenaka) cds.accsenaka = "";
            if (!setAccshippo) cds.accshippo = "";
            if (!setAccxxx) cds.accxxx = ""; 

            System.Xml.Serialization.XmlSerializer serializer = new System.Xml.Serialization.XmlSerializer(typeof(CommonDressSet));  //XmlSerializerオブジェクトを作成。オブジェクトの型を指定する

            System.IO.StreamWriter sw = new System.IO.StreamWriter(fileName, false, new System.Text.UTF8Encoding(false));  //書き込むファイルを開く（UTF-8 BOM無し）

            serializer.Serialize(sw, cds);  //シリアル化し、XMLファイルに保存する

            Console.WriteLine("[VibeYourMaid] 共通衣装セット保存完了：" + name);
            dsErrer = 0;
        }
        private void CdsFileLoad(string xml) {

            string fileName = @"Sybaris\UnityInjector\Config\VibeYourMaid\CommonDressSet\" + xml;  //保存先のファイル名
            if (!System.IO.File.Exists(fileName)) return;

            System.Xml.Serialization.XmlSerializer serializer = new System.Xml.Serialization.XmlSerializer(typeof(CommonDressSet));  //XmlSerializerオブジェクトを作成。オブジェクトの型を指定する

            System.IO.StreamReader sr = new System.IO.StreamReader(fileName, new System.Text.UTF8Encoding(false));  //読み込むファイルを開く

            //XMLファイルから読み込み、逆シリアル化する
            cds = (CommonDressSet)serializer.Deserialize(sr);

            sr.Close(); //ファイルを閉じる

            //衣装データを適用
            Maid maid = stockMaids[tgID].mem;
            if (cds.acchat != "") maid.SetProp(MPN.acchat, cds.acchat, 0, true, false);
            if (cds.headset != "") maid.SetProp(MPN.headset, cds.headset, 0, true, false);
            if (cds.wear != "") maid.SetProp(MPN.wear, cds.wear, 0, true, false);
            if (cds.skirt != "") maid.SetProp(MPN.skirt, cds.skirt, 0, true, false);
            if (cds.onepiece != "") maid.SetProp(MPN.onepiece, cds.onepiece, 0, true, false);
            if (cds.mizugi != "") maid.SetProp(MPN.mizugi, cds.mizugi, 0, true, false);
            if (cds.bra != "") maid.SetProp(MPN.bra, cds.bra, 0, true, false);
            if (cds.panz != "") maid.SetProp(MPN.panz, cds.panz, 0, true, false);
            if (cds.stkg != "") maid.SetProp(MPN.stkg, cds.stkg, 0, true, false);
            if (cds.shoes != "") maid.SetProp(MPN.shoes, cds.shoes, 0, true, false);
            if (cds.megane != "") maid.SetProp(MPN.megane, cds.megane, 0, true, false);
            if (cds.acchead != "") maid.SetProp(MPN.acchead, cds.acchead, 0, true, false);
            if (cds.glove != "") maid.SetProp(MPN.glove, cds.glove, 0, true, false);
            if (cds.accude != "") maid.SetProp(MPN.accude, cds.accude, 0, true, false);
            if (cds.acchana != "") maid.SetProp(MPN.acchana, cds.acchana, 0, true, false);
            if (cds.accmimi != "") maid.SetProp(MPN.accmimi, cds.accmimi, 0, true, false);
            if (cds.accnip != "") maid.SetProp(MPN.accnip, cds.accnip, 0, true, false);
            if (cds.acckubi != "") maid.SetProp(MPN.acckubi, cds.acckubi, 0, true, false);
            if (cds.acckubiwa != "") maid.SetProp(MPN.acckubiwa, cds.acckubiwa, 0, true, false);
            if (cds.accheso != "") maid.SetProp(MPN.accheso, cds.accheso, 0, true, false);
            if (cds.accashi != "") maid.SetProp(MPN.accashi, cds.accashi, 0, true, false);
            if (cds.accsenaka != "") maid.SetProp(MPN.accsenaka, cds.accsenaka, 0, true, false);
            if (cds.accshippo != "") maid.SetProp(MPN.accshippo, cds.accshippo, 0, true, false);
            if (cds.accxxx != "") maid.SetProp(MPN.accxxx, cds.accxxx, 0, true, false);

            AllDressVisible(tgID, true);
            maid.AllProcPropSeqStart();
            Console.WriteLine("[VibeYourMaid] 共通衣装 セット完了");
        }

        private void AllDressVisible(int maidID, bool b) {

          Maid maid = stockMaids[maidID].mem;

          maid.body0.SetMask(TBody.SlotID.headset, b);
          maid.body0.SetMask(TBody.SlotID.hairAho, b);
          maid.body0.SetMask(TBody.SlotID.accHana, b);
          maid.body0.SetMask(TBody.SlotID.accMiMiR, b);
          maid.body0.SetMask(TBody.SlotID.accNipR, b);
          maid.body0.SetMask(TBody.SlotID.accMiMiL, b);
          maid.body0.SetMask(TBody.SlotID.accNipL, b);
          maid.body0.SetMask(TBody.SlotID.accHeso, b);
          maid.body0.SetMask(TBody.SlotID.accAshi, b);
          maid.body0.SetMask(TBody.SlotID.accSenaka, b);
          maid.body0.SetMask(TBody.SlotID.accShippo, b);
          maid.body0.SetMask(TBody.SlotID.megane, b);
          maid.body0.SetMask(TBody.SlotID.accXXX, b);
          maid.body0.SetMask(TBody.SlotID.accHat, b);
          maid.body0.SetMask(TBody.SlotID.wear, b);
          maid.body0.SetMask(TBody.SlotID.mizugi, b);
          maid.body0.SetMask(TBody.SlotID.onepiece, b);
          maid.body0.SetMask(TBody.SlotID.bra, b);
          maid.body0.SetMask(TBody.SlotID.skirt, b);
          maid.body0.SetMask(TBody.SlotID.panz, b);
          maid.body0.SetMask(TBody.SlotID.glove, b);
          maid.body0.SetMask(TBody.SlotID.accUde, b);
          maid.body0.SetMask(TBody.SlotID.stkg, b);
          maid.body0.SetMask(TBody.SlotID.shoes, b);
          maid.body0.SetMask(TBody.SlotID.accKubi, b);
          maid.body0.SetMask(TBody.SlotID.accKubiwa, b);
        }

      //外部データ読み込み関係終了----------------------------


      //-------------------------------------------------
      //ボイスセット関係---------------------------------
        private bool vs_Overwrite = false;
        private int vsErrer = 0;
        private string[] vsErrerText = new string[] { "" , "ボイスセット名が空白のため保存できません" , "上書きする場合は『上書／ｸﾘｱ』にチェックを入れて下さい" , "クリアする場合は『上書／ｸﾘｱ』にチェックを入れて下さい"};
        private List<int> iPersonal = new List<int>();
        private string[] vsState = new string[] { "弱" , "強" , "余韻時" , "停止時" , "指定無"};
        private string[] vsCondition = new string[] { "通常" , "キス" , "フェラ" , "絶頂後" , "放心" , "指定無"};
        private string[] vsLevel = new string[] { "0" , "1" , "2" , "3" , "－" };
        private int[] fVoiceSet = new int[]{ 15, 4, 4, 4, 5 };
        private int[] fVoiceSet2 = new int[]{ 0, 0 };

        VoiceSet_Xml VSX = new VoiceSet_Xml();
        /// <summary>
        /// ボイスセットクラス XML保存用
        /// [ファイル名, 性格, 興奮低, 興奮高, 絶頂低, 絶頂高, 強度, メイド状態, (開始秒)] の配列 開始秒は利用時のみ設定
        /// </summary>
        public class VoiceSet_Xml
        {
          public string saveVoiceSetName = "";
          public List<string[]> saveVoiceSet = new List<string[]>{
            new string[] { "" , "0" , "0" , "3" , "0" , "3" , "0" , "0" } //ファイル名、性格、興奮低、興奮高、絶頂低、絶頂高、強度、メイド状態
          };

        }

        //ボイスセットをロードしてメイドに設定 xmlの内容をVSXに格納してオリジナルボイスセット編集に利用
        private bool voiceSetLoad(string xml, int maidID)
        {
          #if DEBUG
          Debug.Log("voiceSetLoad("+xml+", "+maidID+")");
          #endif

          MaidState maidState = maidsState[maidID];

          VoiceSet_Xml voiceSet = getVoiceSetXml(xml);
          if (voiceSet == null) {
            //解除して終了
            maidState.editVoiceSetName = "";
            maidState.editVoiceSet = new List<string[]>();
            return false;
          }

          VSX = voiceSet;
          maidState.editVoiceSetName = voiceSet.saveVoiceSetName;
          maidState.editVoiceSet = createMaidEditVoiceSet(voiceSet, stockMaids[maidID].iPersonal);
          return true;
        }

        //キス用のボイスセットをロードしてメイドに設定
        private bool kissVoiceSetLoad(string xml, int maidID)
        {
          #if DEBUG
          Debug.Log("kissVoiceSetLoad("+xml+", "+maidID+")");
          #endif

          MaidState maidState = maidsState[maidID];

          VoiceSet_Xml voiceSet = getVoiceSetXml(xml);
          if (voiceSet == null) {
            //解除して終了
            maidState.kissVoiceSetName = "";
            maidState.kissVoiceSet = null;
            return false;
          }

          maidState.kissVoiceSetName = voiceSet.saveVoiceSetName;
          maidState.kissVoiceSet = createMaidEditVoiceSet(voiceSet, stockMaids[maidID].iPersonal);
          return true;
        }

        //固定ファイルなのでキャッシュしておく
        string sotodashiVSCacheFileName = "";
        VoiceSet_Xml sotodashiVSCache = null;
        //射精リアクション用のボイスセットをロードしてメイドに設定
        private bool sotodashiVoiceSetLoad(string xml, int maidID)
        {
          #if DEBUG
          Debug.Log("sotodashiVoiceSetLoad("+xml+", "+maidID+")");
          #endif

          if (sotodashiVSCacheFileName != xml && sotodashiVSCache == null) sotodashiVSCache = getVoiceSetXml(xml);
          VoiceSet_Xml voiceSet = sotodashiVSCache;
          if (voiceSet == null) return false;

          sotodashiVSCacheFileName = xml;
          maidsState[maidID].sotodashiVoiceSetName = voiceSet.saveVoiceSetName;
          maidsState[maidID].sotodashiVoiceSet = createMaidEditVoiceSet(voiceSet, stockMaids[maidID].iPersonal);
          return true;
        }
        //固定ファイルなのでキャッシュしておく
        string kaodashiVSCacheFileName = "";
        VoiceSet_Xml kaodashiVSCache = null;
        //射精リアクション用のボイスセットをロードしてメイドに設定
        private bool kaodashiVoiceSetLoad(string xml, int maidID)
        {
          #if DEBUG
          Debug.Log("kaodashiVoiceSetLoad("+xml+", "+maidID+")");
          #endif

          if (kaodashiVSCacheFileName != xml && kaodashiVSCache == null) kaodashiVSCache = getVoiceSetXml(xml);
          VoiceSet_Xml voiceSet = kaodashiVSCache;
          if (voiceSet == null) return false;

          kaodashiVSCacheFileName = xml;
          maidsState[maidID].kaodashiVoiceSetName = voiceSet.saveVoiceSetName;
          maidsState[maidID].kaodashiVoiceSet = createMaidEditVoiceSet(voiceSet, stockMaids[maidID].iPersonal);
          return true;
        }

        //読み込んだボイスセットから性格が同じか-1で音声ファイルがあるもののみc抽出
        private List<string[]> createMaidEditVoiceSet(VoiceSet_Xml voiceSet, int iPersonal)
        {
          List<string[]> editVoiceSet = new List<string[]>();
          int vs1;
          for (int i=0, cnt=voiceSet.saveVoiceSet.Count; i<cnt; i++) {
            string[] vs = voiceSet.saveVoiceSet[i];
            if (int.TryParse(vs[1], out vs1) && (vs1 == -1 || vs1 == iPersonal)) {
              if (GameUty.FileSystem.IsExistentFile(vs[0]) || GameUty.FileSystemOld.IsExistentFile(vs[0]) || GameUty.FileSystemMod.IsExistentFile(vs[0])) {
                editVoiceSet.Add(vs);
              }
            }
          }
          return editVoiceSet;
        }


        //ボイスセットXMLファイルを読み込む
        private VoiceSet_Xml getVoiceSetXml(string xml)
        {
          //保存先のファイル名
          string fileName = @"Sybaris\UnityInjector\Config\VibeYourMaid\EditVoiseSet\" + xml;
          //Console.WriteLine(fileName);

          if (System.IO.File.Exists(fileName)){
            //XmlSerializerオブジェクトを作成
            System.Xml.Serialization.XmlSerializer serializer = new System.Xml.Serialization.XmlSerializer(typeof(VoiceSet_Xml));
            //読み込むファイルを開く
            System.IO.StreamReader sr = new System.IO.StreamReader(fileName, new System.Text.UTF8Encoding(false));

            //XMLファイルから読み込み、逆シリアル化する
            VoiceSet_Xml voiceSet = (VoiceSet_Xml)serializer.Deserialize(sr);

            //ファイルを閉じる
            sr.Close();
            Console.WriteLine("[VibeYourMaid] ボイスセット読み込み完了: "+voiceSet.saveVoiceSetName);
            return voiceSet;
          }
          else Debug.LogError("VoiceSet file not exists : "+xml);
          return null;
        }
        private bool isVoiceSetExist(string voiceSetName)
        {
          string fileName = @"Sybaris\UnityInjector\Config\VibeYourMaid\EditVoiseSet\evs_"+voiceSetName+".xml";
          return System.IO.File.Exists(fileName);
        }

        //ボイスセットをXMLファイルに保存する
        private void voiceSetSave() {

          // フォルダ確認
          if (!System.IO.Directory.Exists(@"Sybaris\UnityInjector\Config\VibeYourMaid\EditVoiseSet\")) {
            //ない場合はフォルダ作成
            System.IO.DirectoryInfo di = System.IO.Directory.CreateDirectory(@"Sybaris\UnityInjector\Config\VibeYourMaid\EditVoiseSet");
          }


          if (VSX.saveVoiceSetName == "") {  //ボイスセット名が空白の場合保存しない
            vsErrer = 1;

          } else {
            //保存先のファイル名
            string fileName = @"Sybaris\UnityInjector\Config\VibeYourMaid\EditVoiseSet\evs_" + VSX.saveVoiceSetName + @".xml";

            if (System.IO.File.Exists(fileName) && !vs_Overwrite){  //上書きのチェック
              vsErrer = 2;

            } else {

              //XmlSerializerオブジェクトを作成
              //オブジェクトの型を指定する
              System.Xml.Serialization.XmlSerializer serializer = new System.Xml.Serialization.XmlSerializer(typeof(VoiceSet_Xml));

              //書き込むファイルを開く（UTF-8 BOM無し）
              System.IO.StreamWriter sw = new System.IO.StreamWriter(fileName, false, new System.Text.UTF8Encoding(false));

              //シリアル化し、XMLファイルに保存する
              serializer.Serialize(sw, VSX);
              //ファイルを閉じる
              sw.Close();

              vs_Overwrite = false;
              vsErrer = 0;
            }
          }
        }

        //ボイスセット再生処理 開始秒のリセットも行う
        private void VoiceSetPlay(int maidID, Maid maid, MaidState maidState) {

          //音声が終わったかチェックして終了処理
          if (maidState.vsFlag == 2) {
            if (!maid.AudioMan) {
              maidState.vsFlag = 0;
              return;
            }
            if (!maid.AudioMan.audiosource.isPlaying || maidState.playedVoiceName != maid.AudioMan.FileName) {
              maidState.vsFlag = 0; //再生中フラグOFF
              maid.AudioMan.audiosource.time = 0; //開始秒は0にリセット
              if (!maid.AudioMan.audiosource.loop) {
                maidState.voiceHoldTime = 0;  //メイドのループ音声を終了後に再生するため、タイマーリセット
              }
            }
          }

          //絶頂ボイス中なら処理しない タイマーも減少無し
          if (maidState.orgasmVoice != 0) return;

          if (maidState.vsFlag == 0) {
            maidState.vsTime -= Time.deltaTime; //再生していないときだけタイマーを動かす
            if (maidState.cameraCheckVoice) maidState.vsKissTime -= Time.deltaTime; //顔が近いときだけキス音声開始時間を減らす
          }

          if (maidState.vsTime < 0) {
            if (!maid.AudioMan) return;
            //ループ音声以外の再生中はスキップ
            if (maid.AudioMan.audiosource.isPlaying && !maid.AudioMan.audiosource.loop) {
              return;
            }

            List<string[]> voiceSet = null;

            //キスのボイス連動する場合はボイスセットをキスに変更 ロードも行う  距離判定はCameraPosCheckで行いcameraCheckVoiceにフラグがセットされる
            //ボイスセットが設定されていない
            if (maidState.editVoiceSetName != "") {
              voiceSet = maidState.editVoiceSet;
            }
            if (maidState.cameraCheckVoice && maidState.kissVoiceSetName != "") {
              if (maidState.kissVoiceSet == null) kissVoiceSetLoad("evs_"+maidState.kissVoiceSetName+".xml", maidID);
              if (maidState.kissVoiceSet != null) {
                //キスボイス再生時間が経過していなかったら次のチェック時間に設定して終了
                if (maidState.vsKissTime  > 0) {
                  maidState.vsTime = maidState.vsKissTime;
                  return;
                }
                voiceSet = maidState.kissVoiceSet;
              }
            }
            //ボイスセットがなければ終了
            if (voiceSet == null) return;

            string[][] vsList = VoiceSetCheck(maidID, maid, maidState, voiceSet); //該当する音声ファイルをリストアップ
            if (vsList.Length > 0) {
              //再生されたらvsFlagに2がセットされる
              VoicePlay(maidID, maidState.maid, maidState, vsList);
            }

            //maidState.vsTime = UnityEngine.Random.Range(maidState.vsInterval - 200f, maidState.vsInterval + 200f);
            maidState.vsTime = UnityEngine.Random.Range(cfgw.voiceSetInterval-cfgw.voiceSetIntervalRange*0.5f, cfgw.voiceSetInterval+cfgw.voiceSetIntervalRange*0.5f);
            maidState.vsKissTime = maidState.vsTime * 0.5f; //半分にする

          }
        }

        private void VoicePlay(int maidID, Maid maid, MaidState maidState, string[][] vsList)
        {
          //音声再生
          int idx = UnityEngine.Random.Range(0, vsList.Length);
          string[] vs = vsList[idx];
          //音声が同じなら再度乱数取得
          if (vsList.Length > 1 && maidState.playedVoiceName == vs[0]) {
            int exceptIdx = idx; //除外するidx
            idx = UnityEngine.Random.Range(0, vsList.Length);
            if (idx == exceptIdx) {
              idx = UnityEngine.Random.Range(0, vsList.Length);
              if (idx == exceptIdx) {
                idx = UnityEngine.Random.Range(0, vsList.Length);
                if (idx == exceptIdx) {
                  idx = UnityEngine.Random.Range(0, vsList.Length);
                }
              }
            }
            vs = vsList[idx];
          }

          float start = 0;
          if (vs.Length > 8) float.TryParse(vs[8], out start);
          maid.AudioMan.audiosource.time = 0; //先に0に戻す
          maid.AudioMan.LoadPlay(vs[0], 0f, false, false);
          if (maid.AudioMan.FileName == vs[0]) {
            maidState.vsFlag = 2; //再生中フラグON
            maidState.playedVoiceName = vs[0];
            maid.AudioMan.audiosource.time = Math.Max(0, start); //Play後に開始時間変更
            Console.WriteLine("[VibeYourMaid] ボイスセット再生開始("+(idx+1)+"/"+vsList.Length+"): " + vs[0]+" time="+start);
          } else {
            maidState.vsFlag = 0; //再生フラグOFF
            Console.WriteLine("[VibeYourMaid] ボイスセット音声なし("+(idx+1)+"/"+vsList.Length+"): " + vs[0]);
          }

          if (maidState.bIsBlowjobing < 2) { //フェラ以外 キスは対象
            //リップシンク有効化
            if (cfgw.voiceSetPlayLipSync) maid.LipSyncEnabled(true);
            //舌を引っ込める
            if (cfgw.voiceSetPlayTangOff) setTangOff(maidState);
          }

        }

        //ボイスセットの該当チェック 開始時間指定があれば返す
        private string[][] VoiceSetCheck(int maidID, Maid maid, MaidState maidState, List<string[]> editVoiceSet) {
          int iPersonal = stockMaids[maidID].iPersonal;
          //if (maidState.voiceMode2 > 0) iPersonal = maidState.voiceMode2 - 1;

          int eLevel = maidState.exciteLevel - 1;

          int oLevel;
          if (Math.Floor(maidState.orgasmValue) < 30) {
            oLevel = 0;
          } else if (Math.Floor(maidState.orgasmValue) < 50) {
            oLevel = 1;
          } else if (Math.Floor(maidState.orgasmValue) < 80) {
            oLevel = 2;
          } else {
            oLevel = 3;
          }
          //メイドの興奮値の大きいほうを設定
          int maidExciteLevel = 0;
          if (maid.status.currentExcite > 250) maidExciteLevel = 3;
          else if (maid.status.currentExcite > 150) maidExciteLevel = 2;
          else if (maid.status.currentExcite > 50) maidExciteLevel = 1;
          if (cfgw.maidStatusLinkVoiceSetExite) eLevel = Math.Max(eLevel, maidExciteLevel);
          if (cfgw.maidStatusLinkVoiceSetOrgasm) oLevel = Math.Max(oLevel, maidExciteLevel);

          int iState = -1;
          if (maidState.vStateMajor == 20) iState = 0;
          if (maidState.vStateMajor == 30) iState = 1;
          if (maidState.vStateMajor == 40) iState = 2;
          if (maidState.vStateMajor == 10) iState = 3;

          checkBlowjobing(maidID, maid, maidState);
          int iCondition = maidState.bIsBlowjobing;
          if (maidState.orgasmHoldTime > 0) iCondition = 3;
          if (maidState.stunFlag) iCondition = 4;

          #if DEBUG
          Debug.Log("VoiceSetCheck maid="+maidID+" eLevel="+eLevel+" oLevel="+oLevel+" State="+iState+" Cond="+iCondition);
          #endif

          List<string[]> _vsList = new List<string[]>();
          List<string> chkList = new List<string>();
          foreach (string[] vs in editVoiceSet) {
            int vsPersonal = intCnv(vs[1], -99);
            if (vs[0] != "" && (vsPersonal == -1 || vsPersonal == iPersonal || vsPersonal == personalList[0].Length - 1) //-1は指定なし
               && (intCnv(vs[2], 0) <= eLevel && eLevel <= intCnv(vs[3], 3))
               && (intCnv(vs[4], 0) <= oLevel && oLevel <= intCnv(vs[5], 3))
               && (intCnv(vs[6]) == iState || intCnv(vs[6]) == 4)
               && (intCnv(vs[7]) == iCondition || intCnv(vs[7]) == 5)
            ) {
              //重複チェック
              string key = vs[0].ToLower()+"_"+vs[2]+"_"+vs[3]+"_"+vs[4]+"_"+vs[5]+"_"+vs[6]+"_"+vs[7];
              if (!chkList.Contains(key)) {
                _vsList.Add(vs);
                chkList.Add(key);
                //Debug.Log("_vsList.Add : " + vs[0]);
              }
            }
          }
          return _vsList.ToArray();
        }

      //ボイスセット関係終了----------------------------


      //-------------------------------------------------
      //データ変換関係---------------------------------

        //int変換
        /*private int intCnv(string s) {
          if (Regex.IsMatch(s, "[^0-9]")) return 0;
          int i = int.Parse(s);

          return i;
        }*/
        private int intCnv(string s) {
          int i;
          if (int.TryParse(s, out i)) return i;
          else return 0;
        }
        private int intCnv(string s, int def) {
          int i;
          if (int.TryParse(s, out i)) return i;
          else return def;
        }

        //float変換
        /*private Regex floatRegex = new Regex(@"^[-+]?[0-9]*\.?[0-9]+$", RegexOptions.Compiled);
        private float floatCnv(string s) {
          if (!floatRegex.IsMatch(s)) return 0f;
          float i = float.Parse(s);

          return i;
        }*/
        private float floatCnv(string s) {
          float f;
          if (float.TryParse(s, out f)) return f;
          else return 0f;
        }

      //データ変換関係終了----------------------------


      //-------------------------------------------------
      //その他処理---------------------------------------

        //ダブルクリック判定処理
        private bool dClickL = false;
        private bool dClickR = false;
        private float delayTime1 = 0f;
        private float delayTime2 = 0f;
        private void DClicCheck() {

          if (Input.GetMouseButtonDown(0)) {
            if (delayTime1 > Time.time) {
              dClickL = true;
              delayTime1 = 0;
            } else {
              dClickL = false;
              delayTime1 = Time.time + 0.2f;
            }
          } else {
            dClickL = false;
          }
          if (Input.GetMouseButtonDown(1)) {
            if (delayTime2 > Time.time) {
              dClickR = true;
              delayTime2 = 0;
            } else {
              dClickR = false;
              delayTime2 = Time.time + 0.2f;
            }
          } else {
            dClickR = false;
          }
        }

        //男を取得 2.5はハイポリエディットボディとの切り替えに対応
        private Maid getSubMan(int idx)
        {
          //設定状況やモーションに応じて切り替え
          #if COM3D2_5
          if (cfgw.useRealMan) {
            if (SubMans[idx].HasNewRealMan) return SubMans[idx].pairMan;
          } else {
            //useRealManがfalseでもpairMan側のみが表示されていたらそちらを取得
            if (SubMans[idx].HasNewRealMan && !SubMans[idx].Visible && SubMans[idx].pairMan.Visible) return SubMans[idx].pairMan;
          }
          #endif
          return SubMans[idx];
        }
        //男の表示状態を取得 2.5はハイポリエディットボディの両方の表示状態をチェック
        private bool isSubManVisible(int idx)
        {
          #if COM3D2_5
          if (SubMans[idx].Visible) return true;
          if (SubMans[idx].HasNewRealMan) return SubMans[idx].pairMan.Visible;
          return false;
          #else
          return SubMans[idx].Visible;
          #endif
        }

        //男の表示状態を変更 2.5は選択は新ボディがあってもcfgw.useRealManがfalseなら強制シルエット表示
        private void setSubManVisible(int idx, bool visible)
        {
          #if COM3D2_5
          if (cfgw.useRealMan && SubMans[idx].HasNewRealMan) {
            SubMans[idx].Visible = false;
            //プリセットを適用する
            if (visible) {
              GameMain.Instance.CharacterMgr.ToNewRealMan(idx, true);
            }
            SubMans[idx].pairMan.Visible = visible;
          } else {
            SubMans[idx].Visible = visible;
            if (SubMans[idx].HasNewRealMan) SubMans[idx].pairMan.Visible = false; //非表示
          }
          #else
          SubMans[idx].Visible = visible;
          #endif
        }

        //男の自動表示 モーションの有無で人数を切り替え
        private void AutoMansVisible(int maidID, string t) {
          if (cfgw.autoManEnabled) {
            int manNum = 0; //男無し
            //6pまでチェック mとm2がない場合がある
            string mamMotion = Regex.Replace(t.Replace(".anm", ""), @"_f\d?$", "_m");
            if (MotionOldCheck(mamMotion) != -1) manNum++;
            if (MotionOldCheck(mamMotion+"2") != -1) manNum++;
            if (MotionOldCheck(mamMotion+"3") != -1) manNum++;
            if (MotionOldCheck(mamMotion+"4") != -1) manNum++;
            if (MotionOldCheck(mamMotion+"5") != -1) manNum++;
            //Debug.Log("AutoMansVisible "+mamMotion+" manNum="+manNum);

            //現在の人数カウント 余分な男は減らす
            for (int im = 0; im < SubMans.Length; im++) {
              if (!SubMans[im]) SubMans[im] = GameMain.Instance.CharacterMgr.GetMan(im);
              if (isSubManVisible(im) && MansTg[im] == maidID) {
                //不要なリンクしている男を非表示
                if (manNum <= 0) {
                  setSubManVisible(im, false);
                  MansTg[im] = -1;
                }
                //表示済みならカウントを減らす
                else manNum--;
              }
            }
            for (int im = 0; im < SubMans.Length; im++) {
              if (manNum == 0) break;
              if (!isSubManVisible(im)) {
                //非表示の男を追加表示
                MansVisible(im);
                //maid.EyeToCamera((Maid.EyeMoveType)0, 0.8f);
                manNum--;
              }
            }
          }
        }

        //男表示切替
        private void MansVisible(int manIdx) {
          if (isSubManVisible(manIdx)) {
            setSubManVisible(manIdx, false);
          } else {
            setSubManVisible(manIdx, true); //読み込み開始させる
            MansTg[manIdx] = tgID;
            Maid subMan  = getSubMan(manIdx);
            subMan.transform.position = stockMaids[MansTg[manIdx]].mem.transform.position;
            subMan.transform.eulerAngles = stockMaids[MansTg[manIdx]].mem.transform.eulerAngles;
            if (cfgw.forceManChinkoVisible) subMan.body0.SetChinkoVisible(true);

            //男の位置調整 追加した男のみ
            setManMotionPosition(tgID, manIdx);

            #if COM3D2_5
            //男切り替え時に見えなくするために一時的に位置を下げる  ToNewRealMan()後に表示していないとロードされない？
            if (cfgw.realManHideOffsetY != 0) {
              if (cfgw.useRealMan && subMan.HasNewRealMan && subMan.IsAllProcPropBusy) {
                //男のロードが終わっていない
                Vector3 pos = subMan.transform.localPosition;
                pos.y += cfgw.realManHideOffsetY; //下げる
                subMan.transform.localPosition = pos;
                StartCoroutine(ManLoadWaitCoroutine(subMan));
              }
            }
            #endif
          }

          checkFpsMan(); //1人称視点自動変更が有効な場合は再取得
          if (fpsModeEnabled && fpsMan && !fpsMan.Visible) setFpsModeEnabled(false); //男非表示なら無効化
        }
        #if COM3D2_5
        //ロード中に隠した男を表示する
        private IEnumerator ManLoadWaitCoroutine(Maid subMan)
        {
          int cnt = 0; //最大ループ回数 10秒
          while(subMan.IsAllProcPropBusy && cnt < 100) {
            cnt++;
            yield return new WaitForSeconds(0.1f);  //0.1秒待つ
            //Debug.LogError("ManLoadWaitCoroutine wait "+cnt);
          }
          //元の位置に戻す
          Vector3 pos = subMan.transform.localPosition;
          pos.y -= cfgw.realManHideOffsetY;
          subMan.transform.localPosition = pos;
        }
        #endif

        //メイドが対象になっている男の人数を取得
        private int MansTgCheck(int maidID) {
          int count = 0;
          for (int im = 0; im < SubMans.Length; im++) {
            if (!SubMans[im]) SubMans[im] = GameMain.Instance.CharacterMgr.GetMan(im);
            if (MansTg[im] == maidID && isSubManVisible(im)) count++;
          }
          return count;
        }

        private bool AndKey() {
          bool andKey = false;
          int index1 = Array.IndexOf(cfgw.andKeyEnabled, true);
          if (index1 == -1) {
            if (!Input.GetKey(KeyCode.LeftControl) && !Input.GetKey(KeyCode.RightControl) && !Input.GetKey(KeyCode.LeftAlt) && !Input.GetKey(KeyCode.RightAlt) && !Input.GetKey(KeyCode.LeftShift) && !Input.GetKey(KeyCode.RightShift)) andKey = true;
          } else if (index1 == 0) {
            if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl)) andKey = true;
          } else if (index1 == 1) {
            if (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt)) andKey = true;
          } else if (index1 == 2) {
            if (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift)) andKey = true;
          }

          return andKey;
        }

        //ショートカットキー
        private void ShortCutKey() {

          if ((ConfigFlag == 0 || ConfigFlag == 1 || !cfgw.configGuiFlag) && scKeyOff) scKeyOff = false;

          if (!scKeyOff && AndKey()) {

            if (Input.anyKeyDown) {

            //　バイブの切替
            if (Input.GetKeyDown(cfgw.keyPluginToggleV4)) {
              //foreach (int maidID in vmId) {
                //if (maidID != tgID && !LinkMaidCheck(tgID, maidID)) continue;
              foreach (int maidID in vymMaidIDList(tgID, cfgw.vibeLinkType)) { //リンクメイド対応
                maidsState[maidID].vLevel = 2;
                maidsState[maidID].pAutoSelect = 0;
                vibeStart(maidID, maidsState[maidID]);
              }
              Console.WriteLine("バイブ強");
            }

            if (Input.GetKeyDown(cfgw.keyPluginToggleV3)) {
              MaidState maidState = maidsState[tgID];
              //foreach (int maidID in vmId) {
                //if (maidID != tgID && !LinkMaidCheck(tgID, maidID)) continue;
              foreach (int maidID in vymMaidIDList(tgID, cfgw.vibeLinkType)) { //リンクメイド対応
                maidsState[maidID].vLevel = 1;
                maidsState[maidID].pAutoSelect = 0;
                vibeStart(maidID, maidsState[maidID]);
              }
              Console.WriteLine("バイブ弱");
            }

            if (Input.GetKeyDown(cfgw.keyPluginToggleV2)) {
              MaidState maidState = maidsState[tgID];
              //foreach (int maidID in vmId) {
                //if (maidID != tgID && !LinkMaidCheck(tgID, maidID)) continue;
              foreach (int maidID in vymMaidIDList(tgID, cfgw.vibeLinkType)) { //リンクメイド対応
                maidsState[maidID].vLevel = 0;
                maidsState[maidID].pAutoSelect = 0;
                vibeStop(maidID, maidsState[maidID]);
              }
              Console.WriteLine("バイブ停止");
            }

            //　男表示切替
            if (Input.GetKeyDown(cfgw.keyPluginToggleV6)) {
              if (!SubMans[0]) SubMans[0] = GameMain.Instance.CharacterMgr.GetMan(0);
              if (SubMans[0]) MansVisible(0);
            }


            //　感度全開（デバッグ用）
            if (Input.GetKeyDown(KeyCode.Z)) {
              if (maidsState[tgID].exciteValue < 12000) maidsState[tgID].exciteValue = 12000;
              if (maidsState[tgID].orgasmValue < 80) maidsState[tgID].orgasmValue = 80;
              maidsState[tgID].boostValue = 50;
              maidsState[tgID].maidStamina = Math.Max(0, maidsState[tgID].maidStamina-500);
              #if DEBUG
              maidsState[tgID].orgasmCount += 1;
              maidsState[tgID].orgasmCmb += 1;
              maidsState[tgID].orgasmHoldTime = 600;
              #endif
              Console.WriteLine("感度全開 : スタミナ="+maidsState[tgID].maidStamina);
            }


            //　一人称視点切り替え 男表示時のみ
            if (Input.GetKeyDown(cfgw.keyPluginToggleV7)) {
              if (fpsMan.Visible) setFpsModeEnabled(!fpsModeEnabled); //トグル
              else setFpsModeEnabled(false);
              
            }

            //　快感値ロック
            if (Input.GetKeyDown(cfgw.keyPluginToggleV8)) ExciteLock = !ExciteLock;

            //　絶頂値ロック
            if (Input.GetKeyDown(cfgw.keyPluginToggleV9)) OrgasmLock = !OrgasmLock;

            //　オートモード切り替え
            /*if (Input.GetKeyDown(cfgw.keyPluginToggleV10)) {

            }*/

            /*if (Input.GetKeyDown(KeyCode.UpArrow)) {
              StartPrevMotion();
            }
            if (Input.GetKeyDown(KeyCode.DownArrow)) {
              StartNextMotion();
            }*/

            }

            //　メイド切替
            //正面メイド選択 GetKey で押している間実行
            if (Input.GetKey(cfgw.keyPluginMaidFront)) {
              int frontMaidID = GetFrontMaid(mainCamera.GetRealHeadTransform(), cfgw.vrFrontMaidAngle, cfgw.vrFrontMaidBackward, cfgw.vrFrontMaidCenter); //VRスティック上の時
              if (frontMaidID != -1 && tgID != frontMaidID) changeTargetMaid(frontMaidID);
              //depthOfField.focalTransformTime = cfgw.DepthFocalTransformTime; //スムーズにフォーカス切替
            }
            else if (Input.GetKeyDown(cfgw.keyPluginMaidPrev)) {
              changePrevMaid(false, cfgw.besideMaidTarget);
            }
            else if (Input.GetKeyDown(cfgw.keyPluginMaidNext)) {
              changeNextMaid(false, cfgw.besideMaidTarget);
            }
            //メイド1～3指定
            else if (Input.GetKeyDown(cfgw.keyPluginMaid1)) {
              if (tgID == vmId[0]) return;
              if (vmId.Count >= 2) changeTargetMaid(vmId[0]);
              if (cfgw.CamChangeEnabled) {
                if (!maidFollowEnabled) CameraChange(tgID, cfgw.cameraChangeDistance, cfgw.cameraChangeTurn, 0); //カメラジャンプ ※メイド固定時は自動移動
              } else {
                followReturnSpeedY = -1f; //メイド固定で移動するのでメイド固の縦移動速度は標準に戻す
                #if DOF
                if (!maidFollowEnabled) depthOfField.focalTransformTime = cfgw.DepthFocalTransformTime; //スムーズにフォーカス切替
                #endif
              }
            }
            else if (Input.GetKeyDown(cfgw.keyPluginMaid2)) {
              if (tgID == vmId[1]) return;
              if (vmId.Count >= 2) changeTargetMaid(vmId[1]);
              if (cfgw.CamChangeEnabled) {
                if (!maidFollowEnabled) CameraChange(tgID, cfgw.cameraChangeDistance, cfgw.cameraChangeTurn, 0); //カメラジャンプ ※メイド固定時は自動移動
              } else {
                followReturnSpeedY = -1f; //メイド固定で移動するのでメイド固の縦移動速度は標準に戻す
                #if DOF
                if (!maidFollowEnabled) depthOfField.focalTransformTime = cfgw.DepthFocalTransformTime; //スムーズにフォーカス切替
                #endif
              }
            }
            else if (Input.GetKeyDown(cfgw.keyPluginMaid3)) {
              if (tgID == vmId[2]) return;
              if (vmId.Count >= 3) changeTargetMaid(vmId[2]);
              if (cfgw.CamChangeEnabled) {
                if (!maidFollowEnabled) CameraChange(tgID, cfgw.cameraChangeDistance, cfgw.cameraChangeTurn, 0); //カメラジャンプ ※メイド固定時は自動移動
              } else {
                followReturnSpeedY = -1f; //メイド固定で移動するのでメイド固の縦移動速度は標準に戻す
                #if DOF
                if (!maidFollowEnabled) depthOfField.focalTransformTime = cfgw.DepthFocalTransformTime; //スムーズにフォーカス切替
                #endif
              }
            }

            //マウスホイールによる高さ調整
            if (!fpsModeEnabled) {
              if (Input.GetMouseButton(0)) {
                foreach (int maidID in vmId) {
                  if (tgID != maidID && !LinkMaidCheck(tgID, maidID)) continue;
                  Vector3 vm = stockMaids[maidID].mem.transform.position;
                  stockMaids[maidID].mem.transform.position = new Vector3(vm.x, vm.y + Input.GetAxis("Mouse ScrollWheel") / 10, vm.z);
                }
                for (int i = 0; i < SubMans.Length; i++) {
                  if (!isSubManVisible(i) || MansTg[i] != tgID) continue;
                  Maid subMan = getSubMan(i);
                  Vector3 vm = subMan.transform.position;
                  subMan.transform.position = new Vector3(vm.x, vm.y + Input.GetAxis("Mouse ScrollWheel") / 10, vm.z);
                }
              }

              if (Input.GetMouseButton(1)) {
                for (int i = 0; i < SubMans.Length; i++) {
                  if (!isSubManVisible(i) || MansTg[i] != tgID) continue;
                  Maid subMan = getSubMan(i);
                  Vector3 vm = subMan.transform.position;
                  subMan.transform.position = new Vector3(vm.x, vm.y + Input.GetAxis("Mouse ScrollWheel") / 20, vm.z);
                }
              }
            }

            //ランダムモーション変更
            if (tgID != -1 && maidsState[tgID].editMotionSetName != "") {
              if (dClickL) maidsState[tgID].msTime1 = 0;  //左ダブルクリックでカテゴリチェンジ
              if (dClickR) maidsState[tgID].msTime2 = 0;  //右ダブルクリックでモーションチェンジ
            }

          }

        }

        /// <summary>
        /// VR用ショートカットキー用コントローラーの抽象クラス
        /// Start()でVR機器に応じたクラスて初期化する
        /// 毎フレームの利用前に setInput() を実行すること
        /// </summary>
        public abstract class VRShortCutController
        {
          public bool followToggle = false;

          //ショートカット用トリガーorグリップ (LTrigger=0 RTrigger=1 LGrip=2 RGrip=3 設定なし(無効)=4)
          public int followButtonIdx = 0;
          public int followOffButtonIdx = 0;
          public int maidButtonIdx = 1;
          public int focusButtonIdx = 0;
          public int vibeButtonIdx = 3;
          public int motionButtonIdx = 1;
          public int motionButton2Idx = 3;
          public int frontMaidIdx = 3;
          //public int frontMaidAxisIdx = 1;

          //スティックのコントローラー 左右 (L=0 R=1 設定なし=2)
          public int maidAxisIdx = 1;
          public int vibeAxisIdx = 1;
          public int motionAxisIdx = 1;

          //カメラ移動トリガーorグリップ (LTrigger=0 RTrigger=1 LGrip=2 RGrip=3 設定なし(無効)=4)
          public int speedButtonIdx = 0;
          public int breakButtonIdx = 2;
          //カメラ移動制限 (LTrigger=0 RTrigger=1 LGrip=2 RGrip=3 設定なし(無効)=4)
          public int moveLimitButtonIdx = 0;
          //スティックのコントローラー 左右 (L=0 R=1 設定なし=2)
          public int aroundAxisIdx = 0;
          public int udAxisIdx = 1;
          public int lrAxisIdx = 0;
          public int zoomAxisIdx = 0;
          public int turnAxisIdx = 1;

          //スティックの1回のみの入力判定用 中央に戻ったらtrueに戻す
          public bool maidAxisEnabled = true;
          public bool vibeAxisEnabled = true;
          public bool motionAxisEnabled = true;
          public bool frontMaidAxisEnabled = true;

          //スティック長押しチェック用
          public float vibeAxisStartTime = 0;
          public bool vibeAxisUp = true;
          public float motionAxisStartTime = 0;
          public bool motionAxisUp = true;

          //カメラ範囲外判定角度(ラジアン)
          public float outsideMaidAngle = 0;

          public Transform vrCameraOrigin;  //GripMoveと同等の移動をさせる場合に利用
          public Transform trRoomBase = null; //GripMove移動量リセット処理用
          public Transform headTransform;   //HMDの位置と回転
          public Transform directionTransform; //自由移動進行方向用 cfgw.vrCameraMoveHeadDirectionの設定が変わった時点で入れ替える
          public bool directionFixHeight = false; //HMD移動時の高さ固定フラグ

           //トリガーとグリップの押し込み量を格納する配列
          protected float[] press = new float[]{0,0,0,0,0,1};
          //左右スティックの傾きを格納する配列
          protected Vector2[] axis = new Vector2[3]{Vector2.zero, Vector2.zero, Vector2.zero};

          //デバイスごとの初期化
          public abstract void init(VibeYourMaidCfgWriting cfgw);

          //コントローラの入力をまとめて取得して配列に格納する 毎フレーム実行すること
          public abstract void setInput();
          
          //メイド固定用のボタンがPress状態を先にチェック (毎フレーム実行 DownやUpやトリガーより先にチェック)
          public abstract bool getFollowPress();
          //メイド固定ボタンが押されたか トリガーが押されているかは先にチェック済み
          public abstract bool getFollowOn();
          //メイド固定解除ボタンが押されたか グリップとボタンのどちらが先でも可 (トリガーが押されていても解除優先)
          public abstract bool getFollowOff();

          //カメラジャンプ時の補正のキャンセルボタンが押されているか
          public abstract bool getCameraJumpFixCancel();


          //共通部分の初期化 initから呼ばれる
          protected void initBase(VibeYourMaidCfgWriting cfgw)
          {
            //移動トリガー
            speedButtonIdx = getButtonIdx(cfgw.vrCameraSpeedTrigger);
            //減速トリガー
            breakButtonIdx = getButtonIdx(cfgw.vrCameraBreakTrigger);
            //移動制限トリガー
            moveLimitButtonIdx = getButtonIdx(cfgw.vrCameraMoveLimitTrigger);
            //最短距離制限常時有効なButtonIndex変更
            if (cfgw.vrCameraMoveLimitAlways) moveLimitButtonIdx = getButtonIdx("ALWAYS");

            followButtonIdx = getButtonIdx(cfgw.vrShortCutFollowOn);
            followOffButtonIdx = getButtonIdx(cfgw.vrShortCutFollowOff);
            //directionResetIdx = getButtonIdx(cfgw.vrShortCutDirectionReset);
            maidButtonIdx = getButtonIdx(cfgw.vrShortCutMaidTarget);
            focusButtonIdx = getButtonIdx(cfgw.vrShortCutMaidFocus);
            vibeButtonIdx = getButtonIdx(cfgw.vrShortCutVibe);
            motionButtonIdx = getButtonIdx(cfgw.vrShortCutMotion);
            motionButton2Idx = getButton2Idx(cfgw.vrShortCutMotion);

            followToggle = followButtonIdx == followOffButtonIdx;

            maidAxisIdx = getAxisIdx(cfgw.vrShortCutMaidTarget);
            vibeAxisIdx = getAxisIdx(cfgw.vrShortCutVibe);
            motionAxisIdx = getAxisIdx(cfgw.vrShortCutMotion);

            zoomAxisIdx = getAxisIdx(cfgw.vrCameraMoveStickZoom);
            udAxisIdx = getAxisIdx(cfgw.vrCameraMoveStickUD);
            aroundAxisIdx = getAxisIdx(cfgw.vrCameraMoveStickAround);
            lrAxisIdx = getAxisIdx(cfgw.vrCameraMoveStickLR);
            turnAxisIdx = getAxisIdx(cfgw.vrCameraMoveStickTurn);

            //正面メイド選択
            frontMaidIdx = getButtonIdx(cfgw.vrFrontMaidTrigger);
            //frontMaidAxisIdx = getAxisIdx(cfgw.vrFrontMaidTrigger);
            //正面範囲外判定角度をラジアンで設定
            outsideMaidAngle = Mathf.Deg2Rad * cfgw.vrOutsideMaidAngle;

          }
          //進行方向の設定変更 initの最後で呼ぶ
          public void setDirectionTransform(bool vrCameraMoveHeadDirection, bool vrCameraMoveHeadFixHeight)
          {
            directionTransform = vrCameraMoveHeadDirection ? headTransform : vrCameraOrigin;
            //高さ固定フラグも変更
            directionFixHeight = vrCameraMoveHeadDirection && vrCameraMoveHeadFixHeight;
          }

          //トリガーボタンの値が格納されている配列インデックス
          private int getButtonIdx(string key)
          {
            switch (key) {
              case "LT": return 0;
              case "RT": return 1;
              case "LG": return 2;
              case "RG": return 3;
              case "LTG": return 0; //トリガーを設定 グリップはgetButton2Idxで設定
              case "RTG": return 1; //トリガーを設定 グリップはgetButton2Idxで設定
              case "ALWAYS": return 5; //常時有効
            }
            return 4; //無効
          }
          //トリガーとグリップ同時押し時の2つ目のボタンの配列インデックス
          private int getButton2Idx(string key)
          {
            switch (key) {
              case "LTG": return 2; //グリップを設定
              case "RTG": return 3; //グリップを設定
            }
            return 4; //無効
          }
          //左右スティックの値が格納されている配列インデックス
          private int getAxisIdx(string key)
          {
            if (key.StartsWith("L")) return 0;
            if (key.StartsWith("R")) return 1;
            return 2;
          }

          //指定したボタンの押し込み量を取得
          public float getPress(int idx)
          {
            return press[idx];
          }
          //左右スティックの値を取得 idx 左:0 右:1
          public Vector2 getAxis(int idx)
          {
            return axis[idx];
          }
          public float getAxisX(int idx)
          {
            return axis[idx].x;
          }
          public float getAxisY(int idx)
          {
            return axis[idx].y;
          }
          //両方のコントローラでidx以外のトリガー/グリップが同時に押されていなければtrue
          public bool isPressOnly(int idx)
          {
            switch (idx) {
              case 0: return press[1] == 0f && press[2] == 0f &&  press[3] == 0f;
              case 1: return press[0] == 0f && press[2] == 0f &&  press[3] == 0f;
              case 2: return press[0] == 0f && press[1] == 0f &&  press[3] == 0f;
              case 3: return press[0] == 0f && press[1] == 0f &&  press[2] == 0f;
            }
            return false;
          }
          //コントローラーのボタンが押されていない
          /// <param name="LR">0=左 1=右 それ以外=両方</param>
          public bool isNoPress(int LR)
          {
            if (LR == 0) return press[0] == 0f && press[2] == 0f;
            if (LR == 1) return press[1] == 0f && press[3] == 0f;
            return press[0] == 0f && press[1] == 0f && press[2] == 0f &&  press[3] == 0f;
          }

          //スティック移動をキャンセルするフラグを設定  グリップ+左右でジャンプしたときにtrue
          /*private bool[] cancelMoveX = new bool[3]; //0:左 1:右 2:設定なし
          public bool isCancelMoveX(int idx)
          {
            return cancelMoveX[idx];
          }
          public void setCancelMoveX(int idx, bool cancel)
          {
            cancelMoveX[idx] = cancel;
          }*/
        }

        //ショートカットコントローラークラス VRでない場合用のダミー VR以外でショートカットが有効になった場合は操作なしの状態を返す
        public class VRShortCutControllerNone : VRShortCutController
        {
          public override void init(VibeYourMaidCfgWriting cfgw) { }
          public override void setInput() { }
          public override bool getFollowPress() { return false; }
          public override bool getFollowOn() { return false; }
          public override bool getFollowOff() { return false; }
          public override bool getCameraJumpFixCancel() { return false; }
        }

#if UNITY_2022_3
        //ショートカットコントローラークラス Quest OpenXR用
        public class VRShortCutControllerQuest : VRShortCutController
        {
          UnityEngine.XR.InputDevice leftDevice;
          UnityEngine.XR.InputDevice rightDevice;

          //メイド固定ボタンPress取得用 UpとDown取得はAVRControllerButtons利用
          UnityEngine.XR.InputDevice followDevice;
          UnityEngine.XR.InputFeatureUsage<bool> followPress = UnityEngine.XR.CommonUsages.primaryButton;

          OvrMgr OvrMgr = GameMain.Instance.OvrMgr;
          //メイド固定ボタン取得用 デフォルトは右 ※STICK_PADはスティックのクリックになる
          OvrMgr.OvrObject.Controller followController;
          AVRControllerButtons.BTN followButton = AVRControllerButtons.BTN.VIRTUAL_L_CLICK;
          OvrMgr.OvrObject.Controller followOffController;
          AVRControllerButtons.BTN followOffButton = AVRControllerButtons.BTN.VIRTUAL_L_CLICK;
          AVRControllerButtons.BTN followOffTrigger = AVRControllerButtons.BTN.GRIP; //GetPressDown取得用

          //カメラジャンプ時の補正キャンセルボタン
          bool cameraJumpFixCancel = true;
          UnityEngine.XR.InputDevice cameraCancelDevice;
          UnityEngine.XR.InputFeatureUsage<bool> cameraCancelPress = UnityEngine.XR.CommonUsages.triggerButton;
          //OvrMgr.OvrObject.Controller cameraJumpFixCancelController;
          //AVRControllerButtons.BTN cameraJumpFixCancelButton = AVRControllerButtons.BTN.TRIGGER;

          //コントローラー生成
          public VRShortCutControllerQuest(VibeYourMaidCfgWriting cfgw)
          {
            init(cfgw);
          }

          //初期化
          public override void init(VibeYourMaidCfgWriting cfgw)
          {
            //共通の初期化
            initBase(cfgw);

            leftDevice = UnityEngine.XR.InputDevices.GetDeviceAtXRNode(UnityEngine.XR.XRNode.LeftHand);
            rightDevice = UnityEngine.XR.InputDevices.GetDeviceAtXRNode(UnityEngine.XR.XRNode.RightHand);

            //Debug.Log("[VibeYourMaid] leftDevice="+leftDevice+" isValid="+leftDevice.isValid+" name="+leftDevice.name+" manufacturer="+leftDevice.manufacturer);

            OvrMgr OvrMgr = GameMain.Instance.OvrMgr;
            //メイド固定 コントローラー変更 ONとOFFは同じボタン
            followController = OvrMgr.ovr_obj.right_controller;
            followDevice = rightDevice;
            followOffController = OvrMgr.ovr_obj.right_controller;
            if (cfgw.vrShortCutFollowOn.StartsWith("L")) {
              followController = OvrMgr.ovr_obj.left_controller;
              followOffController = OvrMgr.ovr_obj.left_controller;
              followDevice = leftDevice;
            }
            /*if (cfgw.vrShortCutFollowOff.StartsWith("L")) {
              followOffController = OvrMgr.ovr_obj.left_controller;
            }*/

            //カメラジャンプ時の補正キャンセルボタン デフォルトRT
            if (cfgw.vrCameraJumpFixCancelButton == "RT") {
              cameraCancelDevice = rightDevice;
            } else if (cfgw.vrCameraJumpFixCancelButton == "LT") {
              cameraCancelDevice = leftDevice;
            } else if (cfgw.vrCameraJumpFixCancelButton == "X") {
              cameraCancelDevice = leftDevice;
              cameraCancelPress = UnityEngine.XR.CommonUsages.primaryButton;
            } else if (cfgw.vrCameraJumpFixCancelButton == "A") {
              cameraCancelDevice = rightDevice;
              cameraCancelPress = UnityEngine.XR.CommonUsages.primaryButton;
            } else {
              cameraJumpFixCancel = false; //無効
            }

            //HMD位置
            GameObject obj;
            //obj = GameObject.Find("TrackingSpace/CenterEyeAnchor");
            //if (obj) headTransform = obj.transform;
            if (GameMain.Instance.OvrMgr.OvrCamera != null) {
              headTransform = GameMain.Instance.OvrMgr.OvrCamera.transform;
            }

            //GripMoveと同じ移動対象
            if (cfgw.vrCameraFreeMoveMode.ToUpper() == "GRIP") {
              obj = GameObject.Find("BaseRoomBase");
              if (obj) {
                vrCameraOrigin = obj.transform;
                trRoomBase = vrCameraOrigin; //GripMoveリセット処理用
              }
            } else if (cfgw.vrCameraFreeMoveMode.ToUpper() == "TRACKING") {
              obj = GameObject.Find("TrackingSpace");
              if (obj) vrCameraOrigin = obj.transform;
              cfgw.vrCameraMoveLimit = false; //移動制限無効化
            }

            setDirectionTransform(cfgw.vrCameraMoveHeadDirection, cfgw.vrCameraMoveHeadFixHeight);
          }

          //コントローラの入力をまとめて取得する 毎フレーム実行 Quest用
          public override void setInput()
          {
            //トリガー/グリップ押し込み量取得
            //LTrigger=0 RTrigger=1 LGrip=2 RGrip=3 無効=4
            float value;
            leftDevice.TryGetFeatureValue(UnityEngine.XR.CommonUsages.trigger, out value);
            press[0] = value;
            rightDevice.TryGetFeatureValue(UnityEngine.XR.CommonUsages.trigger, out value);
            press[1] = value;
            leftDevice.TryGetFeatureValue(UnityEngine.XR.CommonUsages.grip, out value);
            press[2] = value;
            rightDevice.TryGetFeatureValue(UnityEngine.XR.CommonUsages.grip, out value);
            press[3] = value;

            //スティックの値 L=0, R=1
            leftDevice.TryGetFeatureValue(UnityEngine.XR.CommonUsages.primary2DAxis, out Vector2 axisValue);
            axis[0] = axisValue;
            rightDevice.TryGetFeatureValue(UnityEngine.XR.CommonUsages.primary2DAxis, out axisValue);
            axis[1] = axisValue;
          }

          //メイド固定
          public override bool getFollowPress()
          {
            //毎フレーム呼ばれるのでInputDeviceを利用
            followDevice.TryGetFeatureValue(followPress, out bool press);
            return press;
            //return followController.controller_buttons.GetPress(followButton);
          }
          public override bool getFollowOn()
          {
            return getPress(followButtonIdx) > 0f && followController.controller_buttons.GetPressDown(followButton);
          }
          public override bool getFollowOff()
          {
            return followOffController.controller_buttons.GetPress(followOffButton) && followOffController.controller_buttons.GetPressDown(followOffTrigger)
              || followOffController.controller_buttons.GetPressDown(followOffButton) && followOffController.controller_buttons.GetPress(followOffTrigger);
          }
          //カメラジャンプ時の補正のキャンセルボタンが押されているか
          public override bool getCameraJumpFixCancel()
          {
            //ボタンを押している間はtrue
            if (cameraJumpFixCancel) {
              cameraCancelDevice.TryGetFeatureValue(cameraCancelPress, out bool press);
              return press;
              //return cameraJumpFixCancelController.controller_buttons.GetPress(cameraJumpFixCancelButton);
            }
            return false;
          }
        }
#else
        //ショートカットコントローラークラス Quest用
        public class VRShortCutControllerQuest : VRShortCutController
        {
          //メイド固定ボタン デフォルトは右
          OVRInput.Controller followController = OVRInput.Controller.RTouch;
          OVRInput.RawButton followButton = OVRInput.RawButton.A;
          OVRInput.Controller followOffController = OVRInput.Controller.RTouch;
          OVRInput.RawButton followOffButton = OVRInput.RawButton.A;
          OVRInput.RawButton followOffTrigger = OVRInput.RawButton.RHandTrigger; //GetDown取得用

          //カメラジャンプ時の補正キャンセルボタン
          bool cameraJumpFixCancel = true;
          OVRInput.Controller cameraJumpFixCancelController = OVRInput.Controller.RTouch;
          OVRInput.RawButton cameraJumpFixCancelButton = OVRInput.RawButton.RIndexTrigger; //右トリガー

          //コントローラー生成
          public VRShortCutControllerQuest(VibeYourMaidCfgWriting cfgw)
          {
            init(cfgw);
          }

          //初期化
          public override void init(VibeYourMaidCfgWriting cfgw)
          {
            //共通の初期化
            initBase(cfgw);

            //メイド固定 コントローラー変更
            if (cfgw.vrShortCutFollowOn.StartsWith("L")) {
              followController = OVRInput.Controller.LTouch;
              followButton = OVRInput.RawButton.X;
            }
            if (cfgw.vrShortCutFollowOff.StartsWith("L")) {
              followOffController = OVRInput.Controller.LTouch;
              followOffButton = OVRInput.RawButton.X;
              followOffTrigger = OVRInput.RawButton.LHandTrigger; //左グリップ
            }
            //カメラジャンプ時の補正キャンセルボタン デフォルトRT
            if (cfgw.vrCameraJumpFixCancelButton == "RT") {
              //デフォルト
            } else if (cfgw.vrCameraJumpFixCancelButton == "LT") {
              cameraJumpFixCancelController = OVRInput.Controller.LTouch;
              cameraJumpFixCancelButton = OVRInput.RawButton.LIndexTrigger;
            } else if (cfgw.vrCameraJumpFixCancelButton == "X") {
              cameraJumpFixCancelController = OVRInput.Controller.LTouch;
              cameraJumpFixCancelButton = OVRInput.RawButton.X;
            } else if (cfgw.vrCameraJumpFixCancelButton == "A") {
              cameraJumpFixCancelButton = OVRInput.RawButton.A;
            } else {
              cameraJumpFixCancel = false; //無効
            }

            //HMD位置
            GameObject obj;
            //obj = GameObject.Find("TrackingSpace/CenterEyeAnchor");
            //if (obj) headTransform = obj.transform;
            if (GameMain.Instance.OvrMgr.OvrCamera != null) {
              headTransform = GameMain.Instance.OvrMgr.OvrCamera.transform;
            }

            //GripMoveと同じ移動対象
            if (cfgw.vrCameraFreeMoveMode.ToUpper() == "GRIP") {
              obj = GameObject.Find("BaseRoomBase");
              if (obj) {
                vrCameraOrigin = obj.transform;
                trRoomBase = vrCameraOrigin; //GripMoveリセット処理用
              }
            } else if (cfgw.vrCameraFreeMoveMode.ToUpper() == "TRACKING") {
              obj = GameObject.Find("TrackingSpace");
              if (obj) vrCameraOrigin = obj.transform;
              cfgw.vrCameraMoveLimit = false; //移動制限無効化
            }

            setDirectionTransform(cfgw.vrCameraMoveHeadDirection, cfgw.vrCameraMoveHeadFixHeight);
          }

          //コントローラの入力をまとめて取得する 毎フレーム実行 Quest用
          public override void setInput()
          {
            //トリガー/グリップ押し込み量取得
            //LTrigger=0 RTrigger=1 LGrip=2 RGrip=3 無効=4
            press[0] = OVRInput.Get(OVRInput.RawAxis1D.LIndexTrigger, OVRInput.Controller.LTouch);
            press[1] = OVRInput.Get(OVRInput.RawAxis1D.RIndexTrigger, OVRInput.Controller.RTouch);
            press[2] = OVRInput.Get(OVRInput.RawAxis1D.LHandTrigger, OVRInput.Controller.LTouch);
            press[3] = OVRInput.Get(OVRInput.RawAxis1D.RHandTrigger, OVRInput.Controller.RTouch);

            //スティックの値 L=0, R=1
            axis[0] = OVRInput.Get(OVRInput.RawAxis2D.LThumbstick, OVRInput.Controller.LTouch);
            axis[1] = OVRInput.Get(OVRInput.RawAxis2D.RThumbstick, OVRInput.Controller.RTouch);
          }

          //メイド固定用のボタンがPress状態を先にチェック 毎フレームなのでDownやUpやトリガーより先にチェック
          public override bool getFollowPress()
          {
            return OVRInput.Get(followButton, followController);
          }
          //メイド固定ボタンが押されたか
          public override bool getFollowOn()
          {
            return getPress(followButtonIdx) > 0f && OVRInput.GetDown(followButton, followController);
          }
          //メイド固定解除ボタンが押されたか グリップとボタンのどちらが先でも可
          public override bool getFollowOff()
          {
            return OVRInput.Get(followOffTrigger, followOffController) && OVRInput.GetDown(followOffButton, followOffController)
              || OVRInput.GetDown(followOffTrigger, followOffController) && OVRInput.Get(followOffButton, followOffController);
          }
          //カメラジャンプ時の補正のキャンセルボタンが押されているか
          public override bool getCameraJumpFixCancel()
          {
            //ボタンを押している間はtrue
            if (cameraJumpFixCancel) return OVRInput.Get(cameraJumpFixCancelButton, cameraJumpFixCancelController);
            return false;
          }
        }
#endif
        //ショートカットコントローラークラス SteamVR用
        public class VRShortCutControllerVive : VRShortCutController
        {
          OvrMgr OvrMgr = GameMain.Instance.OvrMgr;
          //メイド固定ボタン取得用 デフォルトは右
          OvrMgr.OvrObject.Controller followController;
          AVRControllerButtons.BTN followButton = AVRControllerButtons.BTN.STICK_PAD;
          OvrMgr.OvrObject.Controller followOffController;
          AVRControllerButtons.BTN followOffButton = AVRControllerButtons.BTN.STICK_PAD;
          AVRControllerButtons.BTN followOffTrigger = AVRControllerButtons.BTN.GRIP; //GetPressDown取得用

          //カメラジャンプ時の補正キャンセルボタン
          bool cameraJumpFixCancel = true;
          OvrMgr.OvrObject.Controller cameraJumpFixCancelController;
          AVRControllerButtons.BTN cameraJumpFixCancelButton = AVRControllerButtons.BTN.TRIGGER;

          //コントローラー生成
          public VRShortCutControllerVive(VibeYourMaidCfgWriting cfgw)
          {
            init(cfgw);
          }
          //初期化
          public override void init(VibeYourMaidCfgWriting cfgw)
          {
            //共通の初期化
            initBase(cfgw);

            //メイド固定 コントローラー変更
            followController = OvrMgr.ovr_obj.right_controller;
            if (cfgw.vrShortCutFollowOn.StartsWith("L")) {
              followController = OvrMgr.ovr_obj.left_controller;
            }
            followOffController = OvrMgr.ovr_obj.right_controller;
            if (cfgw.vrShortCutFollowOff.StartsWith("L")) {
              followOffController = OvrMgr.ovr_obj.left_controller;
            }

            //カメラジャンプ時の補正キャンセルボタン デフォルトRT
            if (cfgw.vrCameraJumpFixCancelButton == "RT") {
              cameraJumpFixCancelController = OvrMgr.ovr_obj.right_controller;
              cameraJumpFixCancelButton = AVRControllerButtons.BTN.TRIGGER;
            } else if (cfgw.vrCameraJumpFixCancelButton == "LT") {
              cameraJumpFixCancelController = OvrMgr.ovr_obj.left_controller;
              cameraJumpFixCancelButton = AVRControllerButtons.BTN.GRIP;
            } else if (cfgw.vrCameraJumpFixCancelButton == "X") {
              cameraJumpFixCancelController = OvrMgr.ovr_obj.left_controller;
              cameraJumpFixCancelButton = AVRControllerButtons.BTN.STICK_PAD;
            } else if (cfgw.vrCameraJumpFixCancelButton == "A") {
              cameraJumpFixCancelController = OvrMgr.ovr_obj.right_controller;
              cameraJumpFixCancelButton = AVRControllerButtons.BTN.STICK_PAD;
            } else {
              cameraJumpFixCancel = false; //無効
            }

            //HMD位置
            GameObject obj = GameObject.Find("ViveCameraRig(Clone)");
            if (obj) headTransform = obj.transform;
            Debug.Log("headTransform="+headTransform);

            //GripMoveと同じ移動対象 SteamVRだと高さがずれる？
            if (cfgw.vrCameraFreeMoveMode.ToUpper() == "GRIP") {
              obj = GameObject.Find("BaseRoomBase");
              if (obj) {
                vrCameraOrigin = obj.transform;
                trRoomBase = vrCameraOrigin; //GripMoveリセット処理用
              }
            }

            setDirectionTransform(cfgw.vrCameraMoveHeadDirection, cfgw.vrCameraMoveHeadFixHeight);
          }

          //コントローラの入力をまとめて取得する 毎フレーム実行 SteamVR用
          public override void setInput()
          {
            OvrMgr OvrMgr = GameMain.Instance.OvrMgr;
            //トリガー/グリップ押し込み量取得 AVRControllerButtonsではグリップのRateは取得できない？
            //LTrigger=0 RTrigger=1 LGrip=2 RGrip=3 無効=4
            press[0] = OvrMgr.ovr_obj.left_controller.controller_buttons.GetTriggerRate();
            press[1] = OvrMgr.ovr_obj.right_controller.controller_buttons.GetTriggerRate();
            press[2] = OvrMgr.ovr_obj.left_controller.controller_buttons.GetPress(AVRControllerButtons.BTN.GRIP) ? 1 : 0; 
            press[3] = OvrMgr.ovr_obj.right_controller.controller_buttons.GetPress(AVRControllerButtons.BTN.GRIP) ? 1 : 0;

            //スティックの値 L=0, R=1
            axis[0] = OvrMgr.GetVRControllerButtons(true).GetAxis();
            axis[1] = OvrMgr.GetVRControllerButtons(false).GetAxis();
          }

          //メイド固定用のボタンがPress状態を先にチェック
          public override bool getFollowPress()
          {
            return followController.controller_buttons.GetPress(followButton);
          }
          //メイド固定ボタンが押されたか
          public override bool getFollowOn()
          {
            return getPress(followButtonIdx) > 0f && followController.controller_buttons.GetPressDown(followButton);
          }
          //メイド固定解除ボタンが押されたか
          public override bool getFollowOff()
          {
            return followOffController.controller_buttons.GetPress(followOffButton) && followOffController.controller_buttons.GetPressDown(followOffTrigger)
              || followOffController.controller_buttons.GetPressDown(followOffButton) && followOffController.controller_buttons.GetPress(followOffTrigger);
          }
          //カメラジャンプ時の補正のキャンセルボタンが押されているか
          public override bool getCameraJumpFixCancel()
          {
            //ボタンを押している間はtrue
            if (cameraJumpFixCancel) return cameraJumpFixCancelController.controller_buttons.GetPress(cameraJumpFixCancelButton);
            return false;
          }
       }


        //VRショートカットキー操作
        private void ShortCutVR(VRShortCutController vrCtrl)
        {
          //VRショートカットが無効なら終了
          if (!cfgw.vrShortCut) return;

            //VRコントローラーの状態取得 Axisは1回しか取れない？
            vrCtrl.setInput();

            //メイド固定変更 メイドがいなくても設定
            if (vrCtrl.getFollowPress()) { //メイド固定ボタンが押されている状態
              //ボタンでトグル
              if (vrCtrl.followToggle) {
                if (vrCtrl.getFollowOn()) {
                  maidFollowEnabled = !maidFollowEnabled;
                  setDanceCameraDisabled(maidFollowEnabled); //ダンスカメラ有効無効切り替え
                  if (maidFollowEnabled) {
                    changeTargetMaid(GetLookingkMaidID(45f)); //正面にいるメイドに切り替え
                    //followReturnSpeedY = -1f; //縦移動速度は標準に戻す → 開始時は戻さない
                    bFollowLimitY = true; //メイド固定の高さ戻り制限
                    MaidFollowingCameraStart(tgID); //視点の向きを正面にしてメイド固定 VRのみ
                    if (vrCtrl.trRoomBase) resetRoomBase(vrCtrl.trRoomBase);
                  } else {
                    //メイド固定解除
                    float realAngleY = mainCamera.GetRealHeadTransform().rotation.eulerAngles.y;
                    if (vrCtrl.trRoomBase) {
                      resetRoomBase(vrCtrl.trRoomBase);
                    }
                  }
                }
              } else {
                //ON/OFF別ボタン 同時押しは解除優先 同時押しは向きもリセット
                if (vrCtrl.getFollowOff()) {
                  //メイド固定解除
                  float realAngleY = mainCamera.GetRealHeadTransform().rotation.eulerAngles.y;
                  if (maidFollowEnabled) setDanceCameraDisabled(false); //ダンスカメラ有効無効切り替え メイド固定が切り替わった場合
                  if (vrCtrl.trRoomBase) {
                    resetRoomBase(vrCtrl.trRoomBase);
                    //UOカメラの回転と距離を現在位置に合わせる  メイド固定を解除した時は位置がずれてしまうのでリセットしない
                    if (!maidFollowEnabled) resetUOCamera(mainCamera.GetTargetPos(), mainCamera.GetRealHeadTransform().position);
                  }
                  maidFollowEnabled = false;
                } else {
                  //メイド固定開始
                  if (vrCtrl.getFollowOn()) {
                  if (!maidFollowEnabled) setDanceCameraDisabled(true); //ダンスカメラ有効無効切り替え メイド固定が切り替わった場合
                    maidFollowEnabled = true;
                    changeTargetMaid(GetLookingkMaidID(45f)); //正面にいるメイドに切り替え
                    //followReturnSpeedY = -1f; //縦移動速度は標準に戻す → 開始時は戻さない
                    bFollowLimitY = true; //メイド固定の高さ戻り制限
                    MaidFollowingCameraStart(tgID); //視点の向きを正面にしてメイド固定 VRのみ
                    if (vrCtrl.trRoomBase) resetRoomBase(vrCtrl.trRoomBase);
                  }
                }
              }
            }
            
            //メイド操作 メイドの正面移動 2人以上いたらメインメイド切り替え 他のスティック操作中には反応しないように maidAxisEnabled のチェックを常時行う
            //アクティブメイド変更
            float axisX = vrCtrl.getAxisX(vrCtrl.maidAxisIdx);
            if (vrCtrl.maidAxisEnabled) {
              if (axisX < -0.8f) {
                vrCtrl.maidAxisEnabled = false;
                if (tgID != -1) {
                  //メイド切替
                  if (vrCtrl.getPress(vrCtrl.maidButtonIdx) > 0f) {
                    followReturnSpeedY = -1f; //縦移動速度は標準に戻す
                    if (vmId.Count >= 3 && cfgw.besideMaidTarget) changeTargetMaid(GetSideMaid(tgID, mainCamera.GetRealHeadTransform(), true, cfgw.besideMaidOpposite));
                    else if (vmId.Count >= 2) changeTargetMaid(getPrevMaid());
                    #if DOF
                    depthOfField.focalTransformTime = cfgw.DepthFocalTransformTime; //スムーズにフォーカス切替
                    #endif
                  }
                  //カメラ位置をメイド正面に
                  if (vrCtrl.getPress(vrCtrl.focusButtonIdx) > 0f) {
                    //メイド固定中かメイド切替時
                    if (maidFollowEnabled || vrCtrl.getPress(vrCtrl.maidButtonIdx) > 0f) {
                      followReturnSpeedY = -1f; //縦移動速度は標準に戻す
                      if (vrCtrl.trRoomBase) resetRoomBasePos(vrCtrl.trRoomBase); //GripMoveの移動をリセット 回転はそのまま
                      CameraChange(tgID, cfgw.cameraChangeDistance, cfgw.cameraChangeTurn, 0);
                      #if DOF
                      depthOfField.focalTransformTime = 0f; //フォーカスはすぐに切り替える
                      #endif
                    }
                  }
                }
              } else if (axisX > 0.8f) {
                vrCtrl.maidAxisEnabled = false;
                if (tgID != -1) {
                  //メイド切替
                  if (vrCtrl.getPress(vrCtrl.maidButtonIdx) > 0f) {
                    followReturnSpeedY = -1f; //縦移動速度は標準に戻す
                    if (vmId.Count >= 3 && cfgw.besideMaidTarget) changeTargetMaid(GetSideMaid(tgID, mainCamera.GetRealHeadTransform(), false, cfgw.besideMaidOpposite));
                    else if (vmId.Count >= 2) changeTargetMaid(getNextMaid());
                    #if DOF
                    depthOfField.focalTransformTime = cfgw.DepthFocalTransformTime; //スムーズにフォーカス切替
                    #endif
                  }
                  //カメラ位置をメイド正面に
                  if (vrCtrl.getPress(vrCtrl.focusButtonIdx) > 0f) {
                    //メイド固定中かメイド切替時
                    if (maidFollowEnabled || vrCtrl.getPress(vrCtrl.maidButtonIdx) > 0f) {
                      followReturnSpeedY = -1f; //縦移動速度は標準に戻す
                      if (vrCtrl.trRoomBase) resetRoomBasePos(vrCtrl.trRoomBase); //GripMoveの移動をリセット 回転はそのまま
                      CameraChange(tgID, cfgw.cameraChangeDistance, cfgw.cameraChangeTurn, 0);
                      #if DOF
                      depthOfField.focalTransformTime = 0f; //フォーカスはすぐに切り替える
                      #endif
                    }
                  }
                }
              }
            } else {
              if (axisX > -0.7f && axisX < 0.7f) { //軸が戻った判定
                vrCtrl.maidAxisEnabled = true;
              }
            }

            //上下でバイブ切り替え
            if (vrCtrl.getPress(vrCtrl.vibeButtonIdx) > 0) {
              if (tgID != -1) {
                float axisY = vrCtrl.getAxisY(vrCtrl.vibeAxisIdx);
                if (axisY > 0.8f) { //上
                  if (vrCtrl.vibeAxisEnabled) {
                    if (vrCtrl.isPressOnly(vrCtrl.vibeButtonIdx)) {
                      vrCtrl.vibeAxisUp = true;
                      if (vrCtrl.vibeAxisStartTime == 0) vrCtrl.vibeAxisStartTime = Time.time;
                      else if (Time.time - vrCtrl.vibeAxisStartTime >= 1f) { //1秒以上 長押し
                        vrCtrl.vibeAxisEnabled = false; //軸が戻るまで無効
                        //挿入が有効なら実行
                        int targetID = tgID;
                        if (cfgw.vibeLookingMaid) targetID = GetLookingkMaidID(45f); //正面にいるメイド
                        insertMotionChange(targetID, maidsState[targetID]);
                      }
                    }
                  }
                } else if (axisY < -0.8f) { //下
                  if (vrCtrl.vibeAxisEnabled) {
                    if (vrCtrl.isPressOnly(vrCtrl.vibeButtonIdx)) {
                      vrCtrl.vibeAxisUp = false;
                      if (vrCtrl.vibeAxisStartTime == 0) vrCtrl.vibeAxisStartTime = Time.time;
                      else if (Time.time - vrCtrl.vibeAxisStartTime >= 1f) { //1秒以上 長押し
                        vrCtrl.vibeAxisEnabled = false; //軸が戻るまで無効
                        //抜くが有効なら実行
                        int targetID = tgID;
                        if (cfgw.vibeLookingMaid) targetID = GetLookingkMaidID(45f); //正面にいるメイド
                        removeMotionChange(targetID, maidsState[targetID], false);
                      }
                    }
                  }
                } else if (axisY > -0.7f && axisY < 0.7f) { //軸が戻った判定
                  if (vrCtrl.vibeAxisStartTime != 0 && Time.time - vrCtrl.vibeAxisStartTime < 1f) { //1秒未満
                    if (vrCtrl.isPressOnly(vrCtrl.vibeButtonIdx)) { //他のトリガー/グリップが押されていない
                      //バイブ変更
                      if (vrCtrl.vibeAxisUp) { //バイブ強く
                        int targetID = tgID;
                        if (cfgw.vibeLookingMaid) targetID = GetLookingkMaidID(45f); //正面にいるメイド
                        if (maidsState[targetID].vLevel < 2) {
                          maidsState[targetID].vLevel += 1;
                          vibeStart(targetID, maidsState[targetID]);
                        }
                      } else  { //バイブ弱く
                        int targetID = tgID;
                        if (cfgw.vibeLookingMaid) targetID = GetLookingkMaidID(45f); //正面にいるメイド
                        if (maidsState[targetID].vLevel > 0) {
                          maidsState[targetID].vLevel -= 1;
                          if (maidsState[targetID].vLevel == 0) {
                            maidsState[targetID].pAutoSelect = 0; //バイブが止まったらオートも無効
                            vibeStop(targetID, maidsState[targetID]);
                          }
                        }
                      }
                    }
                  }
                  vrCtrl.vibeAxisStartTime = 0;
                  vrCtrl.vibeAxisEnabled = true;
                }
              }
            }

            //モーション切り替え パネル表示時のみ トリガーとグリップ同時押し
            if (cfgw.unzipGuiFlag && cfgw.mainGuiFlag != 0
              && vrCtrl.getPress(vrCtrl.motionButtonIdx) > 0 && (vrCtrl.motionButton2Idx == 4 ||vrCtrl.getPress(vrCtrl.motionButton2Idx) > 0)) {
              if (tgID != -1) {
                float axisY = vrCtrl.getAxisY(vrCtrl.motionAxisIdx);
                if (vrCtrl.motionAxisEnabled) {
                  if (axisY > 0.8f) { //上
                    vrCtrl.motionAxisUp = true;
                    if (vrCtrl.motionAxisStartTime == 0) vrCtrl.motionAxisStartTime = Time.time;
                    else if (Time.time - vrCtrl.motionAxisStartTime >= 1f) { //1秒以上
                      vrCtrl.motionAxisEnabled = false; //軸が戻るまで無効
                      MaidState tgMaidState = maidsState[tgID];
                      if (tgMaidState.motionID != -1 && maj.analEnabled[tgMaidState.motionID] && !tgMaidState.stunFlag) {
                        if (tgMaidState.analMode) {
                          tgMaidState.analMode = false;
                          analMotionChange(tgID, tgMaidState);
                        }
                      }
                    }
                  } else if (axisY < -0.8f) { //下
                    vrCtrl.motionAxisUp = false;
                    if (vrCtrl.motionAxisStartTime == 0) vrCtrl.motionAxisStartTime = Time.time;
                    else if (Time.time - vrCtrl.motionAxisStartTime >= 1f) { //1秒以上
                      vrCtrl.motionAxisEnabled = false; //軸が戻るまで無効
                      MaidState tgMaidState = maidsState[tgID];
                      if (tgMaidState.motionID != -1 && maj.analEnabled[tgMaidState.motionID] && !tgMaidState.stunFlag) {
                        if (!tgMaidState.analMode) {
                          tgMaidState.analMode = true;
                          analMotionChange(tgID, tgMaidState);
                        }
                      }
                    }
                  }
                } else if (axisY > -0.7f && axisY < 0.7f) { //軸が戻った判定
                  if (vrCtrl.motionAxisStartTime != 0 && Time.time - vrCtrl.motionAxisStartTime < 1f) { //1秒未満
                    //UNZIPパネル表示時のみ
                    if (cfgw.mainGuiFlag != 0 && cfgw.unzipGuiFlag) {
                      if (vrCtrl.motionAxisUp) StartPrevUnzip();
                      else StartNextUnzip();
                    }
                  }
                  vrCtrl.motionAxisStartTime = 0;
                  vrCtrl.motionAxisEnabled = true;
                }
              }
            }

        }

        //VRショートカットキー操作 移動
        private void ShortCutVRMove(VRShortCutController vrCtrl)
        {
            if (fpsModeEnabled) return; //一人称モードは移動しない

            //speedトリガーが押されている場合に各スティックをチェック
            //カメラ移動無効ならspeedButtonIdx=4でspeedが0になり処理されない 減速は 1倍～指定倍率(1未満なら減速) になるようにする
            float speed = vrCtrl.getPress(vrCtrl.speedButtonIdx);

            if (maidFollowEnabled && tgID != -1) {

              //メイド固定時
              if (speed > 0f) {
                speed = speed * (1f - (1f - cfgw.vrCameraBreakSpeed) * vrCtrl.getPress(vrCtrl.breakButtonIdx)); //減速
                speed = speed * (cfgw.vrCameraSpeedMax-cfgw.vrCameraSpeedStart) + cfgw.vrCameraSpeedStart; //開始速度と最大速度調整
                float margin = cfgw.vrCameraSpeedStickMargin;
                Vector2 xy;
                //周回
                xy = vrCtrl.getAxis(vrCtrl.aroundAxisIdx);
                if (xy.x <= -margin) { //左周回
                  mainCamera.SetAroundAngle(new Vector2(mainCamera.GetAroundAngle().x - (xy.x+margin) * 180f * speed*cfgw.vrCameraFollowSpeedAround
                    / Math.Max(mainCamera.GetDistance(), 0.5f) * Time.deltaTime, 0f), false); //Y軸回転 距離補正は0.1だと速すぎるので0.5まで
                  bFollowLimitAngle = true; //メイド固定のアングル戻りを制限
                } else if (xy.x >= margin) { //右周回
                  mainCamera.SetAroundAngle(new Vector2(mainCamera.GetAroundAngle().x - (xy.x-margin) * 180f * speed*cfgw.vrCameraFollowSpeedAround
                    / Math.Max(mainCamera.GetDistance(), 0.5f) * Time.deltaTime, 0f), false); //Y軸回転 距離補正は0.1だと速すぎるので0.5まで
                  bFollowLimitAngle = true; //メイド固定のアングル戻りを制限
                }
                //ズーム
                xy = vrCtrl.getAxis(vrCtrl.zoomAxisIdx);
                if (xy.y <= -margin) { //後
                  float dist = mainCamera.GetDistance();
                  dist -= (xy.y+margin) * 2f * speed*cfgw.vrCameraFollowSpeedZoom * (float)Math.Sqrt(dist*0.5f) * Time.deltaTime;
                  mainCamera.SetDistance(dist, false);
                } else if (xy.y >= margin) { //前 最短距離は制限
                  float dist = mainCamera.GetDistance();
                  dist -= (xy.y-margin) * 2f * speed*cfgw.vrCameraFollowSpeedZoom * (float)Math.Sqrt(dist*0.5f) * Time.deltaTime;
                  if (dist > cfgw.vrCameraMoveZoomMin) mainCamera.SetDistance(dist, false);
                }
                //左右移動 移動制限が難しいので無効
                /*if (vrCtrl.isNoPress(vrCtrl.leftrightAxisIdx)) {
                  xy = vrCtrl.getAxis(vrCtrl.leftrightAxisIdx);
                  if (xy.x <= -margin) { //左
                    Transform realTm = mainCamera.GetRealHeadTransform();
                    mainCamera.SetTargetPos(mainCamera.GetTargetPos() + Quaternion.AngleAxis(realTm.rotation.eulerAngles.y, Vector3.up) * new Vector3((xy.x+margin)
                      * (float)Math.Sqrt(mainCamera.GetDistance()*0.5f) * speed*cfgw.vrCameraFollowSpeedLR * Time.deltaTime, 0f, 0f), false);
                  } else if (xy.x >= margin) { //右
                    Transform realTm = mainCamera.GetRealHeadTransform();
                    mainCamera.SetTargetPos(mainCamera.GetTargetPos() + Quaternion.AngleAxis(realTm.rotation.eulerAngles.y, Vector3.up) * new Vector3((xy.x-margin)
                      * (float)Math.Sqrt(mainCamera.GetDistance()*0.5f) * speed*cfgw.vrCameraFollowSpeedLR * Time.deltaTime, 0f,  0f), false);
                  }
                }*/
                //上下移動
                xy = vrCtrl.getAxis(vrCtrl.udAxisIdx);
                if (xy.y <= -margin) { //下
                  float dist = Math.Max(mainCamera.GetDistance(), Math.Abs(maidsState[tgID].maidMune.position.y-mainCamera.GetPos().y));
                  mainCamera.SetTargetPos(mainCamera.GetTargetPos() + new Vector3(0f, (xy.y+margin) * speed*cfgw.vrCameraFollowSpeedUD
                    * (float)Math.Sqrt(dist*0.5f) * Time.deltaTime, 0f), false);
                  bFollowLimitY = true; //メイド固定の高さ戻り制限
                } else if (xy.y >= margin) { //上
                  float dist = Math.Max(mainCamera.GetDistance(), Math.Abs(maidsState[tgID].maidMune.position.y-mainCamera.GetPos().y));
                  mainCamera.SetTargetPos(mainCamera.GetTargetPos() + new Vector3(0f, (xy.y-margin) * speed*cfgw.vrCameraFollowSpeedUD
                    * (float)Math.Sqrt(dist*0.5f) * Time.deltaTime, 0f), false);
                  bFollowLimitY = true; //メイド固定の高さ戻り制限
                }
              }

            } else {

              if (vrCtrl.vrCameraOrigin) {
                //メイド固定でない & GripMoveと同じTransformの移動

                //メイドより手前になるようにroomBaseを調整 カメラジャンプ時の位置補正もここで行う
                if (cfgw.vrCameraMoveLimit && tgID != -1 && maidsState[tgID].maidHead != null) {
                  //最短制限ボタンが押されている
                  if (vrCtrl.getPress(vrCtrl.moveLimitButtonIdx) > 0f) {
                    if (fixRoomBaseTransform(vrCtrl)) {
                      preHeadPos = vrCtrl.vrCameraOrigin.position; //前フレームのカメラの位置(ジャンプ判定用)
                      return; //移動処理はキャンセル
                    }
                  }
                  preHeadPos = vrCtrl.vrCameraOrigin.position; //前フレームのカメラの位置(ジャンプ判定用)
                }

                if (speed > 0f) {
                  speed = speed * (1f - (1f - cfgw.vrCameraBreakSpeed) * vrCtrl.getPress(vrCtrl.breakButtonIdx)); //減速
                  speed = speed * (cfgw.vrCameraSpeedMax - cfgw.vrCameraSpeedStart) + cfgw.vrCameraSpeedStart; //開始速度と最大速度調整

                  //GripMoveと同様にvrCameraOriginを移動 HaedBaseが傾いている場合も高さが変わらないようにする
                  //左右移動 メイド自動切換え制御のグリップが押されていたら移動しない
                  Vector2 xy = vrCtrl.getAxis(vrCtrl.lrAxisIdx);
                  float marginX = (1 + Math.Abs(xy.y)) * cfgw.vrCameraSpeedStickMargin; //上下側のスティック状態に応じて遊びを増やす
                  if (xy.x <= -marginX) { //左移動
                    if (vrCtrl.directionFixHeight) { //視線方向上下移動なし
                      vrCtrl.vrCameraOrigin.position += Quaternion.Euler(vrCtrl.vrCameraOrigin.rotation.eulerAngles.x, vrCtrl.headTransform.rotation.eulerAngles.y, vrCtrl.vrCameraOrigin.rotation.eulerAngles.z)
                        * new Vector3((xy.x+marginX) * speed*cfgw.vrCameraMoveSpeedLR * Time.deltaTime, 0f, 0f);
                    } else vrCtrl.vrCameraOrigin.position += vrCtrl.directionTransform.rotation * new Vector3((xy.x+marginX) * speed*cfgw.vrCameraMoveSpeedLR * Time.deltaTime, 0f, 0f);
                  } else if (xy.x >= marginX) { //右移動
                    if (vrCtrl.directionFixHeight) { //視線方向上下移動なし
                      vrCtrl.vrCameraOrigin.position += Quaternion.Euler(vrCtrl.vrCameraOrigin.rotation.eulerAngles.x, vrCtrl.headTransform.rotation.eulerAngles.y, vrCtrl.vrCameraOrigin.rotation.eulerAngles.z)
                        * new Vector3((xy.x-marginX) * speed*cfgw.vrCameraMoveSpeedLR * Time.deltaTime, 0f, 0f);
                    } else vrCtrl.vrCameraOrigin.position += vrCtrl.directionTransform.rotation * new Vector3((xy.x-marginX) * speed*cfgw.vrCameraMoveSpeedLR * Time.deltaTime, 0f, 0f);
                  }
                  //前後移動
                  xy = vrCtrl.getAxis(vrCtrl.zoomAxisIdx);
                  float marginY = (1 + Math.Abs(xy.x)) * cfgw.vrCameraSpeedStickMargin; //左右側のスティック状態に応じて遊びを増やす
                  if (xy.y <= -marginY) { //後
                    if (vrCtrl.directionFixHeight) { //視線方向上下移動なし
                      vrCtrl.vrCameraOrigin.position += Quaternion.Euler(vrCtrl.vrCameraOrigin.rotation.eulerAngles.x, vrCtrl.headTransform.rotation.eulerAngles.y, vrCtrl.vrCameraOrigin.rotation.eulerAngles.z)
                        * new Vector3(0f, 0f, (xy.y+marginY) * speed*cfgw.vrCameraMoveSpeedZoom * Time.deltaTime);
                    } else vrCtrl.vrCameraOrigin.position += vrCtrl.directionTransform.rotation * new Vector3(0f, 0f, (xy.y+marginY) * speed*cfgw.vrCameraMoveSpeedZoom * Time.deltaTime);
                  } else if (xy.y >= marginY) { //前
                    if (vrCtrl.directionFixHeight) { //視線方向上下移動なし
                      vrCtrl.vrCameraOrigin.position += Quaternion.Euler(vrCtrl.vrCameraOrigin.rotation.eulerAngles.x, vrCtrl.headTransform.rotation.eulerAngles.y, vrCtrl.vrCameraOrigin.rotation.eulerAngles.z)
                        * new Vector3(0f, 0f, (xy.y-marginY) * speed*cfgw.vrCameraMoveSpeedZoom * Time.deltaTime);
                    } else vrCtrl.vrCameraOrigin.position += vrCtrl.directionTransform.rotation * new Vector3(0f, 0f, (xy.y-marginY) * speed*cfgw.vrCameraMoveSpeedZoom * Time.deltaTime);
                  }
                  //左右回転 メイド切り替えの場合は回転しない
                  xy = vrCtrl.getAxis(vrCtrl.turnAxisIdx);
                  marginX = (1 + Math.Abs(xy.y)) * cfgw.vrCameraSpeedStickMargin; //上下側のスティック状態に応じて遊びを増やす
                  if (xy.x <= -marginX) { //左回転
                    if (vrCtrl.getPress(vrCtrl.maidButtonIdx) == 0f) { //メイド切り替えトリガーが押されていない
                      vrCtrl.vrCameraOrigin.Rotate(0f, (xy.x+marginX) * 60f *speed*cfgw.vrCameraMoveSpeedTurn * Time.deltaTime, 0f);
                    }
                  } else if (xy.x >= marginX) { //右回転
                    if (vrCtrl.getPress(vrCtrl.maidButtonIdx) == 0f) { //メイド切り替えトリガーが押されていない
                      vrCtrl.vrCameraOrigin.Rotate(0f, (xy.x-marginX) * 60f *speed*cfgw.vrCameraMoveSpeedTurn * Time.deltaTime, 0f);
                    }
                  }
                  //上下 メイド自動切換え制御のグリップが押されていたら移動しない
                  xy = vrCtrl.getAxis(vrCtrl.udAxisIdx);
                  marginY = (1 + Math.Abs(xy.x)) * cfgw.vrCameraSpeedStickMargin; //左右側のスティック状態に応じて遊びを増やす
                  if (xy.y <= -marginY) { //下
                    vrCtrl.vrCameraOrigin.position += new Vector3(0f, (xy.y+marginY) * speed*cfgw.vrCameraMoveSpeedUD * Time.deltaTime, 0f);
                  } else if (xy.y >= marginY) { //上
                    vrCtrl.vrCameraOrigin.position += new Vector3(0f, (xy.y-marginY) * speed*cfgw.vrCameraMoveSpeedUD * Time.deltaTime, 0f);
                  }
                }

              } else {
                //メイド固定でない & HANDと同様の移動
                if (speed > 0f) {
                  speed = speed * (1f - (1f - cfgw.vrCameraBreakSpeed) * vrCtrl.getPress(vrCtrl.breakButtonIdx)); //減速
                  speed = speed * (cfgw.vrCameraSpeedMax-cfgw.vrCameraSpeedStart) + cfgw.vrCameraSpeedStart; //開始速度と最大速度調整

                  float margin = cfgw.vrCameraSpeedStickMargin;
                  //左右移動
                  Vector2 xy = vrCtrl.getAxis(vrCtrl.lrAxisIdx);
                  if (xy.x <= -margin) { //左移動
                    Transform realTm = mainCamera.GetRealHeadTransform();
                    mainCamera.SetRealHeadPos(realTm.position
                      + Quaternion.AngleAxis(realTm.rotation.eulerAngles.y, Vector3.up) * new Vector3((xy.x+margin) * speed*cfgw.vrCameraMoveSpeedLR * Time.deltaTime, 0f, 0f), false);
                  } else if (xy.x >= margin) { //右移動
                    Transform realTm = mainCamera.GetRealHeadTransform();
                    mainCamera.SetRealHeadPos(realTm.position
                      + Quaternion.AngleAxis(realTm.rotation.eulerAngles.y, Vector3.up) * new Vector3((xy.x-margin) * speed*cfgw.vrCameraMoveSpeedLR * Time.deltaTime, 0f, 0f), false);
                  }
                  //前後移動
                  xy = vrCtrl.getAxis(vrCtrl.zoomAxisIdx);
                  if (xy.y <= -margin) { //後
                    Transform realTm = mainCamera.GetRealHeadTransform();
                    mainCamera.SetRealHeadPos(realTm.position
                      + Quaternion.AngleAxis(realTm.rotation.eulerAngles.y, Vector3.up) * new Vector3(0f, 0f, (xy.y+margin) * speed*cfgw.vrCameraMoveSpeedZoom * Time.deltaTime), false);
                  } else if (xy.y >= margin) { //前
                    Transform realTm = mainCamera.GetRealHeadTransform();
                    mainCamera.SetRealHeadPos(realTm.position
                      + Quaternion.AngleAxis(realTm.rotation.eulerAngles.y, Vector3.up) * new Vector3(0f, 0f, (xy.y-margin) * speed*cfgw.vrCameraMoveSpeedZoom * Time.deltaTime), false);
                  }
                  //左右回転
                  xy = vrCtrl.getAxis(vrCtrl.turnAxisIdx);
                  if (xy.x <= -margin) { //左回転
                    if (vrCtrl.getPress(vrCtrl.maidButtonIdx) == 0f) { //メイド切り替えトリガーが押されていない
                      mainCamera.SetRealHeadRot(new Vector3(0f, mainCamera.GetRealHeadTransform().rotation.eulerAngles.y + (xy.x+margin) * 90f * speed*cfgw.vrCameraMoveSpeedTurn * Time.deltaTime, 0f), false); //左回転
                    }
                  } else if (xy.x >= margin) { //右回転
                    if (vrCtrl.getPress(vrCtrl.maidButtonIdx) == 0f) { //メイド切り替えトリガーが押されていない
                      mainCamera.SetRealHeadRot(new Vector3(0f, mainCamera.GetRealHeadTransform().rotation.eulerAngles.y + (xy.x-margin) * 90f * speed*cfgw.vrCameraMoveSpeedTurn * Time.deltaTime, 0f), false); //右回転
                    }
                  }
                  //上下
                  xy = vrCtrl.getAxis(vrCtrl.udAxisIdx);
                  if (xy.y <= -margin) { //下
                    mainCamera.SetRealHeadPos(mainCamera.GetRealHeadTransform().position + new Vector3(0f, (xy.y+margin) * speed*cfgw.vrCameraMoveSpeedUD * Time.deltaTime, 0f), false);
                  } else if (xy.y >= margin) { //上
                    mainCamera.SetRealHeadPos(mainCamera.GetRealHeadTransform().position + new Vector3(0f, (xy.y-margin) * speed*cfgw.vrCameraMoveSpeedUD * Time.deltaTime, 0f), false);
                  }
                }
              }
            }
        }

        //カメラ位置のジャンプ判定用
        Vector3 preHeadPos = new Vector3(0f, 0f, 0f);
        //ジャンプ判定無効時間設定用 シーンロード時と再読込時に無効ならPositiveInfinityが設定される
        float cameraJumpFixTime = 0f;

        //BaseRoomBaseのZ方向の移動量をメイドより手前になるように補正 移動制限したらtrueを返す
        public bool fixRoomBaseTransform(VRShortCutController vrCtrl)
        {
          bool ret = false; //trueならこの後の移動処理はキャンセル

          Transform trRoom = vrCtrl.vrCameraOrigin; //GripMove移動用
          Transform trHead = vrCtrl.headTransform; //HMD位置と向き
          Quaternion trHeadRotInverse = Quaternion.Inverse(Quaternion.AngleAxis(trHead.rotation.eulerAngles.y, Vector3.up));
          Vector3 maidPos = maidsState[tgID].maidHead.transform.position;
          //HMD向きでのカメラとメイドの方角 HMD正面がZ軸になるようにY軸のみ回転
          Vector3 maidOffset = trHeadRotInverse * (maidPos - trHead.position);

          //Vector3 basePos = mainCamera.GetBaseHeadTransform().position;
          //Debug.Log("room pos=("+trRoom.position.x+","+trRoom.position.y+","+trRoom.position.z+") base pos=("+basePos.x+","+basePos.y+","+basePos.z+")");

          //カメラがジャンプした場合(指定秒速以上) && 顔からの高さが 上0.5m以上+前0.5m以内
          if (cameraJumpFixTime < Time.time && Vector3.Distance(trHead.position, preHeadPos) > cfgw.vrCameraJumpDistance) {
            cameraJumpFixTime = Time.time + 0.1f; //0.1秒間は次のジャンプ判定しない

            //2人以上なら正面のメイドに切り替え
            if (vmId.Count > 1 && cfgw.vrAutoMaidChange) {
              //ベース位置からの正面のメイドを判定
              int frontMaidID;
              if (vrCtrl.getPress(vrCtrl.frontMaidIdx) > 0) { //グリップのみ
                //ボタン+スティック上 縮小範囲で正面メイド取得 自由移動前の位置から
                frontMaidID = GetFrontMaid(mainCamera.GetBaseHeadTransform(), cfgw.vrFrontMaidAngle, cfgw.vrFrontMaidBackward, cfgw.vrFrontMaidCenter);
              //} else if (vrCtrl.getPress(vrCtrl.froMaidExtIdx) > 0 && vrCtrl.getPress(vrCtrl.frontMaidExt2Idx) > 0) { //トリガー+グリップ
                //ボタン+スティック下 範囲拡張で正面メイド取得 自由移動前の位置から
                //frontMaidID = GetFrontMaid(mainCamera.GetBaseHeadTransform(), cfgw.vrFrontMaidExtendAngle, cfgw.vrFrontExtendBackward, false); //正面判定範囲拡張時
              } else {
                //通常範囲で正面メイド取得
                frontMaidID = GetFrontMaid(mainCamera.GetBaseHeadTransform(), cfgw.vrAutoMaidAngle, cfgw.vrAutoMaidBackward, false); //カメラジャンプ時の範囲
                //取得できなかったら倍の角度で再取得
                if (frontMaidID == -1 && cfgw.vrAutoMaidRetry) {
                  frontMaidID = GetFrontMaid(mainCamera.GetBaseHeadTransform(), cfgw.vrAutoMaidRetryAngle, cfgw.vrAutoMaidBackward, false); //カメラジャンプ時の範囲 再取得
                }
              }
              //メイドが切り替わったらメイドオフセット再計算
              if (frontMaidID != -1 && frontMaidID != tgID) {
                #if DEBUG
                Debug.Log("autoMaidChange "+tgID+" -> "+frontMaidID);
                #endif
                tgID = frontMaidID;
                maidPos = maidsState[tgID].maidHead.transform.position;
                maidOffset = trHeadRotInverse * (maidPos - trHead.position);
                #if DOF
                //被写界深度対象変更
                setDepthOfFieldMaid(tgID);
                #endif
              }
            }

            //自由移動ずれ補正
            if (cfgw.vrCameraJumpFixPos) {
              //カメラジャンプ時の位置初期化
              Transform trBase = mainCamera.GetBaseHeadTransform();
              Vector3 basePos = trBase.position;
              Vector3 offset = Quaternion.Inverse(trBase.rotation) * (trRoom.position - basePos); //RoomBaseの移動量の軸を正規化
              
              if (!cfgw.vrCameraJumpFixPosX) {
                basePos += trBase.right * offset.x; //左右はリセットしない
              }
              if (cfgw.vrCameraJumpFixPosY) {
                //SteamVRとOpenXRはずれるので補正
                basePos.y += vrBaseHeadHeightGap;
              } else {
                basePos.y = trRoom.position.y; //高さはリセットしない
              }
              //前後リセット時のオフセット調整
              if (cfgw.vrCameraJumpFixPosZ) {
                //キャンセルボタン有効ならリセットしない
                if (vrCtrl.getCameraJumpFixCancel()) basePos += trBase.forward * offset.z; //前後はリセットしない
                else {
                  //前後リセット後の距離でズーム補正を制限
                  float z = maidOffset.z + offset.z;
                  if (z >= cfgw.vrCameraJumpFixPosZoomLimit) {
                    //メイドとの距離に前後リセットの移動分を加算して制限距離分下げてからズーム補正
                    basePos += trBase.forward * ((z - cfgw.vrCameraJumpFixPosZoomLimit) * cfgw.vrCameraJumpFixPosZoomRate);
                  }
                }
              } else {
                basePos += trBase.forward * offset.z; //前後はリセットしない
              }
              trRoom.position = basePos;
              mainCamera.transform.position = trRoom.position;
              //回転もリセット
              if (cfgw.vrCameraJumpFixRot) {
                trRoom.rotation = trBase.rotation;
                mainCamera.transform.rotation = trRoom.rotation;
              }
              //メイドオフセット再計算
              maidPos = maidsState[tgID].maidHead.transform.position;
              maidOffset = trHeadRotInverse * (maidPos - trHead.position);
              ret = true; //移動はキャンセル 最短距離制限は実行
            }

            //高さずれでの位置調整が有効な場合のみ 前方距離が高さの2倍より近い場合
            if (cfgw.vrCameraJumpAdjustHeight && -maidOffset.y > cfgw.vrCameraJumpAdjustHeightTh + maidOffset.z * cfgw.vrCameraJumpAdjustHeightZRate) {
              //初期位置に戻す
              Transform trBase = mainCamera.GetBaseHeadTransform();
              Vector3 basePos = trBase.position;
              //basePos = trHead.position; //baseをHMD位置に設定してずれを初期化
              //高さに応じて後ろに下げる
              //basePos -= trRoom.forward * (Math.Abs(maidOffset.y)) - maidOffset.z);
              //高さを指定の割合で下げる
              basePos.y += maidOffset.y * cfgw.vrCameraJumpAdjustHeightRate;
              //SteamVRはずれるので補正
              basePos.y += vrBaseHeadHeightGap;
              trRoom.position = basePos;
              mainCamera.transform.position = trRoom.position;
              if (cfgw.vrCameraJumpFixRot) {
                trRoom.rotation = trBase.rotation; //回転もリセット
                mainCamera.transform.rotation = trRoom.rotation;
              }
              //メイドオフセット再計算
              maidPos = maidsState[tgID].maidHead.transform.position;
              maidOffset = trHeadRotInverse * (maidPos - trHead.position);
              ret = true; //移動はキャンセル 最短距離制限は実行
            }
            #if DOF
            //カメラジャンプなのでフォーカスは常時即変更
            depthOfField.focalTransformTime = 0;
            #endif
          }
          //カメラジャンプでない場合
          else {
            //右グリップ狭い範囲で正面判定
            if (vmId.Count > 1) {
              //正面判定用グリップが押されている
              if (vrCtrl.getPress(vrCtrl.frontMaidIdx) > 0) {
                //ボタン+スティック上 1回実行したらスティックを戻すまで無効
                vrCtrl.frontMaidAxisEnabled = false; //上スティック無効化
                //HMD位置からの正面のメイドを取得
                int frontMaidID = GetFrontMaid(mainCamera.GetRealHeadTransform(), cfgw.vrFrontMaidAngle, cfgw.vrFrontMaidBackward, cfgw.vrFrontMaidCenter); //スティック上の時
                //メイドが切り替わったらカメラオフセット再計算
                if (frontMaidID != -1 && frontMaidID != tgID) {
                  //Debug.Log("frontMaidChange "+tgID+" -> "+frontMaidID);
                  tgID = frontMaidID;
                  maidPos = maidsState[tgID].maidHead.transform.position;
                  maidOffset = trHeadRotInverse * (maidPos - trHead.position);
                  #if DOF
                  //被写界深度対象変更
                  setDepthOfFieldMaid(tgID);
                  depthOfField.focalTransformTime = cfgw.DepthFocalTransformTime; //スムーズにフォーカス切替
                  #endif
                }
              }
              //範囲外チェック  常時有効
              else if (cfgw.vrOutsideMaidChange && //(cfgw.vrOutsideMaidChangeAlways || vrCtrl.getPress()) &&
                (vrCtrl.outsideMaidAngle == 0 || Math.Abs(Mathf.Atan2(maidOffset.x, maidOffset.z)) > vrCtrl.outsideMaidAngle)) { //メインメイドが範囲外 or 角度が0
                //HMD位置からの正面の一番近いメイドを取得
                int frontMaidID = GetFrontMaid(mainCamera.GetRealHeadTransform(), cfgw.vrOutsideMaidFrontAngle, cfgw.vrOutsideMaidBackward, false);
                //メイドが切り替わったらカメラオフセット再計算
                if (frontMaidID != -1 && frontMaidID != tgID) {
                  #if DEBUG
                  Debug.Log("outsideMaidChange "+tgID+" -> "+frontMaidID);
                  #endif
                  tgID = frontMaidID;
                  maidPos = maidsState[tgID].maidHead.transform.position;
                  maidOffset = trHeadRotInverse * (maidPos - trHead.position);
                  #if DOF
                  //被写界深度対象変更
                  setDepthOfFieldMaid(tgID);
                  depthOfField.focalTransformTime = cfgw.DepthFocalTransformTime; //スムーズにフォーカス切替
                  #endif
                }
              }
            }
          }

          //最短距離制限
          if (maidOffset.z < cfgw.vrCameraMoveLimitDistance) {
            if (cfgw.vrCameraMoveLimitHorizontal) {
              //仰角補正なし
              trRoom.position -= trRoom.forward * (cfgw.vrCameraMoveLimitDistance - maidOffset.z); //後ろに補正
              mainCamera.transform.position = trRoom.position;
            } else {
              //仰角補正あり
              maidPos.y += cfgw.vrCameraMoveLimitMaidHeadOffsetY; //仰角方向含めた距離制限時に頭の上下の中心を補正
              maidPos.z += cfgw.vrCameraMoveLimitMaidHeadOffsetZ; //仰角方向含めた距離制限時に頭の前後の中心を補正
              Vector3 maidVector = maidPos - trHead.position; //カメラからメイド方向のベクタ
              float maidDist = maidVector.magnitude;
              if (maidDist < cfgw.vrCameraMoveLimitDistance) { //最短距離以内
                trRoom.position -= maidVector.normalized * (cfgw.vrCameraMoveLimitDistance - maidDist); //HMD後方に補正
                mainCamera.transform.position = trRoom.position;
              }
            }
            //TODO 地面判定
          }
          return ret;
        }

        //GripMoveの移動と回転をリセット 以下と同等の移動
        //mainCamera.SetRealHeadPos(mainCamera.GetRealHeadTransform().position, false);
        //mainCamera.SetRealHeadRot(new Vector3(0f, realAngleY, 0f), false);
        private void resetRoomBase(Transform trRoomBase)
        {
          Transform trReal = mainCamera.GetRealHeadTransform();
          Transform trBaseHead = mainCamera.GetBaseHeadTransform();

          Vector3 pos = trRoomBase.position; //親の移動で変わってしまうので退避
          trBaseHead.position = trReal.position;
          trRoomBase.position = pos;

          float readAngleY = trReal.rotation.eulerAngles.y;
          float angleY = readAngleY - trBaseHead.eulerAngles.y; //視野側に回転
          trBaseHead.rotation =   Quaternion.Euler(trBaseHead.eulerAngles.x, readAngleY, trBaseHead.eulerAngles.z); //正面は視線方向に
          trRoomBase.localRotation = Quaternion.Euler(0, trRoomBase.localRotation.eulerAngles.y-angleY, 0); //視線がずれないように戻す

          preHeadPos = trRoomBase.position; //ジャンプキャンセル
        }

        //GripMoveの移動をリセット
        private void resetRoomBasePos(Transform trRoomBase)
        {
          Transform trReal = mainCamera.GetRealHeadTransform();
          Transform trBaseHead = mainCamera.GetBaseHeadTransform();
          trRoomBase.position = trBaseHead.position;
          //SteamVRはずれるので補正
          if (cfgw.vrCameraJumpFixPosY && vrBaseHeadHeightGap != 0f) {
            Vector3 pos = trRoomBase.position;
            pos.y += vrBaseHeadHeightGap;
            trRoomBase.position = pos;
          }

          preHeadPos = trRoomBase.position; //ジャンプキャンセル
        }

        //UOカメラの回転と距離を現在位置に合わせる
        private void resetUOCamera(Vector3 targetPos, Vector3 realPos)
        {
          setTargetAroundAngle(targetPos - realPos); //現在位置からターゲットへの方向
          float dist = Vector3.Distance(targetPos, realPos);
          if (bVR) dist *= cfgw.vrCamSetDistanceAdjust; //VR距離補正
          mainCamera.SetDistance(dist, true);
        }
        
        private void setTargetAroundAngle(Vector3 dir)
        {
            float angleY = Mathf.Rad2Deg*(float)Math.Atan2(dir.x, dir.z);
            float angleX = -Mathf.Rad2Deg*(float)Math.Atan2(dir.y, Math.Sqrt(dir.x*dir.x+dir.z*dir.z));
            mainCamera.SetAroundAngle(new Vector2(angleY, angleX), true); //Y軸,X軸回転 上向きが-
            #if DEBUG
            Debug.Log("dir=("+dir.x+","+dir.y+","+dir.z+")");
            Debug.Log("angle Y="+angleY+" X="+angleX);
            #endif
        }

        //dir : 視線の正面方向ベクトル 胸なら背中方向が+
        //angleXOffset : 仰角の補正 +なら下を向く 視点は上がる
        //up : 体の上方向 胸から首の方向
        private void setTargetAroundAngle(Vector3 dir, float angleXOffset, Vector3 up)
        {
            float angleY;
            float supineBodyY = 0.65f;//Mathf.Cos(Mathf.Deg2Rad*40); //体の傾き 直立が0
            float supineY = 0.7f;//Mathf.Sin(Mathf.Deg2Rad*45);
            if (up.y < supineBodyY) { //体が傾いている場合
              if (dir.y < -supineY) angleY = Mathf.Rad2Deg*(float)Math.Atan2(up.x, up.z); //仰向けは上が前
              else if (dir.y > supineY) angleY = Mathf.Rad2Deg*(float)Math.Atan2(-up.x, -up.z); //うつ伏せは下が前
              else angleY = Mathf.Rad2Deg*(float)Math.Atan2(dir.x, dir.z);
            } else angleY = Mathf.Rad2Deg*(float)Math.Atan2(dir.x, dir.z);

            float angleX = -Mathf.Rad2Deg*(float)Math.Atan2(dir.y, Math.Sqrt(dir.x*dir.x+dir.z*dir.z));
            angleX = Math.Max(-90, Math.Min(90, angleX + angleXOffset)); //90度以上は反転するので制限

            mainCamera.SetAroundAngle(new Vector2(angleY, angleX), true); //Y軸(時計回り),X軸(下向き+ 視点は上がる)

            #if DEBUG
            Debug.Log("dir=("+dir.x+","+dir.y+","+dir.z+")");
            Debug.Log("up=("+up.x+","+up.y+","+up.z+")");
            Debug.Log("angle Y="+angleY+" X="+angleX);
            #endif
        }

        //一人称視点の処理
        private float fpsTime = 0;
        private float scrollValue = 0f;
        private float scrollValue2 = 0f;
        private Vector3 bManHeadPos = Vector3.zero;
        private Transform manHead;
        private Renderer manHeadRen;
        //private Transform manBipHead;
        private bool fpsModeEnabled = false; //一人称視点フラグ
        private float fieldOfViewBack = 35.0f;
        //private bool vacationEnabled = false;

        //一人称モードの有効無効切替
        private void setFpsModeEnabled(bool enabled)
        {
          if (enabled) {
            //有効化
            if (fpsMan.Visible && !fpsModeEnabled) {
              if (bVR) {
                //向きと位置をリセット
                resetRoomBase(vrShortCutController.trRoomBase);
                resetUOCamera(mainCamera.GetTargetPos(), mainCamera.GetRealHeadTransform().position);
              } else {
                fieldOfViewBack = Camera.main.fieldOfView;
                Camera.main.fieldOfView = 60.0f;
              }
            }
          } else {
            //無効化
            if (fpsModeEnabled) {
              //頭表示
              #if COM3D2_5
              if (fpsMan.IsNewManIsRealMan) {
                if (manHead) {
                  //manHead.localScale = Vector3.one;
                  manHead.gameObject.SetActive(true);
                }
              } else 
              #endif
              {
                if (manHeadRen) manHeadRen.enabled = true;
              }
              //VR以外はFoVと距離は戻す
              if (!bVR) {
                Camera.main.fieldOfView = fieldOfViewBack;
                if (tgID != -1) {
                  Transform maidTm = getMaidLookpointTransform(tgID);
                  if (maidTm != null) {
                    Vector3 pos = maidTm.position;
                    Vector3 cameraPos = mainCamera.GetRealHeadTransform().position;
                    float dist = Mathf.Sqrt((pos.x-cameraPos.x)*(pos.x-cameraPos.x)+(pos.z-cameraPos.z)*(pos.z-cameraPos.z)); //水平距離
                    //ターゲットは男の頭のまま距離だけ設定 メイド固定ならメイドに移動する
                    mainCamera.SetDistance(Math.Max(0.1f, dist), true); //最短 10cm
                  }
                }
              }

              manHead = null; //開始時に再取得させる
              manHeadRen = null;
            }
          }
          fpsModeEnabled = enabled;
        }

        private void FpsModeChange()
        {
          //頭の取得と位置のずれの調整 毎フレーム行わない
          if (fpsTime <= Time.time) {
            fpsTime = Time.time + 0.25f; //0.25秒間隔

            //ご主人様の頭を取得する 表示まで遅延がある対策で毎回実行？
            if (!manHead) {
              manHead = ManHeadGet(fpsMan);
              if (manHead) manHeadRen = manHead.gameObject.GetComponent<Renderer>();
              else {
                return;
              }
            }
            
            //ご主人様の頭を消す
            #if COM3D2_5
            if (fpsMan.IsNewManIsRealMan) {
              if (cfgw.fpsHideNewManHead) manHead.gameObject.SetActive(false);
            } else {
              if (manHeadRen) if (cfgw.fpsHideManHead) manHeadRen.enabled = false;
            }
            #else
            if (manHeadRen) if (cfgw.fpsHideManHead) manHeadRen.enabled = false;
            #endif

            //カメラの移動チェック
            float fDistanceToManHead = Vector3.Distance(bManHeadPos, mainCamera.transform.position);

            //大きく移動していれば向きを調整
            if (fDistanceToManHead > 0.3f) {
              if (bVR) {
                //向きと位置をリセット
                resetRoomBase(vrShortCutController.trRoomBase);
                resetUOCamera(mainCamera.GetTargetPos(), mainCamera.GetRealHeadTransform().position);
              }
              #if COM3D2_5
              if (fpsMan.IsNewManIsRealMan) {
                //right→上(y=-1) up→前(z=+1) right→左(x=-1)
                float cx = manHead.eulerAngles.z + 90f;
                if (cx >= 360) cx -= 360;
                float cy = manHead.eulerAngles.y + 90f;
                if (bVR) cy += 180f;
                if (cy >= 360) cy -= 360;
                mainCamera.transform.eulerAngles = new Vector3(-cx, cy, 0.0f);
              } else 
              #endif
              {
                // forward→上(y=+1) up→後ろ(z=-1) right→左(x=-1)
                if (100 < manHead.eulerAngles.z && manHead.eulerAngles.z < 260 ) {
                  float cy = manHead.eulerAngles.y + 180f;
                  if (cy >= 360) cy -= 360;
                  mainCamera.transform.eulerAngles = new Vector3(manHead.eulerAngles.x, cy, 0.0f);
                } else {
                  float cx = manHead.eulerAngles.x + 90f;
                  if (cx >= 360) cx -= 360;
                  mainCamera.transform.eulerAngles = new Vector3(cx, manHead.eulerAngles.y, 0.0f);
                }
              }
              Console.WriteLine("カメラ向き変更");

              scrollValue = 0f;  //ホイール値リセット
            }

            bManHeadPos = mainCamera.transform.position;
          }

          //男エディットボディだとmanHeadはDestroyされる
          if (!manHead) return;

          //頭の位置を挿入
          Vector3 pos = manHead.position;
          //オフセット指定があれば上下位置調整 upは後ろ
          #if COM3D2_5
          if (fpsMan.IsNewManIsRealMan) {
            if (cfgw.fpsManHeadOffsetY != 0) pos += manHead.up * cfgw.fpsManHeadOffsetY;
            if (cfgw.fpsManHeadOffsetZ != 0) pos -= manHead.right * cfgw.fpsManHeadOffsetZ;
          } else 
          #endif
          {
            if (cfgw.fpsManHeadOffsetY != 0) pos += manHead.forward * cfgw.fpsManHeadOffsetY;
            if (cfgw.fpsManHeadOffsetZ != 0) pos -= manHead.up * cfgw.fpsManHeadOffsetZ;
          }

          //マウスホイールでカメラ位置の前後調整
          if (Input.GetMouseButton(0)) scrollValue += Input.GetAxis("Mouse ScrollWheel") / 10;
          if (Input.GetMouseButton(1)) scrollValue2 += Input.GetAxis("Mouse ScrollWheel") / 10;
          if (scrollValue > 0.2f) scrollValue = 0.2f;
          if (scrollValue < -0.2f) scrollValue = -0.2f;
          if (Input.GetMouseButtonDown(2)) {
            scrollValue = 0f;
            scrollValue2 = 0f;
          }
          if (scrollValue != 0 || scrollValue2 != 0) {
            Vector3 cameraForward = Vector3.Scale(Camera.main.transform.forward, new Vector3(1, 1, 1)).normalized;
            Vector3 moveForward = cameraForward * scrollValue + Camera.main.transform.up * scrollValue2;
            pos += moveForward;
          }

          //カメラ位置の移動
          if (bVR) {
            mainCamera.SetPos(pos);
          } else {
            mainCamera.SetTargetPos(pos, true);
            mainCamera.SetDistance(0f, true);
          }
        }

        //ご主人様の頭取得
        private Transform ManHeadGet(Maid man)
        {
            #if COM3D2_5
            if (man.IsNewManIsRealMan) return man.body0.trsHead;
            #endif

            Transform[] objList = man.transform.GetComponentsInChildren<Transform>();
            if (objList.Count() != 0) {
              foreach (var manBipHead in objList) {
                if (manBipHead.name == "ManBip Head") {
                  foreach (Transform mh in manBipHead) {
                    if (mh.name.Contains("_SM_mhead")) {
                      GameObject smManHead = mh.gameObject;
                      foreach (Transform smmh in smManHead.transform) {
                        if (smmh.name.Contains("ManHead")) {
                          return smmh;
                          //manHeadRen = manHead.GetComponent<Renderer>();
                        }
                      }
                    }
                  }
                }
              }
            }
            return null;
        }

        //メイド切替時にカメラ追従  正面にY軸回転も可能
        //メイド固定の注視点を回転の原点になる
        //distance -1なら変更なし
        //aroundType 0=回転  1＝body0の正面 2=胸の正面
        //angleOffset 回転量または正面からのオフセット角度
        private void CameraChange(int maidID, float distance, int aroundType, float angleOffset) {

          if (!fpsModeEnabled) {
            Vector3 pos = Vector3.zero;

            //カメラの移動先決定
            Transform maidObj = getMaidLookpointTransform(maidID);
            if (!maidObj) return;

            pos = maidObj.transform.position;

            //オフセットがあればそれに合わせる
            if (maidFollowHeightOffset != 0f) pos.y += maidFollowHeightOffset;

            //カメラ移動
            //mainCamera.SetPos(pos); //不要
            mainCamera.SetTargetPos(pos, true);
            if (distance > 0f) mainCamera.SetDistance(bVR ? (distance * cfgw.vrCamSetDistanceAdjust) : distance, true); //VR補正

            //カメラ回転
            if (aroundType == 0) {
              //左右回転
              if (angleOffset != 0) {
                mainCamera.SetAroundAngle(new Vector2(mainCamera.GetAroundAngle().x - angleOffset, 0f), true); //Y軸回転
              }
            } else if (aroundType == 1) {
              //body0の正面移動
              Transform tr = stockMaids[maidID].mem.body0.transform; //body0
              float angle = (tr.eulerAngles.y + 180f + angleOffset) % 360;
              mainCamera.SetAroundAngle(new Vector2(angle, 0f), true); //Y軸回転
            } else if (aroundType == 2) {
              Transform tr = maidsState[maidID].maidMune; //胸
              float angle = (tr.eulerAngles.y - 90f + angleOffset) % 360;
              mainCamera.SetAroundAngle(new Vector2(angle, 0f), true); //Y軸回転
            }
          }
        }

        //ダンスのダミーや非表示でないならtrue
        private bool isActiveMaid(Maid maid)
        {
          return maid.transform.localScale.x > 0.00001f; //0.00001fなのはDCM対策
        }
        //ダミーメイドでなければtrue
        private bool isNoDummyMaid(Maid maid)
        {
            if (RhythmAction_Mgr.Instance) {
              //RhythmAction_Mgr.InstanceからDanceMainを取得
              DanceMain danceMain = (DanceMain)danceMainInfo.GetValue(RhythmAction_Mgr.Instance);
              //プリセット上書き指定があるメイドはモニター表示用としてダミー判定
              if (danceMain.m_PresetCopyToDummyChara.Length > maid.ActiveSlotNo && danceMain.m_PresetCopyToDummyChara[maid.ActiveSlotNo] != maid.ActiveSlotNo) return false;
            }
            return true;
        }

        //カメラが近すぎる場合は距離を修正 プライベートモードでは0.1になってしまうためメイドの距離に強制変更
        private void adjustCameraDistance()
        {
          //シナリオ再生時は無効
          if (vSceneLevel == 15) return;

          //メインメイドがいればメイドとの距離を取得 VRはメイド固定時のみ
          if ((maidFollowEnabled || !bVR) && tgID != -1 && maidsState[tgID].maidHead != null) {
            if (mainCamera.GetDistance() == 0.1f) {
              Transform maidTm = getMaidLookpointTransform(tgID);
              if (maidTm == null) return;
              Vector3 pos = maidTm.position;
              Vector3 cameraPos = mainCamera.GetBaseHeadTransform().position;
              float dist = Mathf.Sqrt((pos.x-cameraPos.x)*(pos.x-cameraPos.x)+(pos.z-cameraPos.z)*(pos.z-cameraPos.z));
              if (dist > 2.5) return; //メイドとの実距離が2.5m以上の場合は処理しない
              if (bVR) {
                if (bOculusVR) dist *= 2.0f; //Questは実座標の距離の2倍にする 原因不明
                //else return; //SteamVRは処理しない
              }
              //mainCamera.SetPos(pos); //不要
              mainCamera.SetDistance(dist, true);
              mainCamera.SetTargetPos(pos, true);
              Console.WriteLine("[VibeYourMaid] adjustCameraDistance="+dist);
            }
          }
        }

        //視点の中央に近いメイドのIDを取得 左右45度内のメイドのみ
        //距離が近い場合は体の幅相当の角度を考慮して一番近いものを取得
        private int GetLookingkMaidID(float frontAngle)
        {
          //リアル視点 GripMoveの移動含む
          Transform realTm = mainCamera.GetRealHeadTransform();
          Vector3 realPos = realTm.position;
          float realAngleY = realTm.rotation.eulerAngles.y % 360;
          if (realAngleY < 0) realAngleY = 360f + realAngleY; //0-360に

          float minAngle = 360f;
          float minDist = float.MaxValue; //angle=0の時の距離
          int lookingMaidID = tgID;
          foreach (int maidID in vmId) {
            MaidState maidState = maidsState[maidID];
            if (isActiveMaid(maidState.maid)) {
              if (!maidState.maidMune && maidState.maid.body0.m_trBones) maidState.maidMune = CMT.SearchObjName(maidState.maid.body0.m_trBones, "Bip01 Spine1", true);
              Transform maidTm = maidState.maidMune;
              float angle = Quaternion.LookRotation(maidTm.position - realPos).eulerAngles.y % 360; //カメラからメイドへの方向
              if (angle < 0) angle = 360f + angle; //0-360に
              angle = Math.Abs(angle - realAngleY); //視野中央からの角度 0～

              float dist = (float)Math.Sqrt((maidTm.position.x-realPos.x)*(maidTm.position.x-realPos.x)+(maidTm.position.z-realPos.z)*(maidTm.position.z-realPos.z));
              //距離に応じて体の幅の分中央に寄せる 体の幅は50cm 0.5m未満は制限  atan2(0.25, 0.5)=26.5度 atan2(0.25, 1)=14度
              float bodyAngle = Mathf.Atan2(cfgw.lookingMaidBodyRadius, Math.Max(0.5f, dist)) * Mathf.Rad2Deg;
              angle = angle - bodyAngle;

              if (angle <= 0f) {
                if (dist < minDist) { //角度0以下の場合は近い順
                  minAngle = 0;
                  lookingMaidID = maidID;
                  minDist = dist;
                }
              } else if (angle <= frontAngle && angle < minAngle) { //正面でない場合は指定角度内の中央寄り
                minAngle = angle;
                lookingMaidID = maidID;
              }
            }
          }
          return lookingMaidID;
        }

        //正面角度範囲内で距離が一番近いメイドを取得 backOffsetは角度幅を広げる用で後ろは対象外
        private int GetFrontMaid(Transform cameraTm, float frontAngle, float backOffset, bool centerMaid)
        {
          Vector3 camPos = cameraTm.position;
          Vector3 forward = cameraTm.forward;
          forward.y = 0;
          forward.Normalize();
          camPos.x -= forward.x * backOffset;
          camPos.z -= forward.z * backOffset;

          //後ろに下がった分を除外する 距離の2乗
          float distLimit = 0;
          if (backOffset > 0) distLimit = backOffset * backOffset;

          float realAngleY = cameraTm.rotation.eulerAngles.y % 360;
          if (realAngleY < 0) realAngleY = 360f + realAngleY; //0-360に

          //中心のメイド 体の幅補正あり
          if (centerMaid) {
            float minAngle = 360f;
            float minDist = float.MaxValue; //angle=0の時の距離
            int lookingMaidID = -1;
            foreach (int maidID in vmId) {
              MaidState maidState = maidsState[maidID];
              if (isActiveMaid(maidState.maid)) {
                Transform maidTm = maidState.maidMune;
                float angle = Quaternion.LookRotation(maidTm.position - camPos).eulerAngles.y % 360; //カメラからメイド方向の絶対角度
                if (angle < 0) angle = 360f + angle; //0-360に
                angle = Math.Abs(angle - realAngleY); //正面中央からの角度 0～
                float dist = (maidTm.position.x-camPos.x)*(maidTm.position.x-camPos.x)+(maidTm.position.z-camPos.z)*(maidTm.position.z-camPos.z);
                //距離に応じて体の幅の分中央に寄せる 体の幅は20cm 0.5m未満は制限 atan2(0.1, 0.5)=19.7度 atan2(0.1, 1)=9.9度
                //float bodyAngle = Mathf.Atan2(cfgw.vrFrontMaidBodyRadius, Math.Max(0.5f, (float)Math.Sqrt(dist))) * Mathf.Rad2Deg;
                //angle = angle - bodyAngle;
                //Debug.Log("  maidID="+maidID+" dist="+dist+" angle="+angle);
                //前にいるメイドのみ
                if (distLimit < dist) {
                  if (angle <= 0f) {
                    if (dist < minDist) { //正面の場合は近い順
                      minAngle = 0;
                      lookingMaidID = maidID;
                      minDist = dist;
                    }
                  } else if (angle <= frontAngle && angle < minAngle) { //正面でない場合は角度内の中央寄り
                    minAngle = angle;
                    lookingMaidID = maidID;
                  }
                }
              }
            }
            #if DEBUG
            Debug.Log("GetFrontMaid frontAngle="+frontAngle+" backOffset="+backOffset+" centerMaid="+centerMaid+" lookingMaidID="+lookingMaidID);
            #endif
            return lookingMaidID;
          } else {
            float minDist = float.MaxValue; //メイドの距離 Sqrtしないので2乗された値のまま比較する
            int closestMaidID = -1;
            foreach (int maidID in vmId) {
              MaidState maidState = maidsState[maidID];
              if (isActiveMaid(maidState.maid)) {
                Transform maidTm = maidState.maidMune;
                float angle = Quaternion.LookRotation(maidTm.position - camPos).eulerAngles.y % 360; //下げたカメラからメイドへの方向
                if (angle < 0) angle = 360f + angle; //0-360に
                angle = Math.Abs(angle - realAngleY); //視野中央からの角度 0～
                float dist = (maidTm.position.x-camPos.x)*(maidTm.position.x-camPos.x)+(maidTm.position.z-camPos.z)*(maidTm.position.z-camPos.z);
                //前にいるメイドのみ
                if (distLimit < dist) {
                  //正面範囲内で一番近いメイド
                  if (dist < minDist && angle <= frontAngle) {
                    minDist = dist;
                    closestMaidID = maidID;
                  }
                }
              }
            }
            #if DEBUG
            Debug.Log("GetFrontMaid frontAngle="+frontAngle+" backOffset="+backOffset+" centerMaid="+centerMaid+" closestMaidID="+closestMaidID);
            #endif
            return closestMaidID;
          }
        }

        //横のメイドを取得 一番端なら反対側を選択 体の幅補正はなし
        //bLeft 左側に移動ならtrue
        private int GetSideMaid(int currentID, Transform cameraTm, bool bLeft, bool opposite)
        {
          Vector3 camPos = cameraTm.position;
          float cameraAngleY = cameraTm.rotation.eulerAngles.y;
          float radian = Mathf.Deg2Rad * cameraAngleY;

          float minX = float.PositiveInfinity;
          float oppositeX = 0;
          int besideMaidID = currentID;
          int oppositeMaidID = currentID;
          //選択中のメイドの位置
          Transform maidTm = maidsState[currentID].maidMune;
          float dx = maidTm.position.x - camPos.x;
          float dz = maidTm.position.z - camPos.z;
          float sin = (float)Math.Sin(radian);
          float cos = (float)Math.Cos(radian);
          float currentX = bLeft ? (dz * sin - dx * cos) : (dx * cos - dz * sin); //カメラからの左右 選択方向が+
          float currentZ = dx * sin + dz * cos; //カメラからの前後 奥が+

          foreach (int maidID in vmId) {
            MaidState maidState = maidsState[maidID];
            if (maidID != currentID && isActiveMaid(maidState.maid)) {
              maidTm = maidState.maidMune;
              if (maidTm) {
                dx = maidTm.position.x - camPos.x;
                dz = maidTm.position.z - camPos.z;
                sin = (float)Math.Sin(radian);
                cos = (float)Math.Cos(radian);
                float x = bLeft ? (dz * sin - dx * cos) : (dx * cos - dz * sin); //カメラからの左右 選択方向が+
                float z = dx * sin + dz * cos; //カメラからの前後 奥が+
                x = x - currentX; //対象メイドから
                z = z - currentZ; //対象メイドから
                float dist = x*x + (z*z * cfgw.besideMaidCorrectZ); //2乗したままの値で比較 前後に離れている分を加算して遠くに補正して優先度を下げる
                float buf = 0;
                //buf = cfgw.besidetMaidBuffer; //反対側のメイドも指定バッファ分判定対象にする
                if (x >= -buf) {
                  if (x < 0) dist *= 2; //逆側なら倍の距離で判定
                  if (minX > dist) { //移動側で近い
                    minX = dist;
                    besideMaidID = maidID;
                  }
                }
                //対象メイドの反対側
                else if (x < 0) {
                  //反対側で一番遠いメイドを取得
                  if (oppositeX < dist) {
                    oppositeX = dist;
                    oppositeMaidID = maidID;
                  }
                }
              }
            }
          }
          //横のメイドがいない場合は反対側の一番遠くに
          if (opposite && currentID == besideMaidID) return oppositeMaidID;
          return besideMaidID;
        }

        //ダンスシーンの移動カメラを一時的に有効無効を切り替える VRのみ
        private void setDanceCameraDisabled(bool disabled)
        {
          if (bVR) {
            //ダンスが移動カメラの場合は無効にする
            if (RhythmAction_Mgr.Instance) {
              DanceMain danceMain = (DanceMain)danceMainInfo.GetValue(RhythmAction_Mgr.Instance);
              //privateなのでFieldInfoで強引に変更 切り替え時のみ呼び出すので毎回取得
              FieldInfo danceMainCameraInfo = typeof(DanceMain).GetField("m_OvrCam", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.GetField);
              if (disabled) danceMainCameraInfo.SetValue(danceMain, null);
              else danceMainCameraInfo.SetValue(danceMain, GameMain.Instance.OvrMgr.OvrCamera);
            }

            #if DCM
            //DCMカメラ無効
            if (hasDcmIgnoreCameraMotion) setDCMDanceCameraDisabled(disabled);
            #endif
          }
        }

        #if DCM
        //DCMカメラ無効 クラスがない場合にメソッド呼び出し時にエラーになるため分離
        private void setDCMDanceCameraDisabled(bool disabled)
        {
          COM3D2.DanceCameraMotion.Plugin.MyHelper.ignoreCameraMotion = disabled;
        }
        #endif

        //カメラを常にメイドに追従させる
        private bool maidFollowEnabled = false;
        private Vector3 vFollowPosition = Vector3.zero;

	      private int lookPoint = 0;
        private string[] lookList = new string[]{ "胸" , "顔" , "股" };
        private bool aoutLook = false;
        private float lookTime = 0f;
        private Vector3 lookVelocity;

        private bool aoutTarget = false;
        private float targetTime = 3f;

        private bool aoutAngle = false;
        private bool preAoutAngle = false;
        private int xi = 1;
        private Quaternion vrFollowAngleRotation = Quaternion.identity;

        private bool aoutZoom = false;
        private float zoomTg = 1f;
        private float zoomValue = 1f;
        private float zoomTime = 3f;
	      private float zoomVelocity;

        //高さオフセット メイド固定開始時の高さを維持
        private float maidFollowHeightOffset = 0f;
        private bool bFollowLimitY = false; //メイド固定で高さ戻り制限フラグ
        private bool bFollowLimitAngle = false; //アングルの戻りを制限フラグ
        private float followReturnSpeedY = -1f; //メイド固定で縦方向の秒速 -1なら減速処理しない

        private Transform getMaidLookpointTransform(int maidID)
        {
          MaidState maidState = maidsState[maidID];
          if (lookPoint == 0) {
            if (!maidState.maidMune && maidState.maid.body0.m_trBones) maidState.maidMune = CMT.SearchObjName(maidState.maid.body0.m_trBones, "Bip01 Spine1", true);
            return maidState.maidMune;
          }
          if (lookPoint == 1) {
            if (!maidState.maidHead && maidState.maid.body0.m_trBones) maidState.maidHead = maidState.maid.body0.trsHead;
            return maidState.maidHead;
          }
          if (lookPoint == 2) {
            if (!maidState.maidXxx && maidState.maid.body0.m_trBones) maidState.maidXxx = maidState.maid.body0.Pelvis;
            return maidState.maidXxx;
          }
          return null;

        }
        //メイド固定開始処理
        private void MaidFollowingCameraStart(int maidID)
        {
          if (!maidFollowEnabled || tgID == -1 || !cfgw.maidFollowCameraAdjust || fpsModeEnabled) return;

          //VRのみ HMDの現在位置に合わせてメイド固定開始
          if (bVR) {
            Transform maidTm = getMaidLookpointTransform(maidID);
            if (maidTm == null) return; //エラー対策

            //リアル視点 GripMoveの移動含む
            Transform realTm = mainCamera.GetRealHeadTransform();
            Vector3 realPos = realTm.position;
            float realAngleY = realTm.rotation.eulerAngles.y;

            //水平距離 メイドの現在位置との距離
            float dist = Mathf.Sqrt((maidTm.position.x-realPos.x)*(maidTm.position.x-realPos.x)+(maidTm.position.z-realPos.z)*(maidTm.position.z-realPos.z));
            //水平距離をカメラの向きに応じて短くする 最低1m
            //dist = Math.Max(1f, dist * (float)Math.Cos((cameraAngleY-realAngleY) * (Math.PI / 180.0)));

            //見ている方向を正面にTargetを移動
            mainCamera.SetTargetPos(realPos + Quaternion.AngleAxis(realAngleY, Vector3.up) * new Vector3(0f, 0f, dist), true);
            mainCamera.SetAroundAngle(new Vector2(realAngleY, 0f), true);

            //距離を設定 Questは実座標の距離の2倍にする 原因不明
            mainCamera.SetDistance(dist * cfgw.vrCamSetDistanceAdjust, true);

            //高さのずれはそのまま残す 上下個別指定
            maidFollowHeightOffset = realPos.y - maidTm.position.y;
            maidFollowHeightOffset = Math.Max(-cfgw.maidFollowKeepHeightBottom, Math.Min(cfgw.maidFollowKeepHeightTop, maidFollowHeightOffset));

            //VR用の遷移中の角度初期化
            vrFollowAngleRotation = Quaternion.Euler(0, realAngleY, 0);

            //GripMoveの移動をリセット 正面もHMD向きになる
            //mainCamera.SetRealHeadRot(new Vector3(0f, realAngleY, 0f), true); //falseだと視線方向の2倍回転してしまう
          }
        }

        //fpsModeEnabled のチェックは呼ぶ前にやっておく
        private void MaidFollowingCamera(int maidID) {
          if (!maidFollowEnabled) return;

          var cameraTm = mainCamera.transform;

          //視点の設定
          if (aoutLook) { //オート変更
            if (lookTime <= 0f) {
              lookPoint = UnityEngine.Random.Range(0, lookList.Length);
              lookTime = UnityEngine.Random.Range(240f,480f);
            } else {
              lookTime -= timerRate;
            }
          }

          Transform maidTm = getMaidLookpointTransform(maidID);
          if (maidTm == null) return; //エラー対策

          //ターゲットメイドのオート変更
          if (aoutTarget) {
            if (targetTime <= 0f) {
              int ti = UnityEngine.Random.Range(0, vmId.Count);
              changeTargetMaid(vmId[ti]);
              #if DOF
              depthOfField.focalTransformTime = cfgw.DepthFocalTransformTime; //スムーズにフォーカス切替
              #endif
              targetTime = UnityEngine.Random.Range(600f,1200f);
            } else {
              targetTime -= timerRate;
            }
          }

          float targetAngleYOffset = 0f;
          //カメラアングルのオート変更
          if (aoutAngle) {
            
            float angleY = 360 - maidTm.rotation.eulerAngles.y;
            float angleZ = 360 - maidTm.rotation.eulerAngles.z;
            if (lookPoint == 1) { angleY -= 180; angleZ += 90; }

            if (lookPoint >= 1) angleZ += 90f;
            float x = Mathf.Cos(angleY * Mathf.Deg2Rad);
            float y = Mathf.Cos(angleZ * Mathf.Deg2Rad);
            float z = Mathf.Sin(angleY * Mathf.Deg2Rad);
            if (lookPoint == 0) cameraTm.position = new Vector3(maidTm.position.x + x, maidTm.position.y + y , maidTm.position.z + z); //胸
            if (lookPoint == 1) cameraTm.position = new Vector3(maidTm.position.x - x, maidTm.position.y - y * cfgw.maidFollowAngleHeightRate, maidTm.position.z - z); //顔
            if (lookPoint == 2) { //股
              if (xi == 1) {
                if (130f < maidTm.rotation.eulerAngles.z && maidTm.rotation.eulerAngles.z < 200f) xi = -1;
              } else {
                if (50f > maidTm.rotation.eulerAngles.z || maidTm.rotation.eulerAngles.z > 280f) xi = 1;
              }
              cameraTm.position = new Vector3(maidTm.position.x + x * xi, maidTm.position.y + y, maidTm.position.z + z * xi);
            }
            Quaternion rotation = Quaternion.LookRotation(maidTm.position - cameraTm.position);

            //if (bVR) mainCamera.SetAroundAngle(new Vector2(rotation.eulerAngles.y, rotation.eulerAngles.x), true); //VR
            if (bVR) {
              Transform realTm = mainCamera.GetRealHeadTransform();
              if (bFollowLimitAngle) {
                bFollowLimitAngle = false; //アングル戻り制限は解除しておく
                vrFollowAngleRotation = Quaternion.Euler(0, mainCamera.GetAroundAngle().x, 0); //y軸とx軸のVector2なのでxを設定
              } else {
                if (!preAoutAngle) vrFollowAngleRotation = Quaternion.Euler(0, realTm.rotation.eulerAngles.y, 0); //アングル固定開始時に遷移中の角度初期化
                preAoutAngle = true;
                vrFollowAngleRotation = Quaternion.Slerp(vrFollowAngleRotation, rotation, Time.deltaTime * cfgw.maidFollowAngleSpeed);
                mainCamera.SetAroundAngle(new Vector2(vrFollowAngleRotation.eulerAngles.y, 0), false); //VR 仰角は0にして上下位置補正で対応
              }
              Vector3 dist = maidTm.position - realTm.position;
              //角度分上下にオフセット 上下は離れすぎないように制限 距離は20cmより近くしない
              targetAngleYOffset = Math.Max(cfgw.maidFollowAngleHeightLimitBottom, Math.Min(cfgw.maidFollowAngleHeightLimit,
                -(rotation * new Vector3(0f, 0f, Math.Max(0.3f, Mathf.Sqrt(dist.x*dist.x+dist.z*dist.z)))).y //最短30cmで高さ調整
              ));
            } else {
              //カメラを回転
             cameraTm.rotation = Quaternion.Slerp(cameraTm.rotation, rotation, Time.deltaTime * cfgw.maidFollowAngleSpeed);
            }
          } else {
            preAoutAngle = false;
          }

          //ズームのオート変更
          if (aoutZoom) {
            zoomValue = Mathf.SmoothDamp(mainCamera.GetDistance(), zoomTg, ref zoomVelocity , zoomTime);
            mainCamera.SetDistance(zoomValue, false);
            float d = Mathf.Abs(zoomTg - mainCamera.GetDistance());
            if (d < 0.01) {
              zoomTg = UnityEngine.Random.Range(0.22f,2f);
              zoomTime = UnityEngine.Random.Range(0.7f,2.8f) * timerRate;
            }
          }

          //カメラの移動先決定 高さ戻り速度は移動中と移動後で調整する
          float targetY = mainCamera.GetTargetPos().y;
          float maidY = maidTm.position.y;
          maidY += maidFollowHeightOffset + targetAngleYOffset; //オフセット対応 アングルの上下移動分も追加
          if (bFollowLimitY) {
            followReturnSpeedY = 0.2f * cfgw.cameraMoveReturnSpeedY; //制限の後は高さ戻り速度変更
            if (maidY < targetY) maidY = Math.Max(maidY, targetY - 0.01f); //移動中は戻り速度を遅くする (停止状態にできるように少し抵抗をつける)
            else maidY = Math.Min(maidY, targetY + 0.01f);
            bFollowLimitY = false; //高さ戻り制限は解除しておく
          } else {
            //戻り速度の最大値を設定 0は変更なし VRカメラ移動のスピードに合わせる
            if (followReturnSpeedY >= 0f && maidY != targetY) {
              if (maidY < targetY) maidY = Math.Max(maidY, targetY - followReturnSpeedY);
              else maidY = Math.Min(maidY, targetY + followReturnSpeedY);
              //maidY = targetY - (targetY-maidY) * followReturnSpeedY; //移動先の高さを割合で小さくする
            }
          }
          Vector3 pos = new Vector3(maidTm.position.x, maidY, maidTm.position.z);
          //float fDistance = Vector3.Distance(maidTm.position, mainCamera.GetTargetPos());
          //vFollowPosition = Vector3.SmoothDamp(mainCamera.GetTargetPos(), pos, ref lookVelocity, Time.deltaTime , fDistance * 7 * timerRate);
          //1秒だと遅いので0.5秒
          vFollowPosition = Vector3.SmoothDamp(mainCamera.GetTargetPos(), pos, ref lookVelocity, 0.5f / cfgw.maidFollowSpeed);

          //カメラ移動
          //mainCamera.SetPos(vFollowPosition); //不要
          mainCamera.SetTargetPos(vFollowPosition, false);
        }

        //メイドの移動処理
        private void MaidMove(int maidID, string mode, float move, bool all) {
          foreach (int ID in vmId) {
            if (ID == maidID || (maidID == tgID && LinkMaidCheck(maidID, ID) && all)) {
              Maid maid = stockMaids[ID].mem;
              Vector3 vm = maid.transform.position;
              Vector3 em = maid.transform.eulerAngles;
              if (mode == "px") maid.transform.position = new Vector3(vm.x + move, vm.y, vm.z);
              if (mode == "py") maid.transform.position = new Vector3(vm.x, vm.y + move, vm.z);
              if (mode == "pz") maid.transform.position = new Vector3(vm.x, vm.y, vm.z + move);

              if (mode == "ex") maid.transform.eulerAngles = new Vector3(move, em.y, em.z);
              if (mode == "ey") maid.transform.eulerAngles = new Vector3(em.x, move, em.z);
              if (mode == "ez") maid.transform.eulerAngles = new Vector3(em.x, em.y, move);
            }
          }

          if (all) {
            for (int i = 0; i < SubMans.Length; i++) {
              if (!isSubManVisible(i) || MansTg[i] != maidID) continue;
              Maid subMan = getSubMan(i);
              Vector3 vm = subMan.transform.position;
              Vector3 em = subMan.transform.eulerAngles;
              if (mode == "px") subMan.transform.position = new Vector3(vm.x + move, vm.y, vm.z);
              if (mode == "py") subMan.transform.position = new Vector3(vm.x, vm.y + move, vm.z);
              if (mode == "pz") subMan.transform.position = new Vector3(vm.x, vm.y, vm.z + move);

              if (mode == "ex") subMan.transform.eulerAngles = new Vector3(move, em.y, em.z);
              if (mode == "ey") subMan.transform.eulerAngles = new Vector3(em.x, move, em.z);
              if (mode == "ez") subMan.transform.eulerAngles = new Vector3(em.x, em.y, move);
            }
          }
        }

#if DOF
        //被写界深度一時無効化 Update()から0.1秒間隔で呼ばれる  元に戻すチェックはコルーチンで実行
        private void checkTempDepthOfField()
        {
          if (bVR) {
            //タブレットが表示されていて一時無効化されていないならタブレット前かをチェック
            if (GameMain.Instance.OvrMgr.OvrCamera.IsUIShow && disableTempDepthOfFieldCoroutine == null) {
              //タブレット表示中はコントローラーの位置に応じて切り替え
              if (cfgw.DepthEnabled && depthOfField != null) {
                //コントローラがタブレット上かチェック
                if (IsHitOvrTablet()) {
                  depthOfField.aperture = 0f;
                  //一時無効化解除コルーチン開始
                  disableTempDepthOfFieldCoroutine = StartCoroutine(disableTempDepthOfField());
                }
              }
            }
          }
        }
        //被写界深度一時無効化解除コルーチン 停止していたらnull
        Coroutine disableTempDepthOfFieldCoroutine;
        //被写界深度一時無効化解除 0.2秒毎にチェック  ダンス軽量モード時はUpdateから呼ばれないのでコールーチン化
        private IEnumerator disableTempDepthOfField()
        {
          do {
            yield return new WaitForSeconds(0.2f);
          } while (GameMain.Instance.OvrMgr.OvrCamera.IsUIShow && IsHitOvrTablet());
          //被写界深度を設定値に戻す
          if (depthOfField != null) depthOfField.aperture = cfgw.DepthAperture;
          disableTempDepthOfFieldCoroutine = null;
        }
        //コントローラーがタブレットの前にあるかチェック
        public bool IsHitOvrTablet()
        {
          OvrTablet tablet = GameMain.Instance.OvrMgr.OvrCamera.OvrTablet;
          float x = tablet.m_vHitArea.x * 0.4f; //左右
          float y = tablet.m_vHitArea.y * 0.4f; //前後
          float z = tablet.m_vHitArea.z * 0.4f; //上下
          Vector3 vector = tablet.transform.InverseTransformPoint(GameMain.Instance.OvrMgr.ovr_obj.left_controller.hand_trans.position);
          if (-x <= vector.x && vector.x <= x && -z <= vector.z && vector.z <= z && -y <= vector.y && vector.y <= y) return true;
          vector = tablet.transform.InverseTransformPoint(GameMain.Instance.OvrMgr.ovr_obj.right_controller.hand_trans.position);
          if (-x <= vector.x && vector.x <= x && -z <= vector.z && vector.z <= z && -y <= vector.y && vector.y <= y) return true;
          return false;
        }

        //被写界深度対象メイドのID
        //int depthMaidID = -1;
        //カメラに被写界深度を設定 VRも対応
        private void initDepthOfFieldMaid(int maidID)
        {
          //被写界深度設定 初期化
          if (depthOfField == null) {
            if (bVR) {
              //VRはOvrCamera.m_goCenterEye に設定する
              depthOfField = GameMain.Instance.OvrMgr.OvrCamera.m_goCenterEye.AddComponent<DepthOfFieldDistance>();
            } else {
              depthOfField = GameMain.Instance.MainCamera.gameObject.AddComponent<DepthOfFieldDistance>();
            }
          }

          if (depthOfField) {
            if (cfgw.DepthEnabled) {
              if (maidID == -1) {
                depthOfField.enabled = false;
                return;
              }

              //一時変更されていたらコルーチン停止
              if (disableTempDepthOfFieldCoroutine != null) {
                StopCoroutine(disableTempDepthOfFieldCoroutine);
                disableTempDepthOfFieldCoroutine = null;
              }

              if (depthOfField.dofHdrShader == null) depthOfField.dofHdrShader = Shader.Find("Hidden/Dof/DepthOfFieldHdr");
              if (depthOfField.dx11BokehShader == null) depthOfField.dx11BokehShader = Shader.Find("Hidden/Dof/DX11Dof");
              if (depthOfField.dx11BokehTexture == null) depthOfField.dx11BokehTexture = Resources.Load("Textures/hexShape") as Texture2D;

              depthOfField.distanceCloseLimit = cfgw.DepthDistanceCloseLimit;
              depthOfField.distanceCorrectRate = cfgw.DepthDistanceCorrectRate;
              depthOfField.focalTransformRadius = cfgw.DepthFocalTransformRadius;
              depthOfField.focalTransformTime = 0;

              depthOfField.highResolution = cfgw.DepthHighResolution;
              depthOfField.blurSample = cfgw.DepthBlurSample == 0 ? DepthOfFieldDistance.BlurSample.Low :
                (cfgw.DepthBlurSample == 1 ? DepthOfFieldDistance.BlurSample.Medium : DepthOfFieldDistance.BlurSample.High);
              //depthOfField.nearBlur = cfgw.DepthNearBlur;
              depthOfField.focalSize = cfgw.DepthFocalSize;
              depthOfField.aperture = cfgw.DepthAperture;
              depthOfField.maxBlurSize = cfgw.DepthMaxBlurSize;
              depthOfField.foregroundOverlap = cfgw.DepthForegroundOverlap;

              if (cfgw.DepthDX11) depthOfField.blurType = DepthOfFieldDistance.BlurType.DX11;
              else depthOfField.blurType = DepthOfFieldDistance.BlurType.DiscBlur;
              depthOfField.dx11SpawnHeuristic = cfgw.DepthDx11SpawnHeuristic;
              depthOfField.dx11BokehScale = cfgw.DepthDx11BokehScale;
              depthOfField.dx11BokehIntensity = cfgw.DepthDx11BokehIntensity;

              depthOfField.focalTransform = stockMaids[maidID].mem.body0.trsHead; //メインメイドの頭 半径も指定
              //depthMaidID = maidID;
            }
            //コルーチンがあるので後から設定反映
            depthOfField.enabled = cfgw.DepthEnabled;
            if (depthOfField.focalTransform == null) depthOfField.enabled = false; //メイドが取得できていなかったら無効

            #if DEBUG
            Debug.Log("depthOfField="+depthOfField);
            Debug.Log("CheckResources="+depthOfField.CheckResources());
            //Debug.Log("Dx11Support="+depthOfField.Dx11Support());
            Debug.Log("dofHdrShader="+depthOfField.dofHdrShader);
            //Debug.Log("CheckShaderAndCreateMaterial="+depthOfField.CheckShaderAndCreateMaterial(depthOfField.dofHdrShader, null));
            #endif
          }
        }

        //被写界深度の対象メイドを切り替え
        private void setDepthOfFieldMaid(int maidID)
        {
          if (cfgw.DepthEnabled && depthOfField) {
            if (maidID == -1) {
              depthOfField.enabled = false;
              return;
            }
            depthOfField.focalTransformTime = 0; //基本は0 スムーズにしたい場合は別途指定する
            depthOfField.focalTransform = stockMaids[maidID].mem.body0.trsHead; //メインメイドの頭 半径も指定
            //depthMaidID = maidID;
            depthOfField.enabled = depthOfField.focalTransform != null; //取得できていなかったら無効
          }
        }
        //被写界深度の対象メイドを見ているメイドに切り替え
        /*private void setDepthOfFieldLookingMaid()
        {
          if (cfgw.DepthEnabled && depthOfField) {
            int frontMaid = GetFrontMaid();
            if (depthMaidID != frontMaid) {
              depthOfField.focalTransform = stockMaids[maidID].mem.body0.trsHead; //メインメイドの頭 半径も指定
              depthMaidID = frontMaid;
            }
          }
        }*/
#endif
        
        //メイド切り替え時の処理
        private void changeTargetMaid(int newID) {
          if (tgID == newID) return;

          int oldID = tgID;
          tgID = newID;

          //リンクしていたら主従入れ替え
          if (maidsState[newID].linkID == oldID) {
            maidsState[oldID].linkID = newID;
            maidsState[newID].linkID = -1;
            //入れ替わった場合は他のメイドもリンク先のメインメイドを入れ替え
            foreach (int maidID in vmId) {
              if (maidsState[maidID].linkID == oldID) maidsState[maidID].linkID = newID;
            }
          } else {
            //解除
            foreach (int maidID in vmId) {
              if (maidsState[maidID].linkID == oldID) maidsState[maidID].linkID = -1;
            }
          }
          //リンクしているサブメイドと入れ替わったらサブメイドと男の位置のみを再設定
          if (maidsState[newID].motionLinkID == newID && maidsState[newID].motionLinkID != -1 && maidsState[newID].motionID != -1) {
            //新メイドの位置
            MotionAdjustDo(newID, maj.motionName[maidsState[newID].motionID], false, -1); //アイテムは変更しない
            //男の位置を再設定
            setManMotionPosition(newID, -1);

            //サブモーションのメイドに入れ替わった場合は位置を調整
            if (maidsState[newID].motionLinkID == oldID) {
              MotionAdjustDo(oldID, maj.motionName[maidsState[oldID].motionID], false, newID); //アイテムは変更しない
              setManMotionPosition(oldID, -1);
            }
            //サブメイド以外のモーションリンクIDを入れ替え
            foreach (int maidID in vmId) {
              if (maidID != newID && maidsState[maidID].motionLinkID == oldID) maidsState[maidID].motionLinkID = newID;
            }
          }
          //被写界深度対象変更
          #if DOF
          setDepthOfFieldMaid(tgID);
          #endif
        }

        //前のメイドを取得
        private int getPrevMaid() {
          int i = vmId.IndexOf(tgID) - 1;
          if (i < 0) i = vmId.Count - 1;
          //ダンスで見えていないメイドには切り替えない
          while (!isActiveMaid(stockMaids[vmId[i]].mem)) {
            if (tgID == vmId[i]) return tgID; //1周回ったら抜ける
            i--;
            if (i < 0) i = vmId.Count - 1;
          }
          return vmId[i];
        }

        //次のメイドを取得
        private int getNextMaid() {
          int i = vmId.IndexOf(tgID) + 1;
          if (i >= vmId.Count) i = 0;
          //ダンスで見えていないメイドには切り替えない
          while (!isActiveMaid(stockMaids[vmId[i]].mem)) {
            if (tgID == vmId[i]) return tgID; //1周回ったら抜ける
            i++;
            if (i >= vmId.Count) i = 0;
          }
          return vmId[i];
        }


        //前のメイドに切り替え
        private void changePrevMaid(bool camChange, bool beside)
        {
          int maidID = tgID;
          if (vmId.Count >= 3 && beside) maidID = GetSideMaid(tgID, mainCamera.GetRealHeadTransform(), true, cfgw.besideMaidOpposite);
          else if (vmId.Count >= 2) maidID = getPrevMaid();
          if (tgID != maidID) {
            changeTargetMaid(maidID);
          }
          if (camChange) {
            if (!maidFollowEnabled) CameraChange(tgID, cfgw.cameraChangeDistance, cfgw.cameraChangeTurn, 0); //カメラジャンプ ※メイド固定時は自動移動
          } else {
            if (tgID != maidID) {
              followReturnSpeedY = -1f; //メイド固定で移動するのでメイド固の縦移動速度は標準に戻す
              #if DOF
              depthOfField.focalTransformTime = cfgw.DepthFocalTransformTime; //スムーズにフォーカス切替
              #endif
            }
          }
        }
        //次のメイドに切り替え
        private void changeNextMaid(bool camChange, bool beside)
        {
          int maidID = tgID;
          if (vmId.Count >= 3 && beside) maidID = GetSideMaid(tgID, mainCamera.GetRealHeadTransform(), false, cfgw.besideMaidOpposite);
          else if (vmId.Count >= 2) maidID = getNextMaid();
          if (tgID != maidID) {
            changeTargetMaid(maidID);
          }
          if (camChange) {
            if (!maidFollowEnabled) CameraChange(tgID, cfgw.cameraChangeDistance, cfgw.cameraChangeTurn, 0); //カメラジャンプ ※メイド固定時は自動移動
          } else {
            if (tgID != maidID) {
              followReturnSpeedY = -1f; //メイド固定で移動するのでメイド固の縦移動速度は標準に戻す
              #if DOF
              depthOfField.focalTransformTime = cfgw.DepthFocalTransformTime; //スムーズにフォーカス切替
              #endif
            }
          }
        }


        //バイブ開始時に1回実行する処理  待機か射精後なら_2_または_3_に変更
        private void vibeStart(int maidID, MaidState maidState)
        {
          if (maidState.motionID != -1) {
            if (maidID == tgID) { //メインメイドのみ

              //挿入ボタンを押さなかった場合
              if (maidState.maid.body0.LastAnimeFN.Contains("_taiki_") || maidState.maid.body0.LastAnimeFN.Contains("_shaseigo_")) {
                //UNZIPの開始処理実行 面倒なのでモーションだけ変更はしない
                StartMaidUnzip(maidID, maj.motionName[maidState.motionID]);
              }
            }
          }
        }

        //バイブ停止操作時に1回実行する処理
        private void vibeStop(int maidID, MaidState maidState)
        {
          //SE停止
          if (maidID == tgID) GameMain.Instance.SoundMgr.StopSe();
        }

      //その他処理終了----------------------------------

      //GUI関係------------------------------------------

        //リモコンスイッチGUI---------------
        void WindowCallback(int id) {

                Maid tgMaid = stockMaids[tgID].mem;
                MaidState tgMaidState = maidsState[tgID];

                //現在ステータス表示
                int SucoreLevel2 = 0;
                if (Math.Floor(tgMaidState.orgasmValue) < 30) {
                  SucoreLevel2 = 0;
                } else if (Math.Floor(tgMaidState.orgasmValue) < 50) {
                  SucoreLevel2 = 1;
                } else if (Math.Floor(tgMaidState.orgasmValue) < 80) {
                  SucoreLevel2 = 2;
                } else {
                  SucoreLevel2 = 3;
                }

                int SucoreLevel3 = 0;
                if (Math.Floor(tgMaidState.resistValue) < 6) {
                  SucoreLevel3 = 0;
                } else if (Math.Floor(tgMaidState.resistValue) < 13) {
                  SucoreLevel3 = 1;
                } else if (Math.Floor(tgMaidState.resistValue) < 20) {
                  SucoreLevel3 = 2;
                } else {
                  SucoreLevel3 = 3;
                }

                if (GUI.Button(new Rect (196, 0, 24, 20), "x", gsButton)) {
                  cfgw.mainGuiFlag = 0;
                  Console.WriteLine("GUI非表示");
                }

                if (cfgw.mainGuiFlag == 1) {
                  if (GUI.Button(new Rect (172, 0, 24, 20), "－", gsButton)) {
                    cfgw.mainGuiFlag = 2;
                    Console.WriteLine("GUI最小化");
                  }


                if (GUI.Button(new Rect (5, 25, 28, 20), "<", gsButton)) {
                  changePrevMaid(cfgw.CamChangeEnabled, cfgw.besideMaidTarget);
                }

                if (GUI.Button(new Rect (36, 25, 28, 20), ">", gsButton)) {
                  changeNextMaid(cfgw.CamChangeEnabled, cfgw.besideMaidTarget);
                }

                string MaidName = stockMaids[tgID].name;
                GUI.Label(new Rect (70, 15, 150, 40), MaidName, gsLabel);

                  if (GUI.Button(new Rect (150, 50, 60, 20), lang.BTN_SETTING, gsButton)) {
                    cfgw.configGuiFlag = !cfgw.configGuiFlag;
                    if (cfgw.configGuiFlag) {
                      node3.x = node.x - 620 + cfgw.guiOffsetXConfig;
                      node3.y = node.y - 450 + cfgw.guiOffsetYConfig;
                    }
                  }


                  if (GUI.Button(new Rect (150, 77, 60, 20), lang.BTN_UNZIP, gsButton)) {
                    cfgw.unzipGuiFlag = !cfgw.unzipGuiFlag;
                    if (cfgw.unzipGuiFlag) {
                      node4.x = node.x - 620 + cfgw.guiOffsetXUnzip;
                      node4.y = node.y + cfgw.guiOffsetYUnzip;
                    }
                  }


                  if (!ExciteLock) {
                    GUI.Label(new Rect (5, 50, 190, 20), lang.EXCITE_LEVEL + SucoreText1[tgMaidState.exciteLevel - 1], gsLabel);
                  } else {
                    GUI.Label(new Rect (5, 50, 190, 20), lang.LOCK_LEVEL + SucoreText1[tgMaidState.exciteLevel - 1], gsLabel);
                  }

                  if (!OrgasmLock) {
                    GUI.Label(new Rect (5, 70, 190, 20), lang.ORGASM_LEVEL + SucoreText2[SucoreLevel2], gsLabel);
                  } else {
                    GUI.Label(new Rect (5, 70, 190, 20), lang.LOCK_LEVEL + SucoreText2[SucoreLevel2], gsLabel);
                  }

                  GUI.Label(new Rect (5, 90, 190, 20), lang.REGIST_LEVEL + SucoreText3[SucoreLevel3], gsLabel);

                  if (GUI.Button(new Rect (120, 52, 18, 16), "L", gsButton2)) {
                    ExciteLock = !ExciteLock;
                  }
                  if (GUI.Button(new Rect (120, 72, 18, 16), "L", gsButton2)) {
                    OrgasmLock = !OrgasmLock;
                  }

                  int stopButtonWidth = 200; //停止ボタンの幅

                  //UNZIP中でモーションが指定されている  挿入と抜くボタンは停止より先にチェック
                  if (tgMaidState.motionID != -1) {
                    if (isRemovedMotion(tgMaidState)) { //抜いている状態
                      //抜いていたら表示 オートの下
                      if (tgMaidState.insertable) { //素股は挿入がある場合のみ表示
                        stopButtonWidth = 125; //停止ボタンの幅
                        if (GUI.Button(new Rect(145, 142, 65, 20), lang.BTN_INSERT, gsButton)) {
                          insertMotionChange(tgID, tgMaidState);
                        }
                      }
                      //素股モーションがある
                      if (tgMaidState.sumataMotion != "Non") {
                        //素股モーションでない → 素股ボタン表示
                        if (!isSumataMotion(tgMaidState)) {
                          //素股ボタン 停止ボタンの幅
                          if (GUI.Button(new Rect(125, 193, 85, 20), lang.BTN_SUMATA, gsButton)) {
                            sumataMotionChange(tgID, tgMaidState);
                          }
                        }
                        //素股中で待機モーションがあれば待機ボタン
                        else if (tgMaidState.taikiMotion != "Non" ) {
                          if (GUI.Button(new Rect(125, 193, 85, 20), lang.BTN_WAIT, gsButton)) {
                            removeMotionChange(tgID, tgMaidState, false);
                          }
                        }
                      }
                    } else { //挿入中
                      //外出しモーションがあれば抜くボタン表示 (停止ボタンの右)
                      if (tgMaidState.removable) {
                        stopButtonWidth = 125; //停止ボタンの幅
                        if (GUI.Button(new Rect(145, 141, 65, 20), lang.BTN_REMOVE, gsButton)) {
                          removeMotionChange(tgID, tgMaidState, false);
                        }
                      }
                      //前後切り替えボタン
                      if (maj.analEnabled[tgMaidState.motionID] && !tgMaidState.stunFlag) {
                        if (GUI.Button(new Rect(125, 193, 85, 20), tgMaidState.analMode ? lang.BTN_USE_FRONT : lang.BTN_USE_BACK, gsButton)) {
                          tgMaidState.analMode = !tgMaidState.analMode;
                          analMotionChange(tgID, tgMaidState);
                        }
                      }
                    }
                  }

                  //弱ボタン
                  if (GUI.Button(new Rect (10, 115, 95, 20), lang.BTN_VIBE_SLOW+"[ " + cfgw.keyPluginToggleV3 + " ]", tgMaidState.vLevel == 1 ? gsButtonB : gsButton)) {
                    //foreach (int maidID in vmId) {
                    //  if (maidID != tgID && !LinkMaidCheck(tgID, maidID)) continue;
                    foreach (int maidID in vymMaidIDList(tgID, cfgw.vibeLinkType)) { //リンクメイド対応
                      maidsState[maidID].vLevel = 1;
                      maidsState[maidID].pAutoSelect = 0;
                      vibeStart(maidID, maidsState[maidID]);
                    }
                    Console.WriteLine("バイブ弱");
                  }
                  //強ボタン
                  if (GUI.Button(new Rect (115, 115, 95, 20), lang.BTN_VIBE_FAST+"[ " + cfgw.keyPluginToggleV4 + " ]", tgMaidState.vLevel == 2 ? gsButtonB : gsButton)) {
                    //foreach (int maidID in vmId) {
                    //  if (maidID != tgID && !LinkMaidCheck(tgID, maidID)) continue;
                    foreach (int maidID in vymMaidIDList(tgID, cfgw.vibeLinkType)) { //リンクメイド対応
                      maidsState[maidID].vLevel = 2;
                      maidsState[maidID].pAutoSelect = 0;
                      vibeStart(maidID, maidsState[maidID]);
                    }
                    Console.WriteLine("バイブ強");
                  }
                  //停止ボタン 「抜く」「挿入」ボタンがある場合はサイズ変更
                  if (GUI.Button(new Rect (10, 141, stopButtonWidth, 20), lang.BTN_VIBE_STOP+"[ " + cfgw.keyPluginToggleV2 + " ]", gsButton)) {
                    //foreach (int maidID in vmId) {
                    //  if (maidID != tgID && !LinkMaidCheck(tgID, maidID)) continue;
                    foreach (int maidID in vymMaidIDList(tgID, cfgw.vibeLinkType)) { //リンクメイド対応
                      maidsState[maidID].vLevel = 0;
                      maidsState[maidID].pAutoSelect = 0;
                      vibeStop(maidID, maidsState[maidID]);
                    }
                    Console.WriteLine("バイブ停止");
                  }

                  //オートボタン
                  if (GUI.Button(new Rect (125, 167, 85, 20), autoSelectList[tgMaidState.pAutoSelect], tgMaidState.pAutoSelect == 0 ? gsButton : gsButtonB)) {
                    if (tgMaidState.pAutoSelect == 0) {
                      tgMaidState.pAutoTime = 0f;
                      if (tgMaidState.vLevel == 0) { //バイブが止まっていた場合
                        tgMaidState.vLevel = 1; //開始処理用にバイブは弱にする
                        vibeStart(tgID, maidsState[tgID]);
                      }
                    }
                    ++tgMaidState.pAutoSelect;
                    if (tgMaidState.pAutoSelect > 3) tgMaidState.pAutoSelect = 0;
                  }

                  if (tgMaidState.stunFlag) {
                    if (GUI.Button(new Rect (170, 193, 40, 20),lang.BTN_SLAP, gsButton)) {
                      tgMaidState.stunFlag = false;
                      tgMaidState.maidStamina = 3000;
                      GameMain.Instance.SoundMgr.PlaySe("se013.ogg", false);
                      ReactionPlay(tgID);

                      tgMaid.ResetProp("eye_hi", false);//ハイライトを戻す
                      tgMaid.ResetProp("eye_hi_r", false);
                      tgMaid.AllProcPropSeqStart();
                    }
                  }


                  //GUI.Label(new Rect (5, 165, 210, 20), " ﾌﾟﾗｸﾞｲﾝ無効： [ " + cfgw.keyPluginToggleV0 + " ]", gsLabel);
                  //GUI.Label(new Rect (5, 185, 210, 20), " GUI表示切替： [ " + cfgw.keyPluginToggleV1 + " ]", gsLabel);

                  bool bToggle = GUI.Toggle(new Rect (10, 167, 115, 20), maidFollowEnabled, lang.MAID_FOLLOW , gsToggle );
                  if (maidFollowEnabled != bToggle) {
                    maidFollowEnabled = bToggle;
                    followReturnSpeedY = -1f; //縦移動速度は標準に戻す
                    //if (maidFollowEnabled) MaidFollowingCameraStart(tgID); //視点の向きを正面にしてメイド固定
                    if (maidFollowEnabled) adjustCameraDistance(); //距離補正
                    setDanceCameraDisabled(maidFollowEnabled); //ダンスカメラ有効無効切り替え
                  }

                  cfgw.osawariEnabled = GUI.Toggle(new Rect (10, 193, 115, 20), cfgw.osawariEnabled, lang.TOUCH_ENABLED , gsToggle );

                } else if (cfgw.mainGuiFlag == 2) {
                  if (GUI.Button(new Rect (172, 0, 24, 20), "+", gsButton)) {
                    cfgw.mainGuiFlag = 1;
                    Console.WriteLine("GUI表示");
                  }
                }


          GUI.DragWindow();
        }

        //サブキャラ操作GUI---------------
        Vector2 subGUIScrollPos = Vector2.zero;

        void WindowCallback2a(int id) {

          Vector3 vm;
          int y = 0;
          int h = 0;

          for (int i = 0; i < SubMans.Length; i++) {
            if (tgID != -1) {
              if (!vmId.Contains(MansTg[i])) MansTg[i] = tgID;
            } else {
              MansTg[i] = -1;
            }
          }


          if (cfgw.subGuiFlag == 0) {
            //閉じている場合
            //メインパネルに追従する
            node2.x = node.x + cfgw.guiOffsetXSub;
            if (cfgw.guiOffsetYSub < 450) node2.y = node.y - 20 + cfgw.guiOffsetYSub; //上にある場合
            else node2.y = node.y - 450 + cfgw.guiOffsetYSub; //下にある場合
            node2.height = 20;

            if (GUI.Button(new Rect (190, 0, 30, 20), "＋", gsButton)) {
              cfgw.subGuiFlag = 1;
              node2.height = 450;
              if (cfgw.guiOffsetYSub < 450) {
                node2.y -= 430; //上にある場合
                if (node5.y > node2.y - 190) {
                  node5.y = node2.y - 190;
                  if (node5.y < 0) node5.y = 0;
                }
              }
            }

          } else {
            //展開中
            if (GUI.Button(new Rect (190, 0, 30, 20), "－", gsButton)) {
              cfgw.subGuiFlag = 0;
              node2.height = 20;
              if (cfgw.guiOffsetYSub < 450) node2.y += 430; //上にある場合
            }

            if (GUI.Button(new Rect (100, 5, 85, 20), lang.BTN_CONFIG_2B, gsButton)) {
              cfgw.subGuiFlag = 2;
            }
            y += 30;

            Maid tgMaid = stockMaids[tgID].mem;
            MaidState tgMaidState = maidsState[tgID];

            //移動距離スライダー
            GUI.Label(new Rect (5, y, 80, 20), lang.MOVE_DIST + "：" + moveValue * 100 , gsLabel);
            float _moveValue = GUI.HorizontalSlider(new Rect(85, y+5, 130, 20), (float)Math.Sqrt(moveValue/0.3f), (float)Math.Sqrt(0.1f/30f), 1.0f); //スライダの値は0～1をSqrtした値
            _moveValue = _moveValue*_moveValue*0.3f; //スライダの値をSqrtして0.3倍にする
            if (moveValue != _moveValue) { moveValue = (float)Math.Round(_moveValue, _moveValue < 0.01f ? 3 : 2, MidpointRounding.ToEven); }
            y += 25;

            //モーションを同期
            if (GUI.Button(new Rect(5, y, 70, 20), lang.SYNC, gsButton)) {
              //モーションの時間を同期 男も同期する
              syncMotionAnimeTime(tgID, false, true);
            }
            if (GUI.Button(new Rect (90, y, 70, 20), lang.LINK_ALL, gsButton)) {
              foreach (int maidID in vmId) {
                if (maidID == tgID) maidsState[maidID].linkID = -1; //自分は解除
                else maidsState[maidID].linkID = tgID;
              }
            }
            if (GUI.Button(new Rect (164, y, 48, 20), lang.UNLINK, gsButton)) {
              //サブモーションのリンクも解除
              tgMaidState.linkID = -1;
              tgMaidState.motionLinkID = -1;
              foreach (int maidID in vmId) {
                if (maidsState[maidID].linkID == tgID) maidsState[maidID].linkID = -1;
                if (maidsState[maidID].motionLinkID == tgID) maidsState[maidID].motionLinkID = -1;
              }
            }
            y += 25;

            #if COM3D2_5
            cfgw.useRealMan = GUI.Toggle(new Rect(5, y, 190, 20), cfgw.useRealMan, lang.USE_NEW_REAL_MAN, gsToggle);
            y += 25;
            #endif

            GUI.DrawTexture(new Rect(1, y, 218, 1), guiLineTexture, ScaleMode.StretchToFill, true, 0);
            y += 3;

            h += vmId.Count * 125; //メイド表示分
            h += isSubManVisible(0) ? 173 : 28; //ご主人様表示分
            for (int i = 1; i < SubMans.Length; i++) {
              h += isSubManVisible(i) ? 153 : 28;
            }
            if (h < 450 - y) h = 450 - y;

            Rect scrlRect    = new Rect(0, y, 220, 445 - y);
            Rect contentRect = new Rect(0, 0, 195, h);
            subGUIScrollPos = GUI.BeginScrollView( scrlRect, subGUIScrollPos, contentRect, false, true );
            y = 0;


            //先頭にメインメイドを表示
            GUI.Label(new Rect (0, y, 250, 20), "【 " + stockMaids[tgID].name + " 】", gsLabel3);
            y += 25;

            if (GUI.Button(new Rect (5, y, 25, 20), "X↑", gsButton)) {
              MaidMove(tgID, "px", moveValue, true);
            }
            if (GUI.Button(new Rect (35, y, 25, 20), "Y↑", gsButton)) {
              MaidMove(tgID, "py", moveValue, true);
            }
            if (GUI.Button(new Rect (65, y, 25, 20), "Z↑", gsButton)) {
              MaidMove(tgID, "pz", moveValue, true);
            }

            if (GUI.Button(new Rect (100, y, 25, 20), lang.BTN_LEFT, gsButton)) {
              Vector3 em = tgMaid.transform.eulerAngles;
              em.y = em.y - 100f * moveValue;
              if (em.y < 0) em.y += 360f;
              MaidMove(tgID, "ey", em.y, true);
            }
            if (GUI.Button(new Rect (125, y, 25, 20), lang.BTN_RIGHT, gsButton)) {
              Vector3 em = tgMaid.transform.eulerAngles;
              em.y = em.y + 100f * moveValue;
              if (em.y > 360) em.y -= 360f;
              MaidMove(tgID, "ey", em.y, true);
            }
            if (GUI.Button(new Rect (155, y, 46, 20), lang.BTN_INVERT, gsButton)) {
              Vector3 em = tgMaid.transform.eulerAngles;
              MaidMove(tgID, "ey", (em.y > 180f ? em.y-360f : em.y)+180f, true);
            }
            y += 25;

            if (GUI.Button(new Rect (5, y, 25, 20), "X↓", gsButton)) {
              MaidMove(tgID, "px", -moveValue, true);
            }
            if (GUI.Button(new Rect (35, y, 25, 20), "Y↓", gsButton)) {
              MaidMove(tgID, "py", -moveValue, true);
            }
            if (GUI.Button(new Rect (65, y, 25, 20), "Z↓", gsButton)) {
              MaidMove(tgID, "pz", -moveValue, true);
            }

            if (GUI.Button(new Rect (100, y, 25, 20), lang.BTN_FRONT, gsButton)) {
              Vector3 em = tgMaid.transform.eulerAngles;
              float emValue = em.x + 100f * moveValue;
              if (emValue >= 360f) emValue -= 360f;
              if (emValue > 90f && emValue < 270f) emValue = 90f;
              MaidMove(tgID, "ex", emValue, true);
            }
            if (GUI.Button(new Rect (125, y, 25, 20), lang.BTN_BACK, gsButton)) {
              Vector3 em = tgMaid.transform.eulerAngles;
              float emValue = em.x - 100f * moveValue;
              if (emValue < 0f) emValue += 360f;
              if (emValue > 90f && emValue < 270f) emValue = 270f;
              MaidMove(tgID, "ex", emValue, true);
            }
            if (GUI.Button(new Rect (155, y, 46, 20), lang.BTN_RESET, gsButton)) {
              MaidMove(tgID, "ex", 0f, true);
            }
            y += 25;

            if (GUI.Button(new Rect (105, y, 46, 20), lang.BTN_GATHER, gsButton)) {
              foreach (int maidID in vmId) {
                if (maidID != tgID && LinkMaidCheck(tgID, maidID)) {
                  stockMaids[maidID].mem.transform.position = tgMaid.transform.position;
                  stockMaids[maidID].mem.transform.eulerAngles = tgMaid.transform.eulerAngles;
                  maidsState[maidID].majPositionBak.x = tgMaidState.majPositionBak.x;
                  maidsState[maidID].majPositionBak.y = tgMaidState.majPositionBak.y;
                  maidsState[maidID].majPositionBak.z = tgMaidState.majPositionBak.z;
                  maidsState[maidID].majAngleYBak = tgMaidState.majAngleYBak;
                }
              }
              for (int i = 0; i < SubMans.Length; i++) {
                Maid sm = getSubMan(i);
                if (!sm.Visible || MansTg[i] != tgID) continue;
                sm.transform.position = tgMaid.transform.position;
                sm.transform.eulerAngles = tgMaid.transform.eulerAngles;
              }
            }
            if (GUI.Button(new Rect (155, y, 46, 20), lang.BTN_ORIGIN, gsButton)) {
              foreach (int maidID in vmId) {
                if (maidID != tgID && !LinkMaidCheck(tgID, maidID)) continue;
                stockMaids[maidID].mem.transform.position = new Vector3(0f, 0f, 0f);
                maidsState[maidID].majPositionBak.x = 0f;
                maidsState[maidID].majPositionBak.y = 0f;
                maidsState[maidID].majPositionBak.z = 0f;
              }
              for (int i = 0; i < SubMans.Length; i++) {
                Maid sm = getSubMan(i);
                if (!sm.Visible || MansTg[i] != tgID) continue;
                sm.transform.position = new Vector3(0f, 0f, 0f);
              }
            }
            y += 22;

            tgMaid.body0.boEyeToCam = GUI.Toggle(new Rect(5, y, 50, 20), tgMaid.body0.boEyeToCam, lang.EYE_TO_CAM, gsToggle);
            tgMaid.body0.boHeadToCam = GUI.Toggle(new Rect(55, y, 50, 20), tgMaid.body0.boHeadToCam, lang.HEAD_TO_CAM, gsToggle);
            tgMaidState.eAutoSelect = GUI.Toggle(new Rect(115, y, 90, 20), tgMaidState.eAutoSelect, lang.AUTO_CAM, gsToggle);
            y += 25;

            //各メイド
            foreach (int maidID in vmId) {
              if (maidID == tgID) continue;

              Maid maid = stockMaids[maidID].mem;
              MaidState maidState = maidsState[maidID];

              GUI.DrawTexture(new Rect(5, y, 195, 1), guiLineTexture, ScaleMode.StretchToFill, true, 0);
              y += 3;

              GUI.Label(new Rect (0, y, 250, 20), "【 " + stockMaids[maidID].name + " 】", gsLabel3);
              vm = maid.transform.position;
              y += 25;

              if (GUI.Button(new Rect (5, y, 25, 20), "X↑", gsButton)) {
                maid.transform.position = new Vector3(vm.x + moveValue, vm.y, vm.z);
              }
              if (GUI.Button(new Rect (35, y, 25, 20), "Y↑", gsButton)) {
                maid.transform.position = new Vector3(vm.x, vm.y + moveValue, vm.z);
              }
              if (GUI.Button(new Rect (65, y, 25, 20), "Z↑", gsButton)) {
                maid.transform.position = new Vector3(vm.x, vm.y, vm.z + moveValue);
              }

              if (GUI.Button(new Rect (100, y, 28, 20), lang.BTN_SLOW, maidState.vLevel == 1 ? gsButtonB : gsButton)) {
                maidState.vLevel = 1;
                maidState.pAutoSelect = 0;
                vibeStart(maidID, maidState);
              }
              if (GUI.Button(new Rect (132, y, 28, 20), lang.BTN_FAST, maidState.vLevel == 2 ? gsButtonB : gsButton)) {
                maidState.vLevel = 2;
                maidState.pAutoSelect = 0;
                vibeStart(maidID, maidState);
              }
              if (GUI.Button(new Rect (165, y, 35, 20), lang.BTN_STOP, gsButton)) {
                maidState.vLevel = 0;
                maidState.pAutoSelect = 0;
                vibeStop(maidID, maidState);
              }
              y += 25;

              if (maidState.linkEnabled) {
                maidState.pAutoSelect = 0;
                maidState.pAutoTime = 0f;
                GUI.Label(new Rect (105, y, 85, 20), lang.LINKING, gsLabel);
              } else {
                if (GUI.Button(new Rect (105, y, 85, 20), autoSelectList[maidState.pAutoSelect], maidState.pAutoSelect == 0 ? gsButton : gsButtonB)) {
                  if (maidState.pAutoSelect == 0) maidState.pAutoTime = 0f;
                  ++maidState.pAutoSelect;
                  if (maidState.pAutoSelect > 3) maidState.pAutoSelect = 0;
                }
              }

              if (GUI.Button(new Rect (5, y, 25, 20), "X↓", gsButton)) {
                maid.transform.position = new Vector3(vm.x - moveValue, vm.y, vm.z);
              }
              if (GUI.Button(new Rect (35, y, 25, 20), "Y↓", gsButton)) {
                maid.transform.position = new Vector3(vm.x, vm.y - moveValue, vm.z);
              }
              if (GUI.Button(new Rect (65, y, 25, 20), "Z↓", gsButton)) {
                maid.transform.position = new Vector3(vm.x, vm.y, vm.z - moveValue);
              }
              y += 25;

              //maidState.linkEnabled = GUI.Toggle(new Rect(5, y, 190, 20), maidState.linkEnabled, "メインメイドとリンクさせる", gsToggle);
              if (GUI.Button(new Rect (5, y, 50, 20), lang.LINK, gsButton)) {
                int mi = vmId.IndexOf(maidState.linkID) + 1;
                if (mi >= vmId.Count) mi = 0;
                if (maidID == vmId[mi]) {
                  ++mi;
                  if (mi >= vmId.Count) mi = 0;
                }
                maidState.linkID = vmId[mi];
                //maid.transform.position = stockMaids[maidState.linkID].mem.transform.position;
                //maid.transform.eulerAngles = stockMaids[maidState.linkID].mem.transform.eulerAngles;
              }
              string TargetName = lang.NO_TARGET;
              if (maidState.linkID != -1) {
                TargetName = stockMaids[maidState.linkID].name;
                if (GUI.Button(new Rect (175, y, 25, 20), lang.BTN_TARGET_CANCEL, gsButton)) { maidState.linkID = -1; }
              }
              GUI.Label(new Rect (60, y, 140, 20), TargetName, gsLabel);
              y += 22;

              maid.body0.boEyeToCam = GUI.Toggle(new Rect(5, y, 50, 20), maid.body0.boEyeToCam, lang.EYE_TO_CAM, gsToggle);
              maid.body0.boHeadToCam = GUI.Toggle(new Rect(60, y, 50, 20), maid.body0.boHeadToCam, lang.HEAD_TO_CAM, gsToggle);
              maidState.eAutoSelect = GUI.Toggle(new Rect(115, y, 90, 20), maidState.eAutoSelect, lang.AUTO_CAM, gsToggle);
              y += 25;
            }


            //ご主人様操作用
            GUI.DrawTexture(new Rect(1, y, 218, 1), guiLineTexture, ScaleMode.StretchToFill, true, 0);
            y += 3;

            GUI.Label(new Rect(0, y, 100, 20), "【 " + SubMansName[0] + " 】", gsLabel3);
            Maid subMan0 = getSubMan(0);
            vm = subMan0.transform.position;

            if (!isSubManVisible(0)) {
              if (GUI.Button(new Rect (90, y, 80, 20), lang.VISIBLE_TOGGLE, gsButtonB)) {
                if (!SubMans[0]) SubMans[0] = GameMain.Instance.CharacterMgr.GetMan(0);
                if (SubMans[0]) MansVisible(0);
              }
              y += 25;
            } else {
              if (GUI.Button(new Rect (90, y, 75, 20), lang.INVISIBLE, gsButtonB)) {
                if (SubMans[0]) MansVisible(0);
              }
              bool saoVisible = subMan0.body0.GetChinkoVisible(); //竿の表示状態は毎回取得
              bool saoToggle = GUI.Toggle(new Rect (170, y, 35, 20), saoVisible, lang.VISIBLE_SAO , gsButton );
              //if (GUI.Button(new Rect (170, y, 35, 20), lang.VISIBLE_SAO, gsButton)) {
              if (saoToggle != saoVisible) {
                subMan0.body0.SetChinkoVisible(!saoVisible);
              }
              y += 25;

              #if COM3D2_5
              if (subMan0.IsNowRealMan) {
                if (GUI.Button(new Rect (0, y, 60, 20), lang.DRESS_ALL, gsButton)){
                  dressAll(subMan0);
                }
                if (GUI.Button(new Rect (60, y, 60, 20), lang.UNDRESS_ALL, gsButton)){
                  undressAll(subMan0);
                }
                if (GUI.Button(new Rect (120, y, 45, 20), lang.UNDRESS_MANPANTS, gsButton)){
                  subMan0.body0.SetMask(TBody.SlotID.panz, !subMan0.body0.GetMask(TBody.SlotID.panz));
                }
                if (GUI.Button(new Rect (165, y, 45, 20), lang.UNDRESS_SHOES, gsButton)){
                  subMan0.body0.SetMask(TBody.SlotID.shoes, !subMan0.body0.GetMask(TBody.SlotID.shoes));
                }
                y += 25;
              }
              #endif

              if (GUI.Button(new Rect (5, y, 25, 20), "X↑", gsButton)) {
                subMan0.transform.position = new Vector3(vm.x + moveValue, vm.y, vm.z);
              }
              if (GUI.Button(new Rect (35, y, 25, 20), "Y↑", gsButton)) {
                subMan0.transform.position = new Vector3(vm.x, vm.y + moveValue, vm.z);
              }
              if (GUI.Button(new Rect (65, y, 25, 20), "Z↑", gsButton)) {
                subMan0.transform.position = new Vector3(vm.x, vm.y, vm.z + moveValue);
              }
              if (GUI.Button(new Rect (105, y, 85, 20), lang.FIX_POS, gsButton)) {
                subMan0.transform.position = stockMaids[MansTg[0]].mem.transform.position;
                subMan0.transform.eulerAngles = stockMaids[MansTg[0]].mem.transform.eulerAngles;
              }
              y += 25;

              if (GUI.Button(new Rect (5, y, 25, 20), "X↓", gsButton)) {
                subMan0.transform.position = new Vector3(vm.x - moveValue, vm.y, vm.z);
              }
              if (GUI.Button(new Rect (35, y, 25, 20), "Y↓", gsButton)) {
                subMan0.transform.position = new Vector3(vm.x, vm.y - moveValue, vm.z);
              }
              if (GUI.Button(new Rect (65, y, 25, 20), "Z↓", gsButton)) {
                subMan0.transform.position = new Vector3(vm.x, vm.y, vm.z - moveValue);
              }

              if (GUI.Button(new Rect (95, y, 25, 20), lang.BTN_LEFT, gsButton)) {
                Vector3 em = subMan0.transform.eulerAngles;
                em.y = em.y - 100f * moveValue;
                if (em.y < 0) em.y += 360f;
                subMan0.transform.eulerAngles = em;
              }
              if (GUI.Button(new Rect (120, y, 25, 20), lang.BTN_RIGHT, gsButton)) {
                Vector3 em = subMan0.transform.eulerAngles;
                em.y = em.y + 100f * moveValue;
                if (em.y > 360) em.y -= 360f;
                subMan0.transform.eulerAngles = em;
              }
              if (GUI.Button(new Rect (150, y, 25, 20), lang.BTN_FRONT, gsButton)) {
                Vector3 em = subMan0.transform.eulerAngles;
                float emValue = em.x + 100f * moveValue;
                if (emValue >= 360f) emValue -= 360f;
                if (emValue > 90f && emValue < 270f) emValue = 90f;
                subMan0.transform.eulerAngles = new Vector3(emValue, em.y, em.z);
              }
              if (GUI.Button(new Rect (175, y, 25, 20), lang.BTN_BACK, gsButton)) {
                Vector3 em = subMan0.transform.eulerAngles;
                float emValue = em.x - 100f * moveValue;
                if (emValue < 0f) emValue += 360f;
                if (emValue > 90f && emValue < 270f) emValue = 270f;
                subMan0.transform.eulerAngles = new Vector3(emValue, em.y, em.z);
              }
              y += 25;

              GUI.Label(new Rect (5, y, 90, 20), lang.EJACULATION_VALUE+"：" + Math.Floor(syaseiValue[0]) , gsLabel);
              syaseiLock[0] = GUI.Toggle(new Rect (75, y, 18, 20), syaseiLock[0], "L", syaseiLock[0] ? gsButtonLock : gsButton2);
              syaseiValue[0] = GUI.HorizontalSlider(new Rect(100, y+5, 95, 20), syaseiValue[0], 0f, 95f);
              y += 25;

              if (GUI.Button(new Rect (5, y, 50, 20), lang.TARGET, gsButton)) {
                if (cfgw.autoMoveEnabled) cfgw.autoMoveEnabled = false;
                int mi = vmId.IndexOf(MansTg[0]) + 1;
                if (mi >= vmId.Count) mi = 0;
                MansTg[0] = vmId[mi];

                subMan0.transform.position = stockMaids[MansTg[0]].mem.transform.position;
                subMan0.transform.eulerAngles = stockMaids[MansTg[0]].mem.transform.eulerAngles;

                //男のモーション変更
                ManMotionChange(MansTg[0], true, 0.5f, 1.0f);
              }
              string TargetName = lang.NO_TARGET;
              if (MansTg[0] != -1) TargetName = stockMaids[MansTg[0]].name;
              GUI.Label(new Rect (60, y, 160, 20), TargetName, gsLabel);
              y += 20;

              cfgw.autoMoveEnabled = GUI.Toggle(new Rect (5, y, 155, 20), cfgw.autoMoveEnabled, lang.CONNECT_MAIN_MAID , gsToggle );
              y += 25;
            }

            //モブ男
            for (int i = 1; i < SubMans.Length; i++) {
              GUI.DrawTexture(new Rect(5, y, 195, 1), guiLineTexture, ScaleMode.StretchToFill, true, 0);
              y += 3;

              GUI.Label(new Rect(0, y, 100, 20), "【 " + SubMansName[i] + " 】", gsLabel3);
              Maid subMan = getSubMan(i);
              vm = subMan.transform.position;

              if (!isSubManVisible(i)) {
                if (GUI.Button(new Rect (90, y, 80, 20), lang.VISIBLE_TOGGLE, gsButtonB)) {
                  if (!SubMans[i]) SubMans[i] = GameMain.Instance.CharacterMgr.GetMan(i);
                  if (SubMans[i]) MansVisible(i);
                }
                y += 25;

              } else {
                if (GUI.Button(new Rect (90, y, 75, 20), lang.INVISIBLE, gsButtonB)) {
                  if (SubMans[i]) MansVisible(i);
                }
                bool saoVisible = subMan.body0.GetChinkoVisible(); //竿の表示状態は毎回取得
                bool saoToggle = GUI.Toggle(new Rect (170, y, 35, 20), saoVisible, lang.VISIBLE_SAO , gsButton );
                //if (GUI.Button(new Rect (170, y, 35, 20), lang.VISIBLE_SAO, gsButton)) {
                if (saoToggle != saoVisible) {
                  subMan.body0.SetChinkoVisible(!saoVisible);
                }
                y += 25;

                #if COM3D2_5
                if (subMan.IsNowRealMan) {
                  if (GUI.Button(new Rect (0, y, 60, 20), lang.DRESS_ALL, gsButton)){
                    dressAll(subMan);
                  }
                  if (GUI.Button(new Rect (60, y, 60, 20), lang.UNDRESS_ALL, gsButton)){
                    undressAll(subMan);
                  }
                  if (GUI.Button(new Rect (120, y, 45, 20), lang.UNDRESS_MANPANTS, gsButton)){
                    subMan.body0.SetMask(TBody.SlotID.panz, !subMan.body0.GetMask(TBody.SlotID.panz));
                  }
                  if (GUI.Button(new Rect (165, y, 45, 20), lang.UNDRESS_SHOES, gsButton)){
                    subMan.body0.SetMask(TBody.SlotID.shoes, !subMan.body0.GetMask(TBody.SlotID.shoes));
                  }
                  y += 25;
                }
                #endif

                if (GUI.Button(new Rect (105, y, 85, 20), lang.FIX_POS, gsButton)) {
                  getSubMan(i).transform.position = stockMaids[MansTg[i]].mem.transform.position;
                  getSubMan(i).transform.eulerAngles = stockMaids[MansTg[i]].mem.transform.eulerAngles;
                }

                if (GUI.Button(new Rect (5, y, 25, 20), "X↑", gsButton)) {
                  getSubMan(i).transform.position = new Vector3(vm.x + moveValue, vm.y, vm.z);
                }
                if (GUI.Button(new Rect (35, y, 25, 20), "Y↑", gsButton)) {
                  getSubMan(i).transform.position = new Vector3(vm.x, vm.y + moveValue, vm.z);
                }
                if (GUI.Button(new Rect (65, y, 25, 20), "Z↑", gsButton)) {
                  getSubMan(i).transform.position = new Vector3(vm.x, vm.y, vm.z + moveValue);
                }
                y += 25;

                if (GUI.Button(new Rect (5, y, 25, 20), "X↓", gsButton)) {
                  getSubMan(i).transform.position = new Vector3(vm.x - moveValue, vm.y, vm.z);
                }
                if (GUI.Button(new Rect (35, y, 25, 20), "Y↓", gsButton)) {
                  getSubMan(i).transform.position = new Vector3(vm.x, vm.y - moveValue, vm.z);
                }
                if (GUI.Button(new Rect (65, y, 25, 20), "Z↓", gsButton)) {
                  getSubMan(i).transform.position = new Vector3(vm.x, vm.y, vm.z - moveValue);
                }
                if (GUI.Button(new Rect (95, y, 25, 20), lang.BTN_LEFT, gsButton)) {
                  Vector3 em = getSubMan(i).transform.eulerAngles;
                  em.y = em.y - 100f * moveValue;
                  if (em.y < 0) em.y += 360f;
                  getSubMan(i).transform.eulerAngles = em;
                }
                if (GUI.Button(new Rect (120, y, 25, 20), lang.BTN_RIGHT, gsButton)) {
                  Vector3 em = getSubMan(i).transform.eulerAngles;
                  em.y = em.y + 100f * moveValue;
                  if (em.y > 360) em.y -= 360f;
                  getSubMan(i).transform.eulerAngles = em;
                }
                if (GUI.Button(new Rect (150, y, 25, 20), lang.BTN_FRONT, gsButton)) {
                  Vector3 em = getSubMan(i).transform.eulerAngles;
                  float emValue = em.x + 100f * moveValue;
                  if (emValue >= 360f) emValue -= 360f;
                  if (emValue > 90f && emValue < 270f) emValue = 90f;
                  getSubMan(i).transform.eulerAngles = new Vector3(emValue, em.y, em.z);
                }
                if (GUI.Button(new Rect (175, y, 25, 20), lang.BTN_BACK, gsButton)) {
                  Vector3 em = getSubMan(i).transform.eulerAngles;
                  float emValue = em.x - 100f * moveValue;
                  if (emValue < 0f) emValue += 360f;
                  if (emValue > 90f && emValue < 270f) emValue = 270f;
                  getSubMan(i).transform.eulerAngles = new Vector3(emValue, em.y, em.z);
                }
                y += 25;

                GUI.Label(new Rect (5, y, 90, 20), lang.EJACULATION_VALUE+"：" + Math.Floor(syaseiValue[i]) , gsLabel);
                syaseiLock[i] = GUI.Toggle(new Rect (75, y, 18, 20), syaseiLock[i], "L", gsButtonLock);
                syaseiValue[i] = GUI.HorizontalSlider(new Rect(100, y+5, 95, 20), syaseiValue[i], 0f, 95f);
                y += 25;

                if (GUI.Button(new Rect (5, y, 50, 20), lang.TARGET, gsButton)) {
                  int mi = vmId.IndexOf(MansTg[i]) + 1;
                  if (mi >= vmId.Count) mi = 0;
                  MansTg[i] = vmId[mi];

                  getSubMan(i).transform.position = stockMaids[MansTg[i]].mem.transform.position;
                  getSubMan(i).transform.eulerAngles = stockMaids[MansTg[i]].mem.transform.eulerAngles;

                  //男のモーション変更
                  ManMotionChange(MansTg[i], true, 0.5f, 1.0f);
                  maidsState[MansTg[i]].motionHoldTime = 0f; //モーションタイマーリセット
                }

                string TargetName = lang.NO_TARGET;
                if (MansTg[i] != -1) TargetName = stockMaids[MansTg[i]].name;
                GUI.Label(new Rect (60, y, 135, 20), TargetName, gsLabel);
                y += 25;
              }
            }

            GUI.EndScrollView();
            GUI.DragWindow();
          }
        }

        void WindowCallback2b(int id) {

          if (cfgw.subGuiFlag == 0) {
            //閉じている場合
            //メインパネルに追従する
            node2.x = node.x + cfgw.guiOffsetXSub;
            if (cfgw.guiOffsetYSub < 450) node2.y = node.y - 20 + cfgw.guiOffsetYSub; //上にある場合
            else node2.y = node.y - 450 + cfgw.guiOffsetYSub; //下にある場合
            node2.height = 20;

            if (GUI.Button(new Rect (190, 0, 30, 20), "＋", gsButton)) {
              cfgw.subGuiFlag = 1;
              node2.height = 450;
              if (cfgw.guiOffsetYSub < 450) {
                node2.y -= 430; //上にある場合
                if (node5.y > node2.y - 190) {
                  node5.y = node2.y - 190;
                  if (node5.y < 0) node5.y = 0;
                }
              }
            }

          } else {
            //展開中
            if (GUI.Button(new Rect (190, 0, 30, 20), "－", gsButton)) {
              cfgw.subGuiFlag = 0;
              node2.height = 20;
              if (cfgw.guiOffsetYSub < 450) node2.y += 430; //上にある場合
            }

            if (GUI.Button(new Rect (100, 5, 85, 20), lang.BTN_CONFIG_2A, gsButton)) {
              cfgw.subGuiFlag = 1;
            }

            //Maid maid = null;
            //if (tgID != -1) maid = stockMaids[tgID].mem;

            int y = 35;
            int h = 65 * stockMaids.Count + 20;
            Rect scrlRect    = new Rect(5, y, 214, 445 - y);
            Rect contentRect = new Rect(0, 0, 195, h);
            subGUIScrollPos = GUI.BeginScrollView( scrlRect, subGUIScrollPos, contentRect, false, true );
            y = 0;

            foreach (var sm in stockMaids) {
              Maid getmaid = sm.mem;
              if (getmaid.Visible) {
                string MaidName = getmaid.status.lastName + " " + getmaid.status.firstName;

                GUI.Label(new Rect (2, y, 250, 20), MaidName, gsLabel);
                if (GUI.Button(new Rect (130, y, 65, 20), lang.INVISIBLE, gsButton)) {
                  getmaid.Visible = false;
                }
                y += 22;
              }
            }

            //GUI.Label(new Rect (0, y, 195, 20), "―――――――――――", gsLabel2);
            GUI.DrawTexture(new Rect(5, y+8, 195, 1), guiLineTexture, ScaleMode.StretchToFill, true, 0);
            y += 16;

            foreach (var sm in stockMaids) {
              Maid getmaid = sm.mem;
              if (!getmaid.Visible) {

                GUI.DrawTexture(new Rect(0, y, 50, 60), getmaid.GetThumIcon());

                string MaidName = getmaid.status.lastName + " " + getmaid.status.firstName;
                if (GUI.Button(new Rect (50, y, 145, 60), MaidName, gsButton)) {
                  LoadMaid(getmaid);
                  GameMain.Instance.MainCamera.FadeOut(0f, false, null, true, default(Color)); //NormalizeVoice.Pluginにメイドチェック処理をさせるため一旦フェードアウトさせる
                  GameMain.Instance.MainCamera.FadeIn(1f, false, null, true, true, default(Color));

                }
                y += 65;
              }
            }

            GUI.EndScrollView();
            GUI.DragWindow();

          }
        }



        //設定画面GUI---------------
        private int ConfigFlag = 0;
        private int cv = 0;
        private Vector2 EditScroll = Vector2.zero;
        private float moveValue = 0.01f;
        private Vector2 vsScrollPos1 = Vector2.zero;
        private Vector2 vsScrollPos2 = Vector2.zero;
        private Vector2 dsScrollPos = Vector2.zero;
        private string cbsName = "";
        private bool[] hs_Overwrite = new bool[]{false, false, false, false};
        private bool[] ds_Overwrite = new bool[]{false, false, false, false, false};
        private string[] dsErrerText = new string[] { "" , "衣装セット名が空白のため保存できません" , "上書きする場合は『上書』にチェックを入れて下さい"};
        private int dsErrer = 0;
        private bool setWear = true;
        private bool setSkirt = true;
        private bool setOnepiece = true;
        private bool setMizugi = true;
        private bool setBra = true;
        private bool setPanz = true;
        private bool setStkg = true;
        private bool setShoes = true;
        private bool setAcchat = true;
        private bool setHeadset = true;
        private bool setGlove = true;
        private bool setAcchead = true;
        private bool setAcchana = true;
        private bool setAccmimi = true;
        private bool setAccnip = true;
        private bool setAcckubi = true;
        private bool setAcckubiwa = true;
        private bool setAccheso = true;
        private bool setAccude = true;
        private bool setAccashi = true;
        private bool setAccsenaka = true;
        private bool setAccshippo = true;
        private bool setMegane = true;
        private bool setAccxxx = true;
        private string[] bvsText1 = new string[] { "弱　通常音声","弱　フェラ音声","強　通常音声","強　フェラ音声","絶頂　通常音声","絶頂　フェラ音声","停止時音声" };
        private string[] bvsText2 = new string[] { "【快感０の音声】","【快感１の音声】","【快感２の音声】","【快感３の音声】","【放心時の音声】" };
        private string[] bvsText3 = new string[] { "【快感１絶頂の音声】","【快感２絶頂の音声】","【快感３絶頂の音声】","【連続絶頂の音声】","【放心時の音声】" };
        private string[] cliModeText = new string[]{ "通常" , "巨クリ" , "ふたなり"};
        //private string[] mukiText1 = new string[]{ "男に合わせる" , "メイドに合わせる" , "回転させない"};
        //private string[] mukiText2 = new string[]{ "表" , "裏"};
        private string[] chikubiText = new string[]{ "着衣時" , "肌時"};

        private bool vsNormalMode = true; //ボイスセット表示モード

        void WindowCallback3(int id)
        {
            int y = 0;

            MaidState maidState = maidsState[tgID];

            if (GUI.Button(new Rect (595, 0, 25, 20), "x", gsButton)) {
              cfgw.configGuiFlag = false;
            }

            y = 5;
            if (ConfigFlag == 0 || ConfigFlag == 1) {
              if (GUI.Button(new Rect (430, y, 60, 20), lang.RELOAD_SETTING, gsButton)) {
                ConfigFileLoad();
                //MLsit.txt再読み込み
                ItazuraMotionLoad();
                //再初期処理
                initConfig();
              }

              if (GUI.Button(new Rect (505, y, 80, 20), lang.SAVE_SETTING, gsButton)) {
                ConfigFileSave();
              }
            }


            if (ConfigFlag == 0) {
              GUI.Toggle(new Rect (160, y, 120, 20), true, lang.TITLE_SETTING_0, gsButtonB); //選択中
            } else {
              if (GUI.Button(new Rect (160, y, 120, 20), lang.TITLE_SETTING_0, gsButton)) {
                ConfigFlag = 0;
              }
            }
            if (ConfigFlag == 1) {
              GUI.Toggle(new Rect (300, y, 110, 20), true, lang.TITLE_SETTING_1, gsButtonB); //選択中
            } else {
              if (GUI.Button(new Rect (300, y, 110, 20), lang.TITLE_SETTING_1, gsButton)) {
                ConfigFlag = 1;
              }
            }

            switch (ConfigFlag) {
              case 0: WindowCallback3_0(maidState.maid, maidState); break;
              case 1: WindowCallback3_1(maidState.maid, maidState); break;
              //case 2: WindowCallback3_2(maid); break;
              case 3: WindowCallback3_3(); break;
              case 4: WindowCallback3_4(maidState.maid); break;
              case 5: WindowCallback3_5(maidState.maid); break;
              case 6: WindowCallback3_6(maidState.maid, maidState); break;
              #if EmpiresLife
              case 7: WindowCallback3_7(maidState.maid); break;
              #endif
              case 8: WindowCallback3_8(maidState.maid); break;
              case 9: WindowCallback3_9(maidState.maid); break;
              case 10: WindowCallback3_10(maidState.maid, maidState); break; //VR
            }

            GUI.DragWindow();

        }

        //メインメイド操作
        private void WindowCallback3_0(Maid maid, MaidState tgMaidState)
        {
                    int y = 22;
                    //"【脱衣】"
                    GUI.Label(new Rect (5, y, 120, 20), lang.SECTION_UNDRESSING , gsLabel);
                    cfgw.UndressingReaction = GUI.Toggle(new Rect(100, y, 160, 20), cfgw.UndressingReaction, lang.REACT_UNDRESSING, gsToggle);
                    y += 23;

                    if (GUI.Button(new Rect (10, y, 85, 20), lang.DRESS_ALL, gsButton)){
                      dressAll(maid);
                      dCheck = true;
                    }

                    if (GUI.Button(new Rect (10, y+25, 85, 20), lang.UNDRESS_UNDERWARE, gsButton)){
                      if (maid.body0.GetSlotVisible(TBody.SlotID.skirt) || maid.body0.GetSlotVisible(TBody.SlotID.onepiece)) UndressingReaction(tgID, 1);
                      dressUnderware(maid);
                      dCheck = true;
                    }

                    if (GUI.Button(new Rect (10, y+50, 85, 20), lang.UNDRESS_ALL, gsButton)){

                      if (maid.body0.GetSlotVisible(TBody.SlotID.skirt) || maid.body0.GetSlotVisible(TBody.SlotID.onepiece)
                       || maid.body0.GetSlotVisible(TBody.SlotID.mizugi) || maid.body0.GetSlotVisible(TBody.SlotID.panz)) UndressingReaction(tgID, 3);
                      undressAll(maid);
                      dCheck = true;
                    }

                    if (GUI.Button(new Rect (110, y, 80, 20), lang.UNDRESS_TOPS, gsButton)){
                      if (maid.body0.GetSlotVisible(TBody.SlotID.wear)) UndressingReaction(tgID, maid.body0.GetMask(TBody.SlotID.bra) ? 0 : 2);
                      maid.body0.SetMask(TBody.SlotID.wear, !maid.body0.GetMask(TBody.SlotID.wear));
                      dCheck = true;
                    }

                    if (GUI.Button(new Rect (110, y+25, 80, 20), lang.UNDRESS_ONEPIECE, gsButton)){
                      if (maid.body0.GetSlotVisible(TBody.SlotID.onepiece)) UndressingReaction(tgID, 1);
                      maid.body0.SetMask(TBody.SlotID.onepiece, !maid.body0.GetMask(TBody.SlotID.onepiece));
                      dCheck = true;
                    }

                    if (GUI.Button(new Rect (110, y+50, 80, 20), lang.UNDRESS_SKIRT, gsButton)){
                      if (maid.body0.GetSlotVisible(TBody.SlotID.skirt)) UndressingReaction(tgID, 1);
                      maid.body0.SetMask(TBody.SlotID.skirt, !maid.body0.GetMask(TBody.SlotID.skirt));
                      dCheck = true;
                    }

                    if (GUI.Button(new Rect (200, y, 80, 20), lang.UNDRESS_SWIMWARE, gsButton)){
                      if (maid.body0.GetSlotVisible(TBody.SlotID.mizugi)) UndressingReaction(tgID, 3);
                      maid.body0.SetMask(TBody.SlotID.mizugi, !maid.body0.GetMask(TBody.SlotID.mizugi));
                      dCheck = true;
                    }

		                if (GUI.Button(new Rect (200, y+25, 80, 20), lang.UNDRESS_BRA, gsButton)){
                      if (maid.body0.GetSlotVisible(TBody.SlotID.bra)) UndressingReaction(tgID, 2);
                      maid.body0.SetMask(TBody.SlotID.bra, !maid.body0.GetMask(TBody.SlotID.bra));
                      dCheck = true;
		                }

                    if (GUI.Button(new Rect (200, y+50, 80, 20), lang.UNDRESS_SHORTS, gsButton)){
                      if (maid.body0.GetSlotVisible(TBody.SlotID.panz)) UndressingReaction(tgID, 3);
                      maid.body0.SetMask(TBody.SlotID.panz, !maid.body0.GetMask(TBody.SlotID.panz));
                      dCheck = true;
		                }

                    if (GUI.Button(new Rect (295, y, 55, 20), lang.UNDRESS_HEADSET, gsButton)){
                      bool isHeadset = maid.body0.GetMask(TBody.SlotID.headset) || maid.body0.GetMask(TBody.SlotID.accHat);
                      maid.body0.SetMask(TBody.SlotID.headset, !isHeadset);
                      maid.body0.SetMask(TBody.SlotID.accHat, !isHeadset);
                      dCheck = true;
		                }

                    if (GUI.Button(new Rect (360, y, 55, 20), lang.UNDRESS_NECK, gsButton)){
                      bool isKubi = maid.body0.GetMask(TBody.SlotID.accKubi) || maid.body0.GetMask(TBody.SlotID.accKubiwa);
                      maid.body0.SetMask(TBody.SlotID.accKubi, !isKubi);
                      maid.body0.SetMask(TBody.SlotID.accKubiwa, !isKubi);
                      dCheck = true;
		                }

                    if (GUI.Button(new Rect (425, y, 55, 20), lang.UNDRESS_EAR, gsButton)){
                      bool isMimi = maid.body0.GetMask(TBody.SlotID.accMiMiR) || maid.body0.GetMask(TBody.SlotID.accMiMiL);
                      maid.body0.SetMask(TBody.SlotID.accMiMiR, !isMimi);
                      maid.body0.SetMask(TBody.SlotID.accMiMiL, !isMimi);
                      dCheck = true;
		                }

                    if (GUI.Button(new Rect (490, y, 55, 20), lang.UNDRESS_HAT, gsButton)){
                      maid.body0.SetMask(TBody.SlotID.accHat, !maid.body0.GetMask(TBody.SlotID.accHat));
                      dCheck = true;
		                }

                    if (GUI.Button(new Rect (555, y, 55, 20), lang.UNDRESS_GLASSES, gsButton)){
                      bool isMegane = maid.body0.GetMask(TBody.SlotID.megane) || maid.body0.GetMask(TBody.SlotID.accHead);
                      maid.body0.SetMask(TBody.SlotID.megane, !isMegane);
                      maid.body0.SetMask(TBody.SlotID.accHead, !isMegane);
                      dCheck = true;
		                }

                    if (GUI.Button(new Rect (295, y+25, 55, 20), lang.UNDRESS_BACK, gsButton)){
                      maid.body0.SetMask(TBody.SlotID.accSenaka, !maid.body0.GetMask(TBody.SlotID.accSenaka));
                      dCheck = true;
		                }

                    if (GUI.Button(new Rect (360, y+25, 55, 20), lang.UNDRESS_GLOBE, gsButton)){
                      maid.body0.SetMask(TBody.SlotID.glove, !maid.body0.GetMask(TBody.SlotID.glove));
                      dCheck = true;
		                }

                    if (GUI.Button(new Rect (425, y+25, 55, 20), lang.UNDRESS_ARM, gsButton)){
                      maid.body0.SetMask(TBody.SlotID.accUde, !maid.body0.GetMask(TBody.SlotID.accUde));
                      dCheck = true;
		                }

                    if (GUI.Button(new Rect (490, y+25, 55, 20), lang.UNDRESS_XXX, gsButton)){
                      maid.body0.SetMask(TBody.SlotID.accXXX, !maid.body0.GetMask(TBody.SlotID.accXXX));
                      dCheck = true;
		                }

                    if (GUI.Button(new Rect (555, y+25, 55, 20), lang.UNDRESS_UHAIR, gsButton)){
                      maid.body0.SetMask(TBody.SlotID.underhair, !maid.body0.GetMask(TBody.SlotID.underhair));
                      dCheck = true;
		                }

                    if (GUI.Button(new Rect (295, y+50, 55, 20), lang.UNDRESS_SHOES, gsButton)){
                      maid.body0.SetMask(TBody.SlotID.shoes, !maid.body0.GetMask(TBody.SlotID.shoes));
                      dCheck = true;
	            	    }

                    if (GUI.Button(new Rect (360, y+50, 55, 20), lang.UNDRESS_SOCKS, gsButton)){
                      maid.body0.SetMask(TBody.SlotID.stkg, !maid.body0.GetMask(TBody.SlotID.stkg));
                      dCheck = true;
		                }

                    if (GUI.Button(new Rect (425, y+50, 55, 20), lang.UNDRESS_ANKLE, gsButton)){
                      maid.body0.SetMask(TBody.SlotID.accAshi, !maid.body0.GetMask(TBody.SlotID.accAshi));
                      dCheck = true;
	            	    }

                    if (GUI.Button(new Rect (490, y+50, 55, 20), lang.UNDRESS_TAIL, gsButton)){
                      maid.body0.SetMask(TBody.SlotID.accShippo, !maid.body0.GetMask(TBody.SlotID.accShippo));
                      dCheck = true;
	            	    }

                    if (GUI.Button(new Rect (555, y+50, 55, 20), lang.UNDRESS_OTHER, gsButton)){
		                  bool isAccSonota = maid.body0.GetMask(TBody.SlotID.accHana) || maid.body0.GetMask(TBody.SlotID.accNipR)
                                      || maid.body0.GetMask(TBody.SlotID.accNipL) || maid.body0.GetMask(TBody.SlotID.accHeso);
                      maid.body0.SetMask(TBody.SlotID.accHana, !isAccSonota);
                      maid.body0.SetMask(TBody.SlotID.accNipR, !isAccSonota);
                      maid.body0.SetMask(TBody.SlotID.accNipL, !isAccSonota);
                      maid.body0.SetMask(TBody.SlotID.accHeso, !isAccSonota);
                      dCheck = true;
		                }

                    y = 120;
                    if (GUI.Button(new Rect (110, y, 38, 20), lang.UNDRESS_SKIRT_FRNT, gsButton)){
                      if (maid.body0.GetSlotVisible(TBody.SlotID.skirt) && !isPropChanged(maid, "skirt").Contains("めくれ前")
                        || maid.body0.GetSlotVisible(TBody.SlotID.onepiece) && !isPropChanged(maid, "onepiece").Contains("めくれ前")) {
                        UndressingReaction(tgID, 1);
                      }
                      MekureChanged(tgID, "前", true);
                    }

		                if (GUI.Button(new Rect (152, y, 38, 20), lang.UNDRESS_SKIRT_BACK, gsButton)){
                      if (maid.body0.GetSlotVisible(TBody.SlotID.skirt) && !isPropChanged(maid, "skirt").Contains("めくれ後")
                        || maid.body0.GetSlotVisible(TBody.SlotID.onepiece) && !isPropChanged(maid, "onepiece").Contains("めくれ後")) {
                        UndressingReaction(tgID, 1);
                      }
                      MekureChanged(tgID, "後", true);
                    }

                    y = 125;
		                if (GUI.Button(new Rect (205, y, 70, 20), lang.UNDRESS_ZURASHI, gsButton)) {
                      //ずれていない場合は音声再生
                      if (maid.body0.GetSlotVisible(TBody.SlotID.panz) && !isPropChanged(maid, "panz").Contains("ずらし")
                        || maid.body0.GetSlotVisible(TBody.SlotID.mizugi) && !isPropChanged(maid, "mizugi").Contains("ずらし")) {
                        UndressingReaction(tgID, 4);
                      }
                      MekureChanged(tgID, "ずらし", true);
		                }

                    //GUI.Label(new Rect (290, y, 65, 20), "【ぽろり】" , gsLabelR);
		                if (GUI.Button(new Rect (290, y, 70, 20), lang.UNDRESS_PORORI_TOP, gsButton)) {
                      
                      #if COM3D2_5
                      if (maid.IsCrcBody && cfgw.useMekureController) { //2.5ボディでもfalseならmenu置換処理
                        if (maid.mekureController.IsSupportedCostumeType(MaidExtension.MaidCostumeChangeController.CostumeType.Hadake)) {
                          bool flag = maid.mekureController.IsEnabledCostumeType(MaidExtension.MaidCostumeChangeController.CostumeType.Hadake);
                          if (!flag) UndressingReaction(tgID, 5); //ぽろり上
                          maid.mekureController.SetEnabledCostumeType(MaidExtension.MaidCostumeChangeController.CostumeType.Hadake, !flag, null);
                          dCheck = true;
                        }
                        return;
                      }
                      #endif
                      //上のぽろりを実行 ぽろり状態に変わった場合は終了
                      if (PororiTop(maid)) {
                        if (isPorori(maid, "bra")) UndressingReaction(tgID, 5); //ぽろり上
                        else UndressingReaction(tgID, 0); //トップ
                        return;
                      }
                      //ぽろり対応衣装がすべてぽろりしている場合は戻す
                      PororiOff(maid, new string[]{"wear", "onepiece", "mizugi", "bra"},
                        new TBody.SlotID[]{TBody.SlotID.wear, TBody.SlotID.onepiece, TBody.SlotID.mizugi, TBody.SlotID.bra},
                        new MPN[]{MPN.wear, MPN.onepiece, MPN.mizugi, MPN.bra}
                      );
		                }
		                if (GUI.Button(new Rect (370, y, 70, 20), lang.UNDRESS_PORORI_BOTTOM, gsButton)) {
                      //1つなのでautoModeでOn/Off
                      if (PororiChange(maid, true, "panz", TBody.SlotID.panz, MPN.panz)) {
                        UndressingReaction(tgID, 3); //パンツ
                      }
                    }
                    //【拭き】
                    GUI.Label(new Rect (450, y, 55, 20), lang.SECTION_WIPE , gsLabelR);
                    if (GUI.Button(new Rect (510, y, 45, 20), lang.WIPE_FACE, gsButton)) {
                      RemoveSeiekiFace(maid);
                    }
                    if (GUI.Button(new Rect (565, y, 45, 20), lang.WIPE_BODY, gsButton)) {
                      RemoveSeiekiBody(maid);
                    }

                    y = 150;
                    //【吹き】
                    GUI.Label(new Rect (505, y, 80, 20), lang.SECTION_SPURT , gsLabel);
                    if (GUI.Button(new Rect (510, y+25, 45, 20), lang.SPURT_URINE, gsButton)) {
                      float nr = UnityEngine.Random.Range(50f, tgMaidState.nyoVolume);
                      EffectNyo(maid, tgMaidState, nr, true);
                    }
                    if (GUI.Button(new Rect (565, y+25, 45, 20), lang.SPURT_SQUIRT, gsButton)) {
                      tgMaidState.fSio = true;
                      tgMaidState.sioTime = Time.time + 1f; //潮吹き終了時間 1秒後
                      tgMaidState.sioTime2 = 0; //待ち時間なし
                      tgMaidState.sioVolume = 0;  //OrgasmProcessでの潮吹き判定はリセット
                      EffectSio(maid, tgMaidState);
                    }

                  y = 145;
                  //【状態一時変更】
                  GUI.Label(new Rect (5, y-20, 190, 20), lang.SECTION_TEMP_STATUS , gsLabel);
                  GUI.Label(new Rect (10, y, 90, 20), lang.TEMP_KUPA+"："+Math.Floor(tgMaidState.hibuTempValue), gsLabel);
                  float hibuTempValue = GUI.HorizontalSlider(new Rect(10, y+20, 90, 20), tgMaidState.hibuTempValue, 0f, 100f);
                  if (hibuTempValue != tgMaidState.hibuTempValue) {
                    foreach (int maidID in vmId) {
                      MaidState maidState = maidsState[maidID];
                      if (maidID == tgID || maidState.linkID == tgID) {
                        maidState.hibuTempValue = hibuTempValue;
                        //if (!EffectHibuAnime(maidID, maidState.maid, maidState)) {
                          //バイブ中以外は処理されないので直接変更
                        //  try { VertexMorph_FromProcItem(maidState.maid.body0, "kupa", hibuTempValue*0.01f); } catch { /*LogError(ex);*/ }
                        //}
                      }
                    }
                  }
                  GUI.Label(new Rect (110, y, 90, 20), lang.TEMP_ANAL+"："+Math.Floor(tgMaidState.analTempValue), gsLabel);
                  float analTempValue = GUI.HorizontalSlider(new Rect(110, y+20, 90, 20), tgMaidState.analTempValue, 0f, 100f);
                  if (analTempValue != tgMaidState.analTempValue) {
                    foreach (int maidID in vmId) {
                      MaidState maidState = maidsState[maidID];
                      if (maidID == tgID || maidState.linkID == tgID) {
                        maidState.analTempValue = analTempValue;
                        //if (!EffectHibuAnime(maidID, maidState.maid, maidState)) {
                          //バイブ中以外は処理されないので直接変更
                          //try { VertexMorph_FromProcItem(maidState.maid.body0, "analkupa", analTempValue*0.01f); } catch { /*LogError(ex);*/ }
                        //}
                      }
                    }
                  }
                  y += 32;
                  GUI.Label(new Rect (10, y, 90, 20), lang.TEMP_CLITRIS+"："+Math.Floor(tgMaidState.bokkiTempValue), gsLabel);
                  float bokkiTempValue = GUI.HorizontalSlider(new Rect(10, y+20, 90, 20), tgMaidState.bokkiTempValue, 0f, 100f);
                  if (bokkiTempValue != tgMaidState.bokkiTempValue) {
                    foreach (int maidID in vmId) {
                      MaidState maidState = maidsState[maidID];
                      if (maidID == tgID || maidState.linkID == tgID) {
                        maidState.bokkiTempValue = bokkiTempValue;
                        if (maidState.bokkiValue1 == 0) maidState.bokkiValue1++; //0だと反映されないので+1して処理させる
                        EffectBokki(maidState.maid, maidState, 1);
                      }
                    }
                  }
                  GUI.Label(new Rect (110, y, 90, 20), lang.TEMP_SWET+"："+Math.Floor(tgMaidState.aseTempValue), gsLabel);
                  float aseTempValue = GUI.HorizontalSlider(new Rect(110, y+20, 90, 20), tgMaidState.aseTempValue, 0f, 100f);
                  if (aseTempValue != tgMaidState.aseTempValue) {
                    foreach (int maidID in vmId) {
                      MaidState maidState = maidsState[maidID];
                      if (maidID == tgID || maidState.linkID == tgID) {
                        maidState.aseTempValue = aseTempValue;
                        maidState.aseTime = 0; //即時反映させる
                        EffectAse(maidState.maid, maidState);
                      }
                    }
                    if (cfgw.DanceLightweightMode && cfgw.mainGuiFlag != 1) VertexMorph_FixBlendValues(); //シェイプキー反映
                  }
                  y += 34;

                  //コライダー一時無効化
                  GUI.Label(new Rect (5, y, 70, 20), lang.TEMP_COLLIDER, gsLabel);
                  bool toggle = GUI.Toggle(new Rect (75, y, 60, 20), tgMaidState.colliderEnabledHairR, lang.TEMP_COLLIDER_HAIR_R, gsToggle );
                  if (tgMaidState.colliderEnabledHairR != toggle) {
                    setDynamicBoneColliderEnabled(maid, "hairR", toggle);
                    tgMaidState.colliderEnabledHairR = isDynamicBoneColliderEnabled(maid, "hairR"); //コライダーの状態は再チェック
                  }
                  toggle = GUI.Toggle(new Rect (135, y, 60, 20), tgMaidState.colliderEnabledHairT, lang.TEMP_COLLIDER_HAIR_T, gsToggle );
                  if (tgMaidState.colliderEnabledHairT != toggle) {
                    setDynamicBoneColliderEnabled(maid, "hairT", toggle);
                    tgMaidState.colliderEnabledHairT = isDynamicBoneColliderEnabled(maid, "hairT"); //コライダーの状態は再チェック
                  }

                  y = 175;
                  //【地面判定】
                  GUI.Label(new Rect (205, y-25, 120, 20), lang.SECTION_BONE_HEIGHT , gsLabel);
                  try {
                    //if (maid.body0.BoneHitHeightY < -999f) maid.body0.BoneHitHeightY = 0f;
                    if (GUI.Button(new Rect (210, y, 30, 20), "-1", gsButton)) maid.body0.BoneHitHeightY = Math.Max(-2f, maid.body0.BoneHitHeightY-0.01f);
                    if (GUI.Button(new Rect (240, y, 25, 20), "-", gsButton)) maid.body0.BoneHitHeightY = Math.Max(-2f, maid.body0.BoneHitHeightY-0.001f);
                    if (GUI.Button(new Rect (270, y, 25, 20), "+", gsButton)) maid.body0.BoneHitHeightY = Math.Min(2f, maid.body0.BoneHitHeightY+0.001f);
                    if (GUI.Button(new Rect (295, y, 30, 20), "+1", gsButton)) maid.body0.BoneHitHeightY = Math.Min(2f, maid.body0.BoneHitHeightY+0.01f);
                    if (GUI.Button(new Rect (335, y, 30, 20), "0", gsButton)) maid.body0.BoneHitHeightY = 0;
                    if (cfgw.BoneHitHeight.Length > 0) if (GUI.Button(new Rect (370, y, 30, 20), cfgw.BoneHitHeight[0].ToString(), gsButton)) maid.body0.BoneHitHeightY = cfgw.BoneHitHeight[0]*0.01f;
                    if (cfgw.BoneHitHeight.Length > 1) if (GUI.Button(new Rect (405, y, 30, 20), cfgw.BoneHitHeight[1].ToString(), gsButton)) maid.body0.BoneHitHeightY = cfgw.BoneHitHeight[1]*0.01f;
                    if (cfgw.BoneHitHeight.Length > 2) if (GUI.Button(new Rect (440, y, 30, 20), cfgw.BoneHitHeight[2].ToString(), gsButton)) maid.body0.BoneHitHeightY = cfgw.BoneHitHeight[2]*0.01f;
                    if (cfgw.BoneHitHeight.Length > 3) if (GUI.Button(new Rect (475, y, 30, 20), cfgw.BoneHitHeight[3].ToString(), gsButton)) maid.body0.BoneHitHeightY = cfgw.BoneHitHeight[3]*0.01f;
                    y -= 25;
                    maid.body0.BoneHitHeightY = GUI.HorizontalSlider(new Rect(320, y+5, 175, 15), maid.body0.BoneHitHeightY, -2f, 2F);
                    maid.body0.BoneHitHeightY = (float)(Math.Round(maid.body0.BoneHitHeightY * 1000)*0.001);
                    GUI.Label(new Rect (275, y, 40, 20), (maid.body0.BoneHitHeightY * 100).ToString() , gsLabelR);
                  } catch {
                    // NullReferenceException 揉み消し
                  }

                  //一列目
                  y = 230;
                  //【カメラ】
                  GUI.Label(new Rect (5, y, 190, 20), lang.SECTION_CAMERA , gsLabel);
                  if (fpsMan.Visible) {
                    setFpsModeEnabled(GUI.Toggle(new Rect (90, y, 95, 20), fpsModeEnabled, lang.CAMERA_FPS , gsToggle ));
                  } else GUI.Label(new Rect(90, y+2, 95, 20), "☒ "+lang.CAMERA_FPS, gsLabel);
                  y += 20;
                  if (!bVR) {
                    GUI.Label(new Rect (10, y, 90, 20), lang.CAMERA_FOV+"：" + Math.Floor(Camera.main.fieldOfView) , gsLabel);
                    if (!bVR) Camera.main.fieldOfView = GUI.HorizontalSlider(new Rect(90, y+5, 100, 15), Camera.main.fieldOfView, 10.0F, 90.0F);
                    y += 20;
                  }

                  #if DOF
                  bool depthEnabled = GUI.Toggle(new Rect (10, y, 190, 20), cfgw.DepthEnabled, lang.CAMERA_DOF+"  "+lang.CAMERA_DOF_BLUR+": " + cfgw.DepthAperture, gsToggle);
                  if (depthEnabled != cfgw.DepthEnabled) {
                    cfgw.DepthEnabled = depthEnabled;
                    initDepthOfFieldMaid(tgID);
                  }
                  //GUI.Label(new Rect(100, y+2, 95, 20), "強度：" + cfgw.DepthAperture, gsLabelR);
                  y += 25;
                  float depthAperture = GUI.HorizontalSlider(new Rect(10, y, 185, 20), Mathf.Sqrt(cfgw.DepthAperture), 0f, 10f);
                  depthAperture = depthAperture * depthAperture;
                  depthAperture = depthAperture> 50 ? (float)Math.Round(depthAperture) :
                    (depthAperture > 10 ? (float)(Math.Round(depthAperture*2)*0.5) : (float)(Math.Round(depthAperture*10)*0.1));
                  if (cfgw.DepthAperture != depthAperture) {
                    cfgw.DepthAperture = depthAperture;
                    if (depthOfField != null) depthOfField.aperture = cfgw.DepthAperture;
                  }
                  y += 20;
                  #endif

                  //【ボイスセット】
                  GUI.Label(new Rect (5, y, 100, 20), lang.SECTION_VOICESET, gsLabel);
                  vsNormalMode = GUI.Toggle(new Rect (95, y, 60, 20), vsNormalMode, lang.VOICESET_NORMAL , gsToggle );
                  vsNormalMode = !GUI.Toggle(new Rect (155, y, 60, 20), !vsNormalMode, lang.VOICESET_KISS , gsToggle );
                  y += 22;

                  if (vsNormalMode) {
                    if (tgMaidState.editVoiceSetName != "") {
                      if (GUI.Button(new Rect (10, y, 30, 20), lang.VOICESET_CANCEL, gsButton)) {
                        tgMaidState.editVoiceSetName = "";
                        tgMaidState.editVoiceSet = new List<string[]>();
                      }
                      GUI.Label(new Rect (45, y, 160, 20), tgMaidState.editVoiceSetName , gsLabelYB);
                      y += 22;
                    }
                  } else {
                    if (tgMaidState.kissVoiceSetName != "") {
                      if (GUI.Button(new Rect (10, y, 40, 20), lang.VOICESET_CANCEL, gsButton)) {
                        tgMaidState.kissVoiceSetName = "";
                        tgMaidState.kissVoiceSet = null;
                      }
                      GUI.Label(new Rect (55, y, 150, 20), tgMaidState.kissVoiceSetName , gsLabelYB);
                      y += 22;
                    }
                  }

                  int evsCount = 0;
                  foreach (string f in evsFiles) {
                    string FileName = f.Replace("evs_", "");
                    if (FileName.StartsWith("キス")) {
                      if (!vsNormalMode) evsCount++;
                    } else {
                      if (vsNormalMode) evsCount++;
                    }
                  }
                  int h1 = evsCount * 22;
                  //if (tgMaidState.editVoiceSetName != "") h1 += 22;
                  if (h1 < 445 - y) h1 = 445 - y;
                  Rect scrlRect1    = new Rect(10, y, 190, 445 - y);
                  Rect contentRect1 = new Rect(0, 0, 170, h1);
                  vsScrollPos1 = GUI.BeginScrollView(scrlRect1, vsScrollPos1, contentRect1, false, true );

                  y = 0;
                  //通常とキスモードで表示順を切り替え
                  foreach (string f in evsFiles) {
                    string FileName = f.Replace("evs_", "").Replace(".xml", "");
                    if (FileName.StartsWith("キス")) {
                      if (!vsNormalMode) {
                        if (GUI.Button(new Rect (0, y, 170, 20), FileName, tgMaidState.kissVoiceSetName==FileName ? gsButtonYB : gsButton)) {
                          kissVoiceSetLoad(f,tgID);
                        }
                        y += 22;
                      }
                    } else {
                      if (vsNormalMode) {
                        if (GUI.Button(new Rect (0, y, 170, 20), FileName, tgMaidState.editVoiceSetName==FileName ? gsButtonYB : gsButton)) {
                          voiceSetLoad(f,tgID);
                        }
                        y += 22;
                      }
                    }
                  }
                  GUI.EndScrollView();


                  //音声モード切替
                  /*
                  GUI.Label(new Rect (5, 370, 190, 20), "【音声モード切替】" , gsLabel);
                  if (tgMaidState.autoVoiceEnabled) {
                    if (GUI.Button(new Rect (10, 395, 85, 20), "オートモード", gsButton)) {
                      tgMaidState.autoVoiceEnabled = false;
                      tgMaidState.voiceMode = 0;
                    }
                  } else {
                    if (GUI.Button(new Rect (10, 395, 85, 20), ModeSelectList[tgMaidState.voiceMode], gsButton)) {
                      ++tgMaidState.voiceMode;
                      if (tgMaidState.voiceMode > 5) tgMaidState.autoVoiceEnabled = true;
                    }
                  }
                  if (GUI.Button(new Rect (105, 395, 85, 20), ModeSelectList2[0][tgMaidState.voiceMode2], gsButton)) {
                    ++tgMaidState.voiceMode2;
                    if (tgMaidState.voiceMode2 >= ModeSelectList2[0].Length) tgMaidState.voiceMode2 = 0;
                  }
                  */

                  //二列目
                  y = 205;
                  //【興奮値】
                  GUI.Label(new Rect (205, y, 80, 20), lang.SECTION_EXCITE, gsLabel);
                  cfgw.yotogiExciteLink = GUI.Toggle(new Rect (270, y, 110, 20), cfgw.yotogiExciteLink, lang.LINK_EXCITE, gsToggle);
                  y += 22;
                  GUI.Label(new Rect (205, y, 30, 20), ""+maid.status.currentExcite, gsLabelR);
                  int excite = maid.status.currentExcite;
                  if (GUI.Button(new Rect (350, y, 20, 20), "-", gsButton)) excite -= 50;
                  if (GUI.Button(new Rect (375, y, 20, 20), "+", gsButton)) excite += 50;
                  excite = (int)Math.Round(GUI.HorizontalSlider(new Rect(240, y+5, 100, 20), excite, -100, 300)/10)*10;
                  if (excite != maid.status.currentExcite) setExcite(tgID, maid, excite);


                  y = 253;
                  //【Hアイテム装着】
                  GUI.Label(new Rect (205, y, 200, 20), lang.ITEM_EQUIP , gsLabel);

                  if (GUI.Button(new Rect (210, y+20, 80, 20), lang.ITEM_VIBE, gsButton)) {
                    if (maid.GetProp(MPN.accvag).strTempFileName.Contains("accVag_VibePink_I_.menu")) {
                      maid.DelProp(MPN.accvag, true);
                      tgMaidState.itemV = "";
                    } else {
                      maid.SetProp("accvag" , "accVag_VibePink_I_.menu", 0, true, false);
                      maid.body0.SetMask(TBody.SlotID.accVag, true);
                      try { VertexMorph_FromProcItem(maid.body0, "kupa", 0.6f); } catch { /*LogError(ex);*/ }
                      if (tgMaidState.hibuSlider1Value < 60f) tgMaidState.hibuSlider1Value = 60f;
                      if (tgMaidState.hibuSlider2Value < 60f) tgMaidState.hibuSlider2Value = 60f;
                      MekureChanged(tgID, "ずらし", false);
                      ReactionPlay(tgID);
                      tgMaidState.itemV = "accVag_VibePink_I_.menu";
                    }
                    maid.AllProcPropSeqStart();
                  }
                  if (GUI.Button(new Rect (300, y+20, 40, 20), lang.ITEM_HAND, gsButton)) {
                    if (maid.GetProp(MPN.handitem).strTempFileName.Contains("HandItemR_VibePink_I_.menu")) {
                      maid.DelProp(MPN.handitem, true);
                    } else {
                      maid.SetProp("handitem" , "HandItemR_VibePink_I_.menu", 0, true, false);
                      maid.body0.SetMask(TBody.SlotID.HandItemR, true);
                    }
                    maid.AllProcPropSeqStart();
                  }
                  if (GUI.Button(new Rect (350, y+20, 40, 20), lang.ITEM_MAN, gsButton)) {
                    Maid subMan = getSubMan(0);
                    if (subMan.GetProp(MPN.handitem).strTempFileName.Contains("HandItemR_VibePink_I_.menu")) {
                      subMan.DelProp(MPN.handitem, true);
                    } else {
                      subMan.SetProp("handitem" , "HandItemR_VibePink_I_.menu", 0, true, false);
                    }
                    subMan.AllProcPropSeqStart();
                  }

                  if (GUI.Button(new Rect (210, y+45, 80, 20), lang.ITEM_ANAL_VIBE, gsButton)) {
                    if (maid.GetProp(MPN.accanl).strTempFileName.Contains("accAnl_AnalVibe_I_.menu")) {
                      maid.DelProp(MPN.accanl, true);
                      tgMaidState.itemA = "";
                    } else {
                      maid.SetProp("accanl" , "accAnl_AnalVibe_I_.menu", 0, true, false);
                      maid.body0.SetMask(TBody.SlotID.accAnl, true);
                      try { VertexMorph_FromProcItem(maid.body0, "analkupa", 0.3f); } catch { /*LogError(ex);*/ }
                      if (tgMaidState.analSlider1Value < 30f) tgMaidState.analSlider1Value = 30f;
                      if (tgMaidState.analSlider2Value < 30f) tgMaidState.analSlider2Value = 30f;
                      MekureChanged(tgID, "ずらし", false);
                      ReactionPlay(tgID);
                      tgMaidState.itemA = "accAnl_AnalVibe_I_.menu";
                    }
                    maid.AllProcPropSeqStart();
                  }
                  if (GUI.Button(new Rect (300, y+45, 40, 20), lang.ITEM_HAND, gsButton)) {
                    if (maid.GetProp(MPN.handitem).strTempFileName.Contains("HandItemR_AnalVibe_I_.menu")) {
                      maid.DelProp(MPN.handitem, true);
                    } else {
                      maid.SetProp("handitem" , "HandItemR_AnalVibe_I_.menu", 0, true, false);
                      maid.body0.SetMask(TBody.SlotID.HandItemR, true);
                    }
                    maid.AllProcPropSeqStart();
                  }
                  if (GUI.Button(new Rect (350, y+45, 40, 20), lang.ITEM_MAN, gsButton)) {
                    Maid subMan = getSubMan(0);
                    if (subMan.GetProp(MPN.handitem).strTempFileName.Contains("HandItemR_AnalVibe_I_.menu")) {
                      subMan.DelProp(MPN.handitem, true);
                    } else {
                      subMan.SetProp("handitem" , "HandItemR_AnalVibe_I_.menu", 0, true, false);
                    }
                    subMan.AllProcPropSeqStart();
                  }

                  if (GUI.Button(new Rect (210, y+70, 85, 20), lang.ITEM_DOUBLEHEAD_VIBE, gsButton)) {
                    if (maid.GetProp(MPN.handitem).strTempFileName.Contains("HandItemH_SoutouVibe_I_.menu")) {
                      maid.DelProp(MPN.handitem, true);
                    } else {
                      maid.SetProp("handitem" , "HandItemH_SoutouVibe_I_.menu", 0, true, false);
                      maid.body0.SetMask(TBody.SlotID.HandItemR, true);
                      try { VertexMorph_FromProcItem(maid.body0, "kupa", 0.6f); } catch { /*LogError(ex);*/ }
                      if (tgMaidState.hibuSlider1Value < 60f) tgMaidState.hibuSlider1Value = 60f;
                      if (tgMaidState.hibuSlider2Value < 60f) tgMaidState.hibuSlider2Value = 60f;
                      MekureChanged(tgID, "ずらし", false);
                      ReactionPlay(tgID);
                    }
                    maid.AllProcPropSeqStart();
                  }
                  if (GUI.Button(new Rect (305, y+70, 85, 20), lang.ITEM_ELECTRIC_MASSAGER, gsButton)) {
                    Maid subMan = getSubMan(0);
                    if (subMan.GetProp(MPN.handitem).strTempFileName.Contains("HandItemR_Denma_I_.menu")) {
                      subMan.DelProp(MPN.handitem, true);
                    } else {
                      subMan.SetProp("handitem" , "HandItemR_Denma_I_.menu", 0, true, false);
                    }
                    subMan.AllProcPropSeqStart();
                  }

                  if (GUI.Button(new Rect (210, y+95, 85, 20), lang.ITEM_RESTRAINTS_HAND, gsButton)) {
                    if (maid.GetProp(MPN.kousoku_upper).strTempFileName.Contains("KousokuU_TekaseOne_I_.menu")) {
                      maid.DelProp(MPN.kousoku_upper, true);
                    } else {
                      maid.SetProp("kousoku_upper" , "KousokuU_TekaseOne_I_.menu", 0, true, false);
                      maid.body0.SetMask(TBody.SlotID.kousoku_upper, true);
                    }
                    maid.AllProcPropSeqStart();
                  }
                  if (GUI.Button(new Rect (305, y+95, 85, 20), lang.ITEM_RESTRAINTS_FOOT, gsButton)) {
                    if (maid.GetProp(MPN.kousoku_lower).strTempFileName.Contains("KousokuL_AshikaseUp_I_.menu")) {
                      maid.DelProp(MPN.kousoku_lower, true);
                    } else {
                      maid.SetProp("kousoku_lower" , "KousokuL_AshikaseUp_I_.menu", 0, true, false);
                      maid.body0.SetMask(TBody.SlotID.kousoku_lower, true);
                    }
                    maid.AllProcPropSeqStart();
                  }

                  if (GUI.Button(new Rect (210, y+120, 85, 20), lang.ITEM_CRUCIFIXION, gsButton)) {
                    if (maid.GetProp(MPN.kousoku_upper).strTempFileName.Contains("KousokuU_SMRoom_Haritsuke_I_.menu")) {
                      maid.DelProp(MPN.kousoku_upper, true);
                    } else {
                      maid.SetProp("kousoku_upper" , "KousokuU_SMRoom_Haritsuke_I_.menu", 0, true, false);
                      maid.body0.SetMask(TBody.SlotID.kousoku_upper, true);
                    }
                    maid.AllProcPropSeqStart();
                  }

                  if (GUI.Button(new Rect (210, y+145, 85, 20), lang.ITEM_DILDO_STAND, gsButton)) {
                    GameObject prefabFromBg = GameObject.Find( "ディルド＆台" );
                    if (prefabFromBg != null) {
                      GameMain.Instance.BgMgr.DelPrefabFromBg("ディルド＆台");
                    } else {
                      Vector3 zero = maid.transform.position;
                      zero.y = zero.y - 0.0007f * (50 - maid.GetProp(MPN.sintyou).value);
                      Vector3 zero2 = maid.transform.eulerAngles;
                      zero2.x = -90f;
                      GameMain.Instance.BgMgr.AddPrefabToBg("Odogu_DildoBox", "ディルド＆台", null, zero, zero2);
                    }
                  }

                  if (GUI.Button(new Rect (305, y+145, 85, 20), lang.ITEM_WOODEN_HORSE, gsButton)) {

                    GameObject prefabFromBg = GameObject.Find( "三角木馬" );
                    if (prefabFromBg != null) {
                      Console.WriteLine("Odogu_SankakuMokuba有り");
                      GameMain.Instance.BgMgr.DelPrefabFromBg("三角木馬");
                    } else {
                      Console.WriteLine("Odogu_SankakuMokuba無し");
                      Vector3 zero = maid.transform.position;
                      zero.y = zero.y - 0.00185f * (50 - maid.GetProp(MPN.sintyou).value);
                      Vector3 zero2 = maid.transform.eulerAngles;
                      zero2.x = -90f;
                      GameMain.Instance.BgMgr.AddPrefabToBg("Odogu_SankakuMokuba", "三角木馬", null, zero, zero2);
                    }
                  }


                  if (GUI.Button(new Rect (305, y+170, 85, 20), lang.ITEM_REMOVE_ALL, gsButton)) {
                    maid.DelProp(MPN.accvag, true);
                    maid.DelProp(MPN.accanl, true);
                    maid.DelProp(MPN.handitem, true);
                    maid.DelProp(MPN.kousoku_upper, true);
                    maid.DelProp(MPN.kousoku_lower, true);
                    maid.DelProp(MPN.accxxx, true);//自分用
                    maid.AllProcPropSeqStart();

                    Maid subMan = getSubMan(0);
                    subMan.DelProp(MPN.handitem, true);
                    subMan.AllProcPropSeqStart();

                    GameMain.Instance.BgMgr.DelPrefabFromBgAll();
                  }

                  //自分用
                  if (GUI.Button(new Rect (210, y+170, 85, 20), lang.ITEM_FUTANARI, gsButton)) {
                    if (maid.GetProp(MPN.accxxx).strTempFileName == "chinko_nae_m.menu") {
                      maid.DelProp(MPN.accxxx, true);
                    } else {
                      maid.SetProp("accxxx" , "chinko_nae_m.menu", 0, true, false);
                      maid.body0.SetMask(TBody.SlotID.accXXX, true);
                    }
                    maid.AllProcPropSeqStart();
                  }


                  //三列目
                  y = 202;

                  GUI.Label(new Rect (400, y, 60, 20), lang.SECTION_CAM , gsLabel);
                  maid.body0.boEyeToCam = GUI.Toggle(new Rect(450, y, 50, 20), maid.body0.boEyeToCam, lang.EYE_TO_CAM, gsToggle);
                  maid.body0.boHeadToCam = GUI.Toggle(new Rect(500, y, 50, 20), maid.body0.boHeadToCam, lang.HEAD_TO_CAM, gsToggle);
                  tgMaidState.eAutoSelect = GUI.Toggle(new Rect(550, y, 70, 20), tgMaidState.eAutoSelect, lang.AUTO_CAM, gsToggle);
                  y += 22;

                  //【メイド固定】
                  GUI.Label(new Rect (400, y, 190, 20), lang.SECTION_MAID_FOLLOW , gsLabel);
                  y += 18;
                  bool bToggle = GUI.Toggle(new Rect (400, y, 110, 20), maidFollowEnabled, lang.MAID_FOLLOW+"："+cfgw.maidFollowSpeed , gsToggle );
                  if (maidFollowEnabled != bToggle) {
                    maidFollowEnabled = bToggle;
                    followReturnSpeedY = -1f; //縦移動速度は標準に戻す
                    //if (maidFollowEnabled) MaidFollowingCameraStart(tgID); //視点の向きを正面にしてメイド固定
                    if (maidFollowEnabled) adjustCameraDistance(); //距離補正
                    setDanceCameraDisabled(maidFollowEnabled); //ダンスカメラ有効無効切り替え
                  }
                  cfgw.maidFollowSpeed = GUI.HorizontalSlider(new Rect(510, y+5, 100, 15), cfgw.maidFollowSpeed, 0.1f, 3.0f);
                  cfgw.maidFollowSpeed = (float)(Math.Round(cfgw.maidFollowSpeed*10)*0.1);
                  y += 20;

                  aoutAngle = GUI.Toggle(new Rect (400, y, 110, 20), aoutAngle, lang.MAID_FOLLOW_ANGLE+"：" + cfgw.maidFollowAngleSpeed , gsToggle );
                  cfgw.maidFollowAngleSpeed = GUI.HorizontalSlider(new Rect(510, y+5, 100, 15), cfgw.maidFollowAngleSpeed, 0.1f, 3.0f);
                  cfgw.maidFollowAngleSpeed = (float)(Math.Round(cfgw.maidFollowAngleSpeed*10)*0.1);
                  y += 25;

                  if (GUI.Button(new Rect (405, y, 95, 20), lang.MAID_LOOK_AT+" : "+lookList[lookPoint], gsButton)) {
                    lookPoint += 1;
                    if (lookPoint >= lookList.Length) lookPoint = 0;
                  }

                  if (maidFollowEnabled) {
                    //GUI.Label(new Rect (405, y, 100, 20), "▼オート変更" , gsLabel);
                    aoutLook = GUI.Toggle(new Rect (510, y, 100, 20), aoutLook, lang.MAID_LOOK_POINT , gsToggle );
                    y += 20;
                    aoutZoom = GUI.Toggle(new Rect (405, y, 100, 20), aoutZoom, lang.MAID_FOLLOW_ZOOM , gsToggle );
                    aoutTarget = GUI.Toggle(new Rect (510, y, 100, 20), aoutTarget, lang.MAID_FOLLOW_TARGET , gsToggle );
                  }
                  y += 20;

                  //【髪型・衣装の変更】
                  GUI.Label(new Rect (400, y, 200, 20), lang.SECTION_HAIR_WEAR , gsLabel);
                  y += 20;

                  h1 = 25+ cdsFiles.Count * 22 + 47 + 47;
                  scrlRect1    = new Rect(405, y, 215, 445-y);
                  contentRect1 = new Rect(0, 0, 190, Math.Max(120, h1));
                  dsScrollPos = GUI.BeginScrollView(scrlRect1, dsScrollPos, contentRect1, false, true );

                  y = 0;

                  if (GUI.Button(new Rect (5, y, 190, 20), lang.HAIR_WEAR_REVERT, gsButton)) {
                    maid.ResetProp("hairf", false);
                    maid.ResetProp("hairr", false);
                    maid.ResetProp("hairs", false);
                    maid.ResetProp("hairt", false);
                    maid.ResetProp("hairaho", false);
                    maid.ResetProp("acckami", false);
                    maid.ResetProp("acckamisub", false);
                    maid.ResetProp("acchat", false);
                    maid.ResetProp("headset", false);
                    maid.ResetProp("wear", false);
                    maid.ResetProp("skirt", false);
                    maid.ResetProp("onepiece", false);
                    maid.ResetProp("mizugi", false);
                    maid.ResetProp("bra", false);
                    maid.ResetProp("panz", false);
                    maid.ResetProp("stkg", false);
                    maid.ResetProp("shoes", false);
                    maid.ResetProp("megane", false);
                    maid.ResetProp("acchead", false);
                    maid.ResetProp("glove", false);
                    maid.ResetProp("accude", false);
                    maid.ResetProp("acchana", false);
                    maid.ResetProp("accmimi", false);
                    maid.ResetProp("accnip", false);
                    maid.ResetProp("acckubi", false);
                    maid.ResetProp("acckubiwa", false);
                    maid.ResetProp("accheso", false);
                    maid.ResetProp("accashi", false);
                    maid.ResetProp("accsenaka", false);
                    maid.ResetProp("accxxx", false);
                    maid.AllProcPropSeqStart();
                  }
                  y += 25;

                    int btnCount = 0;

                    if (ExSaveData.Contains(maid, "CM3D2.VibeYourMaid.Plugin", "1_hairF")) {
                      if (GUI.Button(new Rect (5, y, 85, 20), lang.HAIR_TYPE+"１", gsButton)){
                        ExLoadHair(maid, "1");
                        Console.WriteLine(lang.HAIR_TYPE+"１ セット完了");
                      }
                      btnCount++;
                      if (btnCount%2 == 0) y += 22;
                    }
                    if (ExSaveData.Contains(maid, "CM3D2.VibeYourMaid.Plugin", "2_hairF")) {
                      if (GUI.Button(new Rect (5+95*(btnCount%2), y, 85, 20), lang.HAIR_TYPE+"２", gsButton)){
                        ExLoadHair(maid, "2");
                        Console.WriteLine(lang.HAIR_TYPE+"２ セット完了");
                      }
                      btnCount++;
                      if (btnCount%2 == 0) y += 22;
                    }
                    if (ExSaveData.Contains(maid, "CM3D2.VibeYourMaid.Plugin", "3_hairF")) {
                      if (GUI.Button(new Rect (5+95*(btnCount%2), y, 85, 20), lang.HAIR_TYPE+"３", gsButton)){
                        ExLoadHair(maid, "3");
                        Console.WriteLine(lang.HAIR_TYPE+"３ セット完了");
                      }
                      btnCount++;
                      if (btnCount%2 == 0) y += 22;
                    }
                    if (ExSaveData.Contains(maid, "CM3D2.VibeYourMaid.Plugin", "4_hairF")) {
                      if (GUI.Button(new Rect (5+95*(btnCount%2), y, 85, 20), lang.HAIR_TYPE+"４", gsButton)){
                        ExLoadHair(maid, "4");
                        Console.WriteLine(lang.HAIR_TYPE+"４ セット完了");
                      }
                      btnCount++;
                      if (btnCount%2 == 0) y += 22;
                    }
                    //奇数だったら改行
                    if (btnCount%2 == 1) y += 22;
                    //ボタンがあれば間をあける
                    if (btnCount > 0) y += 3;

                    btnCount = 0;
                    if (ExSaveData.Contains(maid, "CM3D2.VibeYourMaid.Plugin", "1_acchat")) {
                      if (GUI.Button(new Rect (5, y, 85, 20), lang.WEAR_TYPE+"１", gsButton)){
                        ExLoadWear(maid, "1");
                        Console.WriteLine(lang.WEAR_TYPE+"１ セット完了");
                      }
                      btnCount++;
                      if (btnCount%2 == 0) y += 22;
                    }
                    if (ExSaveData.Contains(maid, "CM3D2.VibeYourMaid.Plugin", "2_acchat")) {
                      if (GUI.Button(new Rect (5+95*(btnCount%2), y, 85, 20), lang.WEAR_TYPE+"２", gsButton)){
                        ExLoadWear(maid, "2");
                        Console.WriteLine(lang.WEAR_TYPE+"２ セット完了");
                      }
                      btnCount++;
                      if (btnCount%2 == 0) y += 22;
                    }
                    if (ExSaveData.Contains(maid, "CM3D2.VibeYourMaid.Plugin", "3_acchat")) {
                      if (GUI.Button(new Rect (5+95*(btnCount%2), y, 85, 20), lang.WEAR_TYPE+"３", gsButton)){
                        ExLoadWear(maid, "3");
                        AllDressVisible(tgID, true);
                        maid.AllProcPropSeqStart();
                        Console.WriteLine(lang.WEAR_TYPE+"３ セット完了");
                      }
                      btnCount++;
                      if (btnCount%2 == 0) y += 22;
                    }
                    if (ExSaveData.Contains(maid, "CM3D2.VibeYourMaid.Plugin", "4_acchat")) {
                      if (GUI.Button(new Rect (5+95*(btnCount%2), y, 85, 20), lang.WEAR_TYPE+"４", gsButton)){
                        ExLoadWear(maid, "4");
                        Console.WriteLine(lang.WEAR_TYPE+"４ セット完了");
                      }
                      btnCount++;
                      if (btnCount%2 == 0) y += 22;
                    }
                    //奇数だったら改行
                    if (btnCount%2 == 1) y += 22;
                    //ボタンがあれば間をあける
                    if (btnCount > 0) y += 3;

                    foreach (string f in cdsFiles) {
                      string FileName = f.Replace("cds_", "").Replace(".xml", "");
                      if (GUI.Button(new Rect (5, y, 190, 20), FileName, gsButton)) {
                        CdsFileLoad(f);
                      }
                      y += 22;
                    }
                    GUI.EndScrollView();
        }

        //各種設定
        private void WindowCallback3_1(Maid tgMaid, MaidState tgMaidState)
        {
            int y = 30;

                  //一列目
                  //【各演出の有無】
                  GUI.Label(new Rect (5, y, 190, 20), lang.SECTION_EFFECT , gsLabel);
                  y += 18;

                  bool toggle = GUI.Toggle(new Rect (5, y, 65, 20), cfgw.ToikiEnabled, lang.EFFECT_SIGH , gsToggle );
                  if (cfgw.ToikiEnabled != toggle) {
                    cfgw.ToikiEnabled = toggle;
                    GameObject obj = tgMaid.GetPrefab("夜伽_吐息");
                    if (obj) obj.SetActive(cfgw.ToikiEnabled);
                  }
                  toggle = GUI.Toggle(new Rect (70, y, 65, 20), cfgw.AiekiEnabled, lang.EFFECT_LOVEJUICE , gsToggle );
                  if (cfgw.AiekiEnabled != toggle) {
                    cfgw.AiekiEnabled = toggle;
                    GameObject obj = tgMaid.GetPrefab("夜伽_愛液1");
                    if (obj) obj.SetActive(cfgw.AiekiEnabled);
                    obj = tgMaid.GetPrefab("夜伽_愛液2");
                    if (obj) obj.SetActive(cfgw.AiekiEnabled);
                    obj = tgMaid.GetPrefab("夜伽_愛液3");
                    if (obj) obj.SetActive(cfgw.AiekiEnabled);
                  }
                  cfgw.aseAnimeEnabled = GUI.Toggle(new Rect (135, y, 60, 20), cfgw.aseAnimeEnabled, lang.EFFECT_SWET , gsToggle );
                  cfgw.HohoEnabled = GUI.Toggle(new Rect (5, y+20, 65, 20), cfgw.HohoEnabled, lang.EFFECT_CHEEKS , gsToggle );
                  cfgw.NamidaEnabled = GUI.Toggle(new Rect (70, y+20, 65, 20), cfgw.NamidaEnabled, lang.EFFECT_TEAR , gsToggle );
                  cfgw.YodareEnabled = GUI.Toggle(new Rect (135, y+20, 65, 20), cfgw.YodareEnabled, lang.EFFECT_DROOLING , gsToggle );
                  cfgw.SioEnabled = GUI.Toggle(new Rect (5, y+40, 95, 20), cfgw.SioEnabled, lang.EFFECT_SQUIRT , gsToggle );
                  cfgw.NyoEnabled = GUI.Toggle(new Rect (100, y+40, 95, 20), cfgw.NyoEnabled, lang.EFFECT_PEELING , gsToggle );
                  cfgw.OrgsmAnimeEnabled = GUI.Toggle(new Rect (5, y+60, 95, 20), cfgw.OrgsmAnimeEnabled, lang.EFFECT_CONVULSIONS , gsToggle );
                  cfgw.AheEnabled = GUI.Toggle(new Rect (100, y+60, 95, 20), cfgw.AheEnabled, lang.EFFECT_EYE_AHE , gsToggle );
                  cfgw.CliAnimeEnabled = GUI.Toggle(new Rect (5, y+80, 190, 20), cfgw.CliAnimeEnabled, lang.EFFECT_CLITRIS_ERECTION , gsToggle );
                  cfgw.uDatsuEnabled = GUI.Toggle(new Rect (5, y+100, 190, 20), cfgw.uDatsuEnabled, lang.EFFECT_UTERINE_PROLAPSE , gsToggle );
                  cfgw.zViceWaitEnabled = GUI.Toggle(new Rect (5, y+120, 190, 20), cfgw.zViceWaitEnabled, lang.EFFECT_VOICE_WAIT_ORGASM , gsToggle );
                  y += 145;

                  //【口元の変更】
                  GUI.Label(new Rect (5, y, 190, 20), lang.SECTION_MOUTH_CHANGE , gsLabel);
                  y += 18;
                  cfgw.MouthNomalEnabled = GUI.Toggle(new Rect (5, y, 90, 20), cfgw.MouthNomalEnabled, lang.MOUTH_NORMAL , gsToggle );
                  cfgw.MouthKissEnabled = GUI.Toggle(new Rect (95, y, 90, 20), cfgw.MouthKissEnabled, lang.MOUTH_KISS , gsToggle );
                  cfgw.MouthZeccyouEnabled = GUI.Toggle(new Rect (5, y+20, 90, 20), cfgw.MouthZeccyouEnabled, lang.MOUTH_ORGASM , gsToggle );
                  cfgw.MouthFeraEnabled = GUI.Toggle(new Rect (95, y+20, 90, 20), cfgw.MouthFeraEnabled, lang.MOUTH_FERA , gsToggle );
                  y += 45;

                  //【カメラの距離判定機能】
                  GUI.Label(new Rect (5, y, 190, 20), lang.SECTION_CAMERA_DISTANCE , gsLabel);
                  y += 18;
                  GUI.Label(new Rect (10, y, 85, 20), lang.CAMERA_DISTANCE+"：" , gsLabel);
                  GUI.Label(new Rect (50, y, 40, 20), ""+Math.Floor(cfgw.camCheckRange * 100) , gsLabelR);
                  cfgw.camCheckRange = GUI.HorizontalSlider(new Rect(95, y+5, 100, 20), cfgw.camCheckRange, 0.0F, 1.0F);
                  cfgw.camCheckEnabled = GUI.Toggle(new Rect (10, y+20, 190, 20), cfgw.camCheckEnabled, lang.CAMERA_KISS_CHANGE , gsToggle );
                  cfgw.camCheckVoiceEnabled = GUI.Toggle(new Rect (10, y+40, 190, 20), cfgw.camCheckVoiceEnabled, lang.CAMERA_KISS_VOICE_LINK , gsToggle );
                  y += 65;

                  //【メイド切替時の設定】
                  GUI.Label(new Rect(5, y, 190, 20), lang.SECTION_SWITCH_MAID, gsLabel);
                  y += 18;
                  //cfgw.TaikiEnabled = GUI.Toggle(new Rect(5, y, 190, 20), cfgw.TaikiEnabled, "余韻状態にする", gsToggle);
                  cfgw.CamChangeEnabled = GUI.Toggle(new Rect(5, y, 105, 20), cfgw.CamChangeEnabled, lang.SWITCH_MAID_CAMERA+"："+(cfgw.cameraChangeDistance==0?"":""+cfgw.cameraChangeDistance), gsToggle);
                  cfgw.cameraChangeDistance = GUI.HorizontalSlider(new Rect(115, y+5, 80, 20), cfgw.cameraChangeDistance, 0.0f, 3.0f);
                  cfgw.cameraChangeDistance = (float)(Math.Round(cfgw.cameraChangeDistance*10)*0.1);
                  cfgw.besideMaidTarget = GUI.Toggle(new Rect(5, y+20, 190, 20), cfgw.besideMaidTarget, lang.SWITCH_MAID_BESIDE, gsToggle);
                  y += 45;

                  /*GUI.Label(new Rect(5, y, 190, 20), "【移動速度】", gsLabel);
                  y += 18;
                  GUI.Label(new Rect (10, y, 95, 20), "メイド固定：" + cfgw.maidFollowSpeed , gsLabel);
                  cfgw.maidFollowSpeed = GUI.HorizontalSlider(new Rect(105, y+5, 90, 15), cfgw.maidFollowSpeed, 0.1f, 3.0f);
                  cfgw.maidFollowSpeed = (float)(Math.Round(cfgw.maidFollowSpeed*10)*0.1);
                  y += 20;
                  GUI.Label(new Rect (10, y, 95, 20), "アングル　：" + cfgw.maidFollowAngleSpeed , gsLabel);
                  cfgw.maidFollowAngleSpeed = GUI.HorizontalSlider(new Rect(105, y+5, 90, 15), cfgw.maidFollowAngleSpeed, 0.1f, 3.0f);
                  cfgw.maidFollowAngleSpeed = (float)(Math.Round(cfgw.maidFollowAngleSpeed*10)*0.1);
                  y += 27;
                  */
                  //【SE】
                  GUI.Label(new Rect (5, y, 40, 20), lang.SECTION_SE , gsLabel);
                  if (GUI.Button(new Rect (50, y, 60, 20), lang.SE_SWITCH, gsButton)) {
                    cfgw.SelectSE += 1;
                    if (cfgw.SelectSE >= SeFileList[0].Length) cfgw.SelectSE = 0;
                  }
                  GUI.Label(new Rect (115, y, 90, 20), SeFileList[0][cfgw.SelectSE] , gsLabel);


                  //二列目
                  y = 30;
                  //【秘部のシェイプアニメを連動】
                  GUI.Label(new Rect (205, y, 190, 20), lang.SECTION_GENITAL_SHAPEANIME , gsLabel);
                  y += 18;
                  cfgw.hibuAnime1Enabled = GUI.Toggle(new Rect (205, y, 190, 20), cfgw.hibuAnime1Enabled, lang.GENTITAL_VIBE_MOVING , gsToggle );
                  GUI.Label(new Rect (210, y+20, 80, 20), lang.GENTITAL_OPEN_KUPA+"：" , gsLabel);
                  GUI.Label(new Rect (250, y+20, 40, 20), ""+Math.Floor(tgMaidState.hibuSlider1Value) , gsLabelR);
                  tgMaidState.hibuSlider1Value = GUI.HorizontalSlider(new Rect(295, y+25, 110, 20), tgMaidState.hibuSlider1Value, 0.0F, 100.0F);
                  GUI.Label(new Rect (210, y+40, 80, 20), lang.GENTITAL_OPEN_ANAL+"：" , gsLabel);
                  GUI.Label(new Rect (250, y+40, 40, 20), ""+Math.Floor(tgMaidState.analSlider1Value) , gsLabelR);
                  tgMaidState.analSlider1Value = GUI.HorizontalSlider(new Rect(295, y+45, 110, 20), tgMaidState.analSlider1Value, 0.0F, 100.0F);
                  y += 60;
                  cfgw.hibuAnime2Enabled = GUI.Toggle(new Rect (205, y, 190, 20), cfgw.hibuAnime2Enabled, lang.GENTITAL_VIBE_STOPPED , gsToggle );
                  GUI.Label(new Rect (210, y+20, 80, 20), lang.GENTITAL_OPEN_KUPA+"：" , gsLabel);
                  GUI.Label(new Rect (250, y+20, 40, 20), ""+Math.Floor(tgMaidState.hibuSlider2Value) , gsLabelR);
                  tgMaidState.hibuSlider2Value = GUI.HorizontalSlider(new Rect(295, y+25, 110, 20), tgMaidState.hibuSlider2Value, 0.0F, 100.0F);
                  GUI.Label(new Rect (210, y+40, 80, 20), lang.GENTITAL_OPEN_ANAL+"：" , gsLabel);
                  GUI.Label(new Rect (250, y+40, 40, 20), ""+Math.Floor(tgMaidState.analSlider2Value) , gsLabelR);
                  tgMaidState.analSlider2Value = GUI.HorizontalSlider(new Rect(295, y+45, 110, 20), tgMaidState.analSlider2Value, 0.0F, 100.0F);
                  y += 62;

                  //【クリ設定】 （※要SAVE）
                  GUI.Label(new Rect (205, y, 210, 20), lang.SECTION_CLITRIS , gsLabel);
                  if (GUI.Button(new Rect (210, y+20, 70, 20), lang.CLITORIS_TYPE, gsButton)) {
                    ++tgMaidState.cliMode;
                    if (tgMaidState.cliMode > 2) tgMaidState.cliMode = 0;
                    ExSaveData.Set(tgMaid, "CM3D2.VibeYourMaid.Plugin", "cliMode", tgMaidState.cliMode.ToString(), true);
                    
                    try { VertexMorph_FromProcItem(tgMaid.body0, "clitoris", 0f); } catch { /*LogError(ex);*/ }
                    try { VertexMorph_FromProcItem(tgMaid.body0, "pussy_clitoris_large", 0f); } catch { /*LogError(ex);*/ }
                    try { VertexMorph_FromProcItem(tgMaid.body0, "pussy_clitoris_penis", 0f); } catch { /*LogError(ex);*/ }
                    if (tgMaidState.bokkiValue1 == 0) tgMaidState.bokkiValue1++; //0だと反映されないので+1して処理させる
                    EffectBokki(tgMaid, tgMaidState, 1);
                  }
                  GUI.Label(new Rect (285, y+20, 100, 20), "： "+cliModeText[tgMaidState.cliMode] , gsLabel);

                  GUI.Label(new Rect (220, y+42, 150, 20), lang.CLITORIS_SCALE+"：" + Math.Round(tgMaidState.cliScale*100.0) +"%" , gsLabel);
                  float cliScale = GUI.HorizontalSlider(new Rect(320, y+47, 75, 20), tgMaidState.cliScale, 0.1f, 1.0f);
                  cliScale = (float)(Math.Round(cliScale*10f)*0.1);
                  if (tgMaidState.cliScale != cliScale) {
                    tgMaidState.cliScale = cliScale;
                    ExSaveData.Set(tgMaid, "CM3D2.VibeYourMaid.Plugin", "cliScale", tgMaidState.cliScale.ToString(), true);
                    if (tgMaidState.bokkiValue1 == 0) tgMaidState.bokkiValue1++; //0だと反映されないので+1して処理させる
                    EffectBokki(tgMaid, tgMaidState, 1);
                  }
                  y += 64;

                  //【胸の衝突判定】
                  GUI.Label(new Rect (205, y, 190, 20), lang.SECTION_BREAST_COLLISION , gsLabel);
                  y += 18;
                  bool enabled = GUI.Toggle(new Rect (205, y, 115, 20), cfgw.muneYoriEnabled, lang.BREAST_UPPERARM_ROTATION , gsToggle );
                  if (enabled != cfgw.muneYoriEnabled) {
                    cfgw.muneYoriEnabled = enabled;
                    foreach (int maidID in vmId) {
                      MaidState maidState = maidsState[maidID];
                      setTBodyTransform(maidState); //Body変更対策
                      initVisibleMaidMune(maidState);
                    }
                  }
                  enabled = GUI.Toggle(new Rect (320, y, 90, 20), cfgw.muneDrawGizmo, lang.BREAST_SHOW_RANGE , gsToggle );
                  if (enabled != cfgw.muneDrawGizmo) {
                    cfgw.muneDrawGizmo = enabled;
                    foreach (int maidID in vmId) {
                      MaidState maidState = maidsState[maidID];
                      setTBodyTransform(maidState); //Body変更対策
                      initVisibleMaidMune(maidState);
                    }
                  }
                  y += 20;
                  enabled = GUI.Toggle(new Rect (205, y, 190, 20), cfgw.muneColliderEnabled, lang.BREAST_COLLIDER , gsToggle );
                  if (enabled != cfgw.muneColliderEnabled) {
                    cfgw.muneColliderEnabled = enabled;
                    //メイドの状態を更新 無効状態の場合はレンダラー等が破棄される
                    foreach (int maidID in vmId) {
                      MaidState maidState = maidsState[maidID];
                      setTBodyTransform(maidState); //Body変更対策
                      initVisibleMaidMune(maidState);
                    }
                  }
                  y += 20;
                  if (!cfgw.muneColliderEnabled) {
                    GUI.Label(new Rect (220, y+2, 80, 20), "☒ "+lang.BREAST_FOREARM_COLLIDER, gsLabel);
                    GUI.Label(new Rect (300, y+2, 80, 20), "☒ "+lang.BREAST_PENIS_COLLIDER, gsLabel);
                    y += 20;
                    GUI.Label(new Rect (220, y+2, 80, 20), "☒ "+lang.BREAST_CAMERA_COLLIDER, gsLabel);
                    GUI.Label(new Rect (300, y+2, 80, 20), "☒ "+lang.BREAST_VRHAND_COLLIDER, gsLabel);
                  } else {
                    enabled = GUI.Toggle(new Rect (220, y, 80, 20), cfgw.muneHitForearmEnabled, lang.BREAST_FOREARM_COLLIDER, gsToggle);
                    if (enabled != cfgw.muneHitForearmEnabled) {
                      cfgw.muneHitForearmEnabled = enabled;
                      foreach (MaidState maidState in maidsState) {
                        muneCollider.setForearmEnabled(maidState.muneColliderInfo, cfgw.muneHitForearmEnabled);
                      }
                    }
                    enabled = GUI.Toggle(new Rect (300, y, 80, 20), cfgw.muneHitChinkoEnabled, lang.BREAST_PENIS_COLLIDER, gsToggle);
                    if (enabled != cfgw.muneHitChinkoEnabled) {
                      cfgw.muneHitChinkoEnabled = enabled;
                      muneCollider.setChinkoColliderEnabledAll(enabled);
                      chinkoCheckTime = enabled ? 0 : float.PositiveInfinity; //無効ならチェックさせない
                    }
                    y += 20;
                    enabled = GUI.Toggle(new Rect (220, y, 80, 20), cfgw.camColliderEnabled, lang.BREAST_CAMERA_COLLIDER, gsToggle);
                    if (enabled != cfgw.camColliderEnabled) {
                      cfgw.camColliderEnabled = enabled;
                      muneCollider.setCamColliderEnabled(cfgw.camColliderEnabled);
                    }
                    enabled = GUI.Toggle(new Rect (300, y, 80, 20), cfgw.muneTouchColliderEnabled, lang.BREAST_VRHAND_COLLIDER, gsToggle);
                    if (enabled != cfgw.muneTouchColliderEnabled) {
                      cfgw.muneTouchColliderEnabled = enabled;
                      osawari.setTouchColliderEnabled(cfgw.muneTouchColliderEnabled);
                    }
                  }
                  y += 22;

                  //【おさわり設定】
                  GUI.Label(new Rect(205, y, 190, 20), lang.SECTION_TOUCH, gsLabel);
                  y += 18;
                  cfgw.osawariEnabled = GUI.Toggle(new Rect(205, y, 100, 20), cfgw.osawariEnabled, lang.TOUCH_ENABLED, gsToggle);
                  cfgw.osawariAlways = GUI.Toggle(new Rect(310, y, 100, 20), cfgw.osawariAlways, lang.TOUCH_ALWAYS, gsToggle);
                  y += 22;
                  GUI.Label(new Rect(210, y, 90, 20), lang.TOUCH_MOVE_RATE+"：" + cfgw.osawariMoveRate, gsLabel);
                  cfgw.osawariMoveRate = GUI.HorizontalSlider(new Rect(295, y+5, 100, 20), cfgw.osawariMoveRate, 0.1f, 5.0f);
                  cfgw.osawariMoveRate = (float)(Math.Round(cfgw.osawariMoveRate*10)*0.1);
                  y += 20;
                  GUI.Label(new Rect (210, y, 90, 20), lang.TOUCH_SENSITIVE+"：" + cfgw.osawariSensitive, gsLabel);
                  cfgw.osawariSensitive = GUI.HorizontalSlider(new Rect(295, y+5, 100, 20), cfgw.osawariSensitive, 0.1f, 5.0f);
                  cfgw.osawariSensitive = (float)(Math.Round(cfgw.osawariSensitive*10)*0.1);
                  y += 22;
                  if (GUI.Button(new Rect (210, y, 20, 20), "-", gsButton)) { cfgw.osawariGamanLevel = Math.Max(0, cfgw.osawariGamanLevel-1); }
                  if (GUI.Button(new Rect (232, y, 20, 20), "+", gsButton)) { cfgw.osawariGamanLevel = Math.Min(3, cfgw.osawariGamanLevel+1); }
                  GUI.Label(new Rect (260, y, 160, 20), lang.TOUCH_REGIST_LEVEL+"：" + cfgw.osawariGamanLevel, gsLabel);
                  //y += 25;


                  //三列目
                  y = 30;
                  GUI.Label(new Rect (410, y, 150, 20), lang.SETTING_BUTTONS , gsLabel);
                  y += 20;

                  if (GUI.Button(new Rect (420, y, 190, 20), lang.BTN_SETTING_VR, gsButton)) { ConfigFlag = 10; }
                  y += 30;

                  /*if (GUI.Button(new Rect (420, y, 190, 20), "基本ボイスセット", gsButton)) { ConfigFlag = 2; }
                  y += 30; */

                  if (GUI.Button(new Rect (420, y, 190, 20), lang.BTN_SETTING_VOICESET, gsButton)) { ConfigFlag = 3; }
                  y += 25;
                  GUI.Label(new Rect (420, y, 95, 20), lang.VOICESET_INTERVAL+": " + cfgw.voiceSetInterval , gsLabel);
                  cfgw.voiceSetInterval = GUI.HorizontalSlider(new Rect(505, y+5, 100, 15), cfgw.voiceSetInterval, 0f, 30f);
                  cfgw.voiceSetInterval = (float)(Math.Round(cfgw.voiceSetInterval*2)*0.5);
                  y += 30;

                  if (GUI.Button(new Rect (420, y, 190, 20), lang.BTN_SETTING_RANDOM_MOTION, gsButton)) { ConfigFlag = 4; }
                  y += 25;

                  if (GUI.Button(new Rect (420, y, 190, 20), lang.BTN_SETTING_MOTION_ADJUST, gsButton)) { ConfigFlag = 6; }
                  y += 22;
                  cfgw.majEnabled = GUI.Toggle(new Rect (425, y, 190, 20), cfgw.majEnabled, lang.MOTION_ADJUST_ENABLED , gsToggle );
                  cfgw.majItemClear = GUI.Toggle(new Rect (430, y+20, 190, 20), cfgw.majItemClear, lang.MOTION_ADJUST_ITEM_CLEAR , gsToggle );
                  cfgw.majKupaEnabled = GUI.Toggle(new Rect (430, y+40, 190, 20), cfgw.majKupaEnabled, lang.MOTION_ADJUST_KUPA_ENABLED , gsToggle );
                  y += 70;

                  if (GUI.Button(new Rect (420, y, 190, 20), lang.BTN_SETTING_HAIR, gsButton)) { ConfigFlag = 5; }
                  y += 25;

                  if (GUI.Button(new Rect (420, y, 190, 20), lang.BTN_SETTING_NIPPLES, gsButton)) { ConfigFlag = 9; }
                  y += 30;

                  /*
                  if (GUI.Button(new Rect (420, y, 190, 20), "エンパイアズライフ設定", gsButton)) {
                    LifeSceneLoad();
                    ConfigFlag = 7;
                  }
                  y += 25;*/

                  y = 375;
                  if (GUI.Button(new Rect (420, y, 190, 20), lang.BTN_SETTING_STATUS, gsButton)) { ConfigFlag = 8; }
                  y += 30;

                  /*if (vSceneLevel == 3) {
                    if (GUI.Button(new Rect (420, y, 150, 20), "UI表示切り替え", gsButton)) {
                      gameObject_ui.SetActive(!gameObject_ui.activeSelf);
                    }
                  }
                  y += 25;*/

                  GUI.Label(new Rect (410, y, 190, 20), lang.SHORTCUT_KEY_ENABLED , gsLabel);
                  cfgw.andKeyEnabled[0] = GUI.Toggle(new Rect (410, y+20, 55, 20), cfgw.andKeyEnabled[0], " Ctrl" , gsToggle );
                  if (cfgw.andKeyEnabled[0]) cfgw.andKeyEnabled = new bool[]{true , false , false};
                  cfgw.andKeyEnabled[1] = GUI.Toggle(new Rect (470, y+20, 55, 20), cfgw.andKeyEnabled[1], " Alt" , gsToggle );
                  if (cfgw.andKeyEnabled[1]) cfgw.andKeyEnabled = new bool[]{false , true , false};
                  cfgw.andKeyEnabled[2] = GUI.Toggle(new Rect (530, y+20, 70, 20), cfgw.andKeyEnabled[2], " Shift" , gsToggle );
                  if (cfgw.andKeyEnabled[2]) cfgw.andKeyEnabled = new bool[]{false , false , true};

                  /*開発用
                  if (GUI.Button(new Rect (460, 380, 150, 20), "性格チェック", gsButton)) {
                    Console.WriteLine(stockMaids[tgID].personal);
                  }

                  if (GUI.Button(new Rect (460, 405, 150, 20), "MAJ 一括初期設定", gsButton)) {
                    for (int i = 0; i < maj.motionName.Count; i++) {
                      if (!maj.giveSexual[i][9]) {
                        maj.giveSexual[i] = GiveSexualSet(maj.motionName[i]);
                      }
                    }
                  }
                  */

        }

            /*
        //ボイスセット編集画面
        private void WindowCallback3_2(Maid maid) {
            int x = 0;
            int y = 0;

              x = 0;
              y = 0;
              scKeyOff = GUI.Toggle(new Rect(420, 5, 140, 20), scKeyOff, "ショートカット無効", gsToggle);

              x = 5;
              y = 40;
              GUI.Label(new Rect (x, y, 400, 20), "基本ボイス編集画面　現在準備中" , gsLabel3);


              //性格選択メニュー
              for (int i = 0; i < personalList[0].Length; i++) {
                if (fVoiceSet2[0] == i) {
                  GUI.Label(new Rect (x, y, 60, 20), personalList[0][i] , gsLabel3);
                } else {
                  if (GUI.Button(new Rect (x, y, 60, 20), personalList[0][i], gsButton)) {
                    fVoiceSet2[0] = i;
                  }
                }
                x += 65;
                if (x + 60 > 620) {
                  x = 5;
                  y += 25;
                }

              }

              //音声種類選択
              x = 10;
              y += 35;
              for (int i = 0; i < bvsText1.Length; i++) {
                if (fVoiceSet2[1] == i) {
                  GUI.Label(new Rect (x, y, 60, 20), bvsText1[i] , gsLabel3);
                } else {
                  if (GUI.Button(new Rect (x, y, 60, 20), bvsText1[i], gsButton)) {
                    fVoiceSet2[1] = i;
                  }
                }
              }

              x = 220;
              y -= 180;
              int h2 = VSX.saveVoiceSet.Count * 65 + 30;
              if (h2 < 445 - y) h2 = 445 - y;

              Rect scrlRect2    = new Rect(x, y, 400, 445 - y);
              Rect contentRect2 = new Rect(0, 0, 380, h2);
              vsScrollPos2 = GUI.BeginScrollView( scrlRect2, vsScrollPos2, contentRect2, false, true );

              y = 0;
              int iv;
              var _vf = new List<List<string>>();

              if (fVoiceSet2[1] != 6) {
                _vf = new List<List<string>>();
                if (fVoiceSet2[1] == 0) _vf.AddRange(bvs[i].sLoopVoice20Vibe);
                if (fVoiceSet2[1] == 1) _vf.AddRange(bvs[i].sLoopVoice20Fera);
                if (fVoiceSet2[1] == 2) _vf.AddRange(bvs[i].sLoopVoice30Vibe);
                if (fVoiceSet2[1] == 3) _vf.AddRange(bvs[i].sLoopVoice30Fera);
                if (fVoiceSet2[1] == 4) _vf.AddRange(bvs[i].sOrgasmVoice30Vibe);
                if (fVoiceSet2[1] == 5) _vf.AddRange(bvs[i].sOrgasmVoice30Fera);


                for (int i2 = 0; i2 < 5; i2++) {
                  for (int i3 = 0; i3 < _vf.Count; i3++) {
                    if (!GameUty.FileSystem.IsExistentFile(_vf[i3]) && !GameUty.FileSystemOld.IsExistentFile(_vf[i3]) && _vf[i3] != "" && _vf[i3] != ".ogg") {
                      Console.WriteLine("音声ファイルが存在しないため除外：" + _vf[i3]);
                      _vf.RemoveAt(i3);
                      i3--;
                    }
                  }
                  bvs[i].sLoopVoice20Vibe[i2] = _vf.ToArray();
                }
              }

              for (int r = 0; r < 5; r++) {
                for (int i = 0; i < bvs[fVoiceSet2[0]].sLoopVoice20Vibe[i].Length; i++) {

                  GUI.Label(new Rect (0, 0 + y, 30, 20), "音声" , gsLabel);
                  VSX.saveVoiceSet[i][0] = GUI.TextField(new Rect(30, 0 + y, 110, 20), VSX.saveVoiceSet[i][0]);

                  if (GUI.Button(new Rect (220, 25 + y, 80, 20), "テスト再生", gsButton)) {
                    if (!Regex.IsMatch(VSX.saveVoiceSet[i][0],@"\.[a-zA-Z][a-zA-Z]")) VSX.saveVoiceSet[i][0] = VSX.saveVoiceSet[i][0] + ".ogg";
                    stockMaids[tgID].mem.AudioMan.LoadPlay(VSX.saveVoiceSet[i][0], 0f, false, false);
                  }

                  if (GUI.Button(new Rect (310, 25 + y, 60, 20), "削除", gsButton)) {
                    VSX.saveVoiceSet.RemoveAt(i);
                  }

                  GUI.Label(new Rect (5, 45 + y, 370, 20), "―――――――――――――――――――――――――――――", gsLabel2);

                  y += 65;
                }
              }

              if (GUI.Button(new Rect (315, 0 + y, 60, 20), "追加", gsButton)) {
                string[] set = new string[]{ "" , fVoiceSet[0].ToString() , "0" , "3" , "0" , "3" , fVoiceSet[3].ToString() , fVoiceSet[4].ToString() };
                VSX.saveVoiceSet.Add(set);
              }

              GUI.EndScrollView();
          }
            */

        //オリジナルボイスセット
        private void WindowCallback3_3() {
            int x = 0;
            int y = 0;

              x = 0;
              y = 0;
              scKeyOff = GUI.Toggle(new Rect(420, 2, 140, 20), scKeyOff, "ショートカット無効", gsToggle);

              y += 40;
              GUI.Label(new Rect (5, y, 90, 20), "ボイスセット名" , gsLabel);
              vs_Overwrite = GUI.Toggle(new Rect(105, y, 70, 20), vs_Overwrite, "上書／ｸﾘｱ", gsToggle);

              y += 20;
              VSX.saveVoiceSetName = GUI.TextField(new Rect(5, y, 170, 20), VSX.saveVoiceSetName);

              y += 25;

              if (GUI.Button(new Rect (5, y, 40, 20), "振分", gsButton)) {
                for (int i = 0; i < VSX.saveVoiceSet.Count; i++) {
                  if (VSX.saveVoiceSet[i][0] == "")VSX.saveVoiceSet.RemoveAt(i);
                  if (Regex.IsMatch(VSX.saveVoiceSet[i][0], "^s0_", RegexOptions.IgnoreCase)) VSX.saveVoiceSet[i][1] = "0";
                  if (Regex.IsMatch(VSX.saveVoiceSet[i][0], "^s1_", RegexOptions.IgnoreCase)) VSX.saveVoiceSet[i][1] = "1";
                  if (Regex.IsMatch(VSX.saveVoiceSet[i][0], "^s2_", RegexOptions.IgnoreCase)) VSX.saveVoiceSet[i][1] = "2";
                  if (Regex.IsMatch(VSX.saveVoiceSet[i][0], "^s3_", RegexOptions.IgnoreCase)) VSX.saveVoiceSet[i][1] = "3";
                  if (Regex.IsMatch(VSX.saveVoiceSet[i][0], "^s4_", RegexOptions.IgnoreCase)) VSX.saveVoiceSet[i][1] = "4";
                  if (Regex.IsMatch(VSX.saveVoiceSet[i][0], "^s5_", RegexOptions.IgnoreCase)) VSX.saveVoiceSet[i][1] = "5";
                  if (Regex.IsMatch(VSX.saveVoiceSet[i][0], "^s6_", RegexOptions.IgnoreCase)) VSX.saveVoiceSet[i][1] = "6";
                  if (Regex.IsMatch(VSX.saveVoiceSet[i][0], "^h0_", RegexOptions.IgnoreCase)) VSX.saveVoiceSet[i][1] = "7";
                  if (Regex.IsMatch(VSX.saveVoiceSet[i][0], "^h1_", RegexOptions.IgnoreCase)) VSX.saveVoiceSet[i][1] = "8";
                  if (Regex.IsMatch(VSX.saveVoiceSet[i][0], "^h2_", RegexOptions.IgnoreCase)) VSX.saveVoiceSet[i][1] = "9";
                  if (Regex.IsMatch(VSX.saveVoiceSet[i][0], "^h3_", RegexOptions.IgnoreCase)) VSX.saveVoiceSet[i][1] = "10";
                  if (Regex.IsMatch(VSX.saveVoiceSet[i][0], "^h4_", RegexOptions.IgnoreCase)) VSX.saveVoiceSet[i][1] = "11";
                  if (Regex.IsMatch(VSX.saveVoiceSet[i][0], "^h5_", RegexOptions.IgnoreCase)) VSX.saveVoiceSet[i][1] = "12";
                  if (Regex.IsMatch(VSX.saveVoiceSet[i][0], "^h6_", RegexOptions.IgnoreCase)) VSX.saveVoiceSet[i][1] = "13";
                  if (Regex.IsMatch(VSX.saveVoiceSet[i][0], "^h7_", RegexOptions.IgnoreCase)) VSX.saveVoiceSet[i][1] = "14";
                  if (Regex.IsMatch(VSX.saveVoiceSet[i][0], "^h7_", RegexOptions.IgnoreCase)) VSX.saveVoiceSet[i][1] = "15";
                  if (Regex.IsMatch(VSX.saveVoiceSet[i][0], "^h8_", RegexOptions.IgnoreCase)) VSX.saveVoiceSet[i][1] = "16";
                  if (Regex.IsMatch(VSX.saveVoiceSet[i][0], "^h9_", RegexOptions.IgnoreCase)) VSX.saveVoiceSet[i][1] = "17";
                  if (Regex.IsMatch(VSX.saveVoiceSet[i][0], "^h10_", RegexOptions.IgnoreCase)) VSX.saveVoiceSet[i][1] = "18";
                  if (Regex.IsMatch(VSX.saveVoiceSet[i][0], "^h11_", RegexOptions.IgnoreCase)) VSX.saveVoiceSet[i][1] = "19";
                  if (Regex.IsMatch(VSX.saveVoiceSet[i][0], "^v1_", RegexOptions.IgnoreCase)) VSX.saveVoiceSet[i][1] = "20"; //きさく
                  if (Regex.IsMatch(VSX.saveVoiceSet[i][0], "^v0_", RegexOptions.IgnoreCase)) VSX.saveVoiceSet[i][1] = "21"; //淑女
                }
              }

              if (GUI.Button(new Rect (55, y, 55, 20), "クリア", gsButton)) {
                if (vs_Overwrite) {
                  VSX.saveVoiceSet = new List<string[]>{
                    new string[] { "" , "0" , "0" , "3" , "0" , "3" , "0" , "0" }
                  };
                  VSX.saveVoiceSetName = "";
                  maidsState[tgID].editVoiceSetName = "";
                  maidsState[tgID].editVoiceSet = new List<string[]>();
                  vs_Overwrite = false;
                } else {
                  vsErrer = 3;
                }
              }
              //XMLファイルに保存する
              if (GUI.Button(new Rect (120, y, 55, 20), "保存", gsButton)) {
                voiceSetSave();
                XmlFilesCheck();
              }

              y += 30;
              if (vsErrer != 0) {
                if (GUI.Button(new Rect (5, y, 20, 20), "x", gsButton)) {
                  vsErrer = 0;
                }
                GUI.Label(new Rect (30, y, 170, 60), vsErrerText[vsErrer], gsLabelErr);
                y += 45;
              } else {


                //フィルタ機能
                GUI.Label(new Rect (5, y, 145, 20), "【フィルタリング機能】" , gsLabel);

                y += 20;
                if (GUI.Button(new Rect (5, y, 70, 20), personalList[0][fVoiceSet[0]], gsButton)) {
                  ++fVoiceSet[0];
                  if (fVoiceSet[0] >= personalList[0].Length) fVoiceSet[0] = 0;
                }

                if (GUI.Button(new Rect (80, y, 55, 20), vsState[fVoiceSet[3]], gsButton)) {
                  ++fVoiceSet[3];
                  if (fVoiceSet[3] >= vsState.Length) fVoiceSet[3] = 0;
                }

                if (GUI.Button(new Rect (140, y, 55, 20), vsCondition[fVoiceSet[4]], gsButton)) {
                  ++fVoiceSet[4];
                  if (fVoiceSet[4] >= vsCondition.Length) fVoiceSet[4] = 0;
                }


                y += 25;
                GUI.Label(new Rect (5, y, 30, 20), "興奮", gsLabel);
                if (GUI.Button(new Rect (35, y, 20, 20), vsLevel[fVoiceSet[1]], gsButton)) {
                  ++fVoiceSet[1];
                  if (fVoiceSet[1] > 4) fVoiceSet[1] = 0;
                }

                GUI.Label(new Rect (65, y, 30, 20), "絶頂", gsLabel);
                if (GUI.Button(new Rect (95, y, 20, 20), vsLevel[fVoiceSet[2]], gsButton)) {
                  ++fVoiceSet[2];
                  if (fVoiceSet[2] > 4) fVoiceSet[2] = 0;
                }

                if (GUI.Button(new Rect (125, y, 70, 20), "リセット", gsButton)) {
                  fVoiceSet = new int[]{ 15, 4, 4, 4, 5 };
                }
              }



              //ボイスセット一覧
              y += 35;
              GUI.Label(new Rect (5, y, 145, 20), "【ボイスセット読み込み】" , gsLabel);

              y += 20;
              int h1 = evsFiles.Count * 22;
              if (h1 < 445 - y) h1 = 445 - y;
              Rect scrlRect1    = new Rect(5, y, 200, 445 - y);
              Rect contentRect1 = new Rect(0, 0, 175, h1);
              vsScrollPos1 = GUI.BeginScrollView(scrlRect1, vsScrollPos1, contentRect1, false, true );

              y = 0;
              foreach (string f in evsFiles) {
                string FileName = f.Replace("evs_", "").Replace(".xml", "");
                if (GUI.Button(new Rect (0, y, 175, 20), FileName, gsButton)) {
                  voiceSetLoad(f,tgID);
                }
                y += 22;
              }
              GUI.EndScrollView();


              //ボイスセット編集画面
              x = 205;
              y = 40;

              //性格選択メニュー
              for (int i = 0; i < personalList[0].Length; i++) {
                if (GUI.Button(new Rect (x, y, 60, 20), personalList[0][i], gsButton)) {
                  fVoiceSet[0] = i;
                }
                x += 65;
                if (x + 60 > 620) {
                  x = 205;
                  y += 25;
                }
              }

              x = 220;
              y += 35;
              int h2 = VSX.saveVoiceSet.Count * 65 + 30;
              if (h2 < 445 - y) h2 = 445 - y;

              Rect scrlRect2    = new Rect(x, y, 400, 445 - y);
              Rect contentRect2 = new Rect(0, 0, 380, h2);
              vsScrollPos2 = GUI.BeginScrollView( scrlRect2, vsScrollPos2, contentRect2, false, true );

              y = 0;
              int iv;
              for (int i = 0; i < VSX.saveVoiceSet.Count; i++) {

                if ((fVoiceSet[0] == intCnv(VSX.saveVoiceSet[i][1]) || fVoiceSet[0] == personalList[0].Length - 1 || intCnv(VSX.saveVoiceSet[i][1]) == personalList[0].Length - 1)
                   && (intCnv(VSX.saveVoiceSet[i][2]) <= fVoiceSet[1] && fVoiceSet[1] <= intCnv(VSX.saveVoiceSet[i][3]) || fVoiceSet[1] == 4 )
                   && (intCnv(VSX.saveVoiceSet[i][4]) <= fVoiceSet[2] && fVoiceSet[2] <= intCnv(VSX.saveVoiceSet[i][5]) || fVoiceSet[2] == 4 )
                   && (fVoiceSet[3] == intCnv(VSX.saveVoiceSet[i][6]) || fVoiceSet[3] == 4 || intCnv(VSX.saveVoiceSet[i][6]) == 4)
                   && (fVoiceSet[4] == intCnv(VSX.saveVoiceSet[i][7]) || fVoiceSet[4] == 5 || intCnv(VSX.saveVoiceSet[i][7]) == 5) )
                {

                  GUI.Label(new Rect (0, y, 30, 20), "音声" , gsLabel);
                  VSX.saveVoiceSet[i][0] = GUI.TextField(new Rect(30, 0 + y, 110, 20), VSX.saveVoiceSet[i][0]);

                  //開始秒
                  GUI.Label(new Rect (145, y, 30, 20), "開始" , gsLabel);
                  String startStr = GUI.TextField(new Rect(175, 0 + y, 30, 20), VSX.saveVoiceSet[i].Length <= 8 ? "0.0" : VSX.saveVoiceSet[i][8]+(VSX.saveVoiceSet[i][8].IndexOf('.')>=0?"":".0"));
                  float start = 0;
                  if (float.TryParse(startStr, out start)) {
                    string[] arr = VSX.saveVoiceSet[i];
                    if (arr.Length <= 8) Array.Resize(ref arr, 9);
                    arr[8] = ""+start;
                    VSX.saveVoiceSet[i] = arr;
                  }

                  if (GUI.Button(new Rect (210, y, 60, 20), "▶ 再生", gsButton)) {
                    Maid maid = stockMaids[tgID].mem;
                    if (!Regex.IsMatch(VSX.saveVoiceSet[i][0],@"\.[a-zA-Z][a-zA-Z]")) VSX.saveVoiceSet[i][0] = VSX.saveVoiceSet[i][0] + ".ogg";
                    maid.AudioMan.audiosource.time = 0; //先に0に戻す
                    maid.AudioMan.LoadPlay(VSX.saveVoiceSet[i][0], 0f, false, false);
                    //VoicePlay再生時と同じ状態にする
                    if (maid.AudioMan.FileName == VSX.saveVoiceSet[i][0]) {
                      maidsState[tgID].vsFlag = 2; //再生中フラグON
                      maidsState[tgID].playedVoiceName = VSX.saveVoiceSet[i][0];
                      maid.AudioMan.audiosource.time = Math.Max(0, start); //開始秒設定
                    }
                    else maidsState[tgID].vsFlag = 0; //再生フラグOFF
                  }

                  //性格選択
                  iv = intCnv(VSX.saveVoiceSet[i][1]);
                  GUI.Label(new Rect (275, y, 105, 20), personalList[0][iv] , gsLabel);

                  y += 25;

                  //興奮度指定
                  GUI.Label(new Rect (0, y, 30, 20), "興奮", gsLabel);
                  iv = intCnv(VSX.saveVoiceSet[i][2]);
                  if (GUI.Button(new Rect (30, y, 20, 20), VSX.saveVoiceSet[i][2], gsButton)) {
                    ++iv;
                    if (iv >= 4) iv = 0;
                    VSX.saveVoiceSet[i][2] = iv.ToString();
                  }

                  GUI.Label(new Rect (52, y, 15, 20), "～", gsLabel);

                  iv = intCnv(VSX.saveVoiceSet[i][3]);
                  if (GUI.Button(new Rect (65, y, 20, 20), VSX.saveVoiceSet[i][3], gsButton)) {
                    ++iv;
                    if (iv >= 4) iv = 0;
                    VSX.saveVoiceSet[i][3] = iv.ToString();
                  }

                  if (intCnv(VSX.saveVoiceSet[i][2]) > intCnv(VSX.saveVoiceSet[i][3])) VSX.saveVoiceSet[i][3] = VSX.saveVoiceSet[i][2];

                  //絶頂度指定
                  GUI.Label(new Rect (95, y, 30, 20), "絶頂", gsLabel);
                  iv = intCnv(VSX.saveVoiceSet[i][4]);
                  if (GUI.Button(new Rect (125, y, 20, 20), VSX.saveVoiceSet[i][4], gsButton)) {
                    ++iv;
                    if (iv >= 4) iv = 0;
                    VSX.saveVoiceSet[i][4] = iv.ToString();
                  }

                  GUI.Label(new Rect (147, y, 15, 20), "～", gsLabel);

                  iv = intCnv(VSX.saveVoiceSet[i][5]);
                  if (GUI.Button(new Rect (160, y, 20, 20), VSX.saveVoiceSet[i][5], gsButton)) {
                    ++iv;
                    if (iv >= 4) iv = 0;
                    VSX.saveVoiceSet[i][5] = iv.ToString();
                  }

                  if (intCnv(VSX.saveVoiceSet[i][4]) > intCnv(VSX.saveVoiceSet[i][5])) VSX.saveVoiceSet[i][5] = VSX.saveVoiceSet[i][4];

                  //強度選択
                  iv = intCnv(VSX.saveVoiceSet[i][6]);
                  if (GUI.Button(new Rect (190, y, 60, 20), vsState[iv], gsButton)) {
                    ++iv;
                    if (iv >= vsState.Length) iv = 0;
                    VSX.saveVoiceSet[i][6] = iv.ToString();
                  }

                  //状態選択
                  iv = intCnv(VSX.saveVoiceSet[i][7]);
                  if (GUI.Button(new Rect (260, y, 60, 20), vsCondition[iv], gsButton)) {
                    ++iv;
                    if (iv >= vsCondition.Length) iv = 0;
                    VSX.saveVoiceSet[i][7] = iv.ToString();
                  }


                  if (GUI.Button(new Rect (330, y, 50, 20), "削除", gsButton)) {
                    VSX.saveVoiceSet.RemoveAt(i);
                  }

                  //GUI.Label(new Rect (5, 20 + y, 370, 15), "―――――――――――――――――――――――――――――", gsLabel2);
                  GUI.DrawTexture(new Rect(5, 24 + y, 370, 1), guiLineTexture, ScaleMode.StretchToFill, true, 0);

                  y += 30;
                }

              }

              if (GUI.Button(new Rect (320, 0 + y, 60, 20), "追加", gsButton)) {
                string[] set = new string[]{ "" , fVoiceSet[0].ToString() , "0" , "3" , "0" , "3" , fVoiceSet[3].ToString() , fVoiceSet[4].ToString() };
                VSX.saveVoiceSet.Add(set);
              }

              GUI.EndScrollView();
        }

        //ランダムモーションセット
        private void WindowCallback3_4(Maid maid) {
            int x = 0;
            int y = 0;

              x = 0;
              y = 0;
              scKeyOff = GUI.Toggle(new Rect(420, 2, 140, 20), scKeyOff, "ショートカット無効", gsToggle);

              //モーションセット編集画面
              x = 5;
              y = 40;
              GUI.Label(new Rect (5, y, 120, 20), "モーションセット名" , gsLabel);
              ms_Overwrite = GUI.Toggle(new Rect(125, y, 70, 20), ms_Overwrite, "上書／ｸﾘｱ", gsToggle);

              y += 20;
              MSX.saveMotionSetName = GUI.TextField(new Rect(5, y, 170, 20), MSX.saveMotionSetName);

              y += 25;
              if (GUI.Button(new Rect (55, y, 55, 20), "クリア", gsButton)) {
                if (ms_Overwrite) {
                  MSX.saveMotionSet = new List<List<string>>();
                  MSX.saveMotionSetName = "";
                  ms_Overwrite = false;
                  msCategory = 0;
                } else {
                  msErrer = 3;
                }
              }
              //XMLファイルに保存する
              if (GUI.Button(new Rect (120, y, 55, 20), "保存", gsButton)) {
                MotionSetSave();
                XmlFilesCheck();
              }

              y += 30;
              if (msErrer != 0) {
                if (GUI.Button(new Rect (5, y, 20, 20), "x", gsButton)) {
                  msErrer = 0;
                }
                GUI.Label(new Rect (30, y, 170, 60), msErrerText[msErrer], gsLabelErr);
              }
              y += 45;


              //モーションセット一覧
              y += 35;
              GUI.Label(new Rect (5, y, 200, 20), "【モーションセット読み込み】" , gsLabel);

              y += 20;
              int h1 = emsFiles.Count * 22;
              if (h1 < 445 - y) h1 = 445 - y;
              Rect scrlRect1    = new Rect(5, y, 200, 445 - y);
              Rect contentRect1 = new Rect(0, 0, 175, h1);
              vsScrollPos1 = GUI.BeginScrollView(scrlRect1, vsScrollPos1, contentRect1, false, true );

              y = 0;
              foreach (string f in emsFiles) {
                string FileName = f.Replace("ems_", "").Replace(".xml", "");
                if (GUI.Button(new Rect (0, y, 175, 20), FileName, gsButton)) {
                  MotionSetLoad(f);
                }
                y += 22;
              }
              GUI.EndScrollView();


              //ボイスセット編集画面
              x = 210;
              y = 50;

              //カテゴリ切り替え
              GUI.Label(new Rect (x, y, 120, 20), "【カテゴリ " + msCategory + " 】" , gsLabel);
              if (MSX.saveMotionSet.Count == 0) {
                List<string> nm = new List<string>(){""};
                MSX.saveMotionSet.Add(nm);
              }
              if (GUI.Button(new Rect (x + 125, y, 100, 20), "カテゴリ追加", gsButton)) {
                List<string> nm = new List<string>(){""};;
                MSX.saveMotionSet.Add(nm);
                msCategory = MSX.saveMotionSet.Count - 1;
              }
              if (MSX.saveMotionSet.Count > 1) {
                if (GUI.Button(new Rect (x + 235, y, 100, 20), "カテゴリ削除", gsButton)) {
                  MSX.saveMotionSet.RemoveAt(msCategory);
                  if (msCategory >= MSX.saveMotionSet.Count) msCategory = MSX.saveMotionSet.Count - 1;
                }
              }

              x = 220;
              y += 30;

              for (int i = 0; i < MSX.saveMotionSet.Count; i++) {
                if (GUI.Button(new Rect (x, y, 30, 20), i.ToString(), gsButton)) {
                  msCategory = i;
                }
                x += 35;
                if (x + 30 > 620) {
                  x = 220;
                  y += 25;
                }
              }


              x = 220;
              y += 40;
              int h2 = MSX.saveMotionSet[msCategory].Count * 65 + 30;
              if (h2 < 445 - y) h2 = 445 - y;

              Rect scrlRect2    = new Rect(x, y, 400, 445 - y);
              Rect contentRect2 = new Rect(0, 0, 380, h2);
              vsScrollPos2 = GUI.BeginScrollView( scrlRect2, vsScrollPos2, contentRect2, false, true );

              y = 0;
              for (int i = 0; i < MSX.saveMotionSet[msCategory].Count; i++) {

                GUI.Label(new Rect (0, 0 + y, 70, 20), "モーション" , gsLabel);
                MSX.saveMotionSet[msCategory][i] = GUI.TextField(new Rect(70, 0 + y, 300, 20), MSX.saveMotionSet[msCategory][i]);

                GUI.Label(new Rect (10, 25 + y, 200, 20), MotionNameChange(MSX.saveMotionSet[msCategory][i]) , gsLabel);

                if (GUI.Button(new Rect (215, 25 + y, 50, 20), "取得", gsButton)) {
                  string motion = stockMaids[tgID].mem.body0.LastAnimeFN;
                  motion = regZeccyouBackup.Match(motion).Groups[1].Value;  // 「 - Que…」を除く
                  motion = Regex.Replace(motion, "_[23](?!ana)(?!p_)(?!vibe)", "_1");
                  motion = Regex.Replace(motion, @"[a-zA-Z][0-9][0-9]", "");
                  MSX.saveMotionSet[msCategory][i] = motion;
                }
                if (GUI.Button(new Rect (270, 25 + y, 50, 20), "再生", gsButton)) {
                  MotionChange(maid, MSX.saveMotionSet[msCategory][i], true, 0.7f, 1f);
                  ManMotionChange(tgID, true, 0.7f, 1f);
                }
                if (GUI.Button(new Rect (325, 25 + y, 50, 20), "削除", gsButton)) {
                  MSX.saveMotionSet[msCategory].RemoveAt(i);
                }
                GUI.Label(new Rect (5, 45 + y, 370, 20), "―――――――――――――――――――――――――――――", gsLabel2);

                y += 65;
              }

              if (GUI.Button(new Rect (315, 0 + y, 60, 20), "追加", gsButton)) {
                MSX.saveMotionSet[msCategory].Add("");
              }

              GUI.EndScrollView();
        }

        //髪型・服装の登録
        private void WindowCallback3_5(Maid maid) {

              scKeyOff = GUI.Toggle(new Rect(420, 2, 140, 20), scKeyOff, "ショートカット無効", gsToggle);

                    GUI.Label(new Rect (5, 35, 190, 20), "【髪型】" , gsLabel);
                    GUI.Label(new Rect (5, 55, 190, 20), "前髪：" + maid.GetProp(MPN.hairf).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsLabel );
                    GUI.Label(new Rect (5, 75, 190, 20), "後髪：" + maid.GetProp(MPN.hairr).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsLabel );
                    GUI.Label(new Rect (5, 115, 190, 20), "横髪：" + maid.GetProp(MPN.hairs).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsLabel );
                    GUI.Label(new Rect (5, 95, 190, 20), "ｴｸｽﾃ髪：" + maid.GetProp(MPN.hairt).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsLabel );
                    GUI.Label(new Rect (5, 135, 190, 20), "アホ毛：" + maid.GetProp(MPN.hairaho).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsLabel );
                    GUI.Label(new Rect (5, 155, 190, 20), "リボン：" + maid.GetProp(MPN.acckamisub).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsLabel );
                    GUI.Label(new Rect (5, 175, 190, 20), "髪ｱｸｾ：" + maid.GetProp(MPN.acckami).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsLabel );

                    GUI.Label(new Rect (5, 205, 190, 20), "【服装】" , gsLabel);
                    setAcchat = GUI.Toggle(new Rect (5, 225, 190, 20), setAcchat, "帽子：" + maid.GetProp(MPN.acchat).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsToggle );
                    setHeadset = GUI.Toggle(new Rect (5, 245, 190, 20), setHeadset, "ﾍｯﾄﾞﾄﾞﾚｽ：" + maid.GetProp(MPN.headset).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsToggle );
                    setWear = GUI.Toggle(new Rect (5, 265, 190, 20), setWear, "ﾄｯﾌﾟｽ：" + maid.GetProp(MPN.wear).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsToggle );
                    setSkirt = GUI.Toggle(new Rect (5, 285, 190, 20), setSkirt, "ﾎﾞﾄﾑｽ：" + maid.GetProp(MPN.skirt).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsToggle );
                    setOnepiece = GUI.Toggle(new Rect (5, 305, 190, 20), setOnepiece, "ﾜﾝﾋﾟｰｽ：" + maid.GetProp(MPN.onepiece).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsToggle );
                    setMizugi = GUI.Toggle(new Rect (5, 325, 190, 20), setMizugi, "水着：" + maid.GetProp(MPN.mizugi).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsToggle );
                    setBra = GUI.Toggle(new Rect (5, 345, 190, 20), setBra, "ﾌﾞﾗｼﾞｬｰ：" + maid.GetProp(MPN.bra).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsToggle );
                    setPanz = GUI.Toggle(new Rect (5, 365, 190, 20), setPanz, "パンツ：" + maid.GetProp(MPN.panz).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsToggle );
                    setStkg = GUI.Toggle(new Rect (5, 385, 190, 20), setStkg, "靴下：" + maid.GetProp(MPN.stkg).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsToggle );
                    setShoes = GUI.Toggle(new Rect (5, 405, 190, 20), setShoes, "靴：" + maid.GetProp(MPN.shoes).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsToggle );

                    GUI.Label(new Rect (205, 35, 190, 20), "【アクセサリーその他】" , gsLabel);
                    setMegane = GUI.Toggle(new Rect (205, 55, 190, 20), setMegane, "メガネ：" + maid.GetProp(MPN.megane).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsToggle );
                    setAcchead = GUI.Toggle(new Rect (205, 75, 190, 20), setAcchead, "ｱｲﾏｽｸ：" + maid.GetProp(MPN.acchead).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsToggle );
                    setGlove = GUI.Toggle(new Rect (205, 95, 190, 20), setGlove, "手袋：" + maid.GetProp(MPN.glove).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsToggle );
                    setAccude = GUI.Toggle(new Rect (205, 115, 190, 20), setAccude, "腕：" + maid.GetProp(MPN.accude).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsToggle );
                    setAcchana = GUI.Toggle(new Rect (205, 135, 190, 20), setAcchana, "鼻：" + maid.GetProp(MPN.acchana).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsToggle );
                    setAccmimi = GUI.Toggle(new Rect (205, 155, 190, 20), setAccmimi, "耳：" + maid.GetProp(MPN.accmimi).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsToggle );
                    setAccnip = GUI.Toggle(new Rect (205, 175, 190, 20), setAccnip, "乳首：" + maid.GetProp(MPN.accnip).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsToggle );
                    setAcckubi = GUI.Toggle(new Rect (205, 195, 190, 20), setAcckubi, "ﾈｯｸﾚｽ：" + maid.GetProp(MPN.acckubi).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsToggle );
                    setAcckubiwa = GUI.Toggle(new Rect (205, 215, 190, 20), setAcckubiwa, "ﾁｮｰｶｰ：" + maid.GetProp(MPN.acckubiwa).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsToggle );
                    setAccheso = GUI.Toggle(new Rect (205, 235, 190, 20), setAccheso, "へそ：" + maid.GetProp(MPN.accheso).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsToggle );
                    setAccashi = GUI.Toggle(new Rect (205, 255, 190, 20), setAccashi, "足首：" + maid.GetProp(MPN.accashi).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsToggle );
                    setAccsenaka = GUI.Toggle(new Rect (205, 275, 190, 20), setAccsenaka, "背中：" + maid.GetProp(MPN.accsenaka).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsToggle );
                    setAccshippo = GUI.Toggle(new Rect (205, 295, 190, 20), setAccshippo, "しっぽ：" + maid.GetProp(MPN.accshippo).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsToggle );
                    setAccxxx = GUI.Toggle(new Rect (205, 315, 190, 20), setAccxxx, "前穴：" + maid.GetProp(MPN.accxxx).strFileName.Replace("_i_", "").Replace("_I_", "").Replace("del.menu", "無し").Replace(".menu", "") , gsToggle );

                    GUI.Label(new Rect (205, 350, 190, 20), maid.GetProp(MPN.skirt).strTempFileName , gsLabel);


                    GUI.Label(new Rect (405, 35, 190, 20), "【現在の髪型を登録（個別）】" , gsLabel);
                    if (GUI.Button(new Rect (410, 60, 85, 20), lang.HAIR_TYPE+"１", gsButton)){
                      if (ExSaveData.Contains(maid, "CM3D2.VibeYourMaid.Plugin", "1_hairF") && !hs_Overwrite[0]) {
                        dsErrer = 2;
                      } else {
                        ExSaveHair(maid, "1");
                        Console.WriteLine(lang.HAIR_TYPE+"１ 登録完了");
                        hs_Overwrite[0] = false;
                        dsErrer = 0;
                      }
                    }
                    if (ExSaveData.Contains(maid, "CM3D2.VibeYourMaid.Plugin", "1_hairF")) hs_Overwrite[0] = GUI.Toggle(new Rect(505, 60, 70, 20), hs_Overwrite[0], "上書", gsToggle);

                    if (GUI.Button(new Rect (410, 85, 85, 20), lang.HAIR_TYPE+"２", gsButton)){
                      if (ExSaveData.Contains(maid, "CM3D2.VibeYourMaid.Plugin", "2_hairF") && !hs_Overwrite[1]) {
                        dsErrer = 2;
                      } else {
                        ExSaveHair(maid, "2");
                        Console.WriteLine(lang.HAIR_TYPE+"２ 登録完了");
                        hs_Overwrite[1] = false;
                        dsErrer = 0;
                      }
                    }
                    if (ExSaveData.Contains(maid, "CM3D2.VibeYourMaid.Plugin", "2_hairF")) hs_Overwrite[1] = GUI.Toggle(new Rect(505, 85, 70, 20), hs_Overwrite[1], "上書", gsToggle);

                    if (GUI.Button(new Rect (410, 110, 85, 20), lang.HAIR_TYPE+"３", gsButton)){
                      if (ExSaveData.Contains(maid, "CM3D2.VibeYourMaid.Plugin", "3_hairF") && !hs_Overwrite[2]) {
                        dsErrer = 2;
                      } else {
                        ExSaveHair(maid, "3");
                        Console.WriteLine(lang.HAIR_TYPE+"３ 登録完了");
                        hs_Overwrite[2] = false;
                        dsErrer = 0;
                      }
                    }
                    if (ExSaveData.Contains(maid, "CM3D2.VibeYourMaid.Plugin", "3_hairF")) hs_Overwrite[2] = GUI.Toggle(new Rect(505, 110, 70, 20), hs_Overwrite[2], "上書", gsToggle);

                    if (GUI.Button(new Rect (410, 135, 85, 20), lang.HAIR_TYPE+"４", gsButton)){
                      if (ExSaveData.Contains(maid, "CM3D2.VibeYourMaid.Plugin", "4_hairF") && !hs_Overwrite[3]) {
                        dsErrer = 2;
                      } else {
                        ExSaveHair(maid, "4");
                        Console.WriteLine(lang.HAIR_TYPE+"４ 登録完了");
                        hs_Overwrite[3] = false;
                        dsErrer = 0;
                      }
                    }
                    if (ExSaveData.Contains(maid, "CM3D2.VibeYourMaid.Plugin", "4_hairF")) hs_Overwrite[3] = GUI.Toggle(new Rect(505, 135, 70, 20), hs_Overwrite[3], "上書", gsToggle);


                    GUI.Label(new Rect (405, 165, 190, 20), "【現在の衣装を登録（個別）】" , gsLabel);
                    if (GUI.Button(new Rect (410, 190, 85, 20), lang.WEAR_TYPE+"１", gsButton)){
                      if (ExSaveData.Contains(maid, "CM3D2.VibeYourMaid.Plugin", "1_acchat") && !ds_Overwrite[0]) {
                        dsErrer = 2;
                      } else {
                        ExSaveWear(maid, "1");
                        Console.WriteLine(lang.WEAR_TYPE+"１ 登録完了");
                        ds_Overwrite[0] = false;
                        dsErrer = 0;
                      }
                    }
                    if (ExSaveData.Contains(maid, "CM3D2.VibeYourMaid.Plugin", "1_acchat")) ds_Overwrite[0] = GUI.Toggle(new Rect(505, 190, 70, 20), ds_Overwrite[0], "上書", gsToggle);

                    if (GUI.Button(new Rect (410, 215, 85, 20), lang.WEAR_TYPE+"２", gsButton)){
                      if (ExSaveData.Contains(maid, "CM3D2.VibeYourMaid.Plugin", "2_acchat") && !ds_Overwrite[1]) {
                        dsErrer = 2;
                      } else {
                        ExSaveWear(maid, "2");
                        Console.WriteLine(lang.WEAR_TYPE+"２ 登録完了");
                        ds_Overwrite[1] = false;
                        dsErrer = 0;
                      }
                    }
                    if (ExSaveData.Contains(maid, "CM3D2.VibeYourMaid.Plugin", "2_acchat")) ds_Overwrite[1] = GUI.Toggle(new Rect(505, 215, 70, 20), ds_Overwrite[1], "上書", gsToggle);

                    if (GUI.Button(new Rect (410, 240, 85, 20), lang.WEAR_TYPE+"３", gsButton)){
                      if (ExSaveData.Contains(maid, "CM3D2.VibeYourMaid.Plugin", "3_acchat") && !ds_Overwrite[2]) {
                        dsErrer = 2;
                      } else {
                        ExSaveWear(maid, "3");
                        Console.WriteLine(lang.WEAR_TYPE+"３ 登録完了");
                        ds_Overwrite[2] = false;
                        dsErrer = 0;
                      }
                    }
                    if (ExSaveData.Contains(maid, "CM3D2.VibeYourMaid.Plugin", "3_acchat")) ds_Overwrite[2] = GUI.Toggle(new Rect(505, 240, 70, 20), ds_Overwrite[2], "上書", gsToggle);

                    if (GUI.Button(new Rect (410, 265, 85, 20), lang.WEAR_TYPE+"４", gsButton)){
                      if (ExSaveData.Contains(maid, "CM3D2.VibeYourMaid.Plugin", "4_acchat") && !ds_Overwrite[3]) {
                        dsErrer = 2;
                      } else {
                        ExSaveWear(maid, "4");
                        Console.WriteLine(lang.WEAR_TYPE+"４ 登録完了");
                        ds_Overwrite[3] = false;
                        dsErrer = 0;
                      }
                    }
                    if (ExSaveData.Contains(maid, "CM3D2.VibeYourMaid.Plugin", "4_acchat")) ds_Overwrite[3] = GUI.Toggle(new Rect(505, 265, 70, 20), ds_Overwrite[3], "上書", gsToggle);

                    GUI.Label(new Rect (405, 295, 190, 20), "【現在の衣装を登録（共通）】" , gsLabel);
                    GUI.Label(new Rect (405, 320, 90, 20), "衣装セット名" , gsLabel);
                    ds_Overwrite[4] = GUI.Toggle(new Rect(530, 320, 70, 20), ds_Overwrite[4], "上書", gsToggle);

                    cbsName = GUI.TextField(new Rect(405, 345, 170, 20), cbsName);

                    //XMLファイルに保存する
                    if (GUI.Button(new Rect (520, 370, 55, 20), "保存", gsButton)) {
                      CdsFileSave(cbsName);
                      XmlFilesCheck();
                      ds_Overwrite[4] = false;
                    }

                    if (dsErrer != 0) {
                      if (GUI.Button(new Rect (405, 400, 20, 20), "x", gsButton)) {
                        dsErrer = 0;
                      }
                      GUI.Label(new Rect (430, 400, 170, 40), dsErrerText[dsErrer], gsLabelErr);
                    }

                    GUI.Label(new Rect (150, 420, 450, 20), "※ メイド個別の髪型と衣装は拡張セーブデータに保存されます（要SAVE）" , gsLabelR);
        }

        //モーションアジャスト詳細設定
        bool showSubMotionUI = false; //サブメイド用の設定UI表示
        private void WindowCallback3_6(Maid maid, MaidState tgMaidState) {

            int tgMotionID = tgMaidState.motionID; //ターゲットメイドのモーションID

            Vector3 vm;
            Vector3 vml;
            Vector3 em;
            int x = 0;
            int y = 0;

              if (tgMotionID == -1) {
                GUI.Label(new Rect (10, 30, 400, 20), "UNZIPモーションを選択してください" , gsLabel);
                return;
              }

              scKeyOff = GUI.Toggle(new Rect(420, 2, 140, 20), scKeyOff, "ショートカット無効", gsToggle);

                  GUI.Label(new Rect (10, 30, 400, 20), MotionNameChange(maj.motionName[tgMotionID]) + "　/　" + maj.motionName[tgMotionID] , gsLabel);

                  if (GUI.Button(new Rect (420, 28, 180, 25), "調整値保存", gsButton)) {
                    MajFileSave(true);
                  }
                  GUI.DrawTexture(new Rect(1, 56, 618, 1), guiLineTexture, ScaleMode.StretchToFill, true, 0);

                  if (tgMotionID >= 0) {
                    Rect scrlRect2    = new Rect(0, 58, 620, 268);
                    Rect contentRect2 = new Rect(0, 0, 600, 490);
                    vsScrollPos2 = GUI.BeginScrollView(scrlRect2, vsScrollPos2, contentRect2, false, true );

                    float sliderValue;


                    x = 10; y = 0;
                    GUI.Label(new Rect (x-5, y, 100, 20), "【基本位置】", gsLabel);

                    List<float> majParam;

                    //UIでの値はメインメイドからの相対距離
                    float basicHeight = maj.basicHeight[tgMotionID];
                    float basicForward = maj.basicForward[tgMotionID];
                    float basicRight = maj.basicRight[tgMotionID];
                    float basicAngleY = maj.basicAngleY[tgMotionID];

                    if (tgMaidState.motionLinkID == -1) {
                      showSubMotionUI = false;
                      GUI.Label(new Rect (x+80, y, 100, 20), "メインメイド", gsLabel);
                    } else {
                      showSubMotionUI = !GUI.Toggle(new Rect (x+80, y, 100, 20), !showSubMotionUI, "メインメイド", gsToggle );
                      showSubMotionUI = GUI.Toggle(new Rect (x+180, y, 100, 20), showSubMotionUI, "サブメイド", gsToggle );
                    }

                    //サブメイド表示中は切り替える
                    int motionMaidID = tgID;
                    if (showSubMotionUI) {
                      motionMaidID = tgMaidState.motionLinkID;
                      if (motionMaidID != -1) {
                        basicHeight = maj.basicHeight[maidsState[motionMaidID].motionID] - basicHeight;
                        basicForward = maj.basicForward[maidsState[motionMaidID].motionID] - basicForward;
                        basicRight = maj.basicRight[maidsState[motionMaidID].motionID] - basicRight;
                        basicAngleY = maj.basicAngleY[maidsState[motionMaidID].motionID] - basicAngleY;
                      }
                    }
                    MaidState motionMadeState = maidsState[motionMaidID];

                    majParam = maj.basicHeight;
                    GUI.Label(new Rect (x, y+20, 110, 20), "上下: " + Math.Round(basicHeight * 1000000)*0.1, gsLabel);
                    if (GUI.Button(new Rect (x+65, y+20, 18, 20), "0", gsButton)) {
                      float offset = - majParam[motionMadeState.motionID];
                      if (showSubMotionUI) { majParam[motionMadeState.motionID] = majParam[tgMotionID]; setSubMotionPosition(motionMaidID, tgID); }
                      else { majParam[motionMadeState.motionID] = 0; setBasicMotionPositionOffset(tgID, maid, offset, 0, 0, 0); }
                    }
                    if (GUI.Button(new Rect (x+85, y+20, 18, 20), "-", gsButton)) {
                      float value = (float)(Math.Round(Math.Max(-0.005f, majParam[motionMadeState.motionID] - moveValue * 0.001f) * 1000000) * 0.000001); //移動後の値
                      float offset = value - majParam[motionMadeState.motionID];
                      majParam[motionMadeState.motionID] = value;
                      if (showSubMotionUI) setSubMotionPosition(motionMaidID, tgID);
                      else setBasicMotionPositionOffset(tgID, maid, offset, 0, 0, 0);
                    }
                    if (GUI.Button(new Rect (x+105, y+20, 18, 20), "+", gsButton)) {
                      float value = (float)(Math.Round(Math.Min(0.005f, majParam[motionMadeState.motionID] + moveValue * 0.001f) * 1000000) * 0.000001); //移動後の値
                      float offset = value - majParam[motionMadeState.motionID];
                      majParam[motionMadeState.motionID] = value;
                      if (showSubMotionUI) setSubMotionPosition(motionMaidID, tgID);
                      else setBasicMotionPositionOffset(tgID, maid, offset, 0, 0, 0);
                    }
                    sliderValue = GUI.HorizontalSlider(new Rect(x+130, y+25, 150, 15), majParam[motionMadeState.motionID], -0.006f, 0.006f);
                    if (majParam[motionMadeState.motionID] != sliderValue) {
                      sliderValue = (float)(Math.Round(sliderValue * 100000) * 0.00001); //整数値にする
                      float offset = sliderValue - majParam[motionMadeState.motionID];
                      majParam[motionMadeState.motionID] = sliderValue;
                      if (showSubMotionUI) setSubMotionPosition(motionMaidID, tgID);
                      else setBasicMotionPositionOffset(tgID, maid, offset, 0, 0, 0);
                    }

                    majParam = maj.basicForward;
                    GUI.Label(new Rect (x, y+42, 110, 20), "前後: " + Math.Round(basicForward * 1000000)*0.1, gsLabel);
                    if (GUI.Button(new Rect (x+65, y+42, 18, 20), "0", gsButton)) {
                      float offset = - majParam[motionMadeState.motionID];
                      if (showSubMotionUI) { majParam[motionMadeState.motionID] = majParam[tgMotionID]; setSubMotionPosition(motionMaidID, tgID); }
                      else { majParam[motionMadeState.motionID] = 0; setBasicMotionPositionOffset(tgID, maid, 0, offset, 0, 0); }
                    }
                    if (GUI.Button(new Rect (x+85, y+42, 18, 20), "-", gsButton)) {
                      float value = (float)(Math.Round(Math.Max(-0.005f, majParam[motionMadeState.motionID] - moveValue * 0.001f) * 1000000) * 0.000001); //移動後の値
                      float offset = value - majParam[motionMadeState.motionID];
                      majParam[motionMadeState.motionID] = value;
                      if (showSubMotionUI) setSubMotionPosition(motionMaidID, tgID);
                      else setBasicMotionPositionOffset(tgID, maid, 0, offset, 0, 0);
                    }
                    if (GUI.Button(new Rect (x+105, y+42, 18, 20), "+", gsButton)) {
                      float value = (float)(Math.Round(Math.Min(0.005f, majParam[motionMadeState.motionID] + moveValue * 0.001f) * 1000000) * 0.000001); //移動後の値
                      float offset = value - majParam[motionMadeState.motionID];
                      majParam[motionMadeState.motionID] = value;
                      if (showSubMotionUI) setSubMotionPosition(motionMaidID, tgID);
                      else setBasicMotionPositionOffset(tgID, maid, 0, offset, 0, 0);
                    }
                    sliderValue = GUI.HorizontalSlider(new Rect(x+130, y+47, 150, 15), majParam[motionMadeState.motionID], -0.006f, 0.006f);
                    if (majParam[motionMadeState.motionID] != sliderValue) {
                      sliderValue = (float)(Math.Round(sliderValue * 100000) * 0.00001); //整数値にする
                      float offset = sliderValue - majParam[motionMadeState.motionID];
                      majParam[motionMadeState.motionID] = sliderValue;
                      if (showSubMotionUI) setSubMotionPosition(motionMaidID, tgID);
                      else setBasicMotionPositionOffset(tgID, maid, 0, offset, 0, 0);
                    }

                    majParam = maj.basicRight;
                    GUI.Label(new Rect (x, y+64, 110, 20), "左右: " + Math.Round(basicRight * 1000000)*0.1, gsLabel);
                    if (GUI.Button(new Rect (x+65, y+64, 18, 20), "0", gsButton)) {
                      float offset = - majParam[motionMadeState.motionID];
                      if (showSubMotionUI) { majParam[motionMadeState.motionID] = majParam[tgMotionID]; setSubMotionPosition(motionMaidID, tgID); }
                      else { majParam[motionMadeState.motionID] = 0; setBasicMotionPositionOffset(tgID, maid, 0, 0, offset, 0); }
                    }
                    if (GUI.Button(new Rect (x+85, y+64, 18, 20), "-", gsButton)) {
                      float value = (float)(Math.Round(Math.Max(-0.005f, majParam[motionMadeState.motionID] - moveValue * 0.001f) * 1000000) * 0.000001); //移動後の値
                      float offset = value - majParam[motionMadeState.motionID];
                      majParam[motionMadeState.motionID] = value;
                      if (showSubMotionUI) setSubMotionPosition(motionMaidID, tgID);
                      else setBasicMotionPositionOffset(tgID, maid, 0, 0, offset, 0);
                    }
                    if (GUI.Button(new Rect (x+105, y+64, 18, 20), "+", gsButton)) {
                      float value = (float)(Math.Round(Math.Min(0.005f, majParam[motionMadeState.motionID] + moveValue * 0.001f) * 1000000) * 0.000001); //移動後の値
                      float offset = value - majParam[motionMadeState.motionID];
                      majParam[motionMadeState.motionID] = value;
                      if (showSubMotionUI) setSubMotionPosition(motionMaidID, tgID);
                      else setBasicMotionPositionOffset(tgID, maid, 0, 0, offset, 0);
                    }
                    sliderValue = GUI.HorizontalSlider(new Rect(x+130, y+69, 150, 15), majParam[motionMadeState.motionID], -0.006f, 0.006f);
                    if (majParam[motionMadeState.motionID] != sliderValue) {
                      sliderValue = (float)(Math.Round(sliderValue * 100000) * 0.00001); //整数値にする
                      float offset = sliderValue - majParam[motionMadeState.motionID];
                      majParam[motionMadeState.motionID] = sliderValue;
                      if (showSubMotionUI) setSubMotionPosition(motionMaidID, tgID);
                      else setBasicMotionPositionOffset(tgID, maid, 0, 0, offset, 0);
                    }

                    majParam = maj.basicAngleY;
                    GUI.Label(new Rect (x, y+86, 110, 20), "回転: " + Math.Round(basicAngleY * 10)*0.1, gsLabel);
                    if (GUI.Button(new Rect (x+65, y+86, 18, 20), "0", gsButton)) {
                      float offset = -majParam[motionMadeState.motionID];
                      if (showSubMotionUI) { majParam[motionMadeState.motionID] = majParam[tgMotionID]; setSubMotionPosition(motionMaidID, tgID); }
                      else { majParam[motionMadeState.motionID] = 0; setBasicMotionPositionOffset(tgID, maid, 0, 0, 0, offset); }
                    }
                    if (GUI.Button(new Rect (x+85, y+86, 18, 20), "-", gsButton)) {
                      float value = (float)(Math.Round(Math.Max(-180, majParam[motionMadeState.motionID] - moveValue * 100f) * 10) * 0.1); //移動後の値
                      float offset = value - majParam[motionMadeState.motionID];
                      majParam[motionMadeState.motionID] = value;
                      if (showSubMotionUI) setSubMotionPosition(motionMaidID, tgID);
                      else setBasicMotionPositionOffset(tgID, maid, 0, 0, 0, offset);
                    }
                    if (GUI.Button(new Rect (x+105, y+86, 18, 20), "+", gsButton)) {
                      float value = (float)(Math.Round(Math.Min(180, majParam[motionMadeState.motionID] + moveValue * 100f) * 10) * 0.1); //移動後の値
                      float offset = value - majParam[motionMadeState.motionID];
                      majParam[motionMadeState.motionID] = value;
                      if (showSubMotionUI) setSubMotionPosition(motionMaidID, tgID);
                      else setBasicMotionPositionOffset(tgID, maid, 0, 0, 0, offset);
                    }
                    sliderValue = GUI.HorizontalSlider(new Rect(x+130, y+91, 150, 15), majParam[motionMadeState.motionID], -180, 180);
                    if (majParam[motionMadeState.motionID] != sliderValue) {
                      sliderValue = Mathf.Round(sliderValue); //整数値にする
                      float offset = sliderValue - majParam[motionMadeState.motionID];
                      majParam[motionMadeState.motionID] = sliderValue;
                      if (showSubMotionUI) setSubMotionPosition(motionMaidID, tgID);
                      else setBasicMotionPositionOffset(tgID, maid, 0, 0, 0, offset);
                    }

                    x = 10;
                    y = 110;
                    GUI.Label(new Rect (x-5, y, 190, 20), "【身長位置補正】" , gsLabel);

                    majParam = maj.mansHeight;
                    GUI.Label(new Rect (x, y+20, 110, 20), "上下: " + Math.Round(majParam[motionMadeState.motionID] * 1000000)*0.1 , gsLabel);
                    if (GUI.Button(new Rect (x+65, y+20, 18, 20), "0", gsButton)) {
                      majParam[motionMadeState.motionID] = 0;
                      if (showSubMotionUI) setSubMotionPosition(tgMaidState.motionLinkID, tgID);
                      else setManMotionPosition(tgID, -1);
                    }
                    if (GUI.Button(new Rect (x+85, y+20, 18, 20), "-", gsButton)) {
                      majParam[motionMadeState.motionID] = Math.Max(-0.002f, majParam[motionMadeState.motionID] - moveValue * 0.001f);
                      if (showSubMotionUI) setSubMotionPosition(tgMaidState.motionLinkID, tgID);
                      else setManMotionPosition(tgID, -1);
                    }
                    if (GUI.Button(new Rect (x+105, y+20, 18, 20), "+", gsButton)) {
                      majParam[motionMadeState.motionID] = Math.Min(0.002f, majParam[motionMadeState.motionID] + moveValue * 0.001f);
                      if (showSubMotionUI) setSubMotionPosition(tgMaidState.motionLinkID, tgID);
                      else setManMotionPosition(tgID, -1);
                    }
                    sliderValue = GUI.HorizontalSlider(new Rect(x+130, y+25, 150, 20), majParam[motionMadeState.motionID], -0.002F, 0.002F);
                    if (majParam[motionMadeState.motionID] != sliderValue) {
                      majParam[motionMadeState.motionID] = (float)(Math.Round(sliderValue * 100000) * 0.00001); //整数値にする;
                      if (showSubMotionUI) setSubMotionPosition(tgMaidState.motionLinkID, tgID);
                      else setManMotionPosition(tgID, -1);
                    }
                    majParam = maj.mansForward;
                    GUI.Label(new Rect (x, y+42, 110, 20), "前後: " + Math.Round(majParam[motionMadeState.motionID] * 1000000)*0.1 , gsLabel);
                    if (GUI.Button(new Rect (x+65, y+42, 18, 20), "0", gsButton)) {
                      majParam[motionMadeState.motionID] = 0;
                      if (showSubMotionUI) setSubMotionPosition(tgMaidState.motionLinkID, tgID);
                      else setManMotionPosition(tgID, -1);
                    }
                    if (GUI.Button(new Rect (x+85, y+42, 18, 20), "-", gsButton)) {
                      majParam[motionMadeState.motionID] = Math.Max(-0.002f, majParam[motionMadeState.motionID] - moveValue * 0.001f);
                      if (showSubMotionUI) setSubMotionPosition(tgMaidState.motionLinkID, tgID);
                      else setManMotionPosition(tgID, -1);
                    }
                    if (GUI.Button(new Rect (x+105, y+42, 18, 20), "+", gsButton)) {
                      majParam[motionMadeState.motionID] = Math.Min(0.002f, majParam[motionMadeState.motionID] + moveValue * 0.001f);
                      if (showSubMotionUI) setSubMotionPosition(tgMaidState.motionLinkID, tgID);
                      else setManMotionPosition(tgID, -1);
                    }
                    sliderValue = GUI.HorizontalSlider(new Rect(x+130, y+47, 150, 20), majParam[motionMadeState.motionID], -0.002F, 0.002F);
                    if (majParam[motionMadeState.motionID] != sliderValue) {
                      majParam[motionMadeState.motionID] = (float)(Math.Round(sliderValue * 100000) * 0.00001); //整数値にする;
                      if (showSubMotionUI) setSubMotionPosition(tgMaidState.motionLinkID, tgID);
                      else setManMotionPosition(tgID, -1);
                    }
                    majParam = maj.mansRight;
                    GUI.Label(new Rect (x, y+64, 110, 20), "左右: " + Math.Round(majParam[motionMadeState.motionID] * 1000000)*0.1 , gsLabel);
                    if (GUI.Button(new Rect (x+65, y+64, 18, 20), "0", gsButton)) {
                      majParam[motionMadeState.motionID] = 0;
                      if (showSubMotionUI) setSubMotionPosition(tgMaidState.motionLinkID, tgID);
                      else setManMotionPosition(tgID, -1);
                    }
                    if (GUI.Button(new Rect (x+85, y+64, 18, 20), "-", gsButton)) {
                      majParam[motionMadeState.motionID] = Math.Max(-0.002f, majParam[motionMadeState.motionID] - moveValue * 0.001f);
                      if (showSubMotionUI) setSubMotionPosition(tgMaidState.motionLinkID, tgID);
                      else setManMotionPosition(tgID, -1);
                    }
                    if (GUI.Button(new Rect (x+105, y+64, 18, 20), "+", gsButton)) {
                      majParam[motionMadeState.motionID] = Math.Min(0.002f, majParam[motionMadeState.motionID] + moveValue * 0.001f);
                      if (showSubMotionUI) setSubMotionPosition(tgMaidState.motionLinkID, tgID);
                      else setManMotionPosition(tgID, -1);
                    }
                    sliderValue = GUI.HorizontalSlider(new Rect(x+130, y+69, 150, 20), majParam[motionMadeState.motionID], -0.002F, 0.002F);
                    if (majParam[motionMadeState.motionID] != sliderValue) {
                      majParam[motionMadeState.motionID] = (float)(Math.Round(sliderValue * 100000) * 0.00001); //整数値にする;
                      if (showSubMotionUI) setSubMotionPosition(tgMaidState.motionLinkID, tgID);
                      else setManMotionPosition(tgID, -1);
                    }

                  if (!showSubMotionUI) {

                    x = 310;
                    y = 0;
                    GUI.Label(new Rect (x-15, y, 110, 20), "【男位置】", gsLabel);
                    GUI.Label(new Rect (x, y+20, 80, 20), "上下: " + Math.Round(maj.submanHeight[tgMotionID] * 10000)*0.1 , gsLabel);
                    if (GUI.Button(new Rect (x+65, y+20, 18, 20), "0", gsButton)) {
                      maj.submanHeight[tgMotionID] = 0;
                      setManMotionPosition(tgID, -1);
                    }
                    if (GUI.Button(new Rect (x+85, y+20, 18, 20), "-", gsButton)) {
                      maj.submanHeight[tgMotionID] = Math.Max(-0.1f, maj.submanHeight[tgMotionID] - moveValue * 0.1f);
                      setManMotionPosition(tgID, -1);
                    }
                    if (GUI.Button(new Rect (x+105, y+20, 18, 20), "+", gsButton)) {
                      maj.submanHeight[tgMotionID] = Math.Min(0.1f, maj.submanHeight[tgMotionID] + moveValue * 0.1f);
                      setManMotionPosition(tgID, -1);
                    }
                    sliderValue = GUI.HorizontalSlider(new Rect(x+130, y+25, 150, 20), maj.submanHeight[tgMotionID], -0.1f, 0.1f);
                    if (maj.submanHeight[tgMotionID] != sliderValue) {
                      maj.submanHeight[tgMotionID] = (float)(Math.Round(sliderValue * 1000) * 0.001); //整数値にする;sliderValue;
                      setManMotionPosition(tgID, -1);
                    }

                    GUI.Label(new Rect (x, y+42, 80, 20), "前後: " + Math.Round(maj.submanForward[tgMotionID] * 10000)*0.1 , gsLabel);
                    if (GUI.Button(new Rect (x+65, y+42, 18, 20), "0", gsButton)) {
                      maj.submanForward[tgMotionID] = 0;
                      setManMotionPosition(tgID, -1);
                    }
                    if (GUI.Button(new Rect (x+85, y+42, 18, 20), "-", gsButton)) {
                      maj.submanForward[tgMotionID] = Math.Max(-0.1f, maj.submanForward[tgMotionID] - moveValue * 0.1f);
                      setManMotionPosition(tgID, -1);
                    }
                    if (GUI.Button(new Rect (x+105, y+42, 18, 20), "+", gsButton)) {
                      maj.submanForward[tgMotionID] = Math.Min(0.1f, maj.submanForward[tgMotionID] + moveValue * 0.1f);
                      setManMotionPosition(tgID, -1);
                    }
                    sliderValue = GUI.HorizontalSlider(new Rect(x+130, y+47, 150, 20), maj.submanForward[tgMotionID], -0.1f, 0.1f);
                    if (maj.submanForward[tgMotionID] != sliderValue) {
                      maj.submanForward[tgMotionID] = (float)(Math.Round(sliderValue * 1000) * 0.001); //整数値にする;sliderValue;
                      setManMotionPosition(tgID, -1);
                    }

                    GUI.Label(new Rect (x, y+64, 80, 20), "左右: " + Math.Round(maj.submanRight[tgMotionID] * 10000)*0.1 , gsLabel);
                    if (GUI.Button(new Rect (x+65, y+64, 18, 20), "0", gsButton)) {
                      maj.submanRight[tgMotionID] = 0;
                      setManMotionPosition(tgID, -1);
                    }
                    if (GUI.Button(new Rect (x+85, y+64, 18, 20), "-", gsButton)) {
                      maj.submanRight[tgMotionID] = Math.Max(-0.1f, maj.submanRight[tgMotionID] - moveValue * 0.1f);
                      setManMotionPosition(tgID, -1);
                    }
                    if (GUI.Button(new Rect (x+105, y+64, 18, 20), "+", gsButton)) {
                      maj.submanRight[tgMotionID] = Math.Min(0.1f, maj.submanRight[tgMotionID] + moveValue * 0.1f);
                      setManMotionPosition(tgID, -1);
                    }
                    sliderValue = GUI.HorizontalSlider(new Rect(x+130, y+69, 150, 20), maj.submanRight[tgMotionID], -0.1f, 0.1f);
                    if (maj.submanRight[tgMotionID] != sliderValue) {
                      maj.submanRight[tgMotionID] = (float)(Math.Round(sliderValue * 1000) * 0.001); //整数値にする;sliderValue;
                      setManMotionPosition(tgID, -1);
                    }

                    GUI.Label(new Rect (x, y+86, 80, 20), "回転: " + Math.Round(maj.submanAngleY[tgMotionID] * 10)*0.1 , gsLabel);
                    if (GUI.Button(new Rect (x+65, y+86, 18, 20), "0", gsButton)) {
                      maj.submanAngleY[tgMotionID] = 0;
                      setManMotionPosition(tgID, -1);
                    }
                    if (GUI.Button(new Rect (x+85, y+86, 18, 20), "-", gsButton)) {
                      maj.submanAngleY[tgMotionID] = Math.Max(-180f, maj.submanAngleY[tgMotionID] - moveValue * 100f);
                      setManMotionPosition(tgID, -1);
                    }
                    if (GUI.Button(new Rect (x+105, y+86, 18, 20), "+", gsButton)) {
                      maj.submanAngleY[tgMotionID] = Math.Min(180f, maj.submanAngleY[tgMotionID] + moveValue * 100f);
                      setManMotionPosition(tgID, -1);
                    }
                    sliderValue = GUI.HorizontalSlider(new Rect(x+130, y+91, 150, 20), maj.submanAngleY[tgMotionID], -180f, 180f);
                    if (maj.submanAngleY[tgMotionID] != sliderValue) {
                      maj.submanAngleY[tgMotionID] = Mathf.Round(sliderValue); //整数値にする;sliderValue;
                      setManMotionPosition(tgID, -1);
                    }

                    x = 310;
                    y = 110;
                    GUI.Label(new Rect (x-15, y, 105, 20), "【anal位置】" , gsLabel);
                    maj.analEnabled[tgMotionID] = GUI.Toggle(new Rect (x-5, y+20, 95, 20), maj.analEnabled[tgMotionID], "anal有効化" , gsToggle );
                    if (maj.analEnabled[tgMotionID]) {
                      x = 400;
                      y = 90;
                      GUI.Label(new Rect (x, y+20, 80, 20), "上下: " + Math.Round(maj.analHeight[tgMotionID] * 10000)*0.1 , gsLabel);
                      if (GUI.Button(new Rect (x, y+40, 18, 20), "0", gsButton)) {
                        maj.analHeight[tgMotionID] = 0;
                        setManMotionPosition(tgID, -1);
                      }
                      if (GUI.Button(new Rect (x+20, y+40, 18, 20), "-", gsButton)) {
                        maj.analHeight[tgMotionID] = Math.Max(-0.1f, maj.analHeight[tgMotionID] - moveValue * 0.1f);
                        setManMotionPosition(tgID, -1);
                      }
                      if (GUI.Button(new Rect (x+40, y+40, 18, 20), "+", gsButton)) {
                        maj.analHeight[tgMotionID] = Math.Min(0.1f, maj.analHeight[tgMotionID] + moveValue * 0.1f);
                        setManMotionPosition(tgID, -1);
                      }
                      GUI.Label(new Rect (x+70, y+20, 80, 20), "前後: " + Math.Round(maj.analForward[tgMotionID] * 10000)*0.1 , gsLabel);
                      if (GUI.Button(new Rect (x+70, y+40, 18, 20), "0", gsButton)) {
                        maj.analForward[tgMotionID] = 0;
                        setManMotionPosition(tgID, -1);
                      }
                      if (GUI.Button(new Rect (x+90, y+40, 18, 20), "-", gsButton)) {
                        maj.analForward[tgMotionID] = Math.Max(-0.1f, maj.analForward[tgMotionID] - moveValue * 0.1f);
                        setManMotionPosition(tgID, -1);
                      }
                      if (GUI.Button(new Rect (x+110, y+40, 18, 20), "+", gsButton)) {
                        maj.analForward[tgMotionID] = Math.Min(0.1f, maj.analForward[tgMotionID] + moveValue * 0.1f);
                        setManMotionPosition(tgID, -1);
                      }
                      GUI.Label(new Rect (x+140, y+20, 80, 20), "左右: " + Math.Round(maj.analRight[tgMotionID] * 10000)*0.1 , gsLabel);
                      if (GUI.Button(new Rect (x+140, y+40, 18, 20), "0", gsButton)) {
                        maj.analRight[tgMotionID] = 0;
                        setManMotionPosition(tgID, -1);
                      }
                      if (GUI.Button(new Rect (x+160, y+40, 18, 20), "-", gsButton)) {
                        maj.analRight[tgMotionID] = Math.Max(-0.1f, maj.analRight[tgMotionID] - moveValue * 0.1f);
                        setManMotionPosition(tgID, -1);
                      }
                      if (GUI.Button(new Rect (x+180, y+40, 18, 20), "+", gsButton)) {
                        maj.analRight[tgMotionID] = Math.Min(0.1f, maj.analRight[tgMotionID] + moveValue * 0.1f);
                        setManMotionPosition(tgID, -1);
                      }
                    }

                  }

                    x = 295;
                    y = 155;
                    GUI.Label(new Rect (x, y, 80, 20), "【目顔向き】" , gsLabel);
                    bool maidToCam0 = GUI.Toggle(new Rect(x+80, y, 70, 20), maj.maidToCam[motionMadeState.motionID] != -1, "変更する", gsToggle);
                    if (maidToCam0) {
                      //ONになった場合は現在の状態で初期設定
                      if (maj.maidToCam[motionMadeState.motionID] == -1) {
                        maj.maidToCam[motionMadeState.motionID] = 0;
                        if (maid.body0.boEyeToCam) maj.maidToCam[motionMadeState.motionID] += 1;
                        if (maid.body0.boHeadToCam) maj.maidToCam[motionMadeState.motionID] += 2;
                      }
                      bool maidToCam1 = GUI.Toggle(new Rect(x+150, y, 50, 20), maj.maidToCam[motionMadeState.motionID] == 1 || maj.maidToCam[motionMadeState.motionID] == 3, "目線", gsToggle);
                      bool maidToCam2 = GUI.Toggle(new Rect(x+200, y, 50, 20), maj.maidToCam[motionMadeState.motionID] == 2 || maj.maidToCam[motionMadeState.motionID] == 3, "顔向", gsToggle);
                      int value = maidToCam1 ? 1: 0;
                      if (maidToCam2) value += 2;
                      //トグルが変更された場合は反映する
                      if (maj.maidToCam[motionMadeState.motionID] != value) {
                        maj.maidToCam[motionMadeState.motionID] = value;
                        switch (maj.maidToCam[motionMadeState.motionID]) {
                          case 0: maid.body0.boEyeToCam = false; maid.body0.boHeadToCam = false; break;
                          case 1: maid.body0.boEyeToCam = true; maid.body0.boHeadToCam = false; break;
                          case 2: maid.body0.boEyeToCam = false; maid.body0.boHeadToCam = true; break;
                          case 3: maid.body0.boEyeToCam = true; maid.body0.boHeadToCam = true;  break;
                        }
                      }
                    } else {
                      maj.maidToCam[motionMadeState.motionID] = -1; //変更なし
                    }

                    x = 295;
                    y = 180;
                    GUI.Label(new Rect (x, y, 100, 20), "【kupa遅延】" , gsLabel);
                    string sKupaDelay = maj.kupaDelay[motionMadeState.motionID] < 0 ? "" : (maj.kupaDelay[motionMadeState.motionID] + (maj.kupaDelay[motionMadeState.motionID]==(int)maj.kupaDelay[motionMadeState.motionID]?".0":""));
                    string sKupaDelay2 = GUI.TextField(new Rect(x+90, y, 45, 20), sKupaDelay);
                    if (sKupaDelay != sKupaDelay2) {
                      if (sKupaDelay2 == "") maj.kupaDelay[motionMadeState.motionID] = -1f;
                      else {
                        if (sKupaDelay2.EndsWith(".")) sKupaDelay2 += "0";
                        float fKupaDelay;
                        if (float.TryParse(sKupaDelay2.Replace("..", "."), out fKupaDelay)) maj.kupaDelay[motionMadeState.motionID] = fKupaDelay;
                      }
                    }
                    if (GUI.Button(new Rect (x+141, y, 18, 20), "-", gsButton)) {
                      if (maj.kupaDelay[motionMadeState.motionID] == -1f) maj.kupaDelay[motionMadeState.motionID] = cfgw.majKupaOpenDelay; //空欄ならから減らす初期値
                      maj.kupaDelay[motionMadeState.motionID] = (float)Math.Max(0, Math.Round((maj.kupaDelay[motionMadeState.motionID] - 0.1)*1000)*0.001);
                    }
                    if (GUI.Button(new Rect (x+160, y, 18, 20), "+", gsButton)) {
                      if (maj.kupaDelay[motionMadeState.motionID] == -1f) maj.kupaDelay[motionMadeState.motionID] = cfgw.majKupaOpenDelay; //空欄なら初期値から増やす
                      maj.kupaDelay[motionMadeState.motionID] = (float)Math.Max(0, Math.Round((maj.kupaDelay[motionMadeState.motionID] + 0.1)*1000)*0.001);
                    }

                    y = 205;
                    GUI.Label(new Rect (x, y, 140, 20), "【ボイスセット】" , gsLabel);
                    if (GUI.Button(new Rect (x+140, y, 40, 20), "取得", gsButton)) {
                      //ボイスセット取得
                      maj.mVoiceSet[motionMadeState.motionID] = motionMadeState.editVoiceSetName;
                    }
                    maj.mVoiceSet[motionMadeState.motionID] = GUI.TextField(new Rect(x+5, y+22, 175, 20), maj.mVoiceSet[motionMadeState.motionID]);
                    y += 45;

                    GUI.Label(new Rect (x, y, 140, 20), "【ベースモーション】" , gsLabel);
                    /*if (GUI.Button(new Rect (x+110, y, 40, 20), "再生", gsButton)) {
                      MotionChange(maid, maj.baceMotion[motionMadeState.motionID], true, 0.7f, 1f);
                    }*/
                    if (GUI.Button(new Rect (x+140, y, 40, 20), "取得", gsButton)) {
                      maj.baceMotion[motionMadeState.motionID] = maj.motionName[motionMadeState.motionID];
                    }
                    maj.baceMotion[motionMadeState.motionID] = GUI.TextField(new Rect(x+5, y+22, 175, 20), maj.baceMotion[motionMadeState.motionID]);
                    y += 45;

                    x = 490;
                    y = 180;
                    GUI.Label(new Rect (x-5, y, 90, 20), "【クパ値】" , gsLabel);
                    if (GUI.Button(new Rect (x+70, y, 40, 20), "取得", gsButton)) {
                      //kupa値取得
                      maj.hkupa1[motionMadeState.motionID] = (float)Math.Floor(motionMadeState.hibuSlider1Value);
                      maj.akupa1[motionMadeState.motionID] = (float)Math.Floor(motionMadeState.analSlider1Value);
                      maj.hkupa2[motionMadeState.motionID] = (float)Math.Floor(motionMadeState.hibuSlider2Value);
                      maj.akupa2[motionMadeState.motionID] = (float)Math.Floor(motionMadeState.analSlider2Value);
                    }
                    GUI.Label(new Rect (x+5, y+20, 90, 20), "kupa(動) ： " + maj.hkupa1[motionMadeState.motionID] , gsLabel);
                    GUI.Label(new Rect (x+5, y+40, 90, 20), "anal(動) ： " + maj.akupa1[motionMadeState.motionID] , gsLabel);
                    GUI.Label(new Rect (x+5, y+60, 90, 20), "kupa(停) ： " + maj.hkupa2[motionMadeState.motionID] , gsLabel);
                    GUI.Label(new Rect (x+5, y+80, 90, 20), "anal(停) ：" + maj.akupa2[motionMadeState.motionID] , gsLabel);

                    x = 5;
                    y = 200;
                    GUI.Label(new Rect (x, y, 170, 20), "【抜くモーション】", gsLabel);
                    bool nuku8 = GUI.Toggle(new Rect (x+120, y, 100, 20), (maj.outMotionFlag[motionMadeState.motionID] & 8) == 8, "常時射精" , gsToggle );
                    y += 20;
                    int outMotionFlag = maj.outMotionFlag[motionMadeState.motionID] & 7; //下3ビット
                    GUI.Label(new Rect (x+5, y, 60, 20), "通常時：", gsLabel);
                    bool nuku2 = GUI.Toggle(new Rect (x+55, y, 60, 20), outMotionFlag == 2, "待機", gsToggle );
                    bool nuku1 = GUI.Toggle(new Rect (x+115, y, 60, 20), outMotionFlag == 1, "射精後", gsToggle );
                    bool nuku3 = GUI.Toggle(new Rect (x+175, y, 100, 20), outMotionFlag == 3, "射精後→待機", gsToggle );
                    //bool nuku4 = GUI.Toggle(new Rect (x+190, y, 100, 20), outMotionFlag == 4, "待機→射精後", gsToggle );
                    y += 20;
                    GUI.Label(new Rect (x+5, y, 60, 20), "射精時：", gsLabel);
                    bool nuku16 = GUI.Toggle(new Rect (x+55, y, 160, 20), (maj.outMotionFlag[motionMadeState.motionID] & 16) == 16, "射精の後に待機に遷移", gsToggle );
                    y += 20;
                    GUI.Label(new Rect (x, y, 170, 20), "【挿入モーション】", gsLabel);
                    bool nuku32 = GUI.Toggle(new Rect (x+120, y, 160, 20), (maj.outMotionFlag[motionMadeState.motionID] & 32) == 32, "再挿入モーションなし", gsToggle );
                    y += 25;
                    if (nuku1 || nuku2 || nuku3/* || nuku4*/) {
                      if (nuku1) { if (outMotionFlag != 1) maj.outMotionFlag[motionMadeState.motionID] = 1; }
                      if (nuku2) { if (outMotionFlag != 2) maj.outMotionFlag[motionMadeState.motionID] = 2; }
                      if (nuku3) { if (outMotionFlag != 3) maj.outMotionFlag[motionMadeState.motionID] = 3; }
                      //if (nuku4) { if (outMotionFlag != 4) maj.outMotionFlag[motionMadeState.motionID] = 4; }
                    } else {
                      maj.outMotionFlag[motionMadeState.motionID] = 0; //チェックなし
                    }
                    if (nuku8) maj.outMotionFlag[motionMadeState.motionID] = maj.outMotionFlag[motionMadeState.motionID] | 8;   //4ビットを1に
                    else maj.outMotionFlag[motionMadeState.motionID] = maj.outMotionFlag[motionMadeState.motionID] & 0xF7;      //4ビットを0に
                    if (nuku16) maj.outMotionFlag[motionMadeState.motionID] = maj.outMotionFlag[motionMadeState.motionID] | 16; //5ビットを1に
                    else maj.outMotionFlag[motionMadeState.motionID] = maj.outMotionFlag[motionMadeState.motionID] & 0xEF;      //5ビットを0に
                    if (nuku32) maj.outMotionFlag[motionMadeState.motionID] = maj.outMotionFlag[motionMadeState.motionID] | 32; //6ビットを1に
                    else maj.outMotionFlag[motionMadeState.motionID] = maj.outMotionFlag[motionMadeState.motionID] & 0xDF;      //6ビットを0に

                  if (!showSubMotionUI) { //サブメイド非対応 この中はメインメイドのID tgMotionID を利用

                    GUI.Label(new Rect (x, y, 190, 20), "【快感上昇設定】" , gsLabel);
                    maj.giveSexual[tgMotionID][0] = GUI.Toggle(new Rect (x+5, y+20, 60, 20), maj.giveSexual[tgMotionID][0], "メイド" , gsToggle );
                    maj.giveSexual[tgMotionID][1] = GUI.Toggle(new Rect (x+65, y+20, 60, 20), maj.giveSexual[tgMotionID][1], "男１" , gsToggle );
                    maj.giveSexual[tgMotionID][2] = GUI.Toggle(new Rect (x+125, y+20, 60, 20), maj.giveSexual[tgMotionID][2], "男２" , gsToggle );
                    maj.giveSexual[tgMotionID][3] = GUI.Toggle(new Rect (x+5, y+40, 60, 20), maj.giveSexual[tgMotionID][3], "男３" , gsToggle );
                    maj.giveSexual[tgMotionID][4] = GUI.Toggle(new Rect (x+65, y+40, 60, 20), maj.giveSexual[tgMotionID][4], "男４" , gsToggle );
                    maj.giveSexual[tgMotionID][5] = GUI.Toggle(new Rect (x+125, y+40, 60, 20), maj.giveSexual[tgMotionID][5], "男５" , gsToggle );
                    y += 65;

                    GUI.Label(new Rect (x, y, 190, 20), "【射精タイプ設定】" , gsLabel);
                    for (int i = 0; i < SubMans.Length; i++) {
                      int m = i + 1;
                      GUI.Label(new Rect (x+10, y+20 + i*24, 190, 20), "男" + m + "：" + marksList[maj.syaseiMarks[tgMotionID][i]] , gsLabel);
                      if (GUI.Button(new Rect (x+105, y+20 + i*24, 20, 20), "<", gsButton)) {
                        --maj.syaseiMarks[tgMotionID][i];
                        if (maj.syaseiMarks[tgMotionID][i] < 0) maj.syaseiMarks[tgMotionID][i] = marksList.Length - 1;
                      }
                      if (GUI.Button(new Rect (x+130, y+20 + i*24, 20, 20), ">", gsButton)) {
                        ++maj.syaseiMarks[tgMotionID][i];
                        if (maj.syaseiMarks[tgMotionID][i] >= marksList.Length) maj.syaseiMarks[tgMotionID][i] = 0;
                      }
                    }

                    x = 185;
                    y = 285;
                    GUI.Label(new Rect (x, y, 190, 20), "【装備アイテム】" , gsLabel);
                    bool bItem = GUI.Toggle(new Rect (x+10, y+20, 70, 20), maj.itemSet[tgMotionID][0], "バイブ" , gsToggle );
                    if (maj.itemSet[tgMotionID][0] != bItem) { maj.itemSet[tgMotionID][0] = bItem; setMotionItem(tgID); }
                    bItem = GUI.Toggle(new Rect (x+110, y+20, 90, 20), maj.itemSet[tgMotionID][1], "バイブ(手)" , gsToggle );
                    if (maj.itemSet[tgMotionID][1] != bItem) { maj.itemSet[tgMotionID][1] = bItem; setMotionItem(tgID); }

                    bItem = GUI.Toggle(new Rect (x+10, y+40, 70, 20), maj.itemSet[tgMotionID][2], "Aバイブ" , gsToggle );
                    if (maj.itemSet[tgMotionID][2] != bItem) { maj.itemSet[tgMotionID][2] = bItem; setMotionItem(tgID); }
                    bItem = GUI.Toggle(new Rect (x+110, y+40, 90, 20), maj.itemSet[tgMotionID][3], "Aバイブ(手)" , gsToggle );
                    if (maj.itemSet[tgMotionID][3] != bItem) { maj.itemSet[tgMotionID][3] = bItem; setMotionItem(tgID); }

                    bItem = GUI.Toggle(new Rect (x+10, y+60, 80, 20), maj.itemSet[tgMotionID][5], "拘束(手)" , gsToggle );
                    if (bItem) maj.itemSet[tgMotionID][7] = false; //排他制御
                    if (maj.itemSet[tgMotionID][5] != bItem) { maj.itemSet[tgMotionID][5] = bItem; setMotionItem(tgID); }
                    bItem = GUI.Toggle(new Rect (x+110, y+60, 80, 20), maj.itemSet[tgMotionID][6], "拘束(足)" , gsToggle );
                    if (maj.itemSet[tgMotionID][6] != bItem) { maj.itemSet[tgMotionID][6] = bItem; setMotionItem(tgID); }

                    bItem = GUI.Toggle(new Rect (x+10, y+80, 100, 20), maj.itemSet[tgMotionID][4], "双頭バイブ" , gsToggle );
                    if (maj.itemSet[tgMotionID][4] != bItem) { maj.itemSet[tgMotionID][4] = bItem; setMotionItem(tgID); }
                    bItem = GUI.Toggle(new Rect (x+110, y+80, 60, 20), maj.itemSet[tgMotionID][7], "磔" , gsToggle );
                    if (bItem) maj.itemSet[tgMotionID][5] = false; //排他制御
                    if (maj.itemSet[tgMotionID][7] != bItem) { maj.itemSet[tgMotionID][7] = bItem; setMotionItem(tgID); }
                    /*
                    maj.itemSet[tgMotionID][8] = GUI.Toggle(new Rect (380, y+80, 100, 20), maj.itemSet[tgMotionID][8], "ディルド台" , gsToggle );
                    maj.itemSet[tgMotionID][9] = GUI.Toggle(new Rect (480, y+80, 100, 20), maj.itemSet[tgMotionID][9], "三角木馬" , gsToggle );
                    */

                    x = 185;
                    y += 105;
                    GUI.Label(new Rect (x, y, 60, 20), "【男1】" , gsLabel);
                    y += 20;
                    bItem = GUI.Toggle(new Rect (x+10, y, 70, 20), maj.itemSet[tgMotionID][10], "バイブ" , gsToggle );
                    if (maj.itemSet[tgMotionID][10] != bItem) { maj.itemSet[tgMotionID][10] = bItem; setManMotionItem(tgID); }
                    bItem = GUI.Toggle(new Rect (x+75, y, 70, 20), maj.itemSet[tgMotionID][11], "Aバイブ" , gsToggle );
                    if (maj.itemSet[tgMotionID][11] != bItem) { maj.itemSet[tgMotionID][11] = bItem; setManMotionItem(tgID); }
                    bItem = GUI.Toggle(new Rect (x+145, y, 70, 20), maj.itemSet[tgMotionID][12], "電マ" , gsToggle );
                    if (maj.itemSet[tgMotionID][12] != bItem) { maj.itemSet[tgMotionID][12] = bItem; setManMotionItem(tgID); }
                    y += 25;
                    GUI.Label(new Rect (x, y, 60, 20), "【男2】" , gsLabel);
                    y += 20;
                    bItem = GUI.Toggle(new Rect (x+10, y, 70, 20), maj.itemSet[tgMotionID][15], "バイブ" , gsToggle );
                    if (maj.itemSet[tgMotionID][15] != bItem) { maj.itemSet[tgMotionID][15] = bItem; setManMotionItem(tgID); }
                    bItem = GUI.Toggle(new Rect (x+75, y, 70, 20), maj.itemSet[tgMotionID][16], "Aバイブ" , gsToggle );
                    if (maj.itemSet[tgMotionID][16] != bItem) { maj.itemSet[tgMotionID][16] = bItem; setManMotionItem(tgID); }
                    bItem = GUI.Toggle(new Rect (x+145, y, 70, 20), maj.itemSet[tgMotionID][17], "電マ" , gsToggle );
                    if (maj.itemSet[tgMotionID][17] != bItem) { maj.itemSet[tgMotionID][17] = bItem; setManMotionItem(tgID); }

                    x = 390;
                    y = 295;
                    GUI.Label(new Rect (x, y, 150, 20), "【設置アイテム】", gsLabel);
                    y += 20;

                    if (GUI.Button(new Rect (x+10, y, 20, 20), "<", gsButton)) {
                      --maj.prefabSet[tgMotionID];
                      if (maj.prefabSet[tgMotionID] < 0) maj.prefabSet[tgMotionID] = prefabList[0].Length - 1;
                      addMotionPrefab(tgID, tgMotionID);
                    }
                    if (GUI.Button(new Rect (x+35, y, 20, 20), ">", gsButton)) {
                      ++maj.prefabSet[tgMotionID];
                      if (maj.prefabSet[tgMotionID] >= prefabList[0].Length) maj.prefabSet[tgMotionID] = 0;
                      addMotionPrefab(tgID, tgMotionID);
                    }
                    GUI.Label(new Rect (x+60, y, 150, 20), prefabList[0][maj.prefabSet[tgMotionID]] , gsLabel);
                    y += 25;

                    GUI.Label(new Rect (x+10, y, 60, 20), "X: "+Math.Round(maj.prefabSetX[tgMotionID]*100) , gsLabel);
                    float prefabSetX = GUI.HorizontalSlider(new Rect(x+50, y+5, 160, 15), maj.prefabSetX[tgMotionID], -1.5f, 1.5f);
                    if (maj.prefabSetX[tgMotionID] != prefabSetX) {
                      maj.prefabSetX[tgMotionID] = prefabSetX;
                      setMotionPrefabPosition(tgID, tgMotionID, false);
                    }
                    y += 20;
                    GUI.Label(new Rect (x+10, y, 60, 20), "Y: "+Math.Round(maj.prefabSetY[tgMotionID]*100) , gsLabel);
                    float prefabSetY = GUI.HorizontalSlider(new Rect(x+50, y+5, 160, 15), maj.prefabSetY[tgMotionID], -1.5f, 1.5f);
                    if (maj.prefabSetY[tgMotionID] != prefabSetY) {
                      maj.prefabSetY[tgMotionID] = prefabSetY;
                      setMotionPrefabPosition(tgID, tgMotionID, false);
                    }
                    y += 20;
                    GUI.Label(new Rect (x+10, y, 60, 20), "Z: "+Math.Round(maj.prefabSetZ[tgMotionID]*100) , gsLabel);
                    float prefabSetZ = GUI.HorizontalSlider(new Rect(x+50, y+5, 160, 15), maj.prefabSetZ[tgMotionID], -1.5f, 1.5f);
                    if (maj.prefabSetZ[tgMotionID] != prefabSetZ) {
                      maj.prefabSetZ[tgMotionID] = prefabSetZ;
                      setMotionPrefabPosition(tgID, tgMotionID, false);
                    }
                    y += 20;
                    GUI.Label(new Rect (x+10, y, 60, 20), "R: "+Math.Round(maj.prefabSetR[tgMotionID]) , gsLabel);
                    float prefabSetR = GUI.HorizontalSlider(new Rect(x+50, y+5, 160, 15), maj.prefabSetR[tgMotionID], -180f, 180f);
                    if (maj.prefabSetR[tgMotionID] != prefabSetR) {
                      maj.prefabSetR[tgMotionID] = prefabSetR;
                      setMotionPrefabPosition(tgID, tgMotionID, false);
                    }
                    y += 20;
                    //設置アイテム移動ボタン
                    x += 10;
                    GUI.Label(new Rect (x+10, y, 60, 20), "X:", gsLabel);
                    if (GUI.Button(new Rect (x+30, y, 18, 20), "0", gsButton)) {
                      maj.prefabSetX[tgMotionID] = 0;
                      setMotionPrefabPosition(tgID, tgMotionID, false);
                    }
                    if (GUI.Button(new Rect (x+55, y, 18, 20), "-", gsButton)) {
                      maj.prefabSetX[tgMotionID] -= 0.01f;
                      setMotionPrefabPosition(tgID, tgMotionID, false);
                    }
                    if (GUI.Button(new Rect (x+75, y, 18, 20), "+", gsButton)) {
                      maj.prefabSetX[tgMotionID] += 0.01f;
                      setMotionPrefabPosition(tgID, tgMotionID, false);
                    }
                    x += 100;
                    GUI.Label(new Rect (x+10, y, 60, 20), "Y:", gsLabel);
                    if (GUI.Button(new Rect (x+30, y, 18, 20), "0", gsButton)) {
                      maj.prefabSetY[tgMotionID] = 0;
                      setMotionPrefabPosition(tgID, tgMotionID, false);
                    }
                    if (GUI.Button(new Rect (x+55, y, 18, 20), "-", gsButton)) {
                      maj.prefabSetY[tgMotionID] -= 0.01f;
                      setMotionPrefabPosition(tgID, tgMotionID, false);
                    }
                    if (GUI.Button(new Rect (x+75, y, 18, 20), "+", gsButton)) {
                      maj.prefabSetY[tgMotionID] += 0.01f;
                      setMotionPrefabPosition(tgID, tgMotionID, false);
                    }
                    x -= 100;
                    y += 23;
                    GUI.Label(new Rect (x+10, y, 60, 20), "Z:", gsLabel);
                    if (GUI.Button(new Rect (x+30, y, 18, 20), "0", gsButton)) {
                      maj.prefabSetZ[tgMotionID] = 0;
                      setMotionPrefabPosition(tgID, tgMotionID, false);
                    }
                    if (GUI.Button(new Rect (x+55, y, 18, 20), "-", gsButton)) {
                      maj.prefabSetZ[tgMotionID] -= 0.01f;
                      setMotionPrefabPosition(tgID, tgMotionID, false);
                    }
                    if (GUI.Button(new Rect (x+75, y, 18, 20), "+", gsButton)) {
                      maj.prefabSetZ[tgMotionID] += 0.01f;
                      setMotionPrefabPosition(tgID, tgMotionID, false);
                    }
                    x += 100;
                    GUI.Label(new Rect (x+10, y, 60, 20), "R:", gsLabel);
                    if (GUI.Button(new Rect (x+30, y, 18, 20), "0", gsButton)) {
                      maj.prefabSetR[tgMotionID] = 0;
                      setMotionPrefabPosition(tgID, tgMotionID, false);
                    }
                    if (GUI.Button(new Rect (x+55, y, 18, 20), "-", gsButton)) {
                      maj.prefabSetR[tgMotionID] -= 1f;
                      setMotionPrefabPosition(tgID, tgMotionID, false);
                    }
                    if (GUI.Button(new Rect (x+75, y, 18, 20), "+", gsButton)) {
                      maj.prefabSetR[tgMotionID] += 1f;
                      setMotionPrefabPosition(tgID, tgMotionID, false);
                    }
                    //x -= 110;

                    /*
                    GUI.Label(new Rect (205, 90, 190, 20), "左手アタッチ：" + boneList[maj.iTargetLH[tgMotionID]][1] , gsLabel);
                    if (GUI.Button(new Rect (350, 90, 20, 20), "<", gsButton)) {
                      --maj.iTargetLH[tgMotionID];
                      if (maj.iTargetLH[tgMotionID] < 0) maj.iTargetLH[tgMotionID] = 6;
                    }
                    if (GUI.Button(new Rect (375, 90, 20, 20), ">", gsButton)) {
                      ++maj.iTargetLH[tgMotionID];
                      if (maj.iTargetLH[tgMotionID] > 6) maj.iTargetLH[tgMotionID] = 0;
                    }

                    GUI.Label(new Rect (205, 115, 190, 20), "右手アタッチ：" + boneList[maj.iTargetRH[tgMotionID]][1] , gsLabel);
                    if (GUI.Button(new Rect (350, 115, 20, 20), "<", gsButton)) {
                      --maj.iTargetRH[tgMotionID];
                      if (maj.iTargetRH[tgMotionID] < 0) maj.iTargetRH[tgMotionID] = 6;
                    }
                    if (GUI.Button(new Rect (375, 115, 20, 20), ">", gsButton)) {
                      ++maj.iTargetRH[tgMotionID];
                      if (maj.iTargetRH[tgMotionID] > 6) maj.iTargetRH[tgMotionID] = 0;
                    }
                    */

                  }
                    GUI.EndScrollView();

                    //GUI.Label(new Rect (0, 290, 620, 20), "――――――――――――――――――――――――――――――――――――――――――――――――", gsLabel2);
                    GUI.DrawTexture(new Rect(1, 328, 618, 1), guiLineTexture, ScaleMode.StretchToFill, true, 0);

                    //GUI.Label(new Rect (5, 310, 400, 20), "■以下はモーションアジャスト設定のサポート用" , gsLabel);

                    GUI.Label(new Rect (5, 330, 200, 20), showSubMotionUI?"【ボイスセット】サブメイド":"【ボイスセット】", gsLabel);
                    y = 355;
                    if (motionMadeState.editVoiceSetName != "") {
                      if (GUI.Button(new Rect (10, y, 40, 20), "解除", gsButton)) {
                        motionMadeState.editVoiceSetName = "";
                        motionMadeState.editVoiceSet = new List<string[]>();
                      }
                      GUI.Label(new Rect (55, y, 150, 20), motionMadeState.editVoiceSetName , gsLabelY);
                      y += 22;
                    }

                    int h1 = evsFiles.Count * 22;
                    if (motionMadeState.editVoiceSetName != "") h1 += 30;
                    if (h1 < 445 - y) h1 = 445 - y;
                    Rect scrlRect1    = new Rect(10, y, 190, 445 - y);
                    Rect contentRect1 = new Rect(0, 0, 170, h1);
                    vsScrollPos1 = GUI.BeginScrollView(scrlRect1, vsScrollPos1, contentRect1, false, true );
                    y = 0;

                    foreach (string f in evsFiles) {
                      string FileName = f.Replace("evs_", "").Replace(".xml", "");
                      if (GUI.Button(new Rect (0, y, 170, 20), FileName, gsButton)) {
                        voiceSetLoad(f,motionMaidID);
                      }
                      y += 22;
                    }
                    GUI.EndScrollView();


                    GUI.Label(new Rect (205, 330, 200, 20), "【メインメイドを移動】" , gsLabel);

                    GUI.Label(new Rect (210, 350, 95, 20), "移動距離：" + moveValue * 100 , gsLabel);
                    float _moveValue = GUI.HorizontalSlider(new Rect(215, 370, 160, 15), (float)Math.Sqrt(moveValue/0.3f), (float)Math.Sqrt(0.1f/30f), 1.0f); //スライダの値は0～1をSqrtした値
                    _moveValue = _moveValue*_moveValue*0.3f; //スライダの値をSqrtして0.3倍にする
                    if (moveValue != _moveValue) { moveValue = (float)Math.Round(_moveValue, _moveValue < 0.01f ? 3 : 2, MidpointRounding.ToEven); }

                    vm = maid.transform.position;
                    vml = maid.transform.localPosition;
                    em = maid.transform.eulerAngles;
                    if (GUI.Button(new Rect (210, 395, 25, 20), "X↑", gsButton)) {
                      MaidMove(tgID, "px", moveValue, true);
                    }
                    if (GUI.Button(new Rect (240, 395, 25, 20), "Y↑", gsButton)) {
                      MaidMove(tgID, "py", moveValue, true);
                    }
                    if (GUI.Button(new Rect (270, 395, 25, 20), "Z↑", gsButton)) {
                      MaidMove(tgID, "pz", moveValue, true);
                    }
                    if (GUI.Button(new Rect (300, 395, 50, 20), "集合", gsButton)) {
                      foreach (int maidID in vmId) {
                        if (maidID != tgID && LinkMaidCheck(tgID, maidID)) {
                          stockMaids[maidID].mem.transform.position = maid.transform.position;
                          stockMaids[maidID].mem.transform.eulerAngles = maid.transform.eulerAngles;
                          maidsState[maidID].majPositionBak.x = tgMaidState.majPositionBak.x;
                          maidsState[maidID].majPositionBak.y = tgMaidState.majPositionBak.y;
                          maidsState[maidID].majPositionBak.z = tgMaidState.majPositionBak.z;
                          maidsState[maidID].majAngleYBak = tgMaidState.majAngleYBak;
                        }
                      }
                      for (int i = 0; i < SubMans.Length; i++) {
                        if (!getSubMan(i).Visible || MansTg[i] != tgID) continue;
                        getSubMan(i).transform.position = maid.transform.position;
                        getSubMan(i).transform.eulerAngles = maid.transform.eulerAngles;
                      }
                    }

                    if (GUI.Button(new Rect (210, 420, 25, 20), "X↓", gsButton)) {
                      MaidMove(tgID, "px", -moveValue, true);
                    }
                    if (GUI.Button(new Rect (240, 420, 25, 20), "Y↓", gsButton)) {
                      MaidMove(tgID, "py", -moveValue, true);
                    }
                    if (GUI.Button(new Rect (270, 420, 25, 20), "Z↓", gsButton)) {
                      MaidMove(tgID, "pz", -moveValue, true);
                    }
                    if (GUI.Button(new Rect (300, 420, 50, 20), "原点", gsButton)) {
                      foreach (int maidID in vmId) {
                        if (maidID != tgID && !LinkMaidCheck(tgID, maidID)) continue;
                        stockMaids[maidID].mem.transform.position = new Vector3(0f, 0f, 0f);
                        maidsState[maidID].majPositionBak.x = 0f;
                        maidsState[maidID].majPositionBak.y = 0f;
                        maidsState[maidID].majPositionBak.z = 0f;
                      }
                      for (int i = 0; i < SubMans.Length; i++) {
                        if (!getSubMan(i).Visible || MansTg[i] != tgID) continue;
                        getSubMan(i).transform.position = new Vector3(0f, 0f, 0f);
                      }
                    }


                    GUI.Label(new Rect (385, 330, 200, 20), showSubMotionUI?"【クパ値設定】サブメイド":"【クパ値設定】" , gsLabel);
                    if (GUI.Button(new Rect (570, 330, 40, 20), "取得", gsButton)) {
                      maj.hkupa1[motionMadeState.motionID] = (float)Math.Floor(motionMadeState.hibuSlider1Value);
                      maj.akupa1[motionMadeState.motionID] = (float)Math.Floor(motionMadeState.analSlider1Value);
                      maj.hkupa2[motionMadeState.motionID] = (float)Math.Floor(motionMadeState.hibuSlider2Value);
                      maj.akupa2[motionMadeState.motionID] = (float)Math.Floor(motionMadeState.analSlider2Value);
                    }

                    GUI.Label(new Rect (385, 355, 90, 20), "kupa(動) ： " + Math.Floor(motionMadeState.hibuSlider1Value) , gsLabel);
                    motionMadeState.hibuSlider1Value = GUI.HorizontalSlider(new Rect(475, 360, 140, 20), motionMadeState.hibuSlider1Value, 0.0F, 100.0F);
                    GUI.Label(new Rect (385, 375, 90, 20), "anal(動) ： " + Math.Floor(motionMadeState.analSlider1Value) , gsLabel);
                    motionMadeState.analSlider1Value = GUI.HorizontalSlider(new Rect(475, 380, 140, 20), motionMadeState.analSlider1Value, 0.0F, 100.0F);

                    GUI.Label(new Rect (385, 400, 90, 20), "kupa(停) ： " + Math.Floor(motionMadeState.hibuSlider2Value) , gsLabel);
                    motionMadeState.hibuSlider2Value = GUI.HorizontalSlider(new Rect(475, 405, 140, 20), motionMadeState.hibuSlider2Value, 0.0F, 100.0F);
                    GUI.Label(new Rect (385, 420, 90, 20), "anal(停) ： " + Math.Floor(motionMadeState.analSlider2Value) , gsLabel);
                    motionMadeState.analSlider2Value = GUI.HorizontalSlider(new Rect(475, 425, 140, 20), motionMadeState.analSlider2Value, 0.0F, 100.0F);

                  }
        }

        #if EmpiresLife
        //エンパイアズライフ設定画面
        private void WindowCallback3_7(Maid maid) {
            int x = 0;
            int y = 0;

              x = 0;
              y = 0;
              scKeyOff = GUI.Toggle(new Rect(420, 5, 140, 20), scKeyOff, "ショートカット無効", gsToggle);

              x = 5;
              y = 40;

              if (GUI.Button(new Rect (5, y, 110, 20), "背景情報取得", gsButton)) {
                if(el_Overwrite || ELS.bgCode == ""){
                  ELS.bgCode = GameMain.Instance.BgMgr.GetBGName();
                  ELS.bgName = ELS.bgCode;
                  ELS.timeZone = GameMain.Instance.CharacterMgr.status.GetFlag("時間帯") - 2;
                  LifeSceneLoad(ELS.bgCode);
                } else {
                  elErrer = 3;
                }
              }
              el_Overwrite = GUI.Toggle(new Rect(125, y, 70, 20), el_Overwrite, "上書／ｸﾘｱ", gsToggle);


              y += 25;
              GUI.Label(new Rect (5, y, 180, 20), "背景：" + ELS.bgName , gsLabel);

              y += 25;
              if (GUI.Button(new Rect (5, y, 40, 20), timeText[ELS.timeZone], gsButton)) {
                ++ELS.timeZone;
                if(ELS.timeZone > 2)ELS.timeZone = 0;
              }

              if (GUI.Button(new Rect (55, y, 55, 20), "クリア", gsButton)) {
                if(el_Overwrite){
                  ELS = new EmpiresLifeScene_Xml();
                }else{
                  elErrer = 3;
                }
              }
              //XMLファイルに保存する
              if (GUI.Button(new Rect (120, y, 55, 20), "保存", gsButton)) {
                LifeSceneSave();
                LifeSceneLoad();
              }

              y += 30;
              if(elErrer != 0){
                if (GUI.Button(new Rect (5, y, 20, 20), "x", gsButton)) {
                  elErrer = 0;
                }
                GUI.Label(new Rect (30, y, 170, 60), elErrerText[elErrer], gsLabelErr);
              }
              y += 30;


              GUI.Label(new Rect (5, y, 55, 20), "【ｼｰﾝ名】" , gsLabel);
              ELS.bgName = GUI.TextField(new Rect(70, y, 130, 20), ELS.bgName);
              y += 25;

              GUI.Label(new Rect (5, y, 55, 20), "【BGM】" , gsLabel);
              ELS.bgm = GUI.TextField(new Rect(70, y, 130, 20), ELS.bgm);
              y += 30;

              //初期カメラ位置
              if (GUI.Button(new Rect (5, y, 180, 20), "初期カメラ位置を設定", gsButton)) {
                ELS.cameraPos = mainCamera.transform.position;
                ELS.cameraEul = mainCamera.transform.eulerAngles;
              }
              y += 25;
              GUI.Label(new Rect (5, y, 200, 20), "【位置】 X:" + Math.Round(ELS.cameraPos.x, 2) + " Y:" + Math.Round(ELS.cameraPos.y, 2) + " Z:" + Math.Round(ELS.cameraPos.z, 2), gsLabel);
              y += 20;
              GUI.Label(new Rect (5, y, 200, 20), "【向き】 X:" + Math.Round(ELS.cameraEul.x, 2) + " Y:" + Math.Round(ELS.cameraEul.y, 2) + " Z:" + Math.Round(ELS.cameraEul.z, 2), gsLabel);


              //ライフセット一覧
              y += 30;
              GUI.Label(new Rect (5, y, 200, 20), "【登録済みシーン一覧】" , gsLabel);

              y += 20;
              int h1 = elsFiles.Count * 22;
              if(h1 < 445 - y)h1 = 445 - y;
              Rect scrlRect1    = new Rect(5, y, 200, 445 - y);
              Rect contentRect1 = new Rect(0, 0, 175, h1);
              vsScrollPos1 = GUI.BeginScrollView(scrlRect1, vsScrollPos1, contentRect1, false, true );

              y = 0;
              foreach(EmpiresLifeScene_Xml _els in elsList){
                if (GUI.Button(new Rect (0, y, 175, 20), _els.bgName, gsButton)) {
                  ELS = _els;
                }
                y += 22;
              }
              GUI.EndScrollView();



              //ライフセット編集画面
              x = 220;
              y = 50;

              int h2 = ELE.motionSet.Count * 65 + 30;
              if(h2 < 445 - y)h2 = 445 - y;

              Rect scrlRect2    = new Rect(x, y, 400, 445 - y);
              Rect contentRect2 = new Rect(0, 0, 380, h2);
              vsScrollPos2 = GUI.BeginScrollView( scrlRect2, vsScrollPos2, contentRect2, false, true );

              y = 0;
              for (int i = 0; i < ELE.motionSet.Count; i++){

                GUI.Label(new Rect (0, 0 + y, 110, 20), "モーションセット" , gsLabel);
                ELE.motionSet[i] = GUI.TextField(new Rect(110, 0 + y, 260, 20), ELE.motionSet[i]);

                GUI.Label(new Rect (10, 25 + y, 200, 20), MotionNameChange(MSX.saveMotionSet[msCategory][i]) , gsLabel);

                if (GUI.Button(new Rect (215, 25 + y, 50, 20), "取得", gsButton)) {
                  string motion = stockMaids[tgID].mem.body0.LastAnimeFN;
                  motion = regZeccyouBackup.Match(motion).Groups[1].Value;  // 「 - Que…」を除く
                  motion = Regex.Replace(motion, "_[23](?!ana)(?!p_)(?!vibe)", "_1");
                  motion = Regex.Replace(motion, @"[a-zA-Z][0-9][0-9]", "");
                  MSX.saveMotionSet[msCategory][i] = motion;
                }
                if (GUI.Button(new Rect (270, 25 + y, 50, 20), "再生", gsButton)) {
                  MotionChange(maid, MSX.saveMotionSet[msCategory][i], true, 0.7f, 1f);
                  ManMotionChange(tgID, true, 0.7f, 1f);
                }
                if (GUI.Button(new Rect (325, 25 + y, 50, 20), "削除", gsButton)) {
                  MSX.saveMotionSet[msCategory].RemoveAt(i);
                }
                GUI.Label(new Rect (5, 45 + y, 370, 20), "―――――――――――――――――――――――――――――", gsLabel2);

                y += 65;
              }

              if (GUI.Button(new Rect (315, 0 + y, 60, 20), "追加", gsButton)) {
                MSX.saveMotionSet[msCategory].Add("");
              }

              GUI.EndScrollView();
        }
        #endif

        //エロステータス画面
        private void WindowCallback3_8(Maid maid) {

              GUI.Label(new Rect (5, 30, 190, 20), "【エロステータス（β版）】" , gsLabel);

              GUI.Label(new Rect (10, 60, 300, 20), "クリトリス肥大度：" + Math.Round(maidsState[tgID].cliHidai, 1,  MidpointRounding.AwayFromZero) , gsLabel);
              //GUI.Label(new Rect (10, 80, 300, 20), "乳首肥大度　　　：" + Math.Round(maidsState[tgID].chikubiHidai, 1,  MidpointRounding.AwayFromZero) , gsLabel);

              GUI.Label(new Rect (10, 110, 300, 20), "トータル絶頂数：" + maidsState[tgID].orgTotal + " 回" , gsLabel);
              GUI.Label(new Rect (10, 130, 300, 20), "最大連続絶頂数：" + maidsState[tgID].orgMax + " 回" , gsLabel);

              GUI.Label(new Rect (10, 160, 300, 20), "中出し回数（膣）　：" + maidsState[tgID].syaseiTotal1[0] + " 回（" + Math.Round(maidsState[tgID].syaseiTotal2[0], 2,  MidpointRounding.AwayFromZero) + " ml）" , gsLabel);
              GUI.Label(new Rect (10, 180, 300, 20), "中出し回数（anal）：" + maidsState[tgID].syaseiTotal1[1] + " 回（" + Math.Round(maidsState[tgID].syaseiTotal2[1], 2,  MidpointRounding.AwayFromZero) + " ml）"  , gsLabel);
              GUI.Label(new Rect (10, 200, 300, 20), "精飲回数　　　　　：" + maidsState[tgID].syaseiTotal1[2] + " 回（" + Math.Round(maidsState[tgID].syaseiTotal2[2], 2,  MidpointRounding.AwayFromZero) + " ml）"  , gsLabel);
              GUI.Label(new Rect (10, 220, 300, 20), "外出し回数　　　　：" + maidsState[tgID].syaseiTotal1[3] + " 回（" + Math.Round(maidsState[tgID].syaseiTotal2[3], 2,  MidpointRounding.AwayFromZero) + " ml）"  , gsLabel);

              GUI.Label(new Rect (10, 250, 300, 20), "潮吹き回数：" + maidsState[tgID].sioTotal1 + " 回（" + Math.Round(maidsState[tgID].sioTotal2, 2,  MidpointRounding.AwayFromZero) + " ml）" , gsLabel);
              GUI.Label(new Rect (10, 270, 300, 20), "失禁回数　：" + maidsState[tgID].nyoTotal1 + " 回（" + Math.Round(maidsState[tgID].nyoTotal2, 1,  MidpointRounding.AwayFromZero) + " ml）"  , gsLabel);

              GUI.Label(new Rect (10, 300, 300, 20), "失神回数　：" + maidsState[tgID].stanTotal + " 回" , gsLabel);
              GUI.Label(new Rect (10, 320, 300, 20), "子宮脱回数：" + maidsState[tgID].uDatsuTotal + " 回" , gsLabel);


              GUI.Label(new Rect (10, 350, 300, 20), "潮：" + maidsState[tgID].sioVolume , gsLabel);
              GUI.Label(new Rect (10, 370, 300, 20), "尿：" + maidsState[tgID].nyoVolume , gsLabel);

              /*自分用
              GUI.Label(new Rect (10, 400, 300, 20), "マウス：" + mouse_move , gsLabel);
              GUI.Label(new Rect (10, 420, 300, 20), "おさわりポイント：" + hitName , gsLabel);

              GUI.Label(new Rect (310, 60, 300, 20), "快感レベル：" + maidsState[tgID].kaikanLevel , gsLabel);
              GUI.Label(new Rect (310, 80, 300, 20), "スタミナ：" + maidsState[tgID].maidStamina , gsLabel);
              GUI.Label(new Rect (310, 100, 300, 20), "勃起値：" + maidsState[tgID].bokkiValue1 , gsLabel);


              var angleZ = 360 - maidsState[tgID].maidHead.transform.rotation.eulerAngles.z;
              var kz = Mathf.Cos(angleZ * Mathf.Deg2Rad);
              GUI.Label(new Rect (310, 150, 300, 20), "頭Z：" + maidsState[tgID].maidHead.transform.rotation.eulerAngles.z , gsLabel);
              GUI.Label(new Rect (310, 170, 300, 20), "頭加算：" + kz , gsLabel);

              angleZ = 360 - maidsState[tgID].maidXxx.transform.rotation.eulerAngles.z;
              kz = Mathf.Cos(angleZ * Mathf.Deg2Rad);
              GUI.Label(new Rect (310, 200, 300, 20), "股Z：" + maidsState[tgID].maidXxx.transform.rotation.eulerAngles.z , gsLabel);
              GUI.Label(new Rect (310, 220, 300, 20), "股加Z：" + kz , gsLabel);

              angleZ = 360 - maidsState[tgID].maidXxx.transform.rotation.eulerAngles.y;
              kz = Mathf.Cos(angleZ * Mathf.Deg2Rad);
              GUI.Label(new Rect (310, 250, 300, 20), "股Y：" + maidsState[tgID].maidXxx.transform.rotation.eulerAngles.y , gsLabel);
              GUI.Label(new Rect (310, 270, 300, 20), "股加Y：" + kz , gsLabel);

              GUI.Label(new Rect (310, 300, 300, 20), "股X：" + maidsState[tgID].maidXxx.transform.rotation.eulerAngles.x , gsLabel);

              */
        }


        //乳首設定登録画面
        private void WindowCallback3_9(Maid maid) {
            MaidState mState = maidsState[tgID];
            int y = 0;

              y = 35;
              GUI.Label(new Rect (5, y, 200, 20), "【乳首設定の登録（" + chikubiText[cv] + "）】" , gsLabel);
              y += 25;

              mState.chikubiEnabled = GUI.Toggle(new Rect(10, y, 150, 20), mState.chikubiEnabled, "乳首操作の有効化", gsToggle);

              if (mState.chikubiEnabled) {
                mState.chikubiBokkiEnabled = GUI.Toggle(new Rect(160, y, 100, 20), mState.chikubiBokkiEnabled, "勃起の有無", gsToggle);

                y = 50;
                if (GUI.Button(new Rect (320, y, 80, 30), "着衣時", gsButton)) {
                  cv = 0;
                }
                if (GUI.Button(new Rect (410, y, 80, 30), "裸時", gsButton)) {
                  cv = 1;
                }
                y += 40;

                GUI.Label(new Rect (5, y, 100, 20), "乳首基本：" + Math.Floor(mState.tits_chikubi_def[cv] * 100) , gsLabel);
                mState.tits_chikubi_def[cv] = GUI.HorizontalSlider(new Rect(105, y+5, 190, 20), mState.tits_chikubi_def[cv], 0.0F, 2.0F);
                y += 20;

                GUI.Label(new Rect (5, y, 100, 20), "乳首尖：" + Math.Floor(mState.tits_chikubi_perky[cv] * 100) , gsLabel);
                mState.tits_chikubi_perky[cv] = GUI.HorizontalSlider(new Rect(105, y+5, 190, 20), mState.tits_chikubi_perky[cv], 0.0F, 2.0F);
                y += 20;

                GUI.Label(new Rect (5, y, 100, 20), "乳首牛：" + Math.Floor(mState.tits_chikubi_cow[cv] * 100) , gsLabel);
                mState.tits_chikubi_cow[cv] = GUI.HorizontalSlider(new Rect(105, y+5, 190, 20), mState.tits_chikubi_cow[cv], 0.0F, 2.0F);
                y += 20;

                GUI.Label(new Rect (5, y, 100, 20), "乳首凹：" + Math.Floor(mState.tits_chikubi_observe[cv] * 100) , gsLabel);
                mState.tits_chikubi_observe[cv] = GUI.HorizontalSlider(new Rect(105, y+5, 190, 20), mState.tits_chikubi_observe[cv], 0.0F, 2.0F);
                y += 20;

                GUI.Label(new Rect (5, y, 100, 20), "乳首膨１：" + Math.Floor(mState.tits_chikubi_wide[cv] * 100) , gsLabel);
                mState.tits_chikubi_wide[cv] = GUI.HorizontalSlider(new Rect(105, y+5, 190, 20), mState.tits_chikubi_wide[cv], 0.0F, 2.0F);
                y += 20;

                GUI.Label(new Rect (5, y, 100, 20), "乳首膨２：" + Math.Floor(mState.tits_chikubi_ultrawide[cv] * 100) , gsLabel);
                mState.tits_chikubi_ultrawide[cv] = GUI.HorizontalSlider(new Rect(105, y+5, 190, 20), mState.tits_chikubi_ultrawide[cv], 0.0F, 2.0F);
                y += 20;

                GUI.Label(new Rect (5, y, 100, 20), "乳首長さ：" + Math.Floor(mState.tits_chikubi_ultralong[cv] * 100) , gsLabel);
                mState.tits_chikubi_ultralong[cv] = GUI.HorizontalSlider(new Rect(105, y+5, 190, 20), mState.tits_chikubi_ultralong[cv], 0.0F, 2.0F);
                y += 20;

                GUI.Label(new Rect (5, y, 100, 20), "乳首垂れ：" + Math.Floor(mState.tits_chikubi_ultratare[cv] * 100) , gsLabel);
                mState.tits_chikubi_ultratare[cv] = GUI.HorizontalSlider(new Rect(105, y+5, 190, 20), mState.tits_chikubi_ultratare[cv], 0.0F, 2.0F);
                y += 20;

                GUI.Label(new Rect (5, y, 100, 20), "乳首陥没１：" + Math.Floor(mState.tits_chikubi_kanbotsu_n[cv] * 100) , gsLabel);
                mState.tits_chikubi_kanbotsu_n[cv] = GUI.HorizontalSlider(new Rect(105, y+5, 190, 20), mState.tits_chikubi_kanbotsu_n[cv], 0.0F, 2.0F);
                y += 20;

                GUI.Label(new Rect (5, y, 100, 20), "乳首陥没２：" + Math.Floor(mState.tits_chikubi_kanbotsu_s[cv] * 100) , gsLabel);
                mState.tits_chikubi_kanbotsu_s[cv] = GUI.HorizontalSlider(new Rect(105, y+5, 190, 20), mState.tits_chikubi_kanbotsu_s[cv], 0.0F, 2.0F);
                y += 20;

                GUI.Label(new Rect (5, y, 100, 20), "乳首陥没３：" + Math.Floor(mState.tits_chikubi_kanbotsu_p[cv] * 100) , gsLabel);
                mState.tits_chikubi_kanbotsu_p[cv] = GUI.HorizontalSlider(new Rect(105, y+5, 190, 20), mState.tits_chikubi_kanbotsu_p[cv], 0.0F, 2.0F);
                y = 90;


                GUI.Label(new Rect (305, y, 100, 20), "乳輪基本：" + Math.Floor(mState.tits_nipple_def[cv] * 100) , gsLabel);
                mState.tits_nipple_def[cv] = GUI.HorizontalSlider(new Rect(405, y+5, 190, 20), mState.tits_nipple_def[cv], 0.0F, 2.0F);
                y += 20;

                GUI.Label(new Rect (305, y, 100, 20), "乳輪尖１：" + Math.Floor(mState.tits_nipple_perky1[cv] * 100) , gsLabel);
                mState.tits_nipple_perky1[cv] = GUI.HorizontalSlider(new Rect(405, y+5, 190, 20), mState.tits_nipple_perky1[cv], 0.0F, 2.0F);
                y += 20;

                GUI.Label(new Rect (305, y, 100, 20), "乳輪尖２：" + Math.Floor(mState.tits_nipple_perky2[cv] * 100) , gsLabel);
                mState.tits_nipple_perky2[cv] = GUI.HorizontalSlider(new Rect(405, y+5, 190, 20), mState.tits_nipple_perky2[cv], 0.0F, 2.0F);
                y += 20;

                GUI.Label(new Rect (305, y, 100, 20), "乳輪伸１：" + Math.Floor(mState.tits_nipple_long1[cv] * 100) , gsLabel);
                mState.tits_nipple_long1[cv] = GUI.HorizontalSlider(new Rect(405, y+5, 190, 20), mState.tits_nipple_long1[cv], 0.0F, 2.0F);
                y += 20;

                GUI.Label(new Rect (305, y, 100, 20), "乳輪伸２：" + Math.Floor(mState.tits_nipple_long2[cv] * 100) , gsLabel);
                mState.tits_nipple_long2[cv] = GUI.HorizontalSlider(new Rect(405, y+5, 190, 20), mState.tits_nipple_long2[cv], 0.0F, 2.0F);
                y += 20;

                GUI.Label(new Rect (305, y, 100, 20), "乳輪膨：" + Math.Floor(mState.tits_nipple_wide[cv] * 100) , gsLabel);
                mState.tits_nipple_wide[cv] = GUI.HorizontalSlider(new Rect(405, y+5, 190, 20), mState.tits_nipple_wide[cv], 0.0F, 2.0F);
                y += 20;

                GUI.Label(new Rect (305, y, 100, 20), "ぷっくり：" + Math.Floor(mState.tits_nipple_puffy[cv] * 100) , gsLabel);
                mState.tits_nipple_puffy[cv] = GUI.HorizontalSlider(new Rect(405, y+5, 190, 20), mState.tits_nipple_puffy[cv], 0.0F, 2.0F);
                y += 20;

                GUI.Label(new Rect (305, y, 90, 20), "乳首クパ：" + Math.Floor(mState.tits_nipple_kupa[cv] * 100) , gsLabel);
                mState.tits_nipple_kupa[cv] = GUI.HorizontalSlider(new Rect(405, y+5, 190, 20), mState.tits_nipple_kupa[cv], 0.0F, 2.0F);
                y += 20;

                GUI.Label(new Rect (305, y, 90, 20), "ちっぱい：" + Math.Floor(mState.tits_munel_chippai[cv] * 100) , gsLabel);
                mState.tits_munel_chippai[cv] = GUI.HorizontalSlider(new Rect(405, y+5, 190, 20), mState.tits_munel_chippai[cv], 0.0F, 2.0F);
                y += 40;


                if (GUI.Button(new Rect (320, y, 130, 20), "コピー（着衣 → 裸）", gsButton)) {
                  ChikubiCopy(tgID, 1, 0);
                }
                if (GUI.Button(new Rect (460, y, 130, 20), "コピー（着衣 ← 裸）", gsButton)) {
                  ChikubiCopy(tgID, 0, 1);
                }
                y += 40;


                GUI.Label(new Rect (10, y, 200, 20), "▼基本設定の読み込み" , gsLabel);
                y += 30;

                if (GUI.Button(new Rect (10, y, 120, 20), "基本乳首", gsButton)) {
                  ChikubiReset(tgID, cv);
                  mState.tits_chikubi_def[cv] = 0.22f;
                  mState.tits_chikubi_perky[cv] = 0.35f;
                  mState.tits_chikubi_wide[cv] = 0.40f;
                  mState.tits_nipple_puffy[cv] = 0.31f;
                }

                if (GUI.Button(new Rect (140, y, 120, 20), "大きい乳首", gsButton)) {
                  ChikubiReset(tgID, cv);
                  mState.tits_chikubi_perky[cv] = 0.46f;
                  mState.tits_chikubi_wide[cv] = 0.42f;
                  mState.tits_nipple_wide[cv] = 0.75f;
                  mState.tits_nipple_puffy[cv] = 0.42f;
                }

                if (GUI.Button(new Rect (270, y, 120, 20), "陥没乳首", gsButton)) {
                  ChikubiReset(tgID, cv);
                  mState.tits_chikubi_def[cv] = 0.80f;
                  mState.tits_chikubi_wide[cv] = 0.60f;
                  mState.tits_chikubi_kanbotsu_n[cv] = 0.44f;
                  mState.tits_chikubi_kanbotsu_p[cv] = 1.40f;
                  mState.tits_nipple_wide[cv] = 1.0f;
                  mState.tits_nipple_puffy[cv] = 0.40f;
                }

                if (GUI.Button(new Rect (410, y, 120, 20), "デカ乳輪", gsButton)) {
                  ChikubiReset(tgID, cv);
                  mState.tits_chikubi_def[cv] = 0.42f;
                  mState.tits_chikubi_perky[cv] = 0.35f;
                  mState.tits_chikubi_wide[cv] = 0.77f;
                  mState.tits_nipple_perky1[cv] = 0.29f;
                  mState.tits_nipple_wide[cv] = 1.6f;
                  mState.tits_nipple_puffy[cv] = 0.80f;
                }
                y += 30;

                if (GUI.Button(new Rect (10, y, 120, 20), "トンガリ乳首", gsButton)) {
                  ChikubiReset(tgID, cv);
                  mState.tits_chikubi_def[cv] = 0.21f;
                  mState.tits_chikubi_perky[cv] = 0.34f;
                  mState.tits_chikubi_wide[cv] = 0.40f;
                  mState.tits_nipple_perky1[cv] = 0.75f;
                  mState.tits_nipple_wide[cv] = 0.52f;
                  mState.tits_nipple_puffy[cv] = 0.72f;
                }
                y += 10;

              /*
              GUI.Label(new Rect (20, 300, 300, 20), "上着（本）：" + maid.GetProp(MPN.wear).strFileName , gsLabel);
              GUI.Label(new Rect (320, 300, 300, 20), "上着（仮）：" + maid.GetProp(MPN.wear).strTempFileName , gsLabel);

              GUI.Label(new Rect (20, 320, 300, 20), "ワンピ（本）：" + maid.GetProp(MPN.onepiece).strFileName , gsLabel);
              GUI.Label(new Rect (320, 320, 300, 20), "ワンピ（仮）：" + maid.GetProp(MPN.onepiece).strTempFileName , gsLabel);

              GUI.Label(new Rect (20, 340, 300, 20), "水着（本）：" + maid.GetProp(MPN.mizugi).strFileName , gsLabel);
              GUI.Label(new Rect (320, 340, 300, 20), "水着（仮）：" + maid.GetProp(MPN.mizugi).strTempFileName , gsLabel);

              GUI.Label(new Rect (20, 360, 300, 20), "ブラ（本）：" + maid.GetProp(MPN.bra).strFileName , gsLabel);
              GUI.Label(new Rect (320, 360, 300, 20), "ブラ（仮）：" + maid.GetProp(MPN.bra).strTempFileName , gsLabel);
              */

                if (GUI.Button(new Rect (470, y, 120, 30), "設定保存", gsButton)) {
                  ChikubiSave(tgID, 0);
                  ChikubiSave(tgID, 1);
                }

                ChikubiSet(stockMaids[tgID].mem, mState, cv);
              }
        }

        //VR設定
        private void WindowCallback3_10(Maid tgMaid, MaidState tgMaidState)
        {
          int x = 0;
          int y = 30;

          //一列目
          cfgw.vrShortCut = GUI.Toggle(new Rect (10, y, 190, 20), cfgw.vrShortCut, lang.VR_SHORTCUT_ENABLED, gsToggle);
          if (!cfgw.vrShortCut) return;
          cfgw.vibeLookingMaid = GUI.Toggle(new Rect (190, y, 210, 20), cfgw.vibeLookingMaid, lang.VR_VIBE_TARGET_FROMT_MAID, gsToggle);
          y += 25;
          GUI.DrawTexture(new Rect(1, y, 618, 1), guiLineTexture, ScaleMode.StretchToFill, true, 0);
          y += 2;

          int y1 = y;

          //【移動速度】
          GUI.Label(new Rect (5, y, 190, 20), lang.SECTION_VR_SPEED, gsLabel);
          y += 20;
          GUI.Label(new Rect (10, y, 160, 20), lang.VR_CAMERA+"：" + cfgw.vrCameraSpeedMax, gsLabel);
          y += 20;
          cfgw.vrCameraSpeedMax = GUI.HorizontalSlider(new Rect(10, y, 170, 15), cfgw.vrCameraSpeedMax, 0.1f, 5.0f);
          cfgw.vrCameraSpeedMax = (float)(Math.Round(cfgw.vrCameraSpeedMax*10)*0.1);
          y += 15;
          GUI.Label(new Rect (10, y, 160, 20), lang.VR_DECELERATION+"：" + cfgw.vrCameraBreakSpeed, gsLabel);
          y += 20;
          cfgw.vrCameraBreakSpeed = GUI.HorizontalSlider(new Rect(10, y, 170, 15), cfgw.vrCameraBreakSpeed, 0.1f, 1.0f);
          cfgw.vrCameraBreakSpeed = (float)(Math.Round(cfgw.vrCameraBreakSpeed*20)*0.05);
          y += 15;
          GUI.Label(new Rect (10, y, 160, 20), lang.VR_HEIGHT_RETURN+"：" + cfgw.cameraMoveReturnSpeedY, gsLabel);
          y += 20;
          cfgw.cameraMoveReturnSpeedY = GUI.HorizontalSlider(new Rect(10, y, 170, 15), cfgw.cameraMoveReturnSpeedY, 0.0f, 3.0f);
          cfgw.cameraMoveReturnSpeedY = (float)(Math.Round(cfgw.cameraMoveReturnSpeedY*10)*0.1);
          y += 20;

          //【メイド固定時の速度】
          GUI.Label(new Rect (x+5, y, 190, 20), lang.SECTION_VR_FOLLOW_SPEED, gsLabel);
          y += 20;
          GUI.Label(new Rect (x+10, y, 160, 20), lang.VR_SPEED_ZOOM+"：" + cfgw.vrCameraFollowSpeedZoom, gsLabel);
          y += 20;
          cfgw.vrCameraFollowSpeedZoom = GUI.HorizontalSlider(new Rect(x+10, y, 170, 15), cfgw.vrCameraFollowSpeedZoom, 0.1f, 3.0f);
          cfgw.vrCameraFollowSpeedZoom = (float)(Math.Round(cfgw.vrCameraFollowSpeedZoom*10)*0.1);
          y += 15;
          GUI.Label(new Rect (x+10, y, 160, 20), lang.VR_SPEED_ROT+"：" + cfgw.vrCameraFollowSpeedAround, gsLabel);
          y += 20;
          cfgw.vrCameraFollowSpeedAround = GUI.HorizontalSlider(new Rect(x+10, y, 170, 15), cfgw.vrCameraFollowSpeedAround, 0.1f, 3.0f);
          cfgw.vrCameraFollowSpeedAround = (float)(Math.Round(cfgw.vrCameraFollowSpeedAround*10)*0.1);
          y += 20;

          //【自由移動時の速度】
          GUI.Label(new Rect (x+5, y, 190, 20), lang.SECTION_VR_FREE_MOVE_SPEED, gsLabel);
          y += 20;
          GUI.Label(new Rect (x+10, y, 160, 20), lang.VR_SPEED_FREE_ZOOM+"：" + cfgw.vrCameraMoveSpeedZoom, gsLabel);
          y += 20;
          cfgw.vrCameraMoveSpeedZoom = GUI.HorizontalSlider(new Rect(x+10, y, 170, 15), cfgw.vrCameraMoveSpeedZoom, 0.1f, 3.0f);
          cfgw.vrCameraMoveSpeedZoom = (float)(Math.Round(cfgw.vrCameraMoveSpeedZoom*10)*0.1);
          y += 15;
          GUI.Label(new Rect (x+10, y, 160, 20), lang.VR_SPEED_FREE_ROT+"：" + cfgw.vrCameraMoveSpeedTurn, gsLabel);
          y += 20;
          cfgw.vrCameraMoveSpeedTurn = GUI.HorizontalSlider(new Rect(x+10, y, 170, 15), cfgw.vrCameraMoveSpeedTurn, 0.1f, 3.0f);
          cfgw.vrCameraMoveSpeedTurn = (float)(Math.Round(cfgw.vrCameraMoveSpeedTurn*10)*0.1);
          y += 20;

          //【自由移動】
          GUI.Label(new Rect (x+5, y, 190, 20), lang.SECTION_VR_FREE_MOVE, gsLabel);
          y += 20;
          bool headDirection = GUI.Toggle(new Rect (x+10, y, 190, 20), cfgw.vrCameraMoveHeadDirection, lang.VR_MOVE_HEAD_DIR, gsToggle);
          if (cfgw.vrCameraMoveHeadDirection != headDirection) {
            cfgw.vrCameraMoveHeadDirection = headDirection;
            //変更時に入れ替える
            vrShortCutController.setDirectionTransform(cfgw.vrCameraMoveHeadDirection, cfgw.vrCameraMoveHeadFixHeight);
          }
          if (headDirection) {
            y += 20;
            bool headFixHeight = GUI.Toggle(new Rect (x+10, y, 190, 20), cfgw.vrCameraMoveHeadFixHeight, lang.VR_MOVE_HEAD_FIX_HEIGHT, gsToggle);
            if (cfgw.vrCameraMoveHeadFixHeight != headFixHeight) {
              cfgw.vrCameraMoveHeadFixHeight = headFixHeight;
              vrShortCutController.setDirectionTransform(cfgw.vrCameraMoveHeadDirection, cfgw.vrCameraMoveHeadFixHeight);
            }
          }
          //y += 25;

          //下段 2列目
          x = 185;
          y = y1;

          //【最短距離制限】
          GUI.Label(new Rect (x+5, y, 190, 20), lang.SECTION_VR_MOVE_LIMIT, gsLabel);
          y += 20;
          cfgw.vrCameraMoveLimit = GUI.Toggle(new Rect (x+10, y, 120, 20), cfgw.vrCameraMoveLimit, lang.VR_MOVE_LIMIT_ENABLED, gsToggle);
          bool cameraMoveLimitAlways = GUI.Toggle(new Rect (x+130, y, 70, 20), cfgw.vrCameraMoveLimitAlways, lang.VR_MOVE_LIMIT_ALWAYS, gsToggle);
          if (cameraMoveLimitAlways != cfgw.vrCameraMoveLimitAlways) {
            cfgw.vrCameraMoveLimitAlways = cameraMoveLimitAlways;
            vrShortCutController.init(cfgw); //コントローラー再設定
          }
          y += 22;
          cfgw.vrCameraMoveLimitHorizontal = GUI.Toggle(new Rect (x+10, y, 200, 20), cfgw.vrCameraMoveLimitHorizontal, lang.VR_MOVE_LIMIT_HORIZONTAL, gsToggle);
          y += 25;
          GUI.Label(new Rect (x+20, y, 160, 20), lang.VR_MOVE_LIMIT_DISTANCE+"：" + (cfgw.vrCameraMoveLimitDistance*100f), gsLabel);
          y += 20;
          cfgw.vrCameraMoveLimitDistance = GUI.HorizontalSlider(new Rect(x+20, y, 170, 15), cfgw.vrCameraMoveLimitDistance, 0.0f, 1.5f);
          cfgw.vrCameraMoveLimitDistance = (float)(Math.Round(cfgw.vrCameraMoveLimitDistance*100)*0.01);
          y += 18;

          GUI.Label(new Rect (x+5, y, 190, 20), lang.SECTION_VR_TARGET_MAID, gsLabel);
          y += 20;
          GUI.Label(new Rect (x+10, y, 140, 20), lang.VR_TARGET_MAID_FRONT, gsLabel);
          cfgw.vrFrontMaidCenter = GUI.Toggle(new Rect (x+120, y, 100, 20), cfgw.vrFrontMaidCenter, lang.VR_TARGET_MAID_CENTER, gsToggle);
          y += 20;
          GUI.Label(new Rect (x+10, y, 90, 20), lang.VR_TARGET_MAID_FRONT_ANGLE+"：" + (cfgw.vrFrontMaidAngle*2), gsLabel);
          cfgw.vrFrontMaidAngle = GUI.HorizontalSlider(new Rect(x+100, y+5, 100, 15), cfgw.vrFrontMaidAngle, 5f, 40f);
          cfgw.vrFrontMaidAngle = (float)(Math.Round(cfgw.vrFrontMaidAngle));
          y += 25;

          cfgw.vrOutsideMaidChange = GUI.Toggle(new Rect (x+10, y, 190, 20), cfgw.vrOutsideMaidChange, lang.VR_TARGET_MAID_OUTSIDE, gsToggle);
          //cfgw.vrOutsideMaidChangeAlways = GUI.Toggle(new Rect (x+130, y, 70, 20), cfgw.vrOutsideMaidChangeAlways, "（常時）", gsToggle);
          y += 20;
          GUI.Label(new Rect (x+10, y, 90, 20), lang.VR_TARGET_MAID_OUTSIDE_ANGLE+"：" + (cfgw.vrOutsideMaidAngle*2), gsLabel);
          float angle = GUI.HorizontalSlider(new Rect(x+100, y+5, 100, 15), cfgw.vrOutsideMaidAngle, 10f, 60f);
          angle = (float)(Math.Round(angle));
          if (angle != cfgw.vrOutsideMaidAngle) {
            cfgw.vrOutsideMaidAngle = angle;
            vrShortCutController.outsideMaidAngle = Mathf.Deg2Rad * cfgw.vrOutsideMaidAngle;
          }
          y += 20;
          GUI.Label(new Rect (x+10, y, 90, 20), lang.VR_TARGET_MAID_FRONT_ANGLE+"：" + (cfgw.vrOutsideMaidFrontAngle*2), gsLabel);
          cfgw.vrOutsideMaidFrontAngle = GUI.HorizontalSlider(new Rect(x+100, y+5, 100, 15), cfgw.vrOutsideMaidFrontAngle, 10f, 60f);
          cfgw.vrOutsideMaidFrontAngle = (float)(Math.Round(cfgw.vrOutsideMaidFrontAngle));
          y += 25;

          cfgw.vrAutoMaidChange = GUI.Toggle(new Rect (x+10, y, 190, 20), cfgw.vrAutoMaidChange, lang.VR_TARGET_MAID_JUMP, gsToggle);
          y += 20;
          GUI.Label(new Rect (x+10, y, 90, 20), lang.VR_TARGET_MAID_JUMP_ANGLE+"：" + (cfgw.vrAutoMaidAngle*2), gsLabel);
          cfgw.vrAutoMaidAngle = GUI.HorizontalSlider(new Rect(x+100, y+5, 100, 15), cfgw.vrAutoMaidAngle, 5f, 60f);
          cfgw.vrAutoMaidAngle = (float)(Math.Round(cfgw.vrAutoMaidAngle));
          y += 20;
          cfgw.vrAutoMaidRetry = GUI.Toggle(new Rect (x+10, y, 190, 20), cfgw.vrAutoMaidRetry, lang.VR_TARGET_MAID_JUMP_RETRY, gsToggle);
          y += 20;
          GUI.Label(new Rect (x+10, y, 90, 20), lang.VR_TARGET_MAID_JUMP_ANGLE+"：" + (cfgw.vrAutoMaidRetryAngle*2), gsLabel);
          cfgw.vrAutoMaidRetryAngle = GUI.HorizontalSlider(new Rect(x+100, y+5, 100, 15), cfgw.vrAutoMaidRetryAngle, 5f, 60f);
          cfgw.vrAutoMaidRetryAngle = (float)(Math.Round(cfgw.vrAutoMaidRetryAngle));
          //y += 20;

          //3列目
          x = 395;
          y = y1; //移動速度の下

          //【カメラジャンプ判定】
          GUI.Label(new Rect (x+5, y, 190, 20), lang.SECTION_VR_CAMERA_JUMP, gsLabel);
          y += 20;
          GUI.Label(new Rect (x+10, y, 190, 20), lang.VR_CAMERA_JUMP_DISTANCE+"：" + (cfgw.vrCameraJumpDistance) +"m", gsLabel);
          y += 20;
          cfgw.vrCameraJumpDistance = GUI.HorizontalSlider(new Rect(x+10, y, 180, 15), cfgw.vrCameraJumpDistance, 0.05f, 3f);
          cfgw.vrCameraJumpDistance = (float)(Math.Round(cfgw.vrCameraJumpDistance*10)*0.1);
          y += 20;

          //【カメラジャンプ位置補正】
          GUI.Label(new Rect (x+5, y, 190, 20), lang.SECTION_VR_CAMERA_JUMP_FIX_POS, gsLabel);
          y += 20;
          cfgw.vrCameraJumpFixPos = GUI.Toggle(new Rect (x+10, y, 190, 20), cfgw.vrCameraJumpFixPos, lang.VR_CAMERA_JUMP_FIX_POS, gsToggle);
          y += 20;
          cfgw.vrCameraJumpFixPosX = GUI.Toggle(new Rect (x+15, y, 50, 20), cfgw.vrCameraJumpFixPosX, lang.VR_CAMERA_JUMP_FIX_LR, gsToggle);
          cfgw.vrCameraJumpFixPosY = GUI.Toggle(new Rect (x+65, y, 50, 20), cfgw.vrCameraJumpFixPosY, lang.VR_CAMERA_JUMP_FIX_HEIGHT, gsToggle);
          cfgw.vrCameraJumpFixPosZ = GUI.Toggle(new Rect (x+115, y, 50, 20), cfgw.vrCameraJumpFixPosZ, lang.VR_CAMERA_JUMP_FIX_FR, gsToggle);
          cfgw.vrCameraJumpFixRot = GUI.Toggle(new Rect (x+165, y, 50, 20), cfgw.vrCameraJumpFixRot, lang.VR_CAMERA_JUMP_FIX_ROT, gsToggle);
          y += 25;

          GUI.Label(new Rect (x+20, y, 190, 20), lang.VR_CAMERA_JUMP_FIX_ZOOM+"：" + (cfgw.vrCameraJumpFixPosZoomRate*100) +"%", gsLabel);
          y += 20;
          cfgw.vrCameraJumpFixPosZoomRate = GUI.HorizontalSlider(new Rect(x+20, y, 170, 15), cfgw.vrCameraJumpFixPosZoomRate, 0f, 1.0f);
          cfgw.vrCameraJumpFixPosZoomRate = (float)(Math.Round(cfgw.vrCameraJumpFixPosZoomRate*20)*0.05);
          y += 15;
          GUI.Label(new Rect (x+20, y, 190, 20), lang.VR_CAMERA_JUMP_FIX_ZOOM_LIMIT+"：" + (cfgw.vrCameraJumpFixPosZoomLimit) +"m", gsLabel);
          y += 20;
          cfgw.vrCameraJumpFixPosZoomLimit = GUI.HorizontalSlider(new Rect(x+20, y, 170, 15), cfgw.vrCameraJumpFixPosZoomLimit, 0f, 5.0f);
          cfgw.vrCameraJumpFixPosZoomLimit = (float)(Math.Round(cfgw.vrCameraJumpFixPosZoomLimit*10)*0.1);
          y += 15;

          cfgw.vrCameraJumpAdjustHeight = GUI.Toggle(new Rect (x+10, y, 190, 20), cfgw.vrCameraJumpAdjustHeight, lang.VR_CAMERA_JUMP_ADJUST_HEIGHT, gsToggle);
          y += 20;
          GUI.Label(new Rect (x+20, y, 190, 20), lang.VR_CAMERA_JUMP_ADJUST_HEIGHT_TH+"：" + cfgw.vrCameraJumpAdjustHeightTh +"m", gsLabel);
          y += 20;
          cfgw.vrCameraJumpAdjustHeightTh = GUI.HorizontalSlider(new Rect(x+20, y, 170, 15), cfgw.vrCameraJumpAdjustHeightTh, 0f, 5.0f);
          cfgw.vrCameraJumpAdjustHeightTh = (float)(Math.Round(cfgw.vrCameraJumpAdjustHeightTh*10)*0.1);
          y += 15;
          GUI.Label(new Rect (x+20, y, 190, 20), lang.VR_CAMERA_JUMP_ADJUST_HEIGHT_RATE+"：" + (cfgw.vrCameraJumpAdjustHeightRate*100) +"%", gsLabel);
          y += 20;
          cfgw.vrCameraJumpAdjustHeightRate = GUI.HorizontalSlider(new Rect(x+20, y, 170, 15), cfgw.vrCameraJumpAdjustHeightRate, 0f, 1.0f);
          cfgw.vrCameraJumpAdjustHeightRate = (float)(Math.Round(cfgw.vrCameraJumpAdjustHeightRate*20)*0.05);
          //y += 20;
        }


        //全着衣
        private void dressAll(Maid maid)
        {
          maid.body0.SetMask(TBody.SlotID.wear, true);
          maid.body0.SetMask(TBody.SlotID.mizugi, true);
          maid.body0.SetMask(TBody.SlotID.onepiece, true);
          maid.body0.SetMask(TBody.SlotID.bra, true);
          maid.body0.SetMask(TBody.SlotID.skirt, true);
          maid.body0.SetMask(TBody.SlotID.panz, true);
          maid.body0.SetMask(TBody.SlotID.glove, true);
          maid.body0.SetMask(TBody.SlotID.accUde, true);
          maid.body0.SetMask(TBody.SlotID.stkg, true);
          maid.body0.SetMask(TBody.SlotID.shoes, true);
          maid.body0.SetMask(TBody.SlotID.accKubi, true);
          maid.body0.SetMask(TBody.SlotID.accKubiwa, true);
          maid.body0.SetMask(TBody.SlotID.accSenaka, true);
          #if COM3D2_5
          maid.body0.SetMask(TBody.SlotID.mizugi_top, true);
          maid.body0.SetMask(TBody.SlotID.mizugi_buttom, true);
          maid.body0.SetMask(TBody.SlotID.slip, true);
          maid.body0.SetMask(TBody.SlotID.jacket, true);
          maid.body0.SetMask(TBody.SlotID.vest, true);
          maid.body0.SetMask(TBody.SlotID.shirt, true);
          #endif
        }
        //全脱衣
        private void undressAll(Maid maid)
        {
          maid.body0.SetMask(TBody.SlotID.wear, false);
          maid.body0.SetMask(TBody.SlotID.mizugi, false);
          maid.body0.SetMask(TBody.SlotID.onepiece, false);
          maid.body0.SetMask(TBody.SlotID.bra, false);
          maid.body0.SetMask(TBody.SlotID.skirt, false);
          maid.body0.SetMask(TBody.SlotID.panz, false);
          maid.body0.SetMask(TBody.SlotID.glove, false);
          maid.body0.SetMask(TBody.SlotID.accUde, false);
          maid.body0.SetMask(TBody.SlotID.stkg, false);
          maid.body0.SetMask(TBody.SlotID.shoes, false);
          maid.body0.SetMask(TBody.SlotID.accKubi, false);
          maid.body0.SetMask(TBody.SlotID.accKubiwa, false);
          maid.body0.SetMask(TBody.SlotID.accSenaka, false);
          #if COM3D2_5
          maid.body0.SetMask(TBody.SlotID.mizugi_top, false);
          maid.body0.SetMask(TBody.SlotID.mizugi_buttom, false);
          maid.body0.SetMask(TBody.SlotID.slip, false);
          maid.body0.SetMask(TBody.SlotID.jacket, false);
          maid.body0.SetMask(TBody.SlotID.vest, false);
          maid.body0.SetMask(TBody.SlotID.shirt, false);
          #endif
        }
        //下着
        private void dressUnderware(Maid maid)
        {
          maid.body0.SetMask(TBody.SlotID.wear, false);
          maid.body0.SetMask(TBody.SlotID.onepiece, false);
          maid.body0.SetMask(TBody.SlotID.skirt, false);
          maid.body0.SetMask(TBody.SlotID.shoes, false);
          maid.body0.SetMask(TBody.SlotID.accSenaka, false);

          maid.body0.SetMask(TBody.SlotID.bra, true);
          maid.body0.SetMask(TBody.SlotID.panz, true);
          maid.body0.SetMask(TBody.SlotID.stkg, true);
        }

        //髪型のロード
        private void ExLoadHair(Maid maid, string name)
        {
          ExLoadHair(maid, name+"_hairF", MPN.hairf);
          ExLoadHair(maid, name+"_hairR", MPN.hairr);
          ExLoadHair(maid, name+"_hairS", MPN.hairs);
          ExLoadHair(maid, name+"_hairT", MPN.hairt);
          ExLoadHair(maid, name+"_hairAho", MPN.hairaho);
          ExLoadHair(maid, name+"_accKami", MPN.acckami);
          ExLoadHair(maid, name+"_accKamiSub", MPN.acckamisub);
          maid.AllProcPropSeqStart();
        }
        private void ExLoadHair(Maid maid, string name, MPN mpn)
        {
          maid.SetProp(mpn, ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", name, "0"), 0, true, false);
        }

        //髪型の保存
        private void ExSaveHair(Maid maid, string name)
        {
          ExSaveHair(maid, name+"_hairF", MPN.hairf);
          ExSaveHair(maid, name+"_hairR", MPN.hairr);
          ExSaveHair(maid, name+"_hairS", MPN.hairs);
          ExSaveHair(maid, name+"_hairT", MPN.hairt);
          ExSaveHair(maid, name+"_hairAho", MPN.hairaho);
          ExSaveHair(maid, name+"_accKami", MPN.acckami);
          ExSaveHair(maid, name+"_accKamiSub", MPN.acckamisub);
        }

        private void ExSaveHair(Maid maid, string name, MPN mpn)
        {
          MaidProp mps = maid.GetProp(mpn);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", name, mps.strFileName, true);
        }

        private void ExLoadWear(Maid maid, string name)
        {
          ExLoadWear(maid, name+"_acchat",    MPN.acchat);
          ExLoadWear(maid, name+"_headset",   MPN.headset);
          ExLoadWear(maid, name+"_wear",      MPN.wear);
          ExLoadWear(maid, name+"_skirt",     MPN.skirt);
          ExLoadWear(maid, name+"_onepiece",  MPN.onepiece);
          ExLoadWear(maid, name+"_mizugi",    MPN.mizugi);
          ExLoadWear(maid, name+"_bra",       MPN.bra);
          ExLoadWear(maid, name+"_panz",      MPN.panz);
          ExLoadWear(maid, name+"_stkg",      MPN.stkg);
          ExLoadWear(maid, name+"_shoes",     MPN.shoes);
          ExLoadWear(maid, name+"_megane",    MPN.megane);
          ExLoadWear(maid, name+"_acchead",   MPN.acchead);
          ExLoadWear(maid, name+"_glove",     MPN.glove);
          ExLoadWear(maid, name+"_accude",    MPN.accude);
          ExLoadWear(maid, name+"_acchana",   MPN.acchana);
          ExLoadWear(maid, name+"_accmimi",   MPN.accmimi);
          ExLoadWear(maid, name+"_accnip",    MPN.accnip);
          ExLoadWear(maid, name+"_acckubi",   MPN.acckubi);
          ExLoadWear(maid, name+"_acckubiwa", MPN.acckubiwa);
          ExLoadWear(maid, name+"_accheso",   MPN.accheso);
          ExLoadWear(maid, name+"_accashi",   MPN.accashi);
          ExLoadWear(maid, name+"_accsenaka", MPN.accsenaka);
          ExLoadWear(maid, name+"_accshippo", MPN.accshippo);
          ExLoadWear(maid, name+"_accxxx",    MPN.accxxx);
          AllDressVisible(tgID, true);
          maid.AllProcPropSeqStart();
        }
        private void ExLoadWear(Maid maid, string name, MPN mpn)
        {
          string fileName = ExSaveData.Get(maid, "CM3D2.VibeYourMaid.Plugin", name, "0");
          if (fileName != "") maid.SetProp(mpn, fileName, 0, true, false);
        }
        private void ExSaveWear(Maid maid, string name)
        {
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", name+"_acchat",    setAcchat    ? maid.GetProp(MPN.acchat).strFileName : "", true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", name+"_headset",   setHeadset   ? maid.GetProp(MPN.headset).strFileName : "", true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", name+"_wear",      setWear      ? maid.GetProp(MPN.wear).strFileName : "", true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", name+"_skirt",     setSkirt     ? maid.GetProp(MPN.skirt).strFileName : "", true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", name+"_onepiece",  setOnepiece  ? maid.GetProp(MPN.onepiece).strFileName : "", true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", name+"_mizugi",    setMizugi    ? maid.GetProp(MPN.mizugi).strFileName : "", true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", name+"_bra",       setBra       ? maid.GetProp(MPN.bra).strFileName : "", true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", name+"_panz",      setPanz      ? maid.GetProp(MPN.panz).strFileName : "", true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", name+"_stkg",      setShoes     ? maid.GetProp(MPN.stkg).strFileName : "", true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", name+"_shoes",     setStkg      ? maid.GetProp(MPN.shoes).strFileName : "", true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", name+"_megane",    setMegane    ? maid.GetProp(MPN.megane).strFileName : "", true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", name+"_acchead",   setAcchead   ? maid.GetProp(MPN.acchead).strFileName : "", true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", name+"_glove",     setGlove     ? maid.GetProp(MPN.glove).strFileName : "", true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", name+"_accude",    setAccude    ? maid.GetProp(MPN.accude).strFileName : "", true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", name+"_acchana",   setAcchana   ? maid.GetProp(MPN.acchana).strFileName : "", true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", name+"_accmimi",   setAccmimi   ? maid.GetProp(MPN.accmimi).strFileName : "", true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", name+"_accnip",    setAccnip    ? maid.GetProp(MPN.accnip).strFileName : "", true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", name+"_acckubi",   setAcckubi   ? maid.GetProp(MPN.acckubi).strFileName : "", true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", name+"_acckubiwa", setAcckubiwa ? maid.GetProp(MPN.acckubiwa).strFileName : "", true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", name+"_accheso",   setAccheso   ? maid.GetProp(MPN.accheso).strFileName : "", true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", name+"_accashi",   setAccashi   ? maid.GetProp(MPN.accashi).strFileName : "", true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", name+"_accsenaka", setAccsenaka ? maid.GetProp(MPN.accsenaka).strFileName : "", true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", name+"_accshippo", setAccshippo ? maid.GetProp(MPN.accshippo).strFileName : "", true);
          ExSaveData.Set(maid, "CM3D2.VibeYourMaid.Plugin", name+"_accxxx",    setAccxxx    ? maid.GetProp(MPN.accxxx).strFileName : "", true);
        }


        //UNZIP用GUI---------------
        Vector2 YotogiScrollPos = Vector2.zero;
        Vector2 YotogiScrollPos2 = Vector2.zero;
        int visibleYotogiCount = 0;
        private bool smHVisible = true;
        //private bool unzipSelect = false;
        bool unzipPanelScroll = false;

        static readonly int[] DefaultYotogiMenuColumns = {3,3,3,3,3,3,3,3,3,2,2,3,3,3}; //UNZIPパネルのボタンカラム数

        void WindowCallback4(int id)
        {
          MaidState mState = maidsState[tgID];

          //モーションの時間を同期 男も同期する
          if (GUI.Button(new Rect(460, 0, 70, 20), lang.UNZIP_BTN_SYNC, gsButton)) {
            syncMotionAnimeTime(tgID, false, true);
          }
          //モーションアジャスト設定画面
          if (GUI.Button(new Rect (540, 0, 50, 20), lang.UNZIP_BTN_SETTING, gsButton)) {
            cfgw.configGuiFlag = true; ConfigFlag = 6;
          }
          if (GUI.Button(new Rect (600, 0, 20, 20), "x", gsButton)) {
            cfgw.unzipGuiFlag = false;
          }

          cfgw.majStartTaikMotion = GUI.Toggle(new Rect (10, 20, 135, 20), cfgw.majStartTaikMotion, lang.UNZIP_WAIT_WHEN_STOPPED , gsToggle );
          //cfgw.majInMotionVibeLevel = GUI.Toggle(new Rect (150, 20, 135, 20), cfgw.majInMotionVibeLevel, "挿入時にバイブON" , gsToggle );
          cfgw.sotodashiReactionPlay = GUI.Toggle(new Rect (150, 20, 135, 20), cfgw.sotodashiReactionPlay, lang.UNZIP_OUTSIDE_VOICE , gsToggle );

          cfgw.autoManEnabled = GUI.Toggle(new Rect (290, 20, 105, 20), cfgw.autoManEnabled, lang.UNZIP_AUTOMAN , gsToggle );

          bool toggle = GUI.Toggle(new Rect (400, 20, 85, 20), cfgw.crcMotionVisible, lang.UNZIP_SHOW_CRC , gsToggle );
          if (cfgw.crcMotionVisible != toggle) {
            cfgw.crcMotionVisible = toggle;
            unzipPanelScroll = true;
          }

          toggle = GUI.Toggle(new Rect(490, 20, 140, 20), smHVisible, lang.UNZIP_SHOW_SUBMOTION, gsToggle);
          if (smHVisible != toggle) {
            smHVisible = toggle;
            unzipPanelScroll = true;
          }

                int y = 1;
                int x = 5;
                int w = 70;

                for (int i = 0; i < YotogiGroup.Count; i++) {
                  if (i != YotogiMenu) {
                    if (GUI.Button(new Rect ( x, 20 + y*25, w, 20), YotogiGroup[i], gsButton)) {
                      YotogiMenu = i;
                    }
                  } else {
                    GUI.Label(new Rect (x, 20 + y*25, w, 20), ">> " + YotogiGroup[i], gsLabel2Y);
                  }

                  x += w + 5;
                  if (x + w > 615) {
                    x = 5;
                    y += 1;
                  }
                }

                int scrlRectHeight = cfgw.guiHeightUnzip - 50; //185
                int h = scrlRectHeight - y * 25;
                if (YotogiGroup.Count - 1 > YotogiMenu) {
                  h = 22 * (visibleYotogiCount / cfgw.YotogiMenuColumns[YotogiMenu] + 1);

                  if (h < (scrlRectHeight - y * 25)) {
                    h = scrlRectHeight - y * 25;
                  }
                } else {
                  h = 5 + (int)Math.Ceiling(emsFiles.Count/3.0) * 22;
                  if (mState.editMotionSetName != "") h += 25;
                  if (h < (scrlRectHeight - y * 25))h = scrlRectHeight - y * 25;
                }

                //int panelH = 190 - y * 25;
                int panelH = scrlRectHeight+5 - y * 25;
                Rect scrlRect    = new Rect(10, 45 + y * 25, 609, panelH);
                Rect contentRect = new Rect(0, 0, 590, h);
                YotogiScrollPos = GUI.BeginScrollView( scrlRect, YotogiScrollPos, contentRect, false, true );

                Maid maid = stockMaids[tgID].mem;
                
                //夜伽モーションのリスト画面
                if (YotogiGroup.Count - 1 > YotogiMenu) {
                  y = 0;
                  x = 0;
                  w = 592 / cfgw.YotogiMenuColumns[YotogiMenu] - 2;

                  visibleYotogiCount = 0; //次フレームでスクロール内のパネルの高さを変更する用
                  for (int i = 0; i < YotogiList[YotogiMenu].Count; i++) {
                    string t = YotogiList[YotogiMenu][i];
                    string name = YotogiListName[YotogiMenu][i];
                    if (!smHVisible && (name.Contains("女B") || name.Contains("女C"))) continue;
                    if (!cfgw.crcMotionVisible && t.StartsWith("crc_")) continue; //CRCモーション除外

                    visibleYotogiCount++;


                    bool selected = (mState.motionID != -1 && maj.motionName[mState.motionID] == t);
                    if (selected) {
                      gsButton.normal.textColor = Color.yellow;
                      gsButton.hover.textColor = Color.yellow;
                      //スクロール位置 次のフレームで移動する
                      if (unzipPanelScroll) {
                        if (YotogiScrollPos.y > y*22) YotogiScrollPos.y = y*22;
                        else if (YotogiScrollPos.y+panelH < y*22+20) YotogiScrollPos.y = y*22+20-panelH;
                        unzipPanelScroll = false;
                      }
                    }

                    if (GUI.Button(new Rect ( x, y*22, w, 20), name, gsButton)) {
                      StartMaidUnzip(tgID, t);
                    }

                    if (selected) {
                      gsButton.normal.textColor = Color.white;
                      gsButton.hover.textColor = Color.white;
                    }

                    x += w +2;
                    if (x + w > 592) {
                      x = 0;
                      y += 1;
                    }

                  }

                } else {
                  //ランダムモーションセット
                  y = 5;
                  x = 0;
                  w = 592 / cfgw.YotogiMenuColumns[13] - 2;

                  if (mState.editMotionSetName != "") {
                    if (GUI.Button(new Rect (x, y, 50, 20), lang.UNZIP_BTN_CANCEL, gsButton)) {
                      MotionSetClear(tgID);
                    }
                    GUI.Label(new Rect (x + 60, y, 600, 20), "『" + mState.editMotionSetName +"』：『"+MotionNameChange(maj.motionName[mState.motionID])+"』"+lang.UNZIP_PLAYING , gsLabel);
                    y += 25;
                  }

                  foreach (string f in emsFiles) {
                    string emsName = f.Replace("ems_", "").Replace(".xml", "");

                    bool selected = (mState.editMotionSetName == emsName);
                    if (selected) {
                      gsButton.normal.textColor = Color.yellow;
                      gsButton.hover.textColor = Color.yellow;
                    }
                    if (GUI.Button(new Rect (x, y, w, 20), emsName, gsButton)) {
                      StartRandomUnzip(tgID, f);
                    }
                    if (selected) {
                      gsButton.normal.textColor = Color.white;
                      gsButton.hover.textColor = Color.white;
                    }

                    x += w + 2;
                    if (x + w > 590) {
                      x = 0;
                      y += 22;
                    }
                  }
                }

                GUI.EndScrollView();

          GUI.DragWindow();

        }

        //モーションに対応したUNZIPパネルに切り替え
        private void SelectYotogiMenu(string motion)
        {
          for (int i = 0; i < YotogiList.Count; i++) {
            if (YotogiList[i].IndexOf(motion) >= 0) {
              YotogiMenu = i;
              break;
            }
          }
        }
        //UNZIP再生
        private void StartMaidUnzip(int maidID, string t)
        {
          MaidState maidState = maidsState[maidID];
          Maid maid = maidState.maid;

          //モーション変更前のモーションで挿入可能かチェック
          bool insertable = !t.Contains("_sumata_"); //素股モーション指定ならfalse
          //バイブが動いていれば挿入スキップなし
          if (insertable && maidState.vLevel > 0 && maidState.motionID != -1 && cfgw.majSkipStartInMotion) {
            //前のモーションで抜いてない or 前が素股可変モーションでない → 挿入スキップ
            if (!isRemovedMotion(maidState) && !maidState.maid.body0.LastAnimeFN.Contains("_sumata_")) {
              insertable = false;
              //TODO カテゴリでもチェック 奉仕系なら挿入可能
            }
          }

          //モーションアジャスト実行 サブメイドはSubMotionChangeで実行される
          MotionAdjustDo(maidID, t, true, -1);

          if (maidState.inMotion == "Non") insertable = false; //挿入モーションがなければ挿入スキップ

          bool bTaiki = false; //待機状態でスタート

          //メイドのモーション変更
          if (t.EndsWith("_sumata_f")) {
            //単一の素股モーションはそのまま
          } else if (cfgw.majStartTaikMotion && maidState.vLevel == 0 && maidState.taikiMotion != "Non" && maidState.inMotion != "Non") {
            //バイブ停止中で挿入と待機があれば待機モーションでスタート
            t = maidState.taikiMotion;
            bTaiki = true;
          } else if (maidState.vStateMajor == 20) { //強度に合わせて変更
            t = t.Replace("_1_", "_2_");
          } else if (maidState.vStateMajor == 30) {
            t = t.Replace("_1_", "_3_");
          }

          #if DEBUG
          Debug.Log("StartMaidUnzip(maidID="+maidID+",t="+t+") insertable="+insertable+" bTaiki="+bTaiki+" motionID="+maidState.motionID);
          #endif

          //string inMotion = MotionCheckTokusyu(t, sInMaidMotion); //挿入モーションがあるかチェック
          //UNZIPモーション再生
          if (!insertable || bTaiki) {
            //挿入モーションなし
            MotionChange(maid, t, true, cfgw.majFadeTime, 1f); //ループモーション再生
          } else {
            //挿入モーションあり
            MotionChange(maid, maidState.inMotion, false, cfgw.majFadeTime, 1f); //挿入モーション再生
            MotionChangeAf(maid, t, true, cfgw.majFadeTime, 1f); //挿入後にループモーション再生
            //挿入モーション中はモーション変化スキップ
            maidState.skipMotionChange = Time.time + 2f;
            //挿入モーション再生時ははクパ開始時間を設定
            float kupaDelay = maj.kupaDelay[maidState.motionID];
            if (kupaDelay < 0) kupaDelay = cfgw.majKupaOpenDelay; //デフォルト 0.5秒後
            maidState.kupaOpenTime = Time.time + kupaDelay; //共通設定 0.5秒後
          }
          //バイブ開始 指定モード  オートではなくレベルが上がる場合のみ変更する サブメイドも同様に処理
          if (!bTaiki) { //待機モーションで開始時はバイブはONにしない
            if (cfgw.majInMotionVibeLevel && maidState.pAutoSelect == 0 && maidState.vLevel < 1) {
              maidState.vLevel = 1;
            }
          }

          if (maidState.uDatsu == 2 && maj.hkupa1[maidState.motionID] > 50f) {
            maidState.uDatsuValue1 = 0f;
            maidState.uDatsu = 0;
            try { VertexMorph_FromProcItem(maid.body0, "pussy_uterus_prolapse", 0f); } catch { /*LogError(ex);*/ }
          }

          if (maidState.uDatsu == 3) maidState.uDatsu = 0;

          //2.5のunzipエラー対策
          #if !COM3D2_5
          maid.IKTargetToBone("左手", null, "無し", Vector3.zero, IKCtrlData.IKAttachType.Point, false, false, IKCtrlData.IKExecTiming.Normal);
          maid.IKTargetToBone("右手", null, "無し", Vector3.zero, IKCtrlData.IKAttachType.Point, false, false, IKCtrlData.IKExecTiming.Normal);
          #endif

          //サブメイドとのリンクは一旦解除 SubMotionChangeで設定される
          if (maidState.motionLinkID != -1) {
            foreach (int id in vmId) {
              if (maidsState[id].motionLinkID == maidID) maidsState[id].motionLinkID = -1;
            }
            maidState.motionLinkID = -1;
          }
          //百合・ハーレム相手のモーション変更
          if (YotogiMenu == 8 || YotogiMenu == 9 || regSubMaidMotion.IsMatch(t)) {
            if (!insertable || bTaiki) {
              SubMotionChange(maidID, t, null, true, cfgw.majFadeTime, 1f);
            } else {
              SubMotionChange(maidID, maidState.inMotion, t, true, cfgw.majFadeTime, 1f);
            }
            if (maidState.motionLinkID != -1) {
              foreach (int subID in getMotionLinkedMaidID(maidID)) { //サブメイドすべて設定
                MaidState subState = maidsState[subID];
                //挿入モーション再生時ははクパ開始時間を設定
                if (maidState.inMotion != "Non") {
                  float kupaDelay = maj.kupaDelay[subState.motionID];
                  if (kupaDelay < 0) kupaDelay = cfgw.majKupaOpenDelay; //デフォルト 0.5秒後
                    subState.kupaOpenTime = Time.time + kupaDelay; //共通設定 0.5秒後
                }
                //サブメイドのバイブはメインに合わせる
                if (cfgw.majInMotionVibeLevel && subState.pAutoSelect == 0) {
                  subState.vLevel = maidState.vLevel;
                }
                //サブメイドに前のUNZIPでリンクしていた男は削除
                if (cfgw.autoManEnabled) {
                  for (int im = 0; im < SubMans.Length; im++) {
                    if (isSubManVisible(im) && MansTg[im] == maidState.motionLinkID) setSubManVisible(im, false);
                  }
                }
              }
            }
          }
          
          //男の自動表示
          AutoMansVisible(maidID, t);

          //男のモーション変更
          if (!insertable || bTaiki) {
            ManMotionChange(maidID, true, cfgw.majFadeTime, 1.0f);
          } else {
            ManMotionChange(maidState.inMotion, maidID, false, cfgw.majFadeTime, 1f);
            ManMotionChangeAf(t, maidID, true, cfgw.majFadeTime, 1f); // 終わったら再生する
          }

          //挿入モーションのバックアップを取得
          //maidState.inMotion = inMotion;

          //モーションセットリセット
          MotionSetClear(maidID);

          #if EmpiresLife
          //いたずら開始フラグ
          if (lifeStart >= 5) maidState.elItazuraFlag = true;
          #endif

          //タイマーリセット
          maidState.motionHoldTime = UnityEngine.Random.Range(200f,600f);
          maidState.voiceHoldTime = 0f;
          maidState.faceHoldTime = 0f;
          maidState.MouthHoldTime = 0f;

          //モーションアジャスト詳細設定のメイド選択を初期化
          showSubMotionUI = false;
          //パネルのスクロール変更
          unzipPanelScroll = true;
        }

        private string getPrevUnzip(string motion)
        {
          int idx = motion == null ? -1 : YotogiList[YotogiMenu].IndexOf(motion);
          if (idx == -1) idx = YotogiList[YotogiMenu].Count-1;
          else {
            idx--;
            if (idx < 0) idx = YotogiList[YotogiMenu].Count-1;
          }
          if (!cfgw.crcMotionVisible || !smHVisible) { //crcとサブモーションはスキップ
            int start = idx;
            while ( (!cfgw.crcMotionVisible && YotogiList[YotogiMenu][idx].StartsWith("crc_")) || (!smHVisible && (name.Contains("女B") || name.Contains("女C"))) ) {
              idx--;
              if (idx < 0) idx = YotogiList[YotogiMenu].Count-1;
              if (idx == start) return null;
            }
          }
          return YotogiList[YotogiMenu][idx];
        }

        private string getNextUnzip(string motion)
        {
          int idx = motion == null ? -1 : YotogiList[YotogiMenu].IndexOf(motion);
          if (idx == -1) idx = 0;
          else {
            idx++;
            if (idx >= YotogiList[YotogiMenu].Count) idx = 0;
          }
          if (!cfgw.crcMotionVisible || !smHVisible) { //crcとサブモーションはスキップ
            int start = idx;
            while ( (!cfgw.crcMotionVisible && YotogiList[YotogiMenu][idx].StartsWith("crc_")) || (!smHVisible && (name.Contains("女B") || name.Contains("女C"))) ) {
              idx++;
              if (idx >= YotogiList[YotogiMenu].Count) idx = 0;
              if (idx == start) return null;
            }
          }
          return YotogiList[YotogiMenu][idx];
        }

        private void StartRandomUnzip(int maidID, string emsFile)
        {
          Maid maid = stockMaids[maidID].mem;

          MotionSetClear(maidID);
          MotionSetLoad(emsFile, maidID);

          //男の自動表示 初回
          AutoMansVisible(maidID, maidsState[maidID].editMotionSet[maidsState[maidID].msCategory][0]);

          #if EmpiresLife
          //いたずら開始フラグ
          if (lifeStart >= 5) maidsState[maidID].elItazuraFlag = true;
          #endif
        }

        private string getPrevRandomUnzip(string selectedFile)
        {
          for (int i = 0; i < emsFiles.Count; i++) {
            if (selectedFile == emsFiles[i]) {
              if (i-1 < 0) return emsFiles[emsFiles.Count-1];
              return emsFiles[i-1];
            };
          }
          return emsFiles[emsFiles.Count-1];
        }

        private string getNextRandomUnzip(string selectedFile)
        {
          for (int i = 0; i < emsFiles.Count; i++) {
            if (selectedFile == emsFiles[i]) {
              if (i+1 >= emsFiles.Count) return emsFiles[0];
              return emsFiles[i+1];
            };
          }
          return emsFiles[0];
        }

        private void StartPrevUnzip()
        {
          if (maidsState[tgID].editMotionSetName != "") {
            //ランダムモーション
            string emsFile = getPrevRandomUnzip("ems_"+maidsState[tgID].editMotionSetName+".xml");
            if (emsFile != null) StartRandomUnzip(tgID, emsFile);
          } else {
            //その他モーション
            string motion;
            motion = getPrevUnzip(maidsState[tgID].motionID == -1 ? null : maj.motionName[maidsState[tgID].motionID]);
            if (motion != null) StartMaidUnzip(tgID, motion);
          }
        }

        private void StartNextUnzip()
        {
          if (maidsState[tgID].editMotionSetName != "") {
            //ランダムモーション
            string emsFile = getNextRandomUnzip("ems_"+maidsState[tgID].editMotionSetName+".xml");
            if (emsFile != null) StartRandomUnzip(tgID, emsFile);
          } else {
            //その他モーション
            string motion;
            motion = getNextUnzip(maidsState[tgID].motionID == -1 ? null : maj.motionName[maidsState[tgID].motionID]);
            if (motion != null) StartMaidUnzip(tgID, motion);
          }
        }

        void WindowCallback4a(int id) {

            int y = 0;
            int w = 195;
            int h = 22 * maidsState[tgID].senyouTokusyuMotion.Count;
            if (h < 185) h = 185;

            Maid maid = stockMaids[tgID].mem;

            Rect scrlRect    = new Rect(0, 25, 220, 190);
            Rect contentRect = new Rect(0, 0, 200, h);
            YotogiScrollPos2 = GUI.BeginScrollView( scrlRect, YotogiScrollPos2, contentRect, false, true );

            //特殊モーションリスト
              foreach (string tokusyu in maidsState[tgID].senyouTokusyuMotion) {
                name = MotionNameChange(tokusyu);
                if (GUI.Button(new Rect ( 5, y*22, w, 20), name, gsButton)) {
                  string t = maid.body0.LastAnimeFN;

                  if (tokusyu.Contains("_once_")) {
                    MotionChange(maid, tokusyu, false, 0.7f, 1f);
                    ManMotionChange(tokusyu, tgID, false, 0.7f, 1f);

                    MotionChangeAf(maid, t, true, 0.7f, 1f);
                    ManMotionChangeAf(t, tgID, true, 0.7f, 1f); // 終わったら再生する
                  } else {
                    MotionChange(maid, tokusyu, true, 0.7f, 1f);
                    ManMotionChange(tgID, true, 0.7f, 1.0f);
                  }
                }
              y += 1;
              }

            GUI.EndScrollView();

          GUI.DragWindow();
        }


        #if EmpiresLife
        //エンパイアズライフ用GUI
        private int ElGuiFlag = 0;
        Vector2 elScrollPos = Vector2.zero;
        private bool flagN = false;
        void WindowCallback5(int id)
        {

            GUIStyle gsLabel2 = new GUIStyle("label");
            gsLabel2.fontSize = 12;
            gsLabel2.alignment = TextAnchor.MiddleCenter;
            gsLabel2.normal = new GUIStyleState();
            gsLabel2.normal.textColor = Color.yellow;


            if (ElGuiFlag == 0){
              if (GUI.Button(new Rect (720, 0, 20, 20), "－", gsButton)) {
                ElGuiFlag = 1;
                node5.width = 220;
                node5.height = 20;
              }

                Maid tgMaid = null;
                if(tgID != -1) tgMaid = stockMaids[tgID].mem;

                int x = 0;
                int y = 20;


                //GUI.Label(new Rect (5, y, 190, 20), "【移動先選択】" , gsLabel);
                Rect scrlRect    = new Rect(0, y, 605, 140);
                Rect contentRect = new Rect(0, 0, 585, 25 * bgC);
                elScrollPos = GUI.BeginScrollView( scrlRect, elScrollPos, contentRect, false, true );

                y = 0;

                  for (int i = 0; i < bgArray1.GetLength(0); i++){

                    //bool flagN = GameMain.Instance.CharacterMgr.status.GetFlag("時間帯") == 3;
                    if(bgArray1[i][3] == "0" )continue;
                    if(flagN && bgArray1[i][3] == "1" )continue;
                    if(!flagN && bgArray1[i][3] == "2" )continue;

                    string bgName = bgArray1[i][1].Replace("（夜）", "");
                    if(bgID == i){
                      GUI.Label(new Rect (10 + x, y, 140, 20), "≫ " + bgName , gsLabel2);
                    }else{
                      if (GUI.Button(new Rect (10 + x, y, 140, 20), bgName, gsButton)) {
                         StartCoroutine("ElChange", i);
                      }
                    }

                    if(x >= 435){
                      y += 25;
                      x = 0;
                    } else {
                      x += 145;
                    }
                  }

                  foreach(EmpiresLifeScene_Xml _els in elsList){
                    if(_els.timeZone != 2){
                      if(flagN && _els.timeZone == 0)continue;
                      if(!flagN && _els.timeZone == 1)continue;
                    }

                    if (GUI.Button(new Rect (10 + x, y, 140, 20), _els.bgName, gsButton)) {
                      elsChange(_els);
                    }

                    if(x >= 435){
                      y += 25;
                      x = 0;
                    } else {
                      x += 145;
                    }
                  }

                  if(!maidOver){
                    for (int i2 = 0; i2 < holidayMaid.Count; i2++){

                      string hmName = stockMaids[holidayMaid[i2][0]].mem.status.firstName + "の部屋";
                      if(bgID == 38 && hmID ==i2){
                        GUI.Label(new Rect (10 + x, y, 140, 20), "≫ " + hmName , gsLabel2);
                      }else{
                        if (GUI.Button(new Rect (10 + x, y, 140, 20), hmName, gsButton)) {
                          mn[38] = holidayMaid[i2];
                          StartCoroutine("ElChange", 38);
                          hmID = i2;
                        }
                      }

                      if(x >= 435){
                        y += 25;
                        x = 0;
                      } else {
                        x += 145;
                      }
                    }
                  }


                GUI.EndScrollView();

                y = 165;


                if(!bVR){
                  GUI.Label(new Rect (10, y, 70, 20), "移動速度", gsLabel);
                  speed = GUI.HorizontalSlider(new Rect(70, y + 5, 100, 20), speed, 0.1f, 2f);
                  if (GUI.Button(new Rect (180, y, 20, 20), "R", gsButton)){
                    speed = 1;
                  }
                }

                if (GUI.Button(new Rect (220, y, 90, 20), "ラナルータ", gsButton)){
                  flagN = !flagN;
                  ElStart();
                 if(!flagN)StartCoroutine("ElChange", 0);
                 if(flagN)StartCoroutine("ElChange", 1);
                }

                if (GUI.Button(new Rect (370, y, 120, 20), "アイテム表示切替", gsButton)){
                  isItem = !isItem;
                  tgMaid.body0.SetMask(TBody.SlotID.HandItemR, isItem);
                  tgMaid.body0.SetMask(TBody.SlotID.HandItemL, isItem);
                  tgMaid.body0.SetMask(TBody.SlotID.kousoku_upper, isItem);
                  tgMaid.body0.SetMask(TBody.SlotID.kousoku_lower, isItem);
                }

                if (GUI.Button(new Rect (500, y, 75, 20), "NTR Block", gsButton)){
                  cfgw.ntrBlock = !cfgw.ntrBlock;
                  ElStart();
                  StartCoroutine("ElChange", bgID);
                }

                if(cfgw.ntrBlock)GUI.Label(new Rect (580, y, 35, 20), "ON" , gsLabel);
                if(!cfgw.ntrBlock)GUI.Label(new Rect (580, y, 35, 20), "OFF" , gsLabel);


                if (tgMaid) {
                  GUI.Label(new Rect (605, 5, 200, 20), "【スポット移動】" , gsLabel);
                  y = 25;

                  if (bgID == 36 || bgID == 37) {

                    Vector3[] positions = {new Vector3(-2.81f, 0.6f, -3.76f), new Vector3(-2.73f, 0.83f, -7.27f), new Vector3(-2.73f, -0.22f, 2.56f), new Vector3(2.6f, -0.1f, 3.9f)};
                    Vector3[] angles = {new Vector3(0f, 87.5f, 0f), new Vector3(0f, 180f, 0f), new Vector3(0f, 351f, 0f), new Vector3(0f, 90f, 0f)};
                    float[] boneHeight = {0.5f, 0f, 0f, 0f};
                    string[] motions = {"om_seijyoui_1_f", "hekimen_tati_sokui_1_f", "om_furo_taimenzai_1_f", "mp_arai_1_f"};
                    for (int idx=0; idx<4; idx++) {
                      if (GUI.Button(new Rect (610, y + 40*idx, 85, 20), "スポット"+(idx+1), gsButton)){
                        Maid subMan = getSubMan(0);
                        MansTg[0] = tgID; //メイドと関連付け
                        //他のスポットに設定済みなら削除
                        for (int i=0; i<mn[bgID].Length; i++) {
                          if (mn[bgID][i] == tgID) mn[bgID][i] = -1;
                        }
                        mn[bgID][idx] = tgID;
                        
                        SelectYotogiMenu(motions[idx]); //パネル切替
                        StartMaidUnzip(mn[bgID][idx] , motions[idx]);

                        tgMaid.transform.position = positions[idx];
                        subMan.transform.position = positions[idx];
                        tgMaid.transform.eulerAngles = angles[idx];
                        subMan.transform.eulerAngles = angles[idx];
                        tgMaid.body0.SetBoneHitHeightY(boneHeight[idx]);
                        //tgMaid.CrossFadeAbsolute( motions[idx]+".anm", GameUty.FileSystem, false, true, false, 0.7f, 1f );
                        //subMan.CrossFadeAbsolute( motions[idx]+".anm", GameUty.FileSystem, false, true, false, 0.7f, 1f );
                      }
                      GUI.Label(new Rect (620, y+20 + 40*idx, 200, 20), mn[bgID][idx]==-1?"なし":stockMaids[mn[bgID][idx]].name , gsLabel);
                    }
                  } else {

                    for (int idx=0; idx<4; idx++) {
                      if (life_f[idx][0] != "") {
                        if (GUI.Button(new Rect (610, y+40*idx, 85, 20), "スポット"+(idx+1), gsButton)){
                          elSpot(idx, tgMaid, life_f[idx]);
                        }
                        GUI.Label(new Rect (620, y+20+40*idx, 200, 20), mn[bgID][idx]==-1?"なし":stockMaids[mn[bgID][idx]].name , gsLabel);
                      }
                    }
                  }
                }

            } else if (ElGuiFlag == 1) {
              node5.x = node2.x;
              if (cfgw.guiOffsetYSub < 450) node5.y = node2.y - 20; //サブキャラパネルが上にある場合
              else node5.y = node2.y + 20;
              if (GUI.Button(new Rect (200, 0, 20, 20), "+", gsButton)) {
                ElGuiFlag = 0;
                node5.width = 740;
                node5.height = 190;
                node5.x -= 520;
                if (cfgw.guiOffsetYSub < 450) node5.y -= 190; //サブキャラパネルが上にある場合
              }
            }

          GUI.DragWindow();
        }

        private void elSpot(int idx, Maid tgMaid, string[] param)
        {
          int manIdx = idx;
          for (int i = 0; i < 4; i++){
            if(life_m[i][0] != "" && intCnv(life_m[i][7]) == idx) {
              manIdx = i;
              break;
            }
          }
          tgMaid.transform.position = new Vector3(floatCnv(param[1]), floatCnv(param[2]), floatCnv(param[3]));
          tgMaid.transform.eulerAngles = new Vector3(floatCnv(param[4]), floatCnv(param[5]), floatCnv(param[6]));
          tgMaid.body0.SetBoneHitHeightY(floatCnv(param[9]));
          MaidSetFace(param[7], tgMaid);
          tgMaid.FaceBlend(param[8]);

          //顔と視線の向き変更
          if (param[11] == "0") tgMaid.EyeToCamera((Maid.EyeMoveType)5, 0.8f); //向ける
          if (param[11] == "1") tgMaid.EyeToCamera((Maid.EyeMoveType)0, 0.8f); //向けない
          if (param[11] == "2"){ //目だけ向ける
            tgMaid.EyeToCamera((Maid.EyeMoveType)0, 0.8f);
            tgMaid.body0.boEyeToCam = true;
          }

          //ボイスセット読み込み
          int iPersonal = Array.IndexOf(personalList[1], tgMaid.status.personal.uniqueName);
          //性格なしはMukuになる
          elLoadVoiceSet(iPersonal, idx);

          //マウスモード設定
          if (param[13].Contains("キス")) elMouthMode[idx] = 1;
          else if (param[13].Contains("フェラ")) elMouthMode[idx] = 2;
          else if (param[13].Contains("SEX_A")) elMouthMode[idx] = 0;

          //メイドアイテム装備
          MaidSetItem(param[16], tgMaid);

          if (manIdx > -1) {
            Maid subMan = getSubMan(manIdx);
            string[] manParam = life_m[manIdx];
            subMan.transform.position = new Vector3(floatCnv(manParam[1]), floatCnv(manParam[2]), floatCnv(manParam[3]));
            subMan.transform.eulerAngles = new Vector3(floatCnv(manParam[4]), floatCnv(manParam[5]), floatCnv(manParam[6]));
            ManSetMotion(manParam[0], subMan, 0.7f, 0);
            MansTg[manIdx] = tgID; //メイドと関連付け
          }

          //モーション変更 男も連動
          MaidSetMotion(param[0], tgMaid, 0f, idx);

          //他のスポットに設定済みなら削除
          for (int i=0; i<mn[bgID].Length; i++) {
            if (mn[bgID][i] == tgID) mn[bgID][i] = -1;
          }
          mn[bgID][idx] = tgID;

        }
        #endif

      //GUI関係終了-------------------------------


      //-------------------------------------------------
      #if EmpiresLife
      //新 エンパイアズライフ関係------------------------
        private bool el_Overwrite = false;
        private int elErrer = 0;
        private string[] elErrerText = new string[] { "" , "背景名が空白のため保存できません" , "上書きする場合は『上書／ｸﾘｱ』にチェックを入れて下さい" , "クリアする場合は『上書／ｸﾘｱ』にチェックを入れて下さい"};
        private string[] eyeModeText = new string[] { "自動" , "顔と目を向ける" , "目だけ向ける" , "向けない"};
        private string[] timeText = new string[] { "昼" , "夜" , "共通"};

        EmpiresLifeScene_Xml ELS = new EmpiresLifeScene_Xml();
        List<EmpiresLifeScene_Xml> elsList = new List<EmpiresLifeScene_Xml>();

        public class EmpiresLifeScene_Xml{
          public string bgName = "";
          public string bgCode = "";
          public string bgm = "";
          public int timeZone = 0;
          public Color lightColor = new Color(1f, 1f, 1f, 1f);
          public Vector3 cameraPos = new Vector3(0f, 0f, 0f);
          public Vector3 cameraEul = new Vector3(0f, 0f, 0f);

          public List<string> mansMotion = new List<string>();
          public List<int> mansTime = new List<int>();
          public List<Vector3> mansPos = new List<Vector3>();
          public List<Vector3> mansEul = new List<Vector3>();
        }

        EmpiresLifeEvents_Xml ELE = new EmpiresLifeEvents_Xml();
        public class EmpiresLifeEvents_Xml{
          public string evName = "";
          public string bgCode = "";
          public int timeZone = 0;

          public List<string> motionSet = new List<string>();
          public List<string> voiceSet = new List<string>();
          public List<bool> ntr = new List<bool>();
          public List<int> mans = new List<int>();
          public List<Vector3> pos = new List<Vector3>();
          public List<Vector3> eul = new List<Vector3>();
          public List<string> faceA = new List<string>();
          public List<string> faceB = new List<string>();
          public List<int> autoP = new List<int>();
          public List<int> eyeMode = new List<int>();
          public List<int> Undress = new List<int>();

          public List<string> handitem = new List<string>();
          public List<string> accvag = new List<string>();
          public List<string> accanl = new List<string>();
        }

        //ライフシーンXMLファイルを読み込む
        private List<string> elsFiles = new List<string>();
        private void LifeSceneLoad(){
          List<string> _files = new List<string>();
          string fileName = "";
          string[] files;

          //ライフセットのフォルダ確認
          if (System.IO.Directory.Exists(@"Sybaris\UnityInjector\Config\VibeYourMaid\EmpiresLifeSet\")){
            _files.Clear();
            files = Directory.GetFiles(@"Sybaris\UnityInjector\Config\VibeYourMaid\EmpiresLifeSet\", "*.xml");

            foreach (string file in files){
              fileName = Path.GetFileName(file);
              if(Regex.IsMatch(fileName, "^els_"))_files.Add(fileName);
            }
            elsFiles = new List<string>(_files);
          }

          elsList.Clear();
          foreach (string file in elsFiles){
            fileName = @"Sybaris\UnityInjector\Config\VibeYourMaid\EmpiresLifeSet\" + file;
            elsList.Add(elsXmlLoad(fileName));
          }
        }

        private void LifeSceneLoad(string bgCode){

          //保存先のファイル名
          string fileName = @"Sybaris\UnityInjector\Config\VibeYourMaid\EmpiresLifeSet\els_" + bgCode + @".xml";
          Console.WriteLine(fileName);

          if (System.IO.File.Exists(fileName)){
            ELS = elsXmlLoad(fileName);

          } else { //ファイルが存在しない場合に初期ファイルを作成
            LifeSceneSave();
          }
        }

        private EmpiresLifeScene_Xml elsXmlLoad(string fileName){

          EmpiresLifeScene_Xml _els = new EmpiresLifeScene_Xml();

          //XmlSerializerオブジェクトを作成
          System.Xml.Serialization.XmlSerializer serializer = new System.Xml.Serialization.XmlSerializer(typeof(EmpiresLifeScene_Xml));
          //読み込むファイルを開く
          System.IO.StreamReader sr = new System.IO.StreamReader(fileName, new System.Text.UTF8Encoding(false));

          //XMLファイルから読み込み、逆シリアル化する
          _els = (EmpiresLifeScene_Xml)serializer.Deserialize(sr);

          //ファイルを閉じる
          sr.Close();
          Console.WriteLine("読み込み完了");

          return _els;
        }

        //ライフイベントXMLファイルを読み込む
        private void LifeEventsLoad(string bgCode, string file){

          //保存先のファイル名
          string fileName = @"Sybaris\UnityInjector\Config\VibeYourMaid\EmpiresLifeSet\" + bgCode + @"\ele_" + file + @".xml";
          Console.WriteLine(fileName);

          if (System.IO.File.Exists(fileName)){
            //XmlSerializerオブジェクトを作成
            System.Xml.Serialization.XmlSerializer serializer = new System.Xml.Serialization.XmlSerializer(typeof(EmpiresLifeEvents_Xml));
            //読み込むファイルを開く
            System.IO.StreamReader sr = new System.IO.StreamReader(fileName, new System.Text.UTF8Encoding(false));

            //XMLファイルから読み込み、逆シリアル化する
            ELE = (EmpiresLifeEvents_Xml)serializer.Deserialize(sr);

            //ファイルを閉じる
            sr.Close();
            Console.WriteLine("読み込み完了");
          }
        }

        //ライフシーンをXMLファイルに保存する
        private void LifeSceneSave(){

          // フォルダ確認
          if (!System.IO.Directory.Exists(@"Sybaris\UnityInjector\Config\VibeYourMaid\EmpiresLifeSet\")) {
            //ない場合はフォルダ作成
            System.IO.DirectoryInfo di = System.IO.Directory.CreateDirectory(@"Sybaris\UnityInjector\Config\VibeYourMaid\EmpiresLifeSet");
          }


          if(ELS.bgName == "" || ELS.bgCode == ""){  //ボイスセット名が空白の場合保存しない
            elErrer = 1;

          } else {
            //保存先のファイル名
            string fileName = @"Sybaris\UnityInjector\Config\VibeYourMaid\EmpiresLifeSet\els_" + ELS.bgCode + @".xml";

            if (System.IO.File.Exists(fileName) && !el_Overwrite){  //上書きのチェック
              elErrer = 2;

            } else {

              //XmlSerializerオブジェクトを作成
              //オブジェクトの型を指定する
              System.Xml.Serialization.XmlSerializer serializer = new System.Xml.Serialization.XmlSerializer(typeof(EmpiresLifeScene_Xml));

              //書き込むファイルを開く（UTF-8 BOM無し）
              System.IO.StreamWriter sw = new System.IO.StreamWriter(fileName, false, new System.Text.UTF8Encoding(false));

              //シリアル化し、XMLファイルに保存する
              serializer.Serialize(sw, ELS);
              //ファイルを閉じる
              sw.Close();

              el_Overwrite = false;
              elErrer = 0;
            }
          }
        }

        //ライフイベントをXMLファイルに保存する
        private void LifeEventsSave(){

          // フォルダ確認
          string folder = @"Sybaris\UnityInjector\Config\VibeYourMaid\EmpiresLifeSet\" + ELE.bgCode + @"\";
          if (!System.IO.Directory.Exists(folder)) {
            //ない場合はフォルダ作成
            System.IO.DirectoryInfo di = System.IO.Directory.CreateDirectory(folder);
          }


          if(ELE.evName == "" || ELE.bgCode == ""){  //イベント名が空白の場合保存しない
            elErrer = 1;

          } else {
            //保存先のファイル名
            string fileName = folder + "ele_" + ELE.evName + @".xml";

            if (System.IO.File.Exists(fileName) && !el_Overwrite){  //上書きのチェック
              elErrer = 2;

            } else {

              //XmlSerializerオブジェクトを作成
              //オブジェクトの型を指定する
              System.Xml.Serialization.XmlSerializer serializer = new System.Xml.Serialization.XmlSerializer(typeof(EmpiresLifeEvents_Xml));

              //書き込むファイルを開く（UTF-8 BOM無し）
              System.IO.StreamWriter sw = new System.IO.StreamWriter(fileName, false, new System.Text.UTF8Encoding(false));

              //シリアル化し、XMLファイルに保存する
              serializer.Serialize(sw, ELE);
              //ファイルを閉じる
              sw.Close();

              el_Overwrite = false;
              elErrer = 0;
            }
          }
        }


        private void elsChange(EmpiresLifeScene_Xml els){

          GameMain.Instance.SoundMgr.StopSe();
          GameMain.Instance.SoundMgr.StopBGM(2f);

          GameMain.Instance.MainLight.GetComponent<Light>().color = els.lightColor; //ライト変更

          //全メイドと男を一旦非表示
          GameMain.Instance.CharacterMgr.DeactivateMaidAll();
          GameMain.Instance.CharacterMgr.ResetCharaPosAll();
          for (int i = 0; i < SubMans.Length; i++) {
            setSubManVisible(i, false);
          }

          //背景変更
          Console.WriteLine("背景チェンジ:" + els.bgCode);
          GameMain.Instance.BgMgr.ChangeBg(els.bgCode);

          //カメラ移動
          mainCamera.transform.eulerAngles = els.cameraEul;
          if(!bVR){
            mainCamera.SetPos(els.cameraPos);
            mainCamera.SetTargetPos(els.cameraPos, true);
            mainCamera.SetDistance(0f, true);
          }else{
            mainCamera.SetPos(els.cameraPos);
          }

          //BGM変更
          GameMain.Instance.SoundMgr.PlayBGMLegacy(els.bgm, 0f, true);

        }

      //新 エンパイアズライフ関係終了------------------------
      #endif


      //-------------------------------------------------
      #if EmpiresLife
      //エンパイアズライフ関係---------------------------
        //エンパイアズライフ用変数
        private int bgID = 0;
        private bool elFade = false;
        private int lifeStart = 0;
        private int danceFlag = 0;
        private bool maidOver = false;
        private bool freeOver = false;
        private bool exclusiveOver = false;
        private int hmID = 0;
        private int[] elMouthMode = new int[]{ 0, 0, 0, 0 };
        private int[] eldatui = new int[]{ 0, 0, 0, 0 };
        private float[] lifeTime1 = new float[]{ 0, 0, 0, 0 };
        private float[] lifeTime2 = new float[]{ 0, 0, 0, 0 };
        private float[] lifeTime3 = new float[]{ 0, 0, 0, 0 };
        private int[] elvFlag = new int[]{ 0, 0, 0, 0 };
        private bool[] elcrFlag = new bool[]{ false, false, false, false };
        private bool[] mOnceFlag = new bool[]{ false, false, false, false };
        private string[] mOnceBack = new string[]{ "" , "" , "" , "" };
        private string[][] mItem = new string[][]{
          new string[]{ "" , "" },
          new string[]{ "" , "" },
          new string[]{ "" , "" },
          new string[]{ "" , "" }
        };

        private int[][] mn = new int[][]{
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1},
          new int[]{-1,-1,-1,-1}
        };
        private List<int[]> holidayMaid = new List<int[]>();

        //モーション , PX , PY , PZ , EX , EY , EZ , 表情 , フェイスブレンド , 床調整 , 着衣 , 視線 , ダンスBGM , ボイスセット , ボイス再生距離 , ボイス再生間隔 , メイドアイテム, NTRブロック
        private string[][] life_f = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "" , "" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "" , "" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "" , "" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "" , "" , "" , "0" }
        };
        //モーション , PX , PY , PZ , EX , EY , EZ , ターゲットメイド
        private string[][] life_m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };

        private string[][] bgArray1 = new string[][]{
          new string[] {"Shitsumu_ChairRot"       , "執務室"                 , "bgm015.ogg"    , "1" , "-0.08" , "1.57" ,  "2.60" , "3.7" , "183.4" , "0" , "1" , "1" }, //00
          new string[] {"Shitsumu_ChairRot_Night" , "執務室（夜）"           , "bgm015.ogg"    , "2" , "-0.08" , "1.57" ,  "2.60" , "3.7" , "183.4" , "0" , "1" , "1" }, //01
          new string[] {"Salon"                   , "サロン"                 , "bgm014.ogg"    , "1" ,  "0.00" , "0.00" , "19.00" , "0.0" , "180" , "0" , "1" , "1" }, //02
          new string[] {"Salon"                   , "サロン（夜）"           , "bgm013.ogg"    , "2" ,  "0.00" , "0.00" , "19.00" , "0.0" , "180" , "0" , "5" , "1" }, //03
          new string[] {"Syosai"                  , "書斎"                   , "bgm007.ogg"    , "1" ,  "4.07" , "1.71" ,  "1.83" , "4.72" , "270.47" , "0" , "1" , "1" }, //04
          new string[] {"Syosai_Night"            , "書斎（夜）"             , "bgm007.ogg"    , "2" ,  "4.07" , "1.71" ,  "1.83" , "4.72" , "270.47" , "0" , "1" , "1" }, //05
          new string[] {"DressRoom_NoMirror"      , "ドレスルーム"           , "bgm014.ogg"    , "1" , "-2.22" , "1.19" ,  "1.96" , "1.92" , "92.93" , "0" , "1" , "1" }, //06
          new string[] {"DressRoom_NoMirror"      , "ドレスルーム（夜）"     , "bgm014.ogg"    , "2" , "-2.22" , "1.19" ,  "1.96" , "1.92" , "92.93" , "0" , "1" , "1" }, //07
          new string[] {"MyBedRoom"               , "自室"                   , "bgm007.ogg"    , "1" , "-3.66" , "1.70" ,  "2.87" , "359.13" , "185.21" , "0" , "1" , "1" }, //08
          new string[] {"MyBedRoom_Night"         , "自室（夜）"             , "bgm011.ogg"    , "2" , "-3.66" , "1.70" ,  "2.87" , "359.13" , "185.21" , "0" , "1" , "1" }, //09
          new string[] {"HoneymoonRoom"           , "ハネムーンルーム（夜）" , "bgm011.ogg"    , "2" , "-2.68" , "1.66" ,  "3.80" , "0" , "157.5" , "0" , "1" , "1" },  //10
          new string[] {"Bathroom"                , "お風呂（夜）"           , "bgm006.ogg"    , "2" ,  "0.07" , "1.46" ,  "0.93" , "4.41" , "180.18" , "0" , "1" , "1" }, //11
          new string[] {"PlayRoom"                , "プレイルーム"           , "bgm014.ogg"    , "1" , "-1.63" , "1.58" , "-5.39" , "1.9" , "358.5" , "0" , "1" , "1" }, //12
          new string[] {"PlayRoom"                , "プレイルーム（夜）"     , "bgm005.ogg"    , "2" , "-1.63" , "1.58" , "-5.39" , "1.9" , "358.5" , "0" , "2" , "1" }, //13
          new string[] {"PlayRoom2"               , "プレイルーム2"          , "bgm014.ogg"    , "1" ,  "0.02" , "1.64" ,  "7.47" , "7.2" , "179.5" , "0" , "1" , "1" }, //14
          new string[] {"PlayRoom2"               , "プレイルーム2（夜）"    , "bgm005.ogg"    , "2" ,  "0.02" , "1.64" ,  "7.47" , "7.2" , "179.5" , "0" , "1" , "1" }, //15
          new string[] {"Pool"                    , "プール"                 , "bgm005.ogg"    , "2" , "17.80" , "2.25" , "15.01" , "359.4" , "269.4" , "0" , "1" , "1" }, //16
          new string[] {"SMRoom"                  , "SMルーム"               , "bgm014.ogg"    , "1" , "-2.08" , "1.43" , "-3.85" , "2.2" , "17.1" , "0" , "1" , "1" }, //17
          new string[] {"SMRoom"                  , "SMルーム（夜）"         , "bgm010.ogg"    , "2" , "-2.08" , "1.43" , "-3.85" , "2.2" , "17.1" , "0" , "1" , "1" }, //18
          new string[] {"SMRoom2"                 , "地下室"                 , "bgm014.ogg"    , "1" ,  "0.12" , "1.53" ,  "4.70" , "5" , "181.1" , "0" , "1" , "1" }, //19
          new string[] {"SMRoom2"                 , "地下室（夜）"           , "bgm026.ogg"    , "2" ,  "0.12" , "1.53" ,  "4.70" , "5" , "181.1" , "0" , "1" , "1" }, //20
          new string[] {"Salon_Garden"            , "中庭"                   , "bgm005.ogg"    , "2" , "-0.09" , "1.50" , "13.20" , "4.1" , "186.7" , "0" , "1" , "1" }, //21
          new string[] {"LargeBathRoom"           , "大浴場"                 , "bgm006.ogg"    , "1" ,  "1.97" , "1.95" ,  "6.08" , "9.69" , "188.74" , "0" , "1" , "1" }, //22
          new string[] {"LargeBathRoom"           , "大浴場（夜）"           , "bgm006.ogg"    , "2" ,  "1.97" , "1.95" ,  "6.08" , "9.69" , "188.74" , "0" , "1" , "1" }, //23
          new string[] {"OiranRoom"               , "花魁部屋"               , "bgm012.ogg"    , "1" , "-0.09" , "1.75" ,  "3.92" , "4.7" , "179.1" , "0" , "1" , "1" }, //24
          new string[] {"OiranRoom"               , "花魁部屋（夜）"         , "bgm012.ogg"    , "2" , "-0.09" , "1.75" ,  "3.92" , "4.7" , "179.1" , "0" , "1" , "1" }, //25
          new string[] {"Penthouse"               , "ペントハウス"           , "bgm005.ogg"    , "2" ,  "1.93" , "1.30" ,  "4.54" , "2.8" , "178.9" , "0" , "1" , "1" }, //26
          new string[] {"Town"                    , "街"                     , "bgm005.ogg"    , "0" , "-7.93" , "2.20" ,  "1.60" , "9" , "92.8" , "0" , "1" , "1" }, //27
          new string[] {"Kitchen"                 , "キッチン"               , "bgm014.ogg"    , "1" , "-2.08" , "1.46" ,  "2.28" , "2.8" , "99.5" , "0" , "1" , "1" }, //28
          new string[] {"Kitchen_Night"           , "キッチン（夜）"         , "bgm014.ogg"    , "2" , "-2.08" , "1.46" ,  "2.28" , "2.8" , "99.5" , "0" , "1" , "1" }, //29
          new string[] {"Salon_Entrance"          , "エントランス"           , "bgm013.ogg"    , "0" , "-0.02" , "1.19" , "-17.4" , "1.6" , "3.5" , "0" , "1" , "1" }, //30
          new string[] {"Salon_Entrance"          , "エントランス（夜）"     , "bgm013.ogg"    , "0" , "-0.02" , "1.19" , "-17.4" , "1.6" , "3.5" , "0" , "1" , "1" }, //31
          new string[] {"poledancestage"          , "ポールダンス"           , "fusionicaddiction_short_pole.ogg"    , "2" , "-0.05" , "1.01" , "-14.5" , "359.7" , "358.5" , "0" , "2" , "1" }, //32
          new string[] {"Bar"                     , "バー（夜）"             , "bgm013.ogg"    , "2" , "-0.13" , "1.57" , "-6.19" , "4.4" , "4.5" , "0" , "1" , "1" },  //33
          new string[] {"Toilet"                  , "トイレ"                 , "bgm014.ogg"    , "1" , "-2.25" , "1.78" ,  "4.43" , "7.51" , "180.77" , "0" , "1" , "1" },  //34
          new string[] {"Toilet"                  , "トイレ（夜）"           , "bgm014.ogg"    , "2" , "-2.25" , "1.78" ,  "4.43" , "7.51" , "180.77" , "0" , "1" , "1" },  //35
          new string[] {"Soap"                    , "ソープ"                 , "bgm011.ogg"    , "1" , "-0.02" , "1.34" , "-7.26" , "0" , "0" , "0" , "1" , "1" },  //36
          new string[] {"Soap"                    , "ソープ（夜）"           , "bgm011.ogg"    , "2" , "-0.02" , "1.34" , "-7.26" , "0" , "0" , "0" , "1" , "1" },  //37
          new string[] {"MaidRoom"                , "メイド部屋"             , "bgm014.ogg"    , "0" ,  "0.10" , "1.53" ,  "2.33" , "5.6" , "183.8" , "0" , "6" , "1" }, //38
          new string[] {"MaidRoom"                , "メイド部屋（夜）"       , "bgm014.ogg"    , "0" ,  "0.10" , "1.53" ,  "2.33" , "5.6" , "183.8" , "0" , "1" , "1" }  //39
        };


        //00：執務室 シーン設定
        private string[][] life00_01f = new string[][]{
          new string[] { "soji_mop.anm|soji_mop_kaiwa.anm" , "-1.3" , "0" , "1" , "0" , "312" , "0" , "通常|微笑み|にっこり|思案伏せ目|発情|困った|疑問|誘惑" , "頬０涙０" , "0" , "0" , "0" , "" , "掃除" , "-1" , "-1" , "handitem,HandItemR_Mop_I_.menu" , "0" },
          new string[] { "soji_zoukin.anm|soji_zoukin_kaiwa_l.anm" , "1" , "0" , "1.5" , "0" , "65" , "0" , "通常|微笑み|にっこり|思案伏せ目|発情|困った|疑問|誘惑" , "頬０涙０" , "0" , "0" , "0" , "" , "掃除" , "-1" , "-1" , "handitem,HandItemR_Zoukin2_I_.menu" , "0" },
          new string[] { "" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] { "" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life00_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //01：執務室（夜） シーン設定
        private string[][] life01_01f = new string[][]{
          new string[] { "maid_stand02akubi_ONCE_.anm|maid_dressroom02.anm|maid_stand02ListenB_Unazuki_ONCE_.anm|maid_stand02Listenloop2.anm|maid_stand02tere.anm|maid_stand02sian2_ONCE_.anm|maid_stand02Left_ONCE_.anm|maid_stand02akubi_ONCE_.anm|maid_stand02hair_ONCE_.anm|maid_comehome2_LOOP_.anm" , "1.28" , "0" , "0" , "0" , "272.5" , "0" , "通常|微笑み|笑顔|にっこり|優しさ|思案伏せ目|発情|困った|疑問|誘惑" , "頬０涙０" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] { "" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] { "" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] { "" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life01_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //02：サロン シーン設定
        private string[][] life02_01f = new string[][]{
          new string[] { "dance_cm3d_004_kano_f1.anm" , "0" , "0" , "-0.62" , "0" , "0" , "0" , "引きつり笑顔|困った|泣き" , "頬０涙１" , "0" , "0" , "0" , "dummy" , "" , "-1" , "-1" , "" , "0" },
          new string[] { "dance_cm3d_004_kano_f1.anm" , "-0.9" , "0" , "0.20" , "0" , "0" , "0" , "引きつり笑顔|困った|泣き" , "頬０涙１" , "0" , "0" , "0" , "dummy" , "" , "-1" , "-1" , "" , "0" },
          new string[] { "dance_cm3d_004_kano_f1.anm" , "0.9" , "0" , "0.20" , "0" , "0" , "0" , "通常|笑顔|にっこり|ドヤ顔|ウインク照れ" , "頬０涙０" , "0" , "0" , "0" , "dummy" , "" , "-1" , "-1" , "" , "0" },
          new string[] { "kaiwa_tati_hakusyu_taiki_2_f.anm|kaiwa_tati_hakusyu_taiki_2_f.anm|kaiwa_tati_hakusyu_taiki_2_f.anm|kaiwa_tati_yubisasu_f_ONCE_.anm|kaiwa_tati_kuyasi_f_ONCE_.anm|kaiwa_tati_mo_f_ONCE_.anm|kaiwa_tati_yorokobu_f_ONCE_.anm" , "0" , "0" , "2.04" , "0" , "180" , "0" , "怒り|照れ叫び|ジト目|むー" , "頬０涙０" , "0" , "0" , "1" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life02_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //03：サロン（夜） シーン設定
        private string[][] life03_01f = new string[][]{
          new string[] {"dance_cm3d_001_f1.anm","0","0","0","0","0","0","笑顔|にっこり|ドヤ顔|ウインク照れ|引きつり笑顔|微笑み|発情|誘惑|思案伏せ目|疑問","頬０涙０","0" , "0" , "1" , "entrancetoyou_short.ogg" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"kaiwa_sofa_kangaeruB_taiki_f.anm|kaiwa_sofa_1_f.anm|kaiwa_sofa_kangaeru_f_ONCE_.anm|kaiwa_sofa_noridasu_2_f_ONCE_.anm|kaiwa_sofa_teawaseA_taiki1_f.anm|kaiwa_sofa_teawase_taiki_f.anm|kaiwa_sofa_tere_taiki_f.anm","-5.67","-1.45","7.91","0","106","0","通常|微笑み|笑顔|にっこり|優しさ|思案伏せ目|発情|誘惑","頬０涙０","-2" , "0" , "1" , "" , "会話01" , "-1" , "300" , "" , "0" },
          new string[] {"settai_aibu_2_f.anm|settai_aibu_3_f.anm","3.73","-1.46","11.48","0","205","0","エロ羞恥１|エロ羞恥２|興奮射精後１|エロ痛み２|エロ我慢３|まぶたギュ","頬２涙１","-2" , "0" , "2" , "" , "SEX_A" , "-1" , "0" , "" , "1" },
          new string[] {"om_furo_taimenzai_kiss_2_f.anm|om_furo_taimenzai_kiss_3_f.anm","5.73","-1.47","4.69","0","268","0","エロ羞恥２|エロ羞恥３|エロ好感３|興奮射精後１|発情|エロ興奮３|エロ期待","頬２涙１よだれ","-2" , "3" , "2" , "" , "SEX_A" , "-1" , "0" , "" , "1" }
        };
        private string[][] life03_01m = new string[][]{
          new string[] { "" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] { "man_suwarimati1.anm" , "-5.73" , "-1.41" , "8.6" , "0" , "114" , "0" , "1" },
          new string[] { "settai_aibu_2_m.anm|settai_aibu_3_m.anm" , "3.73" , "-1.46" , "11.48" , "0" , "205" , "0" , "2" },
          new string[] { "om_furo_taimenzai_kiss_2_m.anm|om_furo_taimenzai_kiss_3_m.anm" , "5.73" , "-1.47" , "4.69" , "0" , "268" , "0" , "3" }
        };

        private string[][] life03_02f = new string[][]{
          new string[] { "dance_cm3d2_001_f1.anm" , "0" , "0" , "0" , "0" , "0" , "0" , "笑顔|にっこり|ドヤ顔|ウインク照れ|引きつり笑顔|微笑み|発情|誘惑|思案伏せ目|疑問" , "頬０涙０" , "0" , "0" , "1" , "dokidokifallinlove_short.ogg" , "" , "-1" , "-1" , "" , "0" },
          new string[] { "dance_cm3d2_001_f2.anm" , "0" , "0" , "0" , "0" , "0" , "0" , "笑顔|にっこり|ドヤ顔|ウインク照れ|引きつり笑顔|微笑み|発情|誘惑|思案伏せ目|疑問" , "頬０涙０" , "0" , "0" , "1" , "dokidokifallinlove_short.ogg" , "" , "-1" , "-1" , "" , "0" },
          new string[] { "dance_cm3d2_001_f3.anm" , "0" , "0" , "0" , "0" , "0" , "0" , "笑顔|にっこり|ドヤ顔|ウインク照れ|引きつり笑顔|微笑み|発情|誘惑|思案伏せ目|疑問" , "頬０涙０" , "0" , "0" , "1" , "dokidokifallinlove_short.ogg" , "" , "-1" , "-1" , "" , "0" },
          new string[] { "haimenritui_2_f.anm|haimenritui_2a01_f.anm|haimenritui_2b01_f.anm|haimenritui_2b02_f.anm|haimenritui_3_f.anm|haimenritui_3a01_f.anm|haimenritui_3b01_f.anm|haimenritui_3b02_f.anm" , "-0.77" , "-1.92" , "-4.26" , "0" , "318.3" , "0" , "エロ痛み我慢|エロ羞恥２|興奮射精後１|エロ痛み２|引きつり笑顔|エロ我慢３|まぶたギュ" , "頬２涙１" , "-2" , "3" , "1" , "" , "SEX_A" , "-1" , "0" , "" , "1" }
        };
        private string[][] life03_02m = new string[][]{
          new string[] { "" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] { "haimenritui_2_m.anm|haimenritui_2_m.anm|haimenritui_2_m.anm|haimenritui_2_m.anm|haimenritui_3_m.anm|haimenritui_3_m.anm|haimenritui_3_m.anm|haimenritui_3_m.anm" , "-0.77" , "-1.92" , "-4.26" , "0" , "318.3" , "0" , "3" },
          new string[] { "m_dance000_m.anm" , "0.86" , "-1.94" , "10.25" , "0" , "188.3" , "0" , "0" },
          new string[] { "m_dance000_m.anm" , "-1.11" , "-1.92" , "10.01" , "0" , "172.2" , "0" , "0" }
        };

        private string[][] life03_03f = new string[][]{
          new string[] { "dance_cm3d2_kara_002_cktc_f1.anm" , "0.54" , "0" , "5.58" , "0" , "75.7" , "0" , "笑顔|にっこり|ドヤ顔|ウインク照れ|引きつり笑顔|微笑み|発情|誘惑|思案伏せ目|疑問" , "頬０涙０" , "0" , "0" , "0" , "can_know_two_close.ogg" , "" , "-1" , "-1" , "handitem,HandItemL_Karaoke_Mike_I_.menu" , "0" },
          new string[] { "dance_cm3d_004_kano_f1.anm" , "-0.75" , "0" , "-0.05" , "0" , "0" , "0" , "笑顔|にっこり|ドヤ顔|ウインク照れ|引きつり笑顔|微笑み|発情|誘惑|思案伏せ目|疑問" , "頬０涙０" , "0" , "0" , "1" , "can_know_two_close.ogg" , "" , "-1" , "-1" , "" , "0" },
          new string[] { "dance_cm3d_004_kano_f1.anm" , "0.75" , "0" , "-0.05" , "0" , "0" , "0" , "笑顔|にっこり|ドヤ顔|ウインク照れ|引きつり笑顔|微笑み|発情|誘惑|思案伏せ目|疑問" , "頬０涙０" , "0" , "0" , "1" , "can_know_two_close.ogg" , "" , "-1" , "-1" , "" , "0" },
          new string[] { "jump_s.anm|jump_s.anm|jump_s.anm|[S]turn01_ATOFF_.anm|kaiwa_tati_kuyasi_taiki_1_f.anm|kaiwa_tati_kuyasi_taiki_1_f.anm|kaiwa_tati_yorokobu_f_ONCE_.anm" , "0.50" , "-1.92" , "8.95" , "0" , "186.0" , "0" , "笑顔|にっこり|ドヤ顔|微笑み|ウインク照れ" , "頬１涙０" , "-2" , "0" , "1" , "" , "" , "-1" , "0" , "" , "0" }
        };
        private string[][] life03_03m = new string[][]{
          new string[] { "" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] { "m_dance000_m.anm" , "-2.72" , "-1.92" , "8.78" , "0" , "166.2" , "0" , "0" },
          new string[] { "m_dance000_m.anm" , "2.17" , "-1.92" , "10.29" , "0" , "202.6" , "0" , "0" },
          new string[] { "m_dance000_m.anm" , "-1.11" , "-1.92" , "10.01" , "0" , "172.2" , "0" , "0" }
        };

        private string[][] life03_04f = new string[][]{
          new string[] { "dance_cm3d2_kara_001_sl_f1.anm" , "3.42" , "0" , "0.28" , "0" , "177.7" , "0" , "笑顔|にっこり|ドヤ顔|ウインク照れ|引きつり笑顔|微笑み|発情|誘惑|思案伏せ目|疑問" , "頬０涙０" , "0" , "0" , "0" , "scarlet leap_short.ogg" , "" , "-1" , "-1" , "handitem,HandItemL_Karaoke_Mike_I_.menu" , "0" },
          new string[] { "dance_cm3d_002_end_f1.anm" , "-0.92" , "0" , "-0.48" , "0" , "35" , "0" , "笑顔|にっこり|ドヤ顔|ウインク照れ|引きつり笑顔|微笑み|発情|誘惑|思案伏せ目|疑問" , "頬０涙０" , "0" , "0" , "1" , "scarlet leap_short.ogg" , "" , "-1" , "-1" , "" , "0" },
          new string[] { "dance_cm3d_002_end_f1.anm" , "1.02" , "0" , "-0.38" , "0" , "330" , "0" , "笑顔|にっこり|ドヤ顔|ウインク照れ|引きつり笑顔|微笑み|発情|誘惑|思案伏せ目|疑問" , "頬０涙０" , "0" , "0" , "1" , "scarlet leap_short.ogg" , "" , "-1" , "-1" , "" , "0" },
          new string[] { "jump_s.anm|jump_s.anm|jump_s.anm|[S]turn01_ATOFF_.anm|kaiwa_tati_kuyasi_taiki_1_f.anm|kaiwa_tati_kuyasi_taiki_1_f.anm|kaiwa_tati_yorokobu_f_ONCE_.anm" , "0.50" , "-1.92" , "8.95" , "0" , "186.0" , "0" , "笑顔|にっこり|ドヤ顔|微笑み|ウインク照れ" , "頬１涙０" , "-2" , "0" , "1" , "" , "" , "-1" , "0" , "" , "0" }
        };
        private string[][] life03_04m = new string[][]{
          new string[] { "" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] { "m_dance000_m.anm" , "-2.72" , "-1.92" , "8.78" , "0" , "166.2" , "0" , "0" },
          new string[] { "m_dance000_m.anm" , "2.17" , "-1.92" , "10.29" , "0" , "202.6" , "0" , "0" },
          new string[] { "m_dance000_m.anm" , "-1.11" , "-1.92" , "10.01" , "0" , "172.2" , "0" , "0" }
        };

        private string[][] life03_05f = new string[][]{
          new string[] { "dance_cmo_001_cg_f1.anm" , "0" , "0" , "0" , "0" , "0" , "0" , "笑顔|にっこり|ドヤ顔|ウインク照れ|引きつり笑顔|微笑み|発情|誘惑|思案伏せ目|疑問" , "頬０涙０" , "0" , "0" , "1" , "candygirl_short.ogg" , "" , "-1" , "-1" , "" , "0" },
          new string[] { "dance_cmo_001_cg_f2.anm" , "0" , "0" , "0" , "0" , "0" , "0" , "笑顔|にっこり|ドヤ顔|ウインク照れ|引きつり笑顔|微笑み|発情|誘惑|思案伏せ目|疑問" , "頬０涙０" , "0" , "0" , "1" , "candygirl_short.ogg" , "" , "-1" , "-1" , "" , "0" },
          new string[] { "dance_cmo_001_cg_f3.anm" , "0" , "0" , "0" , "0" , "0" , "0" , "笑顔|にっこり|ドヤ顔|ウインク照れ|引きつり笑顔|微笑み|発情|誘惑|思案伏せ目|疑問" , "頬０涙０" , "0" , "0" , "1" , "candygirl_short.ogg" , "" , "-1" , "-1" , "" , "0" },
          new string[] { "jump_s.anm|jump_s.anm|jump_s.anm|[S]turn01_ATOFF_.anm|kaiwa_tati_kuyasi_taiki_1_f.anm|kaiwa_tati_kuyasi_taiki_1_f.anm|kaiwa_tati_yorokobu_f_ONCE_.anm" , "0.50" , "-1.92" , "8.95" , "0" , "186.0" , "0" , "笑顔|にっこり|ドヤ顔|微笑み|ウインク照れ" , "頬１涙０" , "-2" , "0" , "1" , "" , "" , "-1" , "0" , "" , "0" }
        };
        private string[][] life03_05m = new string[][]{
          new string[] { "" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] { "m_dance000_m.anm" , "-2.72" , "-1.92" , "8.78" , "0" , "166.2" , "0" , "0" },
          new string[] { "m_dance000_m.anm" , "2.17" , "-1.92" , "10.29" , "0" , "202.6" , "0" , "0" },
          new string[] { "m_dance000_m.anm" , "-1.11" , "-1.92" , "10.01" , "0" , "172.2" , "0" , "0" }
        };


        //04：書斎 シーン設定
        private string[][] life04_01f = new string[][]{
          new string[] { "work_saihou.anm" , "-1.139137" , "0.5423361" , "-1.183796" , "0" , "0" , "0" , "ドヤ顔|ジト目|思案伏せ目" , "頬０涙０" , "0" , "0" , "1" , "" , "裁縫" , "-1" , "-1" , "handitem,HandItemD_Shisyuu_Hari_I_.menu" , "0" },
          new string[] { "kaiwa_sofa_kangaeruB_taiki_f.anm|kaiwa_sofa_1_f.anm|kaiwa_sofa_kangaeru_f_ONCE_.anm|kaiwa_sofa_noridasu_2_f_ONCE_.anm|kaiwa_sofa_teawaseA_taiki1_f.anm|kaiwa_sofa_teawase_taiki_f.anm|kaiwa_sofa_tere_taiki_f.anm|kaiwa_sofa_odoroki_taiki_f.anm" , "3.708251" , "0.4274125" , "-0.442423" , "0" , "306.8843" , "0" , "通常|微笑み|にっこり|思案伏せ目|困った|疑問|びっくり" , "頬０涙０" , "0" , "0" , "0" , "" , "会話01" , "-1" , "300" , "" , "0" },
          new string[] { "kaiwa_sofa_kangaeruB_taiki_f.anm|kaiwa_sofa_1_f.anm|kaiwa_sofa_kangaeru_f_ONCE_.anm|kaiwa_sofa_noridasu_2_f_ONCE_.anm|kaiwa_sofa_teawaseA_taiki1_f.anm|kaiwa_sofa_teawase_taiki_f.anm|kaiwa_sofa_tere_taiki_f.anm" , "3.033922" , "0.4356421" , "-1.74213" , "0" , "87.28329" , "0" , "通常|微笑み|にっこり|思案伏せ目|困った|疑問|びっくり" , "頬０涙０" , "0" , "0" , "0" , "" , "会話01" , "-1" , "300" , "" , "0" },
          new string[] { "sleep2.anm" , "-1.119797" , "0.5723807" , "1.035077" , "0" , "173.4105" , "0" , "居眠り安眠|接吻|まぶたギュ" , "頬０涙０" , "0" , "0" , "1" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life04_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //05：書斎（夜） シーン設定
        private string[][] life05_01f = new string[][]{
          new string[] { "midasinami_kesyou_lip_f.anm" , "-2.320528" , "0.5723807" , "1.035077" , "0" , "173.4105" , "0" , "優しさ|思案伏せ目|疑問" , "頬０涙０" , "0" , "0" , "1" , "" , "化粧" , "-1" , "-1" , "handitem,HandItemR_Rip_I_.menu" , "0" },
          new string[] { "midasinami_kesyou_puff_f.anm" , "-1.139137" , "0.5423361" , "-1.072908" , "0" , "0" , "0" , "優しさ|思案伏せ目|疑問|ジト目" , "頬０涙０" , "0" , "0" , "1" , "" , "化粧" , "-1" , "-1" , "handitem,HandItemR_Puff_I_.menu" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" }
        };
        private string[][] life05_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //06：ドレスルーム シーン設定
        private string[][] life06_01f = new string[][]{
          new string[] { "siriname_2_f.anm" , "-2.120155" , "0" , "-1.992422" , "0" , "266.5095" , "0" , "エロ舐め愛情|エロ舌責快楽|エロ舐め快楽" , "頬２涙０" , "0" , "0" , "1" , "" , "フェラ01" , "-1" , "0" , "" , "0" },
          new string[] { "tati_kunni_2_f.anm" , "-2.259117" , "0" , "-1.992422" , "0" , "89.15967" , "0" , "エロ痛み我慢|エロ痛み我慢２|エロ痛み我慢３|エロメソ泣き|エロ羞恥３|エロ我慢３|まぶたギュ" , "頬３涙２よだれ" , "0" , "3" , "1" , "" , "SEX01" , "-1" , "0" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life06_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //07：ドレスルーム（夜） シーン設定
        private string[][] life07_01f = new string[][]{
          new string[] { "turn01_ATOFF_.anm" , "-0.9644787" , "0" , "-0.9544698" , "0" , "8.691078" , "0" , "ウインク照れ" , "頬０涙０" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] { "kaiwa_tati_hakusyu_taiki_2_f.anm" , "-0.9416001" , "0" , "0.3957111" , "0" , "186.1866" , "0" , "疑問" , "頬０涙０" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life07_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //08：自室 シーン設定
        private string[][] life08_01f = new string[][]{
          new string[] { "work_bed.anm" , "-0.2246854" , "0.1080843" , "-1.012155" , "0" , "0" , "0" , "通常|微笑み|にっこり|思案伏せ目|発情|困った|疑問|誘惑" , "頬０涙０" , "0" , "0" , "0" , "" , "掃除" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life08_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //09：自室（夜） シーン設定
        private string[][] life09_01f = new string[][]{
          new string[] { "pose_03_f.anm" , "-0.29" , "0.66" , "-1.94" , "0" , "18.7" , "0" , "発情|誘惑|エロ期待|エロ興奮３|優しさ" , "頬１涙０" , "0" , "1" , "0" , "" , "誘惑" , "-1" , "-1" , "" , "0" },
          new string[] { "edit_pose_010_f.anm" , "0.08" , "0.66" , "-0.71" , "0" , "276.3" , "0" , "発情|誘惑|エロ期待|エロ興奮３|優しさ" , "頬１涙０" , "0" , "1" , "0" , "" , "誘惑" , "-1" , "-1" , "" , "0" },
          new string[] { "fera_onani_2_f.anm" , "-0.5006242" , "0" , "2.292451" , "0" , "177.9255" , "0" , "絶頂射精後１" , "頬３涙０" , "0" , "3" , "1" , "" , "SEX01" , "2.5" , "0" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };        private string[][] life09_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //10：ハネムーンルーム（夜） シーン設定
        private string[][] life10_01f = new string[][]{
          new string[] { "onani_1_f.anm" , "0.24" , "0.47" , "-1.51" , "0" , "320.2" , "0" , "発情|誘惑|エロ期待|エロ興奮３|優しさ" , "頬１涙０" , "0" , "1" , "0" , "" , "誘惑" , "-1" , "-1" , "" , "0" },
          new string[] { "sleep1.anm" , "3.47" , "0.39" , "-2.06" , "0" , "347.3" , "0" , "発情|誘惑|エロ期待|エロ興奮３|優しさ" , "頬２涙０" , "0" , "1" , "0" , "" , "誘惑" , "-1" , "-1" , "" , "0" },
          new string[] { "pose_ero_06_loop_f.anm" , "-6.24" , "0.42" , "-0.46" , "0" , "60.9" , "0" , "発情|誘惑|エロ期待|エロ興奮３|優しさ" , "頬１涙０" , "0" , "1" , "0" , "" , "誘惑" , "-1" , "-1" , "" , "0" },
          new string[] { "yorisoi_sokui_hibuhiraki_1_f.anm" , "-0.63" , "0.42" , "-1.54" , "0" , "318.4" , "0" , "発情|誘惑|エロ期待|エロ興奮３|優しさ" , "頬１涙０" , "0" , "1" , "0" , "" , "誘惑" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life10_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //11：風呂（夜） シーン設定
        private string[][] life11_01f = new string[][]{
          new string[] { "mp_arai_tekoki_2_f.anm|mp_arai_2_f.anm|mp_arai_kiss_f.anm|mp_arai_tikubiname_2_f.anm|mp_arai_asiname_2_f.anm|mp2_siri_f.anm|mp2_sakasaarai_f.anm|mp2_sumata_f.anm" , "-0.9051085" , "0" , "-1.240942" , "0" , "127.0402" , "0" , "エロ羞恥２|エロ羞恥３|エロ好感３|興奮射精後１|発情|エロ興奮３|エロ期待" , "頬２涙１よだれ" , "0" , "1" , "1" , "" , "SEX_A" , "-1" , "0" , "" , "1" },
          new string[] { "taimenzai_2_f.anm|taimenzai_kiss2_f.anm|taimenzai_momi_2_f.anm|taimenzai_3_f.anm|taimenzai_kiss3_f.anm|taimenzai_momi_3_f.anm" , "0.70387" , "-0.5754409" , "-3.30988" , "0" , "355.7758" , "0" , "エロ羞恥２|興奮射精後１|発情|エロ痛み２|引きつり笑顔|エロ我慢３|まぶたギュ" , "頬３涙１" , "-1" , "1" , "1" , "" , "SEX_A" , "-1" , "0" , "" , "1" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life11_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] { "mp_arai_tekoki_2_m.anm|mp_arai_2_m.anm|mp_arai_kiss_m.anm|mp_arai_tikubiname_2_m.anm|mp_arai_asiname_2_m.anm|mp2_siri_m.anm|mp2_sakasaarai_m.anm|mp2_sumata_m.anm" , "-0.9051085" , "0" , "-1.240942" , "0" , "127.0402" , "0" , "0" },
          new string[] { "taimenzai_2_m.anm|taimenzai_kiss2_m.anm|taimenzai_momi_2_m.anm|taimenzai_3_m.anm|taimenzai_kiss3_m.anm|taimenzai_momi_3_m.anm" , "0.70387" , "-0.5754409" , "-3.30988" , "0" , "355.7758" , "0" , "1" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //12：プレイルーム シーン設定
        private string[][] life12_01f = new string[][]{
          new string[] { "soji_hakisouji.anm" , "-1.35" , "-0.04" , "-1.343" , "0" , "318.4" , "0" , "通常|微笑み|にっこり|思案伏せ目|発情|困った|疑問|誘惑" , "頬０涙０" , "0" , "0" , "0" , "" , "掃除" , "-1" , "-1" , "handitem,HandItemR_Houki_I_.menu" , "0" },
          new string[] { "soji_tukuefuki_salon.anm" , "1.88" , "0.50" , "0.22" , "0" , "88.5" , "0" , "通常|微笑み|にっこり|思案伏せ目|発情|困った|疑問|誘惑" , "頬０涙０" , "0" , "0" , "0" , "" , "掃除" , "-1" , "-1" , "handitem,HandItemR_Zoukin2_I_.menu" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life12_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //13：プレイルーム（夜） シーン設定
        private string[][] life13_01f = new string[][]{
          new string[] { "seijyoui_kiss_2_f.anm|j_seijyoui_kiss_2a01_f.anm|k_seijyoui_kiss_2a01_f.anm|t_seijyoui_kiss_2a01_f.anm|seijyoui_kiss_2a01_f.anm|seijyoui_daki_kiss_2_f.anm|seijyoui_2_f.anm|seijyoui_2e01_f.anm|seijyoui_2e02_f.anm|j_seijyoui_2_f.anm|k_seijyoui_2_f.anm|t_seijyoui_2_f.anm|seijyoui_3_f.anm|seijyoui_3e01_f.anm|seijyoui_3e02_f.anm|j_seijyoui_3_f.anm|k_seijyoui_3_f.anm|t_seijyoui_3_f.anm" , "0.95" , "0.5" , "1.92" , "0" , "272.9" , "0" , "エロ羞恥２|エロ羞恥３|エロ好感３|興奮射精後１|発情|エロ興奮３|エロ期待" , "頬２涙１" , "0" , "1" , "1" , "" , "SEX_A" , "-1" , "0" , "" , "1" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life13_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] { "seijyoui_kiss_2_m.anm|j_seijyoui_kiss_2a01_m.anm|k_seijyoui_kiss_2a01_m.anm|t_seijyoui_kiss_2a01_m.anm|seijyoui_kiss_2a01_m.anm|seijyoui_daki_kiss_2_m.anm|seijyoui_2_m.anm|seijyoui_2e01_m.anm|seijyoui_2e02_m.anm|j_seijyoui_2_m.anm|k_seijyoui_2_m.anm|t_seijyoui_2_m.anm|seijyoui_3_m.anm|seijyoui_3e01_m.anm|seijyoui_3e02_m.anm|j_seijyoui_3_m.anm|k_seijyoui_3_m.anm|t_seijyoui_3_m.anm" , "0.95" , "0.5" , "1.92" , "0" , "272.9" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };

        private string[][] life13_02f = new string[][]{
          new string[] { "kouhaii_3_f.anm|kouhaii_3a01_f.anm|kouhaii_3b01_f.anm|kouhaii_3b02_f.anm|kouhaii_cli_3_f.anm|kouhaii_daki_3_f.anm|kouhaii_siri_3_f.anm" , "0.77" , "0.5" , "1.92" , "0" , "272.9" , "0" , "エロ痛み我慢|エロ痛み我慢２|エロ痛み我慢３|エロメソ泣き|エロ羞恥３|エロ我慢３" , "頬３涙２" , "0" , "1" , "1" , "" , "SEX_A" , "-1" , "0" , "" , "1" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life13_02m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] { "kouhaii_3_m.anm|kouhaii_3_m.anm|kouhaii_3_m.anm|kouhaii_3_m.anm|kouhaii_cli_3_m.anm|kouhaii_daki_3_m.anm|kouhaii_siri_3_m.anm" , "0.77" , "0.5" , "1.92" , "0" , "272.9" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //14：プレイルーム2 シーン設定
        private string[][] life14_01f = new string[][]{
          new string[] { "midasinami_moyougae_f.anm" , "-4.50" , "0" , "-1.35" , "0" , "242.1" , "0" , "通常|微笑み|にっこり|思案伏せ目|発情|困った|疑問|誘惑" , "頬０涙０" , "0" , "0" , "0" , "" , "掃除" , "-1" , "-1" , "" , "0" },
          new string[] { "soji_hataki_kaiwa_r.anm" , "3.20" , "0" , "-1.32" , "0" , "110.3" , "0" , "通常|微笑み|にっこり|思案伏せ目|発情|困った|疑問|誘惑" , "頬０涙０" , "0" , "0" , "0" , "" , "掃除" , "-1" , "-1" , "handitem,HandItemR_Dance_Hataki_I_.menu" , "0" },
          new string[] { "soji_tukuefuki_salon.anm" , "-2.06" , "0.42" , "5.3" , "0" , "297.1" , "0" , "通常|微笑み|にっこり|思案伏せ目|発情|困った|疑問|誘惑" , "頬０涙０" , "0" , "0" , "0" , "" , "掃除" , "-1" , "-1" , "handitem,HandItemR_Zoukin2_I_.menu" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life14_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //15：プレイルーム2（夜） シーン設定
        private string[][] life15_01f = new string[][]{
          new string[] {"harem_sex_2_f.anm" , "0" , "0.58" , "-1.38" , "0" , "180" , "0" , "エロ痛み我慢|エロ痛み我慢２|エロ痛み我慢３|エロメソ泣き|エロ羞恥３|エロ我慢３|まぶたギュ" , "頬２涙１" , "0" , "1" , "1" , "" , "SEX02" , "-1" , "0" , "" , "1" },
          new string[] {"harem_sex_2_f2.anm" , "0" , "0.58" , "-1.38" , "0" , "180" , "0" , "エロ羞恥２|興奮射精後１|発情|エロ痛み２|引きつり笑顔|エロ我慢３|まぶたギュ" , "頬２涙１" , "0" , "1" , "1" , "" , "SEX01" , "-1" , "0" , "" , "1" },
          new string[] {"harem_sex_2_f3.anm" , "0" , "0.58" , "-1.38" , "0" , "180" , "0" , "エロ羞恥２|興奮射精後１|発情|エロ痛み２|引きつり笑顔|エロ我慢３|まぶたギュ" , "頬２涙１" , "0" , "1" , "1" , "" , "SEX01" , "-1" , "0" , "" , "1" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life15_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"harem_sex_2_m.anm" , "0" , "0.58" , "-1.38" , "0" , "180" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //16：プール シーン設定
        private string[][] life16_01f = new string[][]{
          new string[] { "sixnine_2_f.anm|sixnine_2a01_f.anm|paizuri_69_2_f.anm|paizuri_69_kunni_f.anm|paizuri_fera_69_2_f.anm" , "4.25" , "0.37" , "10" , "0" , "180" , "0" , "エロ羞恥２|エロ羞恥３|エロ好感３|興奮射精後１|発情|エロ興奮３|エロ期待" , "頬２涙１よだれ" , "0" , "1" , "1" , "" , "SEX_A" , "-1" , "0" , "" , "1" },
          new string[] { "hekimen_tati_sokui_2_f.anm|hekimen_tati_sokui_3_f.anm|hekimen_tati_sokui_kiss_2_f.anm|hekimen_tati_sokui_kiss_2a01_f.anm|hekimen_tati_sokui_kiss_3_f.anm|hekimen_tati_sokui_kiss_3a01_f.anm" , "10.43" , "-0.47" , "0.5" , "0" , "91.4" , "0" , "エロ羞恥２|エロ羞恥３|エロ好感３|興奮射精後１|発情|エロ興奮３|エロ期待" , "頬２涙１" , "-1" , "1" , "1" , "" , "SEX_A" , "-1" , "0" , "" , "1" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life16_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] { "sixnine_2_m.anm|sixnine_2_m.anm|paizuri_69_2_m.anm|paizuri_69_kunni_m.anm|paizuri_fera_69_2_m.anm" , "4.25" , "0.37" , "10" , "0" , "180" , "0" , "0" },
          new string[] { "hekimen_tati_sokui_2_m.anm|hekimen_tati_sokui_3_m.anm|hekimen_tati_sokui_kiss_2_m.anm|hekimen_tati_sokui_kiss_2a01_m.anm|hekimen_tati_sokui_kiss_3_m.anm|hekimen_tati_sokui_kiss_3a01_m.anm" , "10.43" , "-0.47" , "0.5" , "0" , "91.4" , "0" , "1" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //17：SMルーム シーン設定
        private string[][] life17_01f = new string[][]{
          new string[] { "soji_hataki_kaiwa_r.anm|soji_hataki_kaiwa_r.anm|maid_stand02ListenB_ONCE_.anm" , "-2.29" , "0" , "2.61" , "0" , "275.2" , "0" , "通常|微笑み|にっこり|思案伏せ目|発情|困った|疑問|誘惑" , "頬０涙０" , "0" , "0" , "0" , "" , "掃除" , "-1" , "-1" , "handitem,HandItemR_Dance_Hataki_I_.menu" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life17_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //18：SMルーム（夜） シーン設定
        private string[][] life18_01f = new string[][]{
          new string[] { "harituke_3_f.anm|harituke_3_f.anm|harituke_zeccyou_f_once_.anm" , "-0.97" , "0" , "1.22" , "0" , "180" , "0" , "エロ痛み我慢|エロ痛み我慢２|エロ痛み我慢３|エロメソ泣き|エロ羞恥３|エロ我慢３|まぶたギュ" , "頬３涙３よだれ" , "0" , "1" , "1" , "" , "SEX03" , "-1" , "0" , "kousoku_upper,KousokuU_SMRoom_Haritsuke_I_.menu|kousoku_lower,KousokuL_AshikaseUp_I_.menu|accvag,accVag_VibeBig_I_.menu" , "1" },
          new string[] { "x_manguri_vibe_oku_3_f.anm|x_manguri_vibe_zeccyou_f_once_.anm" , "0.75" , "0.32" , "-0.19" , "0" , "109.7" , "0" , "エロ痛み我慢|エロ痛み我慢２|エロ痛み我慢３|エロメソ泣き|エロ羞恥３|エロ我慢３|まぶたギュ" , "頬３涙３" , "0" , "1" , "1" , "" , "SEX02" , "-1" , "0" , "kousoku_upper,KousokuU_TekaseOne_I_.menu|kousoku_lower,KousokuL_AshikaseUp_I_.menu|accvag,accVag_VibeBig_I_.menu" , "1"  },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life18_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] { "harituke_3_m.anm|harituke_3_m.anm|harituke_zeccyou_m_once_.anm" , "-0.97" , "0" , "1.22" , "0" , "180" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //19：地下室 シーン設定
        private string[][] life19_01f = new string[][]{
          new string[] { "soji_mop.anm" , "0.22" , "0" , "1.07" , "0" , "57.3" , "0" , "通常|微笑み|にっこり|思案伏せ目|発情|困った|疑問|誘惑" , "頬０涙０" , "0" , "0" , "0" , "" , "掃除" , "-1" , "-1" , "handitem,HandItemR_Mop_I_.menu" , "0" },
          new string[] { "fukisouji1.anm" , "-3.66" , "0" , "-1.42" , "0" , "264.5" , "0" , "通常|微笑み|にっこり|思案伏せ目|発情|困った|疑問|誘惑" , "頬０涙０" , "0" , "0" , "0" , "" , "掃除" , "-1" , "-1" , "handitem,HandItemL_Zoukin2_I_.menu" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life19_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //20：地下室（夜） シーン設定
        private string[][] life20_01f = new string[][]{
          new string[] {"muri_6p_aibu_2_f.anm|muri_6p_aibu_3_f.anm|muri_6p_aibu_kunni_2_f.anm|muri_6p_aibu_kunni_3_f.anm|muri_6p_seijyoui_2a01_f.anm|muri_6p_seijyoui_3a01_f.anm|muri_6p_seijyoui_3ana_2_f.anm|muri_6p_seijyoui_3ana_3_f.anm" , "0" , "0.146" , "-1.55" , "0" , "0" , "0" , "エロ痛み我慢|エロ痛み我慢２|エロ痛み我慢３|エロ痛み１|エロ痛み２|エロ痛み３|エロ羞恥３" , "頬３涙３よだれ" , "0" , "1" , "1" , "" , "SEX03" , "-1" , "0" , "kousoku_upper,KousokuU_TekaseOne_I_.menu|kousoku_lower,KousokuL_AshikaseUp_I_.menu" , "1" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life20_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] { "muri_6p_aibu_2_m.anm|muri_6p_aibu_3_m.anm|muri_6p_aibu_kunni_2_m.anm|muri_6p_aibu_kunni_3_m.anm|muri_6p_seijyoui_2_m.anm|muri_6p_seijyoui_3_m.anm|muri_6p_seijyoui_3ana_2_m.anm|muri_6p_seijyoui_3ana_3_m.anm" , "0" , "0.146" , "-1.55" , "0" , "0" , "0" , "0" },
          new string[] { "muri_6p_aibu_2_m2.anm|muri_6p_aibu_3_m2.anm|muri_6p_aibu_kunni_2_m2.anm|muri_6p_aibu_kunni_3_m2.anm|muri_6p_seijyoui_2_m2.anm|muri_6p_seijyoui_3_m2.anm|muri_6p_seijyoui_3ana_2_m2.anm|muri_6p_seijyoui_3ana_3_m21.anm" , "0" , "0.146" , "-1.55" , "0" , "0" , "0" , "0" },
          new string[] { "muri_6p_aibu_2_m5.anm|muri_6p_aibu_3_m5.anm|muri_6p_aibu_kunni_2_m5.anm|muri_6p_aibu_kunni_3_m5.anm|muri_6p_seijyoui_2_m5.anm|muri_6p_seijyoui_3_m5.anm|muri_6p_seijyoui_3ana_2_m5.anm|muri_6p_seijyoui_3ana_3_m5.anm" , "0" , "0.1468" , "-1.55" , "0" , "0" , "0" , "0" }
        };


        //21：中庭" シーン設定
        private string[][] life21_01f = new string[][]{
          new string[] { "[S]inu_omocya_aruki_f_ONCE_.anm" , "-1.98" , "0" , "0" , "0" , "180" , "0" , "エロ痛み我慢|エロ痛み我慢２|エロ痛み我慢３|エロメソ泣き|エロ羞恥３|エロ我慢３|まぶたギュ" , "頬３涙２" , "0" , "1" , "0" , "" , "SEX01" , "-1" , "-1" , "accvag,accVag_Vibe_I_.menu|accanl,accAnl_Photo_VibePink_I_.menu" , "1" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life21_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] { "man_porse01.anm" , "-1.98" , "0" , "0.42" , "0" , "180" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //22：大浴場 シーン設定
        private string[][] life22_01f = new string[][]{
          new string[] { "j_taimenkijyoui_momi_1a01_f.anm" , "-3.584383" , "0" , "0.3971604" , "6.920276" , "83.96275" , "0" , "にっこり" , "頬２涙０" , "0" , "1" , "1" , "" , "風呂" , "-1" , "-1" , "" , "0" },
          new string[] { "senakanagasi_f.anm" , "-3.909705" , "0" , "0.4116318" , "4.166075" , "275.2422" , "0" , "笑顔" , "頬１涙０" , "0" , "1" , "1" , "" , "" , "-1" , "-1" , "handitem,HandItemR_Zoukin2_I_.menu" , "0" },
          new string[] { "sit_tukue.anm" , "1.396726" , "0.09520975" , "-1.849392" , "0" , "89.57285" , "0" , "誘惑" , "頬２涙０" , "0" , "1" , "0" , "" , "風呂" , "-1" , "-1" , "" , "0" },
          new string[] { "syagami_pose_f.anm" , "2.150745" , "-0.4503197" , "-0.7838227" , "0" , "113.13" , "0" , "ためいき" , "頬３涙０" , "-1" , "1" , "1" , "" , "風呂" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life22_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //23：大浴場（夜） シーン設定
        private string[][] life23_01f = new string[][]{
          new string[] { "itya_aibu_2_f.anm|itya_aibu_cli_2_f.anm|itya_aibu_kiss_2_f.anm|aibu_hibu_2_f.anm|aibu_tikubi_2_f.anm|itya_aibu_3_f.anm|itya_aibu_cli_3_f.anm|itya_aibu_kiss_3_f.anm|aibu_hibu_3_f.anm|aibu_tikubi_3_f.anm" , "2.05" , "-0.48" , "-2.84" , "0" , "92.6" , "0" , "エロ羞恥２|興奮射精後１|発情|エロ痛み２|引きつり笑顔|エロ我慢３|まぶたギュ" , "頬３涙１" , "-0.5" , "1" , "1" , "" , "SEX_A" , "-1" , "0" , "" , "1" },
          new string[] { "arai2_tubo_1_f.anm|arai2_tubo_2_f.anm|arai2_tawasi_1_f.anm|arai2_tawasi_2_f.anm|arai2_mune_2_f.anm" , "-3.67" , "0" , "2.00" , "0" , "5.6" , "0" , "エロメソ泣き|エロ羞恥２|興奮射精後１|発情|エロ羞恥３|引きつり笑顔|エロ我慢３|まぶたギュ" , "頬２涙１" , "0" , "1" , "1" , "" , "SEX_A" , "-1" , "0" , "" , "1" },
          new string[] { "senboukyou_fera_1_kiss_f.anm|senboukyou_fera_1_sentan_f.anm|senboukyou_fera_1_name_f.anm|senboukyou_fera_1_name_ura_f.anm|senboukyou_fera_2_f.anm|senboukyou_fera_3_f.anm|senboukyou_fera_shasei_kao_f_ONCE_.anm" , "-0.86" , "-0.27" , "-4.09" , "0" , "182.3" , "0" , "エロ舐め愛情|エロ舌責快楽|エロ舐め快楽" , "頬２涙０" , "-0.5" , "1" , "1" , "" , "フェラ01" , "-1" , "0" , "" , "1" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life23_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] { "itya_aibu_2_m.anm|itya_aibu_cli_2_m.anm|itya_aibu_kiss_2_m.anm|aibu_hibu_2_m.anm|aibu_tikubi_2_m.anm|itya_aibu_3_m.anm|itya_aibu_cli_3_m.anm|itya_aibu_kiss_3_m.anm|aibu_hibu_3_m.anm|aibu_tikubi_3_m.anm" , "2.05" , "-0.48" , "-2.84" , "0" , "92.6" , "0" , "0" },
          new string[] { "arai2_tubo_1_m.anm|arai2_tubo_2_m.anm|arai2_tawasi_1_m.anm|arai2_tawasi_2_m.anm|arai2_mune_2_m.anm" , "-3.67" , "-0.05" , "2.00" , "0" , "5.6" , "0" , "1" },
          new string[] { "senboukyou_fera_1_kiss_m.anm|senboukyou_fera_1_sentan_m.anm|senboukyou_fera_1_name_m.anm|senboukyou_fera_1_name_ura_m.anm|senboukyou_fera_2_m.anm|senboukyou_fera_3_m.anm|senboukyou_fera_shasei_kao_m_ONCE_.anm" , "-0.86" , "-0.27" , "-4.09" , "0" , "182.3" , "0" , "2" }
        };


        //24：花魁部屋 シーン設定
        private string[][] life24_01f = new string[][]{
          new string[] {"edit_pose_010_f.anm" , "0.16" , "0.14" , "-4.24" , "0" , "299.2" , "0" , "居眠り安眠|接吻" , "頬０涙０" , "0" , "0" , "1" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life24_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //25：花魁部屋（夜） シーン設定
        private string[][] life25_01f = new string[][]{
          new string[] { "settai_kiss_2_f.anm" , "0" , "0.23" , "-1.11" , "0" , "0" , "0" , "エロ舐め愛情|エロ舌責快楽|エロ舐め快楽" , "頬２涙０" , "0" , "1" , "1" , "" , "キス01" , "-1" , "0" , "" , "1" },
          new string[] { "taimenkijyoui_gr_2_f.anm" , "0" , "0.31" , "-1.17" , "0" , "0" , "0" , "エロメソ泣き|エロ羞恥２|興奮射精後１|発情|エロ羞恥３|引きつり笑顔|エロ我慢３|まぶたギュ" , "頬２涙１" , "0" , "1" , "1" , "" , "SEX01" , "-1" , "0" , "" , "1" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life25_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] { "settai_kiss_2_m.anm" , "0" , "0.23" , "-1.11" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //26：ペントハウス シーン設定
        private string[][] life26_01f = new string[][]{
          new string[] { "haimenritui_2_f.anm|haimenritui_2a01_f.anm|haimenritui_2b01_f.anm|haimenritui_2b02_f.anm|haimenritui_3_f.anm|haimenritui_3a01_f.anm|haimenritui_3b01_f.anm|haimenritui_3b02_f.anm|haimenritui_cli_2_f.anm|haimenritui_cli_3_f.anm" , "-6.93" , "-0.52" , "-5.51" , "0" , "87" , "0" , "エロメソ泣き|エロ羞恥２|興奮射精後１|発情|エロ痛み２|引きつり笑顔|エロ我慢３|まぶたギュ" , "頬３涙２" , "-0.5" , "1" , "1" , "" , "SEX_A" , "-1" , "0" , "" , "1" },
          new string[] { "kousokudai_kunni_2_f.anm|kousokudai_kunni_3_f.anm" , "-0.31" , "-0.15" , "2.26" , "0" , "181" , "0" , "エロ痛み我慢|エロ痛み我慢２|エロ痛み我慢３|エロメソ泣き|エロ羞恥３|エロ我慢３|まぶたギュ" , "頬２涙２" , "0" , "1" , "1" , "" , "SEX_A" , "-1" , "0" , "" , "1" },
          new string[] { "wfera_2_f.anm" , "3.97" , "0.039" , "-0.62" , "0" , "259.2" , "0" , "エロ舐め愛情|エロ舌責快楽|エロ舐め快楽" , "頬１涙０" , "0" , "1" , "1" , "" , "フェラ01" , "-1" , "0" , "" , "1" },
          new string[] { "wfera_2_f2.anm" , "3.97" , "0.039" , "-0.62" , "0" , "259.2" , "0" , "エロ舐め愛情|エロ舌責快楽|エロ舐め快楽" , "頬１涙０" , "0" , "1" , "1" , "" , "フェラ01" , "-1" , "0" , "" , "1" }
        };
        private string[][] life26_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] { "haimenritui_2_m.anm|haimenritui_2_m.anm|haimenritui_2_m.anm|haimenritui_2_m.anm|haimenritui_3_m.anm|haimenritui_3_m.anm|haimenritui_3_m.anm|haimenritui_3_m.anm|haimenritui_cli_2_m.anm|haimenritui_cli_3_m.anm" , "-6.93" , "-0.55" , "-5.51" , "0" , "87" , "0" , "0" },
          new string[] { "kousokudai_kunni_2_m.anm|kousokudai_kunni_3_m.anm" , "-0.31" , "-0.31" , "2.26" , "0" , "181" , "0" , "1" },
          new string[] { "wfera_2_m.anm" , "3.970175" , "0.03" , "-0.62" , "0" , "259.2" , "0" , "2" }
        };


        //27：街 シーン設定
        private string[][] life27_01f = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life27_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //28：キッチン シーン設定
        private string[][] life28_01f = new string[][]{
          new string[] { "work_ryouri_houtyou.anm" , "-0.93" , "0" , "-2.22" , "0" , "180" , "0" , "思案伏せ目" , "頬０涙０" , "0" , "0" , "0" , "" , "料理" , "-1" , "-1" , "handitem,HandItemR_Houchou_I_.menu" , "0" },
          new string[] { "soji_syokkiarai.anm" , "1.91" , "-0.05" , "0.25" , "0" , "90.4" , "0" , "微笑み" , "頬０涙０" , "0" , "0" , "0" , "" , "料理" , "-1" , "-1" , "handitem,HandItemD_Sara_Sponge_I_.menu" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life28_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //29：キッチン（夜） シーン設定
        private string[][] life29_01f = new string[][]{
          new string[] { "kyousitu_aibu_kutiosae_1_f.anm" , "2.16" , "0.08" , "-0.87" , "0" , "264.3" , "0" , "エロ痛み我慢３" , "頬２涙１" , "0" , "3" , "0" , "" , "SEX01" , "-1" , "0" , "" , "0" },
          new string[] { "siriname_1_f.anm" , "2.02" , "0.019" , "-0.87" , "0" , "84.3" , "0" , "エロ舐め愛情" , "頬２涙０" , "0" , "0" , "1" , "" , "フェラ01" , "-1" , "0" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life29_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //30：エントランス シーン設定
        private string[][] life30_01f = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life30_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //31：エントランス（夜） シーン設定
        private string[][] life31_01f = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life31_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //モーション , PX , PY , PZ , EX , EY , EZ , 表情 , フェイスブレンド , 床調整 , 着衣 , 視線 , ダンスBGM , ボイスセット , ボイス再生距離 , ボイス再生間隔 , メイドアイテム, NTRブロック
        //32：ポールダンス シーン設定
        private string[][] life32_01f = new string[][]{
          new string[] {"dance_cm3d21_pole_001_fa_f1.anm" , "0.16" , "0" , "0.18" , "0" , "180" , "0" , "通常|微笑み|笑顔|にっこり|優しさ|思案伏せ目|発情|誘惑" , "頬１涙０" , "0" , "0" , "-1" , "fusionicaddiction_short_pole.ogg" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"dance_cm3d21_pole_001_fa_f1.anm" , "-4.44" , "0" , "2.01" , "0" , "137.7" , "0" , "通常|微笑み|笑顔|にっこり|優しさ|思案伏せ目|発情|誘惑" , "頬１涙０" , "0" , "0" , "-1" , "fusionicaddiction_short_pole.ogg" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"dance_cm3d21_pole_001_fa_f1.anm" , "4.76" , "0" , "2.01" , "0" , "214" , "0" , "通常|微笑み|笑顔|にっこり|優しさ|思案伏せ目|発情|誘惑" , "頬１涙０" , "0" , "0" , "-1" , "fusionicaddiction_short_pole.ogg" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life32_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };

        private string[][] life32_02f = new string[][]{
          new string[] {"dance_cm3d21_pole_002_lc_f1.anm" , "0.16" , "0" , "0.18" , "0" , "180" , "0" , "通常|微笑み|笑顔|にっこり|優しさ|思案伏せ目|発情|誘惑" , "頬１涙０" , "0" , "0" , "-1" , "lovemorecrymore_short_pole.ogg" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"dance_cm3d21_pole_002_lc_f2.anm" , "-4.44" , "0" , "2.01" , "0" , "137.7" , "0" , "通常|微笑み|笑顔|にっこり|優しさ|思案伏せ目|発情|誘惑" , "頬１涙０" , "0" , "0" , "-1" , "lovemorecrymore_short_pole.ogg" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"dance_cm3d21_pole_002_lc_f3.anm" , "4.76" , "0" , "2.01" , "0" , "214" , "0" , "通常|微笑み|笑顔|にっこり|優しさ|思案伏せ目|発情|誘惑" , "頬１涙０" , "0" , "0" , "-1" , "lovemorecrymore_short_pole.ogg" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life32_02m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //33：バー（夜） シーン設定
        private string[][] life33_01f = new string[][]{
          new string[] { "kaiwa_tati_taiki_f.anm|kaiwa_tati_teawase_f_ONCE_.anm|kaiwa_tati_teawase_taiki_f.anm|kaiwa_tati_hutuu1_taiki_f.anm|kaiwa_tati_ayamaru_f_ONCE_.anm|maid_comehome2_LOOP_.anm|maid_stand02Kaiwa2_ONCE_.anm|kaiwa_tati_hohokaki_taiki_f.anm|kaiwa_tati_tutorial_1_taiki_f.anm" , "-3.17" , "0" , "1.60" , "0" , "89.0" , "0" , "通常|微笑み|笑顔|にっこり|優しさ|思案伏せ目|発情|誘惑" , "頬０涙０" , "0" , "0" , "-1" , "" , "会話01" , "-1" , "300" , "" , "0" },
          new string[] { "work_mimi_f.anm" , "1.03" , "0.55" , "4.67" , "0" , "88.0" , "0" , "通常|微笑み|笑顔|にっこり|優しさ|思案伏せ目|発情|誘惑" , "頬０涙０" , "0" , "0" , "-1" , "" , "会話01" , "-1" , "300" , "handitem,HandItemR_Mimikaki_I_.menu" , "0" },
          new string[] { "op_wine_taiki_f.anm|op_wine_taiki_f.anm|op_wine_taiki_f.anm|op_wine_nomu_f_ONCE_.anm|op_wine_nomu_f_ONCE_.anm|op_wine_kanpai_f_ONCE_.anm" , "2.85" , "0.53" , "-1.12" , "0" , "271.3" , "0" , "通常|微笑み|笑顔|にっこり|優しさ|思案伏せ目|発情|誘惑" , "頬０涙０" , "0" , "0" , "-1" , "" , "会話01" , "-1" , "300" , "handitem,HandItemR_WineGlass_I_.menu" , "0" },
          new string[] { "work_demukae_b.anm|kaiwa_tati_hutuu1_taiki_f.anm|kaiwa_tati_teawase_taiki_f.anm|maid_ojigi02_ONCE_.anm|maid_stand02hair_ONCE_.anm|maid_stand02Left_ONCE_.anm" , "0.47" , "0" , "-2.96" , "0" , "229.8" , "0" , "通常|微笑み|笑顔|にっこり|優しさ|思案伏せ目|発情|誘惑" , "頬０涙０" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life33_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] { "man_suwarimati1.anm" , "-1.47" , "0.71" , "1.70" , "0" , "267.5" , "0" , "0" },
          new string[] { "work_mimi_itazurago_m.anm" , "1.04" , "0.55" , "4.66" , "0" , "88.0" , "0" , "1" },
          new string[] { "man_suwarimati1.anm" , "3.24" , "0.53" , "-1.70" , "0" , "264.0" , "0" , "2" }
        };


        //34：トイレ シーン設定
        private string[][] life34_01f = new string[][]{
          new string[] { "toilet_onani_2_f.anm|toilet_onani_3_f.anm" , "-3.228128" , "0.1530618" , "0.2837493" , "0" , "87.56886" , "0" , "エロ羞恥２|興奮射精後１|発情|エロ興奮３" , "頬３涙１" , "0" , "3" , "1" , "" , "SEX_A" , "-1" , "0" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life34_01m = new string[][]{
          new string[] { "" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] { "" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] { "" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] { "" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //35：トイレ（夜） シーン設定
        private string[][] life35_01f = new string[][]{
          new string[] { "toilet_sex_2_f.anm|toilet_sex_3_f.anm" , "-3.228128" , "0.1530618" , "0.2837493" , "0" , "87.56886" , "0" , "エロ羞恥２|興奮射精後１|発情|エロ興奮３" , "頬３涙２" , "0" , "3" , "1" , "" , "SEX_A" , "4" , "0" , "" , "1" },
          new string[] { "fera_onani_2_f.anm|fera_onani_3_f.anm" , "-2.581944" , "0.01027089" , "-4.653751" , "0" , "180" , "0" , "エロ羞恥２|興奮射精後１|発情|エロ興奮３" , "頬２涙１よだれ" , "0" , "3" , "1" , "" , "SEX_A" , "4" , "0" , "" , "1" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life35_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] { "toilet_sex_2_m.anm|toilet_sex_3_m.anm" , "-3.228128" , "0.1530618" , "0.2837493" , "0" , "87.56886" , "0" , "0" },
          new string[] { "fera_onani_2_m.anm|fera_onani_3_m.anm" , "-2.581944" , "-0.0902865" , "-4.653751" , "0" , "180" , "0" , "1" },
          new string[] { "fera_miage_1_sentan_m.anm" , "3.571411" , "-0.08703265" , "-0.7674932" , "0" , "271.1132" , "0" , "0" }
        };


        //36：ロッカールーム シーン設定
        private string[][] life36_01f = new string[][]{
          //new string[] { "maid_stand02akubi_ONCE_.anm|maid_dressroom02.anm|maid_stand02ListenB_Unazuki_ONCE_.anm|maid_stand02Listenloop2.anm|maid_stand02tere.anm|maid_stand02sian2_ONCE_.anm|maid_stand02Left_ONCE_.anm|maid_stand02akubi_ONCE_.anm|maid_stand02hair_ONCE_.anm|maid_comehome2_LOOP_.anm" , "1.28" , "0" , "0" , "0" , "272.5" , "0" , "通常|微笑み|笑顔|にっこり|優しさ|思案伏せ目|発情|困った|疑問|誘惑" , "頬０涙０" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] { "" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] { "" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] { "" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] { "" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life36_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //37：ロッカールーム（夜） シーン設定
        private string[][] life37_01f = new string[][]{
          //new string[] { "maid_stand02akubi_ONCE_.anm|maid_dressroom02.anm|maid_stand02ListenB_Unazuki_ONCE_.anm|maid_stand02Listenloop2.anm|maid_stand02tere.anm|maid_stand02sian2_ONCE_.anm|maid_stand02Left_ONCE_.anm|maid_stand02akubi_ONCE_.anm|maid_stand02hair_ONCE_.anm|maid_comehome2_LOOP_.anm" , "1.28" , "0" , "0" , "0" , "272.5" , "0" , "通常|微笑み|笑顔|にっこり|優しさ|思案伏せ目|発情|困った|疑問|誘惑" , "頬０涙０" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] { "" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] { "" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] { "" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] { "" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life37_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //38：メイド部屋 シーン設定
        private string[][] life38_01f = new string[][]{
          new string[] {"edit_pose_010_f.anm" , "2.09" , "0.51" , "-1.91" , "0" , "223.5" , "0" , "居眠り安眠|接吻" , "頬０涙０" , "0" , "0" , "1" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life38_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };

        private string[][] life38_02f = new string[][]{
          new string[] { "work_saihou.anm" , "1.47" , "0.55" , "-1.53" , "0" , "270.9" , "0" , "ドヤ顔|ジト目|思案伏せ目" , "頬０涙０" , "0" , "0" , "0" , "" , "裁縫" , "-1" , "-1" , "handitem,HandItemD_Shisyuu_Hari_I_.menu" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life38_02m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };

        private string[][] life38_03f = new string[][]{
          new string[] { "midasinami_kesyou_lip_f.anm" , "2.27" , "0.53" , "2.03" , "0" , "348.6" , "0" , "優しさ|思案伏せ目|疑問" , "頬０涙０" , "0" , "0" , "1" , "" , "化粧" , "-1" , "-1" , "handitem,HandItemR_Rip_I_.menu" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life38_03m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };

        private string[][] life38_04f = new string[][]{
          new string[] { "pose_kakkoii_01_loop_f.anm|pose_kakkoii_06_loop_f.anm|[S]pose_kawaii_01_loop_f.anm|[S]pose_kawaii_03_loop_f.anm|edit_pose_005_f.anm|[S]edit_pose_008_f.anm|[S]edit_pose_009_f.anm|stand_akire.anm|[S]edit_pose_036_f.anm|[S]edit_pose_ke17_002_f.anm|[S]edit_pose_dg17s_003_f.anm|maid_dressroom02.anm|maid_comehome4_Gatsu_ONCE_.anm|maid_stand02hair_ONCE_.anm|maid_stand02sian2_ONCE_.anm|[S]turn01_ATOFF_.anm|kaiwa_tati_appeal_f_ONCE_.anm" , "1.62" , "0.012" , "0.65" , "0" , "87.7" , "0" , "通常|微笑み|にっこり|思案伏せ目|発情|困った|疑問|誘惑" , "頬０涙０" , "0" , "2" , "1" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life38_04m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };

        private string[][] life38_05f = new string[][]{
          new string[] { "onani_2_f.anm|onani_cli_2_f.anm|onani2_1_f.anm|onani2_cli_1_f.anm|onani_3_f.anm|onani_cli_3_f.anm|onani2_1_f.anm|onani3_cli_1_f.anm" , "1.85" , "0.50" , "-1.30" , "0" , "348.6" , "0" , "エロ羞恥１|エロ羞恥２|興奮射精後１|エロ痛み２|エロ我慢３|まぶたギュ" , "頬２涙１" , "0" , "3" , "1" , "" , "SEX_A" , "-1" , "0" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life38_05m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };

        private string[][] life38_06f = new string[][]{
          new string[] { "vibe_onania_2_f.anm|vibe_onania_3_f.anm" , "1.85" , "0.50" , "-1.30" , "0" , "348.6" , "0" , "エロ痛み我慢|エロ痛み我慢２|エロ痛み我慢３|エロメソ泣き|エロ羞恥３|エロ我慢３" , "頬３涙２" , "0" , "3" , "1" , "" , "SEX_A" , "-1" , "0" , "handitem,HandItemR_AnalVibe_I_.menu" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life38_06m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };


        //39：メイド部屋（夜） シーン設定
        private string[][] life39_01f = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "" , "" , "0" , "0" , "0" , "" , "" , "-1" , "-1" , "" , "0" }
        };
        private string[][] life39_01m = new string[][]{
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" },
          new string[] {"" , "0" , "0" , "0" , "0" , "0" , "0" , "0" }
        };



        //エンパイアズライフ用ボイスセット
        private string[][] elVs = new string[][]{
          new string[] { "" , "" , "" , "" , "" },
          new string[] { "" , "" , "" , "" , "" },
          new string[] { "" , "" , "" , "" , "" },
          new string[] { "" , "" , "" , "" , "" }
        };

        private string[][] elVs_sex01 = new string[][]{
          new string[] { "s0_01236.ogg" , "s0_01237.ogg" , "s0_01238.ogg" , "s0_01239.ogg" },
          new string[] { "s1_02396.ogg" , "s1_02390.ogg" , "s1_02391.ogg" , "s1_02392.ogg" },
          new string[] { "s2_01235.ogg" , "s2_01236.ogg" , "s2_01237.ogg" , "s2_01238.ogg" },
          new string[] { "s3_02767.ogg" , "s3_02768.ogg" , "s3_02769.ogg" , "s3_02770.ogg" },
          new string[] { "s4_08211.ogg" , "s4_08212.ogg" , "s4_08213.ogg" , "s4_08214.ogg" },
          new string[] { "s5_04133.ogg" , "s5_04134.ogg" , "s5_04047.ogg" , "s5_04048.ogg" },
          new string[] { "S6_02179.ogg" , "S6_02183.ogg" , "S6_02246.ogg" , "S6_02247.ogg" },

          new string[] { "H0_00069.ogg" , "H0_00070.ogg" , "H0_00229.ogg" , "H0_00230.ogg" },
          new string[] { "H1_00241.ogg" , "H1_00242.ogg" , "H1_00401.ogg" , "H1_00402.ogg" },
          new string[] { "H2_00043.ogg" , "H2_00044.ogg" , "H2_00203.ogg" , "H2_00204.ogg" },
          new string[] { "H3_00534.ogg" , "H3_00535.ogg" , "H3_00734.ogg" , "H3_00735.ogg" },
          new string[] { "H4_00869.ogg" , "H4_00870.ogg" , "H4_01069.ogg" , "H4_01070.ogg" },
          new string[] { "H5_00808.ogg" , "H5_00809.ogg" , "H5_00608.ogg" , "H5_00609.ogg" },
          new string[] { "H6_00374.ogg" , "H6_00375.ogg" , "H6_00174.ogg" , "H6_00175.ogg" },
          new string[] { "H7_02978.ogg" , "H7_02979.ogg" , "H7_02850.ogg" , "H7_02851.ogg" },
          new string[] { "H8_01347.ogg" , "H8_01348.ogg" , "H8_01131.ogg" , "H8_01132.ogg" },
          new string[] { "H9_00786.ogg" , "H9_00787.ogg" , "H9_00570.ogg" , "H9_00571.ogg" },
          new string[] { "H10_03841.ogg" , "H10_03842.ogg" , "H10_04057.ogg" , "H10_04058.ogg" },
          new string[] { "H11_00865.ogg" , "H11_00866.ogg" , "H11_00689.ogg" , "H11_00690.ogg" },
          new string[] { "H12_01205.ogg" , "H12_01206.ogg" , "H12_01421.ogg" , "H12_01422.ogg" },
          new string[] { "V1_00482.ogg" , "V1_00483.ogg" , "V1_00698.ogg" , "V1_00699.ogg" },
          new string[] { "V0_00480.ogg" , "V0_00481.ogg" , "V0_00696.ogg" , "V0_00697.ogg" },
          new string[] { "H13_01252.ogg" , "H13_01253.ogg" , "H13_01052.ogg" , "H13_01053.ogg" }
        };

        private string[][] elVs_sex02 = new string[][]{
          new string[] { "s0_01326.ogg" , "s0_01327.ogg" , "s0_01330.ogg" , "s0_01331.ogg" },
          new string[] { "s1_02401.ogg" , "s1_02400.ogg" , "s1_02402.ogg" , "s1_02404.ogg" },
          new string[] { "s2_01185.ogg" , "s2_01186.ogg" , "s2_01187.ogg" , "s2_01188.ogg" },
          new string[] { "s3_02797.ogg" , "s3_02798.ogg" , "s3_02691.ogg" , "s3_02796.ogg" },
          new string[] { "s4_08140.ogg" , "s4_08134.ogg" , "s4_08149.ogg" , "s4_08150.ogg" },
          new string[] { "s5_04055.ogg" , "s5_04061.ogg" , "s5_04054.ogg" , "s5_04052.ogg" },
          new string[] { "S6_02249.ogg" , "S6_02250.ogg" , "S6_02185.ogg" , "S6_02186.ogg" },

          new string[] { "H0_00073.ogg" , "H0_00074.ogg" , "H0_00233.ogg" , "H0_00234.ogg" },
          new string[] { "H1_00245.ogg" , "H1_00246.ogg" , "H1_00405.ogg" , "H1_00406.ogg" },
          new string[] { "H2_00047.ogg" , "H2_00048.ogg" , "H2_00207.ogg" , "H2_00208.ogg" },
          new string[] { "H3_00538.ogg" , "H3_00539.ogg" , "H3_00738.ogg" , "H3_00739.ogg" },
          new string[] { "H4_00873.ogg" , "H4_00874.ogg" , "H4_01073.ogg" , "H4_01074.ogg" },
          new string[] { "H5_00812.ogg" , "H5_00813.ogg" , "H5_00612.ogg" , "H5_00613.ogg" },
          new string[] { "H6_00378.ogg" , "H6_00379.ogg" , "H6_00178.ogg" , "H6_00179.ogg" },
          new string[] { "H7_02982.ogg" , "H7_02983.ogg" , "H7_02854.ogg" , "H7_02855.ogg" },
          new string[] { "H8_01351.ogg" , "H8_01352.ogg" , "H8_01135.ogg" , "H8_01136.ogg" },
          new string[] { "H9_00790.ogg" , "H9_00791.ogg" , "H9_00574.ogg" , "H9_00575.ogg" },
          new string[] { "H10_03845.ogg" , "H10_03846.ogg" , "H10_04061.ogg" , "H10_04062.ogg" },
          new string[] { "H11_00869.ogg" , "H11_00870.ogg" , "H11_00693.ogg" , "H11_00694.ogg" },
          new string[] { "H12_01209.ogg" , "H12_01210.ogg" , "H12_01425.ogg" , "H12_01426.ogg" },
          new string[] { "V1_00486.ogg" , "V1_00487.ogg" , "V1_00702.ogg" , "V1_00703.ogg" },
          new string[] { "V0_00484.ogg" , "V0_00485.ogg" , "V0_00700.ogg" , "V0_00701.ogg" },
          new string[] { "H13_01256.ogg" , "H13_01257.ogg" , "H13_01056.ogg" , "H13_01057.ogg" }
        };

        private string[][] elVs_sex03 = new string[][]{
          new string[] { "s0_09072.ogg" , "s0_09070.ogg" , "s0_09099.ogg" , "s0_09059.ogg" , "s0_09067.ogg" , "s0_09068.ogg" , "s0_09069.ogg" , "s0_09071.ogg" , "s0_09085.ogg" , "s0_09086.ogg" , "s0_09087.ogg" , "s0_09091.ogg" },
          new string[] { "s1_03207.ogg" , "s1_03205.ogg" , "s1_08993.ogg" , "s1_08971.ogg" , "s1_09344.ogg" , "s1_09370.ogg" , "s1_09371.ogg" , "s1_09372.ogg" , "s1_09374.ogg" , "s1_09398.ogg" , "s1_09392.ogg" , "s1_09365.ogg" },
          new string[] { "s2_09039.ogg" , "s2_09067.ogg" , "s2_09052.ogg" , "s2_08502.ogg" , "s2_09047.ogg" , "s2_09048.ogg" , "s2_09049.ogg" , "s2_09050.ogg" , "s2_09051.ogg" , "s2_09066.ogg" , "s2_09069.ogg" , "s2_09073.ogg" },
          new string[] { "s3_02905.ogg" , "s3_02906.ogg" , "s3_02907.ogg" , "s3_05540.ogg" , "s3_05657.ogg" , "s3_05658.ogg" , "s3_05659.ogg" , "s3_05660.ogg" , "s3_05661.ogg" , "s3_05678.ogg" , "s3_05651.ogg" , "s3_05656.ogg" },
          new string[] { "s4_08347.ogg" , "s4_08355.ogg" , "s4_08356.ogg" , "s4_11658.ogg" , "s4_11684.ogg" , "s4_11677.ogg" , "s4_11680.ogg" , "s4_11683.ogg" , "s4_11661.ogg" , "s4_11659.ogg" , "s4_11654.ogg" , "s4_11660.ogg" },
          new string[] { "s5_04266.ogg" , "s5_18375.ogg" , "s5_18380.ogg" , "s5_18393.ogg" , "s5_18379.ogg" , "s5_18380.ogg" , "s5_18382.ogg" , "s5_18384.ogg" , "s5_18385.ogg" , "s5_18400.ogg" , "s5_18402.ogg" , "s5_18119.ogg" },
          new string[] { "S6_28817.ogg" , "S6_02398.ogg" , "S6_02399.ogg" , "s6_02402.ogg" , "S6_09048.ogg" , "S6_01984.ogg" , "S6_01988.ogg" , "S6_01991.ogg" , "S6_02000.ogg" , "S6_01996.ogg" , "S6_01997.ogg" , "S6_01998.ogg" , "S6_01999.ogg" , "S6_02001.ogg" , "s6_05796.ogg" , "s6_05797.ogg" , "s6_05798.ogg" , "s6_05799.ogg" , "s6_05800.ogg" , "s6_05801.ogg" },

          new string[] { "H0_10874.ogg" , "H0_10860.ogg" , "H0_10957.ogg" , "H0_10960.ogg" , "H0_10869.ogg" , "H0_09681.ogg" , "H0_09691.ogg" , "H0_09712.ogg" , "H0_09724.ogg"},
          new string[] { "H1_11427.ogg" , "H1_11513.ogg" , "H1_05640.ogg" , "H1_09232.ogg" },
          new string[] { "H2_08156.ogg" , "H2_10980.ogg" , "H2_11120.ogg" , "H2_11141.ogg" , "H2_11143.ogg" , "H2_11229.ogg" },
          new string[] { "H3_02523.ogg" , "H3_04910.ogg" , "H3_07704.ogg" , "H3_04967.ogg" , "H3_04974.ogg" , "H3_05026.ogg" },
          new string[] { "H4_01907.ogg" , "H4_01908.ogg" , "H4_05097.ogg" , "H4_05098.ogg" , "H4_03190.ogg" , "H4_03290.ogg" ,"H4_02020.ogg" , "H4_00583.ogg" , "H4_08568.ogg" },
          new string[] { "H5_08487.ogg" , "H5_00250.ogg" , "H5_00259.ogg" , "H5_00270.ogg" , "H5_00290.ogg" , "H5_00370.ogg" , "H5_02835.ogg" , "H5_03009.ogg" , "H5_00479.ogg" },
          new string[] { "H6_04166.ogg" , "H6_04305.ogg" , "H6_05273.ogg" , "H6_06550.ogg" , "H6_06555.ogg" , "H6_05185.ogg" , "H6_08956.ogg" , "H6_08721.ogg" , "H6_08731.ogg" , "H6_02949.ogg" , "H6_03938.ogg" , "H6_00936.ogg" , "H6_05653.ogg" },
          new string[] { "H7_05958.ogg" , "H7_02353.ogg" , "H7_02410.ogg" , "H7_04331.ogg" , "H7_01699.ogg" , "H7_02060.ogg" , "H7_05359.ogg" , "H7_02506.ogg" , "H7_01821.ogg" , "H7_02301.ogg" , "H7_01744.ogg" , "H7_02498.ogg" },
          new string[] { "H8_08471.ogg" , "H8_08473.ogg" , "H8_08500.ogg" , "H8_05361.ogg" , "H8_01936.ogg" , "H8_00646.ogg" , "H8_00648.ogg" , "H8_00657.ogg" , "H8_02023.ogg" , "H8_02025.ogg" , "H8_00717.ogg" , "H8_05547.ogg" },
          new string[] { "H9_07848.ogg" , "H9_06388.ogg" , "H9_06428.ogg" , "H9_06468.ogg" , "H9_09446.ogg" , "H9_07851.ogg" , "H9_04310.ogg" , "H9_04287.ogg" , "H9_09438.ogg" , "H9_04187.ogg" , "H9_09303.ogg" , "H9_04114.ogg" , "H9_06929.ogg" , "H9_03989.ogg" },
          new string[] { "H10_09415.ogg" , "H10_09993.ogg" , "H10_08334.ogg" , "H10_01736.ogg" , "H10_01739.ogg" , "H10_03656.ogg" , "H10_03475.ogg" , "H10_03050.ogg" , "H10_03714.ogg" , "H10_03717.ogg" , "H10_03504.ogg" , "H10_03752.ogg" , "H10_04738.ogg" , "H10_08819.ogg" , "H10_09457.ogg" , "H10_09058.ogg" , "H10_07196.ogg" , "H10_07216.ogg" , "H10_08271.ogg" , "H10_09813.ogg" },
          new string[] { "H11_01458.ogg" , "H11_02000.ogg" , "H11_01850.ogg" , "H11_01963.ogg" , "H11_04177.ogg" , "H11_04265.ogg" , "H11_01980.ogg" , "H11_01988.ogg" , "H11_02029.ogg" , "H11_04914.ogg" , "H11_04738.ogg" , "H11_04915.ogg" , "H11_04983.ogg" ,"H11_05086.ogg" },
          new string[] { "H12_03082.ogg" , "H12_01725.ogg" , "H12_03082.ogg" , "H12_01870.ogg" , "H12_01799.ogg" , "H12_01787.ogg", "H12_01488.ogg" , "H12_01663.ogg" , "H12_03084.ogg" ,"H12_03115.ogg" },
          new string[] { "V1_12363.ogg" , "V1_12364.ogg" , "V1_12365.ogg" , "V1_12378.ogg" , "V1_12399.ogg" , "V1_12400.ogg" , "V1_11553.ogg" , "V1_09218.ogg" , "V1_09219.ogg" , "V1_09302.ogg" , "V1_09312.ogg" , "V1_11618.ogg" , "V1_11624.ogg" , "V1_11896.ogg" ,"V1_11721.ogg" , "V1_12062.ogg" , "V1_12234.ogg" , "V1_11722.ogg" , "V1_11768.ogg" , "V1_11769.ogg" , "V1_09597.ogg" },
          new string[] { "V0_09912.ogg" , "V0_09913.ogg" , "V0_09976.ogg" , "V0_10604.ogg" , "V0_10651.ogg" , "V0_11154.ogg" , "V0_11177.ogg" , "V0_11249.ogg" , "V0_11282.ogg" , "V0_11375.ogg" , "V0_11376.ogg" , "V0_09941.ogg", "V0_09763.ogg" , "V0_09813.ogg" , "V0_09511.ogg" , "V0_10702.ogg" , "V0_10705.ogg" },
          new string[] { "H13_00543.ogg" , "H13_00698.ogg" , "H13_00725.ogg" , "H13_04621.ogg" , "H13_04622.ogg" , "H13_04693.ogg" , "H13_04046.ogg" , "H13_04314.ogg" , "H13_04358.ogg" , "H13_04428.ogg" , "H13_04469.ogg" , "H13_04856.ogg" , "H13_04877.ogg" }
        };

        private string[][] elVs_fera01 = new string[][]{
          new string[] { "S0_01383.ogg" , "S0_01367.ogg" , "S0_01384.ogg" , "S0_01369.ogg" },
          new string[] { "S1_02455.ogg" , "S1_02440.ogg" , "S1_02457.ogg" , "S1_02442.ogg" },
          new string[] { "S2_01296.ogg" , "S2_01281.ogg" , "S2_01298.ogg" , "S2_01282.ogg" },
          new string[] { "S3_02833.ogg" , "S3_02818.ogg" , "S3_02835.ogg" , "S3_02820.ogg" },
          new string[] { "S4_08241.ogg" , "S4_08258.ogg" , "S4_08243.ogg" , "S4_08259.ogg" },
          new string[] { "S5_04163.ogg" , "S5_04162.ogg" , "S5_04179.ogg" , "s5_04174.ogg" },
          new string[] { "S6_02219.ogg" , "S6_02220.ogg" , "S6_02221.ogg" , "S6_02222.ogg" },

          new string[] { "H0_00093.ogg" , "H0_00094.ogg" , "H0_00101.ogg" , "H0_00102.ogg" },
          new string[] { "H1_00265.ogg" , "H1_00266.ogg" , "H1_00273.ogg" , "H1_00274.ogg" },
          new string[] { "H2_00067.ogg" , "H2_00068.ogg" , "H2_00075.ogg" , "H2_00076.ogg" },
          new string[] { "H3_00566.ogg" , "H3_00567.ogg" , "H3_00702.ogg" , "H3_00703.ogg" },
          new string[] { "H4_00901.ogg" , "H4_00902.ogg" , "H4_01037.ogg" , "H4_01038.ogg" },
          new string[] { "H5_00640.ogg" , "H5_00641.ogg" , "H5_00648.ogg" , "H5_00649.ogg" },
          new string[] { "H6_00206.ogg" , "H6_00207.ogg" , "H6_00214.ogg" , "H6_00215.ogg" },
          new string[] { "H7_02810.ogg" , "H7_02811.ogg" , "H7_02818.ogg" , "H7_02819.ogg" },
          new string[] { "H8_01179.ogg" , "H8_01180.ogg" , "H8_01187.ogg" , "H8_01188.ogg" },
          new string[] { "H9_00618.ogg" , "H9_00619.ogg" , "H9_00626.ogg" , "H9_00627.ogg" },
          new string[] { "H10_03889.ogg" , "H10_03890.ogg" , "H10_03897.ogg" , "H10_03898.ogg" },
          new string[] { "H11_00713.ogg" , "H11_00714.ogg" , "H11_00721.ogg" , "H11_00722.ogg" },
          new string[] { "H12_01253.ogg" , "H12_01254.ogg" , "H12_01261.ogg" , "H12_01262.ogg" },
          new string[] { "V1_00530.ogg" , "V1_00531.ogg" , "V1_00538.ogg" , "V1_00539.ogg" },
          new string[] { "V0_00528.ogg" , "V0_00529.ogg" , "V0_00536.ogg" , "V0_00537.ogg" },
          new string[] { "H13_01084.ogg" , "H13_01085.ogg" , "H13_01092.ogg" , "H13_01093.ogg" }
        };

        private string[][] elVs_kiss01 = new string[][]{
          new string[] { "S0_01383.ogg" , "S0_01367.ogg" , "S0_01384.ogg" , "S0_01369.ogg" },
          new string[] { "S1_02455.ogg" , "S1_02440.ogg" , "S1_02457.ogg" , "S1_02442.ogg" },
          new string[] { "S2_01296.ogg" , "S2_01281.ogg" , "S2_01298.ogg" , "S2_01282.ogg" },
          new string[] { "S3_02833.ogg" , "S3_02818.ogg" , "S3_02835.ogg" , "S3_02820.ogg" },
          new string[] { "S4_08241.ogg" , "S4_08258.ogg" , "S4_08243.ogg" , "S4_08259.ogg" },
          new string[] { "S5_04163.ogg" , "S5_04162.ogg" , "S5_04179.ogg" , "s5_04174.ogg" },
          new string[] { "S6_02219.ogg" , "S6_02220.ogg" , "S6_02221.ogg" , "S6_02222.ogg" },

          new string[] { "H0_00093.ogg" , "H0_00094.ogg" , "H0_00101.ogg" , "H0_00102.ogg" },
          new string[] { "H1_00265.ogg" , "H1_00266.ogg" , "H1_00273.ogg" , "H1_00274.ogg" },
          new string[] { "H2_00067.ogg" , "H2_00068.ogg" , "H2_00075.ogg" , "H2_00076.ogg" },
          new string[] { "H3_00566.ogg" , "H3_00567.ogg" , "H3_00702.ogg" , "H3_00703.ogg" },
          new string[] { "H4_00901.ogg" , "H4_00902.ogg" , "H4_01037.ogg" , "H4_01038.ogg" },
          new string[] { "H5_00640.ogg" , "H5_00641.ogg" , "H5_00648.ogg" , "H5_00649.ogg" },
          new string[] { "H6_00206.ogg" , "H6_00207.ogg" , "H6_00214.ogg" , "H6_00215.ogg" },
          new string[] { "H7_02810.ogg" , "H7_02811.ogg" , "H7_02818.ogg" , "H7_02819.ogg" },
          new string[] { "H8_01179.ogg" , "H8_01180.ogg" , "H8_01187.ogg" , "H8_01188.ogg" },
          new string[] { "H9_00618.ogg" , "H9_00619.ogg" , "H9_00626.ogg" , "H9_00627.ogg" },
          new string[] { "H10_03889.ogg" , "H10_03890.ogg" , "H10_03897.ogg" , "H10_03898.ogg" },
          new string[] { "H11_00713.ogg" , "H11_00714.ogg" , "H11_00721.ogg" , "H11_00722.ogg" },
          new string[] { "H12_01253.ogg" , "H12_01254.ogg" , "H12_01261.ogg" , "H12_01262.ogg" },
          new string[] { "V1_00530.ogg" , "V1_00531.ogg" , "V1_00538.ogg" , "V1_00539.ogg" },
          new string[] { "V0_00528.ogg" , "V0_00529.ogg" , "V0_00536.ogg" , "V0_00537.ogg" },
          new string[] { "H13_01084.ogg" , "H13_01085.ogg" , "H13_01092.ogg" , "H13_01093.ogg" }
        };

        private string[][] elVs_souji01 = new string[][]{
          new string[] { "S0_03152.ogg" , "S0_03410.ogg" , "S0_03429.ogg" , "S0_03293.ogg" , "S0_03368.ogg" , "S0_03381.ogg" },
          new string[] { "S1_05632.ogg" , "S1_05656.ogg" , "S1_05632.ogg" , "S1_04690.ogg" , "S1_05643.ogg" },
          new string[] { "S2_04678.ogg" , "S2_04277.ogg" , "S2_04282.ogg" , "S2_04714.ogg" , "S2_04702.ogg" },
          new string[] { "S3_12858.ogg" , "S3_12859.ogg" , "S3_12860.ogg" , "S3_07808.ogg" , "S3_07840.ogg" },
          new string[] { "S4_12860.ogg" , "S4_12862.ogg" , "S4_06759.ogg" , "S4_06760.ogg" },
          new string[] { "S5_15282.ogg" , "S5_15283.ogg" , "S5_15284.ogg" , "S5_03418.ogg" , "S5_03436.ogg" },
          new string[] { "S6_24074.ogg" , "S6_24075.ogg" , "S6_24076.ogg" , "S6_14037.ogg" , "S6_14015.ogg" },

        };

        private string[][] elVs_saiho01 = new string[][]{
          new string[] { "S0_03036.ogg" , "S0_03013.ogg" , "S0_03214.ogg" , "S0_03152.ogg" , "S0_03293.ogg" , "S0_03029.ogg" },
          new string[] { "S1_04524.ogg" , "S1_04598.ogg" , "S1_04697.ogg" , "S1_04690.ogg" , "S1_05656.ogg" , "S1_06549.ogg" },
          new string[] { "S2_02518.ogg" , "S2_02519.ogg" , "S2_02530.ogg" , "S2_02531.ogg" , "S2_02532.ogg" , "S2_02534.ogg" },
          new string[] { "S3_12840.ogg" , "S3_12841.ogg" , "S3_12842.ogg" , "S3_07439.ogg" , "S3_07440.ogg" },
          new string[] { "S4_12842.ogg" , "S4_12843.ogg" , "S4_12844.ogg" , "S4_06325.ogg" , "S4_06367.ogg" , "S4_06395.ogg" },
          new string[] { "S5_15264.ogg" , "S5_15265.ogg" , "S5_15266.ogg" , "S5_01949.ogg" , "S5_01970.ogg" , "S5_01978.ogg" , "S5_02001.ogg" },
          new string[] { "S6_24056.ogg" , "S6_24057.ogg" , "S6_24058.ogg" , "S6_24062.ogg" , "S6_00051.ogg" , "S6_24064.ogg" },

        };

        private string[][] elVs_ryouri01 = new string[][]{
          new string[] { "S0_03086.ogg" , "S0_03090.ogg" , "S0_03121.ogg" , "S0_03214.ogg" , "S0_03293.ogg" , "S0_03064.ogg" , "S0_03075.ogg" },
          new string[] { "S1_04618.ogg" , "S1_04642.ogg" , "S1_05656.ogg" , "S1_04610.ogg" , "S1_04644.ogg" , "S1_04586.ogg" },
          new string[] { "S2_02625.ogg" , "S2_04097.ogg" , "S2_04714.ogg" , "S2_04678.ogg" , "S2_02621.ogg" },
          new string[] { "S3_12843.ogg" , "S3_12844.ogg" , "S3_12845.ogg" , "S3_07477.ogg" , "S3_07509.ogg" , "S3_07516.ogg" },
          new string[] { "S4_12845.ogg" , "S4_12847.ogg" , "S4_06462.ogg" , "S4_06583.ogg" },
          new string[] { "S5_15268.ogg" , "S5_03377.ogg" , "S5_03396.ogg" , "S5_02071.ogg" , "S5_02072.ogg" },
          new string[] { "S6_24059.ogg" , "S6_24060.ogg" , "S6_24061.ogg" , "S6_00051.ogg" , "S6_00077.ogg" , "S6_00113.ogg" },

        };

        private string[][] elVs_kesyou01 = new string[][]{
          new string[] { "S0_03252.ogg" , "S0_03288.ogg" , "S0_03293.ogg" , "S0_03273.ogg" , "S0_03302.ogg" },
          new string[] { "S1_05510.ogg" , "S1_05521.ogg" , "S1_05656.ogg" , "S1_05484.ogg" , "S1_05485.ogg" },
          new string[] { "S2_04607.ogg" , "S2_04624.ogg" , "S2_04646.ogg" , "S2_04714.ogg" , "S2_04678.ogg" },
          new string[] { "S3_12853.ogg" , "S3_07674.ogg" , "S3_07702.ogg" , "S3_07730.ogg" },
          new string[] { "S5_15276.ogg" , "S5_15277.ogg" , "S5_15278.ogg" , "S5_02311.ogg" , "S5_02339.ogg" , "S5_02340.ogg" },
          new string[] { "S4_12854.ogg" , "S4_12855.ogg" , "S4_12856.ogg" , "S4_06637.ogg" , "S4_06648.ogg" },
          new string[] { "S6_24068.ogg" , "S6_24069.ogg" , "S6_24070.ogg" , "S6_00051.ogg" , "S6_00273.ogg" , "S6_00331.ogg" },

        };

        private string[][] elVs_kaiwa01 = new string[][]{
          new string[] { "S0_03621.ogg" , "S0_03625.ogg" , "S0_03631.ogg" , "S0_03638.ogg" , "S0_03655.ogg" , "S0_03656.ogg" , "S0_03657.ogg" , "S0_03666.ogg" , "S0_03668.ogg" , "S0_03728.ogg" , "S0_03729.ogg" , "S0_03738.ogg" , "S0_03767.ogg" , "S0_03769.ogg" , "S0_03770.ogg" , "S0_03776.ogg" , "S0_03780.ogg" , "S0_03781.ogg" },
          new string[] { "S1_03509.ogg" , "S1_03510.ogg" , "S1_03511.ogg" , "S1_03518.ogg" , "S1_03520.ogg" , "S1_03521.ogg" , "S1_03525.ogg" , "S1_03526.ogg" , "S1_03536.ogg" , "S1_03538.ogg" , "S1_03547.ogg" , "S1_03548.ogg" , "S1_03555.ogg" , "S1_03556.ogg" , "S1_03557.ogg" , "S1_03560.ogg" , "S1_03572.ogg" , "S1_03574.ogg" },
          new string[] { "S2_02651.ogg" , "S2_02686.ogg" , "S2_02687.ogg" , "S2_02692.ogg" , "S2_02709.ogg" , "S2_02711.ogg" , "S2_02714.ogg" , "S2_02722.ogg" , "S2_02734.ogg" , "S2_02736.ogg" , "S2_02740.ogg" , "S2_02741.ogg" , "S2_02748.ogg" , "S2_02755.ogg" , "S2_02758.ogg" , "S2_02761.ogg" , "S2_02768.ogg" , "S2_02824.ogg" },
          new string[] { "S3_00052.ogg" , "S3_00053.ogg" , "S3_00054.ogg" , "S3_00060.ogg" , "S3_00071.ogg" , "S3_00072.ogg" , "S3_00073.ogg" , "S3_00074.ogg" , "S3_00077.ogg" , "S3_00079.ogg" , "S3_00080.ogg" , "S3_00087.ogg" , "S3_00089.ogg" , "S3_00090.ogg" , "S3_00092.ogg" , "S3_00093.ogg" , "S3_00098.ogg" , "S3_00099.ogg" },
          new string[] { "S4_04034.ogg" , "S4_04035.ogg" , "S4_04036.ogg" , "S4_04037.ogg" , "S4_04038.ogg" , "S4_04039.ogg" , "S4_04040.ogg" , "S4_04053.ogg" , "S4_04054.ogg" , "S4_04055.ogg" , "S4_04056.ogg" , "S4_04057.ogg" , "S4_04063.ogg" , "S4_04071.ogg" , "S4_04072.ogg" , "S4_04075.ogg" , "S4_04076.ogg" , "S4_04078.ogg" },
          new string[] { "S5_04554.ogg" , "S5_04555.ogg" , "S5_04556.ogg" , "S5_04557.ogg" , "S5_04575.ogg" , "S5_04576.ogg" , "S5_04577.ogg" , "S5_04578.ogg" , "S5_04579.ogg" , "S5_04582.ogg" , "S5_04594.ogg" , "S5_04595.ogg" , "S5_04596.ogg" , "S5_04597.ogg" , "S5_04598.ogg" , "S5_04642.ogg" , "S5_04643.ogg" , "S5_04646.ogg" },
          new string[] { "S6_24126.ogg" , "S6_24127.ogg" , "S6_24128.ogg" , "S6_24129.ogg" , "S6_00474.ogg" , "S6_00476.ogg" , "S6_00477.ogg" , "S6_00479.ogg" , "S6_00480.ogg" , "S6_00491.ogg" , "S6_00492.ogg" , "S6_00493.ogg" , "S6_00494.ogg" , "S6_00495.ogg" , "S6_00531.ogg" , "S6_00532.ogg" , "S6_00533.ogg" , "S6_00534.ogg" },

        };

        private string[][] elVs_suimin01 = new string[][]{
          new string[] { "S0_03176.ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
          new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
          new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
          new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
          new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
          new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
          new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
        };

        private string[][] elVs_furo01 = new string[][]{
          new string[] { "S0_03344.ogg" , "S0_03358.ogg" , "S0_03320.ogg" , "S0_03343.ogg" , "S0_03339.ogg" },
          new string[] { "S1_05610.ogg" , "S1_05620.ogg" , "S1_04524.ogg" , "S1_06930.ogg" },
          new string[] { "S2_04103.ogg" , "S2_04714.ogg" , "S2_04678.ogg" },
          new string[] { "S3_12857.ogg" , "S3_12855.ogg" , "S3_07702.ogg" , "S3_07745.ogg" },
          new string[] { "S4_06686.ogg" , "S4_06695.ogg" , "S4_06711.ogg" },
          new string[] { "S5_15279.ogg" , "S5_02392.ogg" , "S5_02382.ogg" , "S5_02433.ogg" , "S5_02442.ogg" },
          new string[] { "S6_24073.ogg" , "S6_00367.ogg" , "S6_00358.ogg" , "S6_00404.ogg" },
        };

        private string[][] elVs_sake01 = new string[][]{
          new string[] { "S0_03503.ogg" , "S0_03177.ogg" , "S0_03520.ogg" , "S0_08143.ogg" , "S0_08146.ogg" , "S0_18208.ogg" , "S0_18212.ogg" , "S0_03633.ogg" },
          new string[] { "S1_06581.ogg" , "S1_06598.ogg" , "S1_06605.ogg" , "S1_05001.ogg" , "S1_05002.ogg" , "S1_05005.ogg" , "S1_05025.ogg" },
          new string[] { "S2_02663.ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
          new string[] { "S3_12865.ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
          new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
          new string[] { "S5_15289.ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
          new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
        };

        private string[][] elVs_hanyou01 = new string[][]{
          new string[] { "S0_03293.ogg" , "S0_03321.ogg" , ".ogg" , ".ogg" , ".ogg" },
          new string[] { "S1_04524.ogg" , "S1_04690.ogg" , "S1_05656.ogg" , ".ogg" , ".ogg" },
          new string[] { "S2_04714.ogg" , "S2_04678.ogg" , ".ogg" , ".ogg" , ".ogg" },
          new string[] { "S3_07702.ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
          new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
          new string[] { ".ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
          new string[] { "S6_00051.ogg" , ".ogg" , ".ogg" , ".ogg" , ".ogg" },
        };

        private void elLoadVoiceSet(int iPersonal, int i)
        {
          elVs[i] = new string[] { "" , "" , "" , "" , "" };
          if(life_f[i][13] == "SEX01"){
            if (iPersonal < elVs_sex01.Length) {
              elVs[i] = new string[elVs_sex01[iPersonal].Length];
              Array.Copy(elVs_sex01[iPersonal], elVs[i], elVs_sex01[iPersonal].Length);
            }
          }
          if(life_f[i][13] == "SEX02"){
            if (iPersonal < elVs_sex02.Length) {
              elVs[i] = new string[elVs_sex02[iPersonal].Length];
              Array.Copy(elVs_sex02[iPersonal], elVs[i], elVs_sex02[iPersonal].Length);
            }
          }
          if(life_f[i][13] == "SEX03"){
            if (iPersonal < elVs_sex03.Length) {
              elVs[i] = new string[elVs_sex03[iPersonal].Length];
              Array.Copy(elVs_sex03[iPersonal], elVs[i], elVs_sex03[iPersonal].Length);
            }
          }
          if(life_f[i][13] == "キス01"){
            if (iPersonal < elVs_kiss01.Length) {
              elVs[i] = new string[elVs_kiss01[iPersonal].Length];
              Array.Copy(elVs_kiss01[iPersonal], elVs[i], elVs_kiss01[iPersonal].Length);
            }
          }
          if(life_f[i][13] == "フェラ01"){
            if (iPersonal < elVs_fera01.Length) {
              elVs[i] = new string[elVs_fera01[iPersonal].Length];
              Array.Copy(elVs_fera01[iPersonal], elVs[i], elVs_fera01[iPersonal].Length);
            }
          }
          if(life_f[i][13] == "掃除"){
            if (iPersonal < elVs_souji01.Length) {
              elVs[i] = new string[elVs_souji01[iPersonal].Length];
              Array.Copy(elVs_souji01[iPersonal], elVs[i], elVs_souji01[iPersonal].Length);
            }
          }
          if(life_f[i][13] == "裁縫"){
            if (iPersonal < elVs_saiho01.Length) {
              elVs[i] = new string[elVs_saiho01[iPersonal].Length];
              Array.Copy(elVs_saiho01[iPersonal], elVs[i], elVs_saiho01[iPersonal].Length);
            }
          }
          if(life_f[i][13] == "料理"){
            if (iPersonal < elVs_ryouri01.Length) {
              elVs[i] = new string[elVs_ryouri01[iPersonal].Length];
              Array.Copy(elVs_ryouri01[iPersonal], elVs[i], elVs_ryouri01[iPersonal].Length);
            }
          }
          if(life_f[i][13] == "化粧"){
            if (iPersonal < elVs_kesyou01.Length) {
              elVs[i] = new string[elVs_kesyou01[iPersonal].Length];
              Array.Copy(elVs_kesyou01[iPersonal], elVs[i], elVs_kesyou01[iPersonal].Length);
            }
          }
          if(life_f[i][13] == "会話01"){
            if (iPersonal < elVs_kaiwa01.Length) {
              elVs[i] = new string[elVs_kaiwa01[iPersonal].Length];
              Array.Copy(elVs_kaiwa01[iPersonal], elVs[i], elVs_kaiwa01[iPersonal].Length);
            }
          }
          if(life_f[i][13] == "風呂"){
            if (iPersonal < elVs_furo01.Length) {
              elVs[i] = new string[elVs_furo01[iPersonal].Length];
              Array.Copy(elVs_furo01[iPersonal], elVs[i], elVs_furo01[iPersonal].Length);
            }
          }
        }



        //エンパイアズライフ
        private IEnumerator EmpiresLife(){

          //スタート時及び場所移動時の処理
          if(lifeStart == 1){

            elMouthMode = new int[]{ 0, 0, 0, 0 };
	          eldatui = new int[]{ 0, 0, 0, 0 };
	          GameMain.Instance.SoundMgr.StopSe();
	          GameMain.Instance.SoundMgr.StopBGM(2f);

            //GUI位置調整
            checkGUIPos();

            //シーンファイルの読み込み
            ElLoad(bgID);

            //ライト設定
            if(bgID == 32){
              GameMain.Instance.MainLight.GetComponent<Light>().color = new Color(0.9f, 0.8f, 0.7f, 1f);
            }else{
              GameMain.Instance.MainLight.GetComponent<Light>().color = new Color(1f, 1f, 1f, 1f);
            }

            //全メイドと男を一旦非表示
            GameMain.Instance.CharacterMgr.DeactivateMaidAll();
            GameMain.Instance.CharacterMgr.ResetCharaPosAll();
            for (int i = 0; i < SubMans.Length; i++) {
              setSubManVisible(i, false);
            }

            //メイドを呼び出す
            for (int i = 0; i < 4; i++){
              if(mn[bgID][i] == -1 || life_f[i][0] == "")continue;
              LoadMaid(stockMaids[mn[bgID][i]].mem);

              stockMaids[mn[bgID][i]].mem.ResetAll();

            }

            //男を呼び出す
            for (int i = 0; i < 4; i++){
              if(life_m[i][0] == "")continue;

              setSubManVisible(i, true);
            }

            if(node5.y < 0){
              node5.y = 0;
              cfgw.subGuiFlag = 0;
              cfgw.configGuiFlag = false;
            }
            lifeStart = 2;

          }


          if(lifeStart == 2){
            int lc = 0;
            for (int i = 0; i < 4; i++){
              if(life_f[i][0] == "" || mn[bgID][i] == -1){
                ++lc;
              }else if(stockMaids[mn[bgID][i]].mem.body0 != null && stockMaids[mn[bgID][i]].mem.body0.isLoadedBody && !stockMaids[mn[bgID][i]].mem.boAllProcPropBUSY){
                ++lc;
              }

              Maid subMan = getSubMan(i);
              if(life_m[i][0] == ""){
                ++lc;
              }else if(subMan.body0 != null && subMan.body0.isLoadedBody && !subMan.boAllProcPropBUSY){
                ++lc;
              }
            }
            if(lc == 8)lifeStart = 3;
          }

          if(lifeStart == 3){

            lifeStart = 4;

            yield return new WaitForSeconds (1f);  // 1秒待つ

            //メイドの移動とモーション・表情変更
            for (int i = 0; i < 4; i++){
              if(life_f[i][0] == "" || mn[bgID][i] == -1)continue;

              if(stockMaids[mn[bgID][i]].mem.Visible){

                //モーション変更
                if(life_f[i][12] == ""){
                  MaidSetMotion(life_f[i][0], stockMaids[mn[bgID][i]].mem, 0f, i);
                }

                //移動
                stockMaids[mn[bgID][i]].mem.transform.position = new Vector3(floatCnv(life_f[i][1]), floatCnv(life_f[i][2]), floatCnv(life_f[i][3]));
                stockMaids[mn[bgID][i]].mem.transform.eulerAngles = new Vector3(floatCnv(life_f[i][4]), floatCnv(life_f[i][5]), floatCnv(life_f[i][6]));
                stockMaids[mn[bgID][i]].mem.body0.SetBoneHitHeightY(floatCnv(life_f[i][9]));

                //表情変更
                MaidSetFace(life_f[i][7], stockMaids[mn[bgID][i]].mem);
                stockMaids[mn[bgID][i]].mem.FaceBlend(life_f[i][8]);

                //着衣の変更
                if(life_f[i][10] == "0"){ //全着衣
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.wear, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.mizugi, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.onepiece, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.bra, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.skirt, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.panz, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.glove, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.accUde, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.stkg, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.shoes, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.headset, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.accHat, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.accKubi, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.accKubiwa, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.accSenaka, true);
                }
                if(life_f[i][10] == "1"){ //全裸
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.wear, false);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.mizugi, false);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.onepiece, false);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.bra, false);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.skirt, false);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.panz, false);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.glove, false);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.accUde, false);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.stkg, false);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.shoes, false);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.headset, false);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.accHat, false);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.accKubi, false);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.accKubiwa, false);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.accSenaka, false);
                }
                if(life_f[i][10] == "2"){ //下着姿
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.wear, false);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.mizugi, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.onepiece, false);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.bra, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.skirt, false);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.panz, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.glove, false);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.accUde, false);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.stkg, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.shoes, false);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.headset, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.accHat, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.accKubi, false);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.accKubiwa, false);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.accSenaka, false);
                }
                if(life_f[i][10] == "3"){ //ノーパンノーブラ
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.wear, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.mizugi, false);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.onepiece, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.bra, false);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.skirt, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.panz, false);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.glove, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.accUde, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.stkg, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.shoes, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.headset, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.accHat, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.accKubi, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.accKubiwa, true);
                  stockMaids[mn[bgID][i]].mem.body0.SetMask(TBody.SlotID.accSenaka, true);
                }

                //顔と視線の向き変更
                if(life_f[i][11] == "0")stockMaids[mn[bgID][i]].mem.EyeToCamera((Maid.EyeMoveType)5, 0.8f); //向ける
                if(life_f[i][11] == "1")stockMaids[mn[bgID][i]].mem.EyeToCamera((Maid.EyeMoveType)0, 0.8f); //向けない
                if(life_f[i][11] == "2"){ //目だけ向ける
                  stockMaids[mn[bgID][i]].mem.EyeToCamera((Maid.EyeMoveType)0, 0.8f);
                  stockMaids[mn[bgID][i]].mem.body0.boEyeToCam = true;
                }

                //ボイスセット読み込み
                int iPersonal = Array.IndexOf(personalList[1], stockMaids[mn[bgID][i]].personal);
                elLoadVoiceSet(iPersonal, i);

                //マウスモード設定
                if(life_f[i][13].Contains("キス")){
                  elMouthMode[i] = 1;

                } else if(life_f[i][13].Contains("フェラ")){
                  elMouthMode[i] = 2;

                } else if(!life_f[i][13].Contains("SEX_A")) {
                  elMouthMode[i] = 0;
                }

                //メイドアイテム装備
                MaidSetItem(life_f[i][16], stockMaids[mn[bgID][i]].mem);

                //風呂シーン以外では汗を引かせる（要汗MOD）
                if(bgID != 11 && bgID != 22 && bgID != 23){
                  try {
                    VertexMorph_FromProcItem(stockMaids[mn[bgID][i]].mem.body0, "dry", 1f);
                  } catch { /*LogError(ex);*/ }
                }

                lifeTime1[i] = 0;
                lifeTime2[i] = UnityEngine.Random.Range(0f, 300f);
                lifeTime3[i] = UnityEngine.Random.Range(250f, 500f);
                elvFlag[i] = 0;
                elcrFlag[i] = false;


              }
            }

            //男の移動とモーション変更
            for (int i = 0; i < 4; i++){
              if(life_m[i][0] == "")continue;

              Maid subMan = getSubMan(i);
              if(subMan.Visible){
                subMan.transform.position = new Vector3(floatCnv(life_m[i][1]), floatCnv(life_m[i][2]), floatCnv(life_m[i][3]));
                subMan.transform.eulerAngles = new Vector3(floatCnv(life_m[i][4]), floatCnv(life_m[i][5]), floatCnv(life_m[i][6]));

                ManSetMotion(life_m[i][0], subMan ,0.7f, 0);

                //MansTg[i] = vmId[intCnv(life_m[i][7])];
                if (mn[bgID][intCnv(life_m[i][7])] != -1) { //エラー対策
                  MansTg[i] = stockMaids[mn[bgID][intCnv(life_m[i][7])]].id;
                }
              }
            }

             //背景変更
            Console.WriteLine("背景チェンジ:" + bgID);
            GameMain.Instance.BgMgr.ChangeBg(bgArray1[bgID][0]);

            //カメラ移動
            Vector3 pos = Vector3.zero;
            pos = new Vector3( floatCnv(bgArray1[bgID][4]) , floatCnv(bgArray1[bgID][5]) , floatCnv(bgArray1[bgID][6]) );
            mainCamera.transform.eulerAngles = new Vector3( floatCnv(bgArray1[bgID][7]) , floatCnv(bgArray1[bgID][8]) , floatCnv(bgArray1[bgID][9]) );
            if(!bVR){
              mainCamera.SetPos(pos);
              mainCamera.SetTargetPos(pos, true);
              mainCamera.SetDistance(0f, true);
            }else{
              mainCamera.SetPos(pos);
            }

            //BGM変更
            if(life_f[0][12] == ""){
              if(bgID == 32){
                GameMain.Instance.SoundMgr.PlayBGM(bgArray1[bgID][2], 0f, true);
              }else{
                GameMain.Instance.SoundMgr.PlayBGMLegacy(bgArray1[bgID][2], 0f, true);
              }
              danceFlag = 0;
            } else {
              danceFlag = 2; //ダンス曲が設定されている場合ダンスフラグを2に
              if(life_f[0][12] == "dummy")GameMain.Instance.SoundMgr.PlayBGMLegacy(bgArray1[bgID][2], 0f, true); //ダンス曲がダミーの場合は普通にBGM再生
            }

          }

          if(lifeStart == 4){
            StartCoroutine("ElChangeEnd");
          }

          if(lifeStart >= 5 && !elFade && tgID != -1){

            //if(maidsState[tgID].vStateMajor == 10){
              for (int i = 0; i < 4; i++){
                if ( mn[bgID][i] == -1 || life_f[i][0] == "" || maidsState[mn[bgID][i]].elItazuraFlag || osawari.isOsawari(mn[bgID][i]) ) continue;

                Maid maid = stockMaids[mn[bgID][i]].mem;

                //メイドが非表示になったらスポット解除
                if (!maid.Visible) {
                  maid.AudioMan.Stop(0f);
                  elcrFlag[i] = false;
                  mn[bgID][i] = -1;
                  continue;
                }


                //モーション変更処理（ダンスではない場合のみ）
                if(life_f[i][12] == ""){
                  if(mOnceFlag[i]){
                    Animation anim = maid.body0.GetAnimation();
                    if(!anim.isPlaying){
                      lifeTime1[i] = 1f;
                      mOnceFlag[i] = false;
                      maid.CrossFadeAbsolute( mOnceBack[i], GameUty.FileSystemOld, false, true, false, 0f, 1f );
                    }

                  }else if(lifeTime1[i] <= 0){
                    if(lifeStart > 5)MaidSetMotion(life_f[i][0], maid, 0.7f, i);
                    if(lifeStart == 5)MaidSetMotion(life_f[i][0], maid, 0f, i);

                    lifeTime1[i] = UnityEngine.Random.Range(400f, 1200f);  //タイマーリセット

                  } else {
                    lifeTime1[i] -= Time.deltaTime * 60;
                  }

                }

                //脱衣状態チェック
                if(dCheck && life_f[i][10] == "0"){
                  eldatui[i] = 0;
                  if(!maid.body0.GetMask(TBody.SlotID.wear) || !maid.body0.GetMask(TBody.SlotID.skirt) || isPropChanged(maid, "skirt").Contains("めくれ") || isPropChanged(maid, "onepiece").Contains("めくれ"))eldatui[i] += 1;
                  if(!maid.body0.GetMask(TBody.SlotID.panz))eldatui[i] += 1;
                  if(maid.GetProp(MPN.accvag).strTempFileName == "accVag_VibePink_I_.menu")eldatui[i] += 1;
                  if(maid.GetProp(MPN.accanl).strTempFileName == "accAnl_AnalVibe_I_.menu")eldatui[i] += 1;


                  if(eldatui[i] == 0){
                   maid.FaceBlend(life_f[i][8]);
                  }else if(eldatui[i] == 1){
                    maid.FaceBlend("頬２涙１");
                  }else if(eldatui[i] == 2){
                    maid.FaceBlend("頬３涙１");
                  }

                  lifeTime3[i] = 0;
                }


                //表情変更処理
                if(lifeTime3[i] <= 0){
                  //if((life_f[i][12] == "" && bgID != 32) || eldatui[i] == 0){
                  if(life_f[i][10] != "0" || eldatui[i] == 0){
                    MaidSetFace(life_f[i][7], maid);
                  }else{
                    if(eldatui[i] == 1)MaidSetFace("発情|引きつり笑顔|苦笑い|困った|泣き|少し怒り|誘惑|恥ずかしい|エロ羞恥２|エロ興奮３", maid);
                    if(eldatui[i] >= 2)MaidSetFace("発情|引きつり笑顔|苦笑い|困った|泣き|少し怒り|誘惑|恥ずかしい|エロ羞恥２|エロ興奮３|興奮射精後１|絶頂射精後１|エロ痛み１|エロ痛み２|エロ我慢２|エロ我慢３|まぶたギュ", stockMaids[mn[bgID][i]].mem);
                  }

                  //タイマーリセット
                  if(life_f[i][12] == "")lifeTime3[i] = UnityEngine.Random.Range(300f, 600f);
                  if(life_f[i][12] != "")lifeTime3[i] = UnityEngine.Random.Range(100f, 200f);
                } else {
                  lifeTime3[i] -= Time.deltaTime * 60;
                }

                //ボイス再生処理
                if(lifeTime2[i] <= 0){

                  float cr = 0f;
                  if(life_f[i][14] == "-1"){
                    cr = 6f;
                  }else{
                    cr = floatCnv(life_f[i][14]);
                  }

                  //メイドが設定距離より近くにいる場合にボイス再生
                  if(elVs[i][0] != "" && elvFlag[i] == 0){
                    if (DistanceToMaid(maidsState[mn[bgID][i]] , cr)) {
                      int r = UnityEngine.Random.Range(0, elVs[i].Length);
                      maid.AudioMan.audiosource.time = 0; //先に0に戻す
                      if(elcrFlag[i]) maid.AudioMan.LoadPlay(elVs[i][r], 0f, false, false);
                      if(!elcrFlag[i]) maid.AudioMan.LoadPlay(elVs[i][r], 1.5f, false, false);
                      elvFlag[i] = 1;
                      elcrFlag[i] = true;
                      if(life_f[i][13] == "SEX03"){
                        elMouthMode[i] = UnityEngine.Random.Range(2,5);
                        if(elMouthMode[i] < 3) elMouthMode[i] = 0;
                      }
                    }
                  }else{
                      lifeTime2[i] = 30;
                  }

                  //距離が離れたときもしくは再生が終わったときの処理
                  if (elvFlag[i] == 1){
                    if(!DistanceToMaid(maidsState[mn[bgID][i]] , cr)){
                      maid.AudioMan.Stop(1.5f);
                      elcrFlag[i] = false;
                    }

                    if(!maid.AudioMan.audiosource.isPlaying){
                      float vt = 0f;
                      if(life_f[i][15] == "-1"){
                        vt = 700f;

                      }else{
                        vt = floatCnv(life_f[i][15]);
                      }

                      elvFlag[i] = 0; //再生中フラグOFF

                      //タイマーリセット
                      if(elcrFlag[i]){
                        lifeTime2[i] = UnityEngine.Random.Range(vt, vt * 2.5f);
                      }else{
                        lifeTime2[i] = 30;
                      }

                    }
                  }

                } else {
                  lifeTime2[i] -= Time.deltaTime * 60;
                }

              }
              if(dCheck)dCheck = false;


              if(lifeStart == 5)lifeStart = 6;

            //}

            //ダンス関連チェック
            //メイドのモーションをチェックし、全員のダンスモーションが終了していた場合にフラグを2にする
            if(danceFlag == 1){
              int dc = 0;
              for (int i = 0; i < 4; i++){
                if(life_f[i][12] == "" || mn[bgID][i] == -1){
                  ++dc;
                  continue;
                }

                Animation anim = stockMaids[mn[bgID][i]].mem.body0.GetAnimation();
                if(!anim.IsPlaying(life_f[i][0]))++dc;

                //特定のモーションを遅らせて再生
                if(life_f[i][0] == "dance_cm3d2_kara_002_cktc_f1.anm"){
                  if(lifeTime1[i] <= 0){
                    stockMaids[mn[bgID][i]].mem.CrossFadeAbsolute( life_f[i][0], GameUty.FileSystemOld, false, false, false, 0.5f, 1f );
                    lifeTime1[i] = 100000;
                  }else{
                    lifeTime1[i] -= Time.deltaTime * 60;
                    if(290 < lifeTime1[i] && lifeTime1[i] < 300)stockMaids[mn[bgID][i]].mem.body0.StopAnime(life_f[i][0]);
                  }
                }
                if(life_f[i][0] == "dance_cm3d_004_kano_f1.anm"){
                  if(lifeTime1[i] <= 0){
                    stockMaids[mn[bgID][i]].mem.CrossFadeAbsolute( life_f[i][0], GameUty.FileSystemOld, false, false, false, 0.5f, 1f );
                    lifeTime1[i] = 100000;
                  }else{
                    lifeTime1[i] -= Time.deltaTime * 60;
                  }
                }

              }
              if(dc == 4)danceFlag = 2;

            }

            //フラグが2の場合、ダンス曲とダンスモーションを再生する
            if(danceFlag == 2){
              if(life_f[0][12] != "" && life_f[0][12] != "dummy"){
                GameMain.Instance.SoundMgr.StopBGM(0f);
                if(life_f[0][12] == "candygirl_short.ogg" || life_f[0][12] == "fusionicaddiction_short_pole.ogg" || life_f[0][12] == "lovemorecrymore_short_pole.ogg" ){
                  GameMain.Instance.SoundMgr.PlayBGM(life_f[0][12], 0f, false);
                }else{
                  GameMain.Instance.SoundMgr.PlayBGMLegacy(life_f[0][12], 0f, false);
                }
              }

              for (int i = 0; i < 4; i++){
                if(life_f[i][12] != "" && mn[bgID][i] != -1){

                  if(allFilesSet.Contains(life_f[i][0].Replace(".anm", ""))){
                    stockMaids[mn[bgID][i]].mem.CrossFadeAbsolute( life_f[i][0], false, false, false, 0.5f, 1f );
                  } else if(allFilesOldSet.Contains(life_f[i][0].Replace(".anm", ""))){
                    stockMaids[mn[bgID][i]].mem.CrossFadeAbsolute( life_f[i][0], GameUty.FileSystemOld, false, false, false, 0.5f, 1f );
                  }

                  //特定のモーションは再生を遅らせるために一旦停止
                  if(life_f[i][0] == "dance_cm3d2_kara_002_cktc_f1.anm"){
                    lifeTime1[i] = 350; //遅らせる時間設定
                  }
                  if(life_f[i][0] == "dance_cm3d_004_kano_f1.anm"){
                    lifeTime1[i] = 10; //遅らせる時間設定
                  }
                }
              }
              danceFlag = 1;
            }

            //カメラ移動処理
            if(!bVR)ElMove();

          }

        }


        private void MaidSetMotion(string s, Maid m ,float t, int n)
        {
          if (s == "") return;

          string[] motionList = s.Split('|');
          int i = UnityEngine.Random.Range(0 , motionList.Length);
          bool old = false;

          //モーションが見つかるまで回す 前にom_もつける
          string motion = null;
          int cnt = 0;
          while (cnt < motionList.Length) {
            motion = motionList[i].Replace("[S]", "").Replace("[L]", "").Replace("_ONCE_", "_once_");
            if (allFilesSet.Contains(motion.Replace(".anm", ""))){
              old = false;
              break;
            } else if(allFilesOldSet.Contains(motion.Replace(".anm", ""))){
              old = true;
              break;
            } else{
                motion = "om_"+motion;
              if (allFilesSet.Contains(motion.Replace(".anm", ""))){
                old = false;
                break;
              } else if(allFilesOldSet.Contains(motion.Replace(".anm", ""))){
                old = true;
                break;
              } else {
                Console.WriteLine("モーションなし：" + motionList[i]);
              }
            }

            i++;
            if (i >= motionList.Length) i = 0; //先頭に戻す
            cnt++;
          }
          if (motion == null) {
            Console.WriteLine("モーションが見つかりません：" + s);
            return;
          }

          if(motionList[i].Contains("[S]")){
            if(old){
              m.CrossFadeAbsolute( motion, GameUty.FileSystemOld, false, false, false, t, 1f );
            }else{
              m.CrossFadeAbsolute( motion, GameUty.FileSystem, false, false, false, t, 1f );
            }
            mOnceFlag[n] = true;
            mOnceBack[n] = motion;

          } else if(motionList[i].Contains("[L]")) {
            if(m.body0.LastAnimeFN == motion && lifeStart == 6)return;
            if(old){
              m.CrossFadeAbsolute( motion, GameUty.FileSystemOld, false, true, false, t, 1f );
            }else{
              m.CrossFadeAbsolute( motion, GameUty.FileSystem, false, true, false, t, 1f );
            }
            mOnceFlag[n] = false;
            mOnceBack[n] = "";

          }else if(motion.Contains("_once_")){
            if(old){
              m.CrossFadeAbsolute( motion, GameUty.FileSystemOld, false, false, false, t, 1f );
            }else{
              m.CrossFadeAbsolute( motion, GameUty.FileSystem, false, false, false, t, 1f );
            }
            mOnceFlag[n] = true;
            if(allFilesSet.Contains(motion.Replace("f_once_", "taiki_f").Replace(".anm", ""))){
              mOnceBack[n] = motion.Replace("f_once_", "taiki_f");
            }else{
              mOnceBack[n] = motion;
            }

          }else{
            if(m.body0.LastAnimeFN == motion && lifeStart == 6)return;
            if(old){
              m.CrossFadeAbsolute( motion, GameUty.FileSystemOld, false, true, false, t, 1f );
            }else{
              m.CrossFadeAbsolute( motion, GameUty.FileSystem, false, true, false, t, 1f );
            }
            mOnceFlag[n] = false;
            mOnceBack[n] = "";

          }

          //連動して男モーションも変更
          for (int i2 = 0; i2 < 4; i2++){
            if(intCnv(life_m[i2][7]) == n && life_m[i2][0] != ""){
              ManSetMotion(life_m[i2][0], getSubMan(i2) ,t, i);
            }
          }

          //表情タイマーを0
          lifeTime3[n] = 0;

          //"SEX_A"の場合は音声のオート変更処理
          if(life_f[n][13] == "SEX_A"){
            int iPersonal = Array.IndexOf(personalList[1], m.status.personal.uniqueName);
            lifeTime2[n] = 0;
            m.AudioMan.Stop();
            elMouthMode[n] = CheckMouthMode(motion);

            if(elMouthMode[n] == 0){
              if(motion.Contains("_3_f") || motion.Contains("_3a01_f") || motion.Contains("_3b01_f") || motion.Contains("_3b02_f") || motion.Contains("_3e01_f") || motion.Contains("_3e02_f")){
                if (iPersonal < elVs_sex02.Length) {
                  elVs[n] = new string[elVs_sex02[iPersonal].Length];
                  Array.Copy(elVs_sex02[iPersonal], elVs[n], elVs_sex02[iPersonal].Length);
                }
              }else{
                if (iPersonal < elVs_sex01.Length) {
                  elVs[n] = new string[elVs_sex01[iPersonal].Length];
                  Array.Copy(elVs_sex01[iPersonal], elVs[n], elVs_sex01[iPersonal].Length);
                }
              }

            }else if(elMouthMode[n] == 1){
              if (iPersonal < elVs_kiss01.Length) {
                elVs[n] = new string[elVs_kiss01[iPersonal].Length];
                Array.Copy(elVs_kiss01[iPersonal], elVs[n], elVs_kiss01[iPersonal].Length);
              }

            }else if(elMouthMode[n] == 2){
              if (iPersonal < elVs_fera01.Length) {
                elVs[n] = new string[elVs_fera01[iPersonal].Length];
                Array.Copy(elVs_fera01[iPersonal], elVs[n], elVs_fera01[iPersonal].Length);
              }
            }

          }

        }

        private void ManSetMotion(string s, Maid m ,float t, int i){
          if(s == "")return;

          string[] motionList = s.Split('|');
          if(motionList.Length <= i)return;

          string motion = motionList[i];
          if (allFilesSet.Contains(motion.Replace(".anm", ""))) {
            m.CrossFadeAbsolute( motion, GameUty.FileSystem, false, true, false, t, 1f );
            return;
          } else if (allFilesOldSet.Contains(motion.Replace(".anm", ""))) {
            m.CrossFadeAbsolute( motion, GameUty.FileSystemOld, false, true, false, t, 1f );
            return;
          } else {
            motion = "om_"+motion;
            if (allFilesSet.Contains(motion.Replace(".anm", ""))) {
              m.CrossFadeAbsolute( motion, GameUty.FileSystem, false, true, false, t, 1f );
              return;
            } else if (allFilesOldSet.Contains(motion.Replace(".anm", ""))) {
              m.CrossFadeAbsolute( motion, GameUty.FileSystemOld, false, true, false, t, 1f );
              return;
            }
          }

          Console.WriteLine("男のモーションが見つかりません：" + motion);
        }


        private void MaidSetFace(string s, Maid m){
          if(s == "")return;

          string[] faceList = s.Split('|');
          int i = UnityEngine.Random.Range(0 , faceList.Length);
          m.FaceAnime(faceList[i] , cfgw.fAnimeFadeTimeV , 0);
        }

        private void MaidSetItem(string s, Maid m){
          if(s == "")return;

          string[] itemList = s.Split('|');

          foreach(string item in itemList){
            string[] mItem = item.Split(',');
            m.SetProp(mItem[0], mItem[1], 0, true, false);
          }
          m.AllProcPropSeqStart();
        }


        private int bgC = 0;
        private void ElStart(){

          GetStockMaids();
          var ary = Enumerable.Range(0, stockMaids.Count).OrderBy(n => Guid.NewGuid()).Take(stockMaids.Count).ToArray(); //メイドの数だけ重複しないランダム変数を作成
          bgC = 0;
          maidOver = false;
          freeOver = false;
	        exclusiveOver = false;

          int mi = 0;
          int ei = 0;
          int fi = 0;
          int[] hm = new int[]{-1, -1, -1, -1};
          //flagN = GameMain.Instance.CharacterMgr.status.GetFlag("時間帯") == 3;


          //NTRブロック用にフリーとそれ以外のメイドを分ける
          List<int> exclusive = new List<int>();
          List<int> free = new List<int>();
          List<int> all = new List<int>();
          foreach (int a in ary){
            if (stockMaids[a].mem.status.heroineType.ToString() == "Sub")continue; //NPCメイドを除外する

            all.Add(a);
            if(stockMaids[a].mem.status.contract.ToString() == "Free"){
              free.Add(a);
            }else{
              exclusive.Add(a);
            }
          }


          for (int i = 0; i < bgArray1.GetLength(0); i++){

            //背景が存在するかどうかチェック
            UnityEngine.Object @object = GameMain.Instance.BgMgr.CreateAssetBundle(bgArray1[i][0]);
            if (@object == null){
              @object = Resources.Load("BG/" + bgArray1[i][0]);
              if (@object == null){
                @object = Resources.Load("BG/2_0/" + bgArray1[i][0]);
              }
            }
            if (@object == null)bgArray1[i][3] = "0";

            if(bgArray1[i][3] == "0" )continue;
            if(flagN && bgArray1[i][3] == "1" )continue;
            if(!flagN && bgArray1[i][3] == "2" )continue;
            if(bgArray1[i][0] == "MaidRoom" )continue;

            //複数シーンファイルがある場合にランダム選択
            int r = UnityEngine.Random.Range(0,intCnv(bgArray1[i][10])) + 1;
            bgArray1[i][11] = r.ToString();

            //メイド配置のためにシーンファイルをロード
            ElLoad(i);

            //各シーンにランダムに並び替えたメイドを順番に配置する
            for (int i2 = 0; i2 < 4; i2++){
              if(life_f[i2][0] == "")continue;

              if(cfgw.ntrBlock && flagN){ //NTRブロック有効かつ夜の時
                if(life_f[i2][17] == "0"){
                  if(exclusive.Count <= i2){
                    mn[i][i2] = -1;
                    continue;
                  }

                  mn[i][i2] = exclusive[ei];
                  ++ei;
                  if(exclusive.Count <= ei){
                    ei = 0; //メイド数が限界に達した場合０に戻してループさせる
                    exclusiveOver = true;
                  }

                } else {
                  if(free.Count <= i2){
                    mn[i][i2] = -1;
                    continue;
                  }

                  mn[i][i2] = free[fi];
                  ++fi;
                  if(free.Count <= fi){
                    fi = 0; //メイド数が限界に達した場合０に戻してループさせる
                    freeOver = true;
                  }
                }
                if(exclusiveOver && freeOver)maidOver = true;

              } else { //NTRブロック無効時
                if(all.Count <= i2){
                  mn[i][i2] = -1;
                  continue;
                }

                mn[i][i2] = all[mi];
                ++mi;

                if(all.Count <= mi){
                  mi = 0; //メイド数が限界に達した場合０に戻してループさせる
                  maidOver = true;
                }
              }

            }

            ++bgC;

          }

          if(cfgw.ntrBlock && flagN){
            holidayMaid.Clear();
            if(!exclusiveOver){
              for (int e = ei; e < exclusive.Count; e++){
                hm = new int[]{-1, -1, -1, -1};
                hm[0] = exclusive[ei];
                ++ei;

                holidayMaid.Add(hm);
                ++bgC;
              }
            }
            if(!freeOver){
              for (int f = fi; f < free.Count; f++){
                hm = new int[]{-1, -1, -1, -1};
                hm[0] = free[fi];
                ++fi;

                holidayMaid.Add(hm);
                ++bgC;
              }
            }

          }else{
            holidayMaid.Clear();
            if(!maidOver){
              for (int i3 = mi; i3 < all.Count; i3++){
                hm = new int[]{-1, -1, -1, -1};
                hm[0] = all[mi];
                ++mi;

                holidayMaid.Add(hm);
                ++bgC;
              }
            }
          }


          if(bgC % 4 == 0){
            bgC = bgC / 4;
          }else{
            bgC = bgC / 4 + 1;
          }

        }



        private void ElEnd(){
          GameMain.Instance.MainCamera.FadeOut(0f, false, null, true, default(Color));
          elFade = true;

          lifeStart = 0;
          if(!bVR)Camera.main.fieldOfView = 35.0f;
          elMouthMode = new int[]{ 0, 0, 0, 0 };

          //全キャラ非表示
          GameMain.Instance.CharacterMgr.DeactivateMaidAll();
          GameMain.Instance.CharacterMgr.ResetCharaPosAll();
          for (int i = 0; i < SubMans.Length; i++) {
            setSubManVisible(i, false);
          }

          //背景変更
          //bool flagN = GameMain.Instance.CharacterMgr.status.GetFlag("時間帯") == 3;
          if(!flagN)bgID = 0;
          if(flagN)bgID = 1;
          Console.WriteLine("背景チェンジ:" + bgID);
          GameMain.Instance.BgMgr.ChangeBg(bgArray1[bgID][0]);

          //カメラ移動
          Vector3 pos = Vector3.zero;
          pos = new Vector3( floatCnv(bgArray1[bgID][4]) , floatCnv(bgArray1[bgID][5]) , floatCnv(bgArray1[bgID][6]) );
          mainCamera.transform.eulerAngles = new Vector3( floatCnv(bgArray1[bgID][7]) , floatCnv(bgArray1[bgID][8]) , floatCnv(bgArray1[bgID][9]) );
          if(!bVR){
            mainCamera.SetPos(pos);
            mainCamera.SetTargetPos(pos, true);
            mainCamera.SetDistance(0f, true);
          }else{
            mainCamera.SetPos(pos);
          }

          //BGM変更
          GameMain.Instance.SoundMgr.PlayBGMLegacy("bgm015.ogg", 0f, true);

          GameMain.Instance.MainCamera.FadeIn(1f, false, null, true, true, default(Color));
          elFade = false;

        }


        private float speed = 1;
        private void ElMove(){

          Vector3 pos = Vector3.zero;
          pos = Camera.main.transform.position;
          float frontValue = 0;
          float rightValue = 0;


          if(Input.GetKey(KeyCode.W))frontValue = 0.025f * speed;
          if(Input.GetKey(KeyCode.S))frontValue = -0.025f * speed;
          if(Input.GetKey(KeyCode.D))rightValue = 0.025f * speed;
          if(Input.GetKey(KeyCode.A))rightValue = -0.025f * speed;

          if(frontValue != 0 || rightValue != 0 ){
            frontValue += 0.029f;
            Vector3 cameraForward = Vector3.Scale(Camera.main.transform.forward, new Vector3(1, 1, 1)).normalized;
            Vector3 moveForward = cameraForward * frontValue + Camera.main.transform.right * rightValue;
            pos += moveForward;

            //カメラ位置の移動
            if(!bVR){
              mainCamera.SetPos(pos);
              mainCamera.SetTargetPos(pos, true);
              mainCamera.SetDistance(0f, true);
            }else{
              mainCamera.SetPos(pos);
            }
          }

        }

        private IEnumerator ElChange(int i){

          GameMain.Instance.MainCamera.FadeOut(0f, false, null, true, default(Color));
          elFade = true;
          yield return new WaitForSeconds (0.1f);

          bgID = i;
          lifeStart = 1;
        }

        private IEnumerator ElChangeEnd(){
          yield return new WaitForSeconds (1f);
          GameMain.Instance.MainCamera.FadeIn(1f, false, null, true, true, default(Color));
          elFade = false;
          lifeStart = 5;
        }


        //エンパイアズライフのシーン設定読み込み
        private void ElLoad(int i){

            string r = bgArray1[i][11];
            switch(i){
              case 0:
                   life00_01f.CopyTo(life_f, 0);
                   life00_01m.CopyTo(life_m, 0);
                   break;

              case 1:
                   life01_01f.CopyTo(life_f, 0);
                   life01_01m.CopyTo(life_m, 0);
                   break;

              case 2:
                   life02_01f.CopyTo(life_f, 0);
                   life02_01m.CopyTo(life_m, 0);
                   break;

              case 3:
                   if(r == "1"){
                     life03_01f.CopyTo(life_f, 0);
                     life03_01m.CopyTo(life_m, 0);
                   }else if(r == "2"){
                     life03_02f.CopyTo(life_f, 0);
                     life03_02m.CopyTo(life_m, 0);
                   }else if(r == "3"){
                     life03_03f.CopyTo(life_f, 0);
                     life03_03m.CopyTo(life_m, 0);
                   }else if(r == "4"){
                     life03_04f.CopyTo(life_f, 0);
                     life03_04m.CopyTo(life_m, 0);
                   }else if(r == "5"){
                     life03_05f.CopyTo(life_f, 0);
                     life03_05m.CopyTo(life_m, 0);
                   }
                   break;

              case 4:
                   life04_01f.CopyTo(life_f, 0);
                   life04_01m.CopyTo(life_m, 0);
                   break;

              case 5:
                   life05_01f.CopyTo(life_f, 0);
                   life05_01m.CopyTo(life_m, 0);
                   break;

              case 6:
                   life06_01f.CopyTo(life_f, 0);
                   life06_01m.CopyTo(life_m, 0);
                   break;

              case 7:
                   life07_01f.CopyTo(life_f, 0);
                   life07_01m.CopyTo(life_m, 0);
                   break;

              case 8:
                   life08_01f.CopyTo(life_f, 0);
                   life08_01m.CopyTo(life_m, 0);
                   break;

              case 9:
                   life09_01f.CopyTo(life_f, 0);
                   life09_01m.CopyTo(life_m, 0);
                   break;

              case 10:
                   life10_01f.CopyTo(life_f, 0);
                   life10_01m.CopyTo(life_m, 0);
                   break;

              case 11:
                   life11_01f.CopyTo(life_f, 0);
                   life11_01m.CopyTo(life_m, 0);
                   break;

              case 12:
                   life12_01f.CopyTo(life_f, 0);
                   life12_01m.CopyTo(life_m, 0);
                   break;

              case 13:
                   if(r == "1"){
                     life13_01f.CopyTo(life_f, 0);
                     life13_01m.CopyTo(life_m, 0);
                   }else if(r == "2"){
                     life13_02f.CopyTo(life_f, 0);
                     life13_02m.CopyTo(life_m, 0);
                   }
                   break;

              case 14:
                   life14_01f.CopyTo(life_f, 0);
                   life14_01m.CopyTo(life_m, 0);
                   break;

              case 15:
                   life15_01f.CopyTo(life_f, 0);
                   life15_01m.CopyTo(life_m, 0);
                   break;

              case 16:
                   life16_01f.CopyTo(life_f, 0);
                   life16_01m.CopyTo(life_m, 0);
                   break;

              case 17:
                   life17_01f.CopyTo(life_f, 0);
                   life17_01m.CopyTo(life_m, 0);
                   break;

              case 18:
                   life18_01f.CopyTo(life_f, 0);
                   life18_01m.CopyTo(life_m, 0);
                   break;

              case 19:
                   life19_01f.CopyTo(life_f, 0);
                   life19_01m.CopyTo(life_m, 0);
                   break;

              case 20:
                   life20_01f.CopyTo(life_f, 0);
                   life20_01m.CopyTo(life_m, 0);
                   break;

              case 21:
                   life21_01f.CopyTo(life_f, 0);
                   life21_01m.CopyTo(life_m, 0);
                   break;

              case 22:
                   life22_01f.CopyTo(life_f, 0);
                   life22_01m.CopyTo(life_m, 0);
                   break;

              case 23:
                   life23_01f.CopyTo(life_f, 0);
                   life23_01m.CopyTo(life_m, 0);
                   break;

              case 24:
                   life24_01f.CopyTo(life_f, 0);
                   life24_01m.CopyTo(life_m, 0);
                   break;

              case 25:
                   life25_01f.CopyTo(life_f, 0);
                   life25_01m.CopyTo(life_m, 0);
                   break;

              case 26:
                   life26_01f.CopyTo(life_f, 0);
                   life26_01m.CopyTo(life_m, 0);
                   break;

              case 27:
                   life27_01f.CopyTo(life_f, 0);
                   life27_01m.CopyTo(life_m, 0);
                   break;

              case 28:
                   life28_01f.CopyTo(life_f, 0);
                   life28_01m.CopyTo(life_m, 0);
                   break;

              case 29:
                   life29_01f.CopyTo(life_f, 0);
                   life29_01m.CopyTo(life_m, 0);
                   break;

              case 30:
                   life30_01f.CopyTo(life_f, 0);
                   life30_01m.CopyTo(life_m, 0);
                   break;

              case 31:
                   life31_01f.CopyTo(life_f, 0);
                   life31_01m.CopyTo(life_m, 0);
                   break;

              case 32:
                   if(r == "1"){
                     life32_01f.CopyTo(life_f, 0);
                     life32_01m.CopyTo(life_m, 0);
                   }else if(r == "2"){
                     life32_02f.CopyTo(life_f, 0);
                     life32_02m.CopyTo(life_m, 0);
                   }
                   break;

              case 33:
                   life33_01f.CopyTo(life_f, 0);
                   life33_01m.CopyTo(life_m, 0);
                   break;

              case 34:
                   life34_01f.CopyTo(life_f, 0);
                   life34_01m.CopyTo(life_m, 0);
                   break;

              case 35:
                   life35_01f.CopyTo(life_f, 0);
                   life35_01m.CopyTo(life_m, 0);
                   break;

              case 36:
                   life36_01f.CopyTo(life_f, 0);
                   life36_01m.CopyTo(life_m, 0);
                   break;

              case 37:
                   life37_01f.CopyTo(life_f, 0);
                   life37_01m.CopyTo(life_m, 0);
                   break;

              case 38:
                   int r2 = UnityEngine.Random.Range(0,90);
                   if(r2 < 20){
                     life38_01f.CopyTo(life_f, 0);
                     life38_01m.CopyTo(life_m, 0);
                   } else if(r2 < 40){
                     life38_02f.CopyTo(life_f, 0);
                     life38_02m.CopyTo(life_m, 0);
                   } else if(r2 < 60){
                     life38_03f.CopyTo(life_f, 0);
                     life38_03m.CopyTo(life_m, 0);
                   } else if(r2 < 80){
                     life38_04f.CopyTo(life_f, 0);
                     life38_04m.CopyTo(life_m, 0);
                   } else if(r2 < 85){
                     life38_05f.CopyTo(life_f, 0);
                     life38_05m.CopyTo(life_m, 0);
                   } else {
                     life38_06f.CopyTo(life_f, 0);
                     life38_06m.CopyTo(life_m, 0);
                   }
                   break;

              case 39:
                   life39_01f.CopyTo(life_f, 0);
                   life39_01m.CopyTo(life_m, 0);
                   break;
            }

        }
      //エンパイアズライフ関係終了-----------------------
      #endif


      //胸衝突判定-----------------------

      /// <summary>
      /// 胸の初期の回転の値 「胸寄り」と「胸上下」の設定値から算出 胸のおさわり時も利用 
      /// </summary>
      public class MuneValue
      {
        public float MuneUpDown;
        //public float MuneBlend;
        public float MuneUpDown_f;
        public float MuneYori;
        public float MuneYori_f;

        //胸の初期値 MaideStateに格納する MPNの値から算出
        public MuneValue(Maid maid)
        {
          float yori = maid.GetProp(MPN.MuneYori).value * 0.01f;
          float updown = maid.GetProp(MPN.MuneUpDown).value * 0.01f;

          this.MuneUpDown = (updown - 0.5f) * 60f;
          //this.MuneBlend = - (updown - 0.5f);
          this.MuneUpDown_f = Mathf.Abs(updown - 0.5f) * 2f;
          this.MuneYori = (yori - 0.5f) * 25f;
          this.MuneYori_f =  Mathf.Abs(yori - 0.5f) * 2f;
        }
      }

      /// <summary>
      /// 胸衝突時の変形オフセット情報 参照渡しするのでclass
      /// </summary>
      public class MuneOffset
      {
        //現在の胸寄り補正
        public float x = 0;
        public float y = 0;
        //最終的な胸寄り補正
        public float targetX = 0;
        public float targetY = 0;
        //反復動作させるために遅延変動させる移動速度
        public float speedX = 0;
        public float speedY = 0;

        public void reset()
        {
          targetX = 0;
          targetY = 0;
          x = 0;
          y = 0;
          speedX = 0;
          speedY = 0;
        }
      }

      /// <summary>
      /// 胸衝突判定用の座標情報  設定ファイルと拡張セーブデータから取得
      /// メイド読み込み時に実行 ボディのlocalScale変更にも対応
      /// </summary>
      public class MuneParam
      {
        //メイド個別設定 cgfwの値をデフォルト設定
        //胸移動速度
        public float moveSpeedAmp;
        public float moveSpeedTime;
        //public float returnSpeedAmp;
        //public float returnSpeedTime;

        //胸変動倍率
        public float moveRatioX;
        public float moveRatioY;
        public float moveLimitX;
        public float moveLimitY;
        //胸変動量2次曲線反転位置
        public float curvePointX;
        public float curvePointY;

        public float scale;  //セットした時のメイドのスケール

        //public float angleY; //胸寄りに応じた角度 正面が0 反時計回り
        public Quaternion rotY;
        public Quaternion invRotY;

        public Vector3 armOffsetL;  //腕原点オフセット 左
        public Vector3 armOffsetR;  //腕原点オフセット 右

        //左右 外側が+ 左胸の値 ※右胸はdirection.zを反転して利用
        public float outside;      //外端 前 胸サイズを反映
        public float centerX;      //左右中心
        //上下 上が+
        public float top;          //上端
        public float centerY;      //上下中心 胸サイズを反映
        public float bottom;       //下端
        //前後 前が+
        public float front;        //先端 胸サイズを反映
        public float centerFrontZ; //前方の胸横位置 前後の短いほうを基準にする
        public float centerBackZ;  //後方の胸横位置 前後の短いほうを基準にする
        public float back;         //後方の当たり判定開始位置 胴体真ん中あたり
        //胸下げ用
        public float downOutside;  //乳下げ外端 胸サイズの半分を反映
        public float downCenterX;  //乳下げが最大になる横位置 centerXより内側
        public float downInside;   //乳下げ外端 胸サイズの半分を反映
        public float downTop;      //乳下げ 上側
        public float downCenterY;  //乳下げが最大になる高さ centerYより上にする
        public float downBottom;   //乳下げ 下側 胸の中心あたり
        public float downFront;    //乳下げ 前
        public float downCenterZ;  //乳下げ 前後中央
        public float downBack;     //乳下げ 後

        //0～1化の係数
        public float normarizeX;   //左右
        public float normarizeYT;  //上側
        public float normarizeYB;  //下側
        public float normarizeZF;  //前用
        public float normarizeZB;  //後用
        public float normarizeDX;  //乳下げ用 左右
        public float normarizeDYT; //乳下げ用 上側
        public float normarizeDYB; //乳下げ用 下側
        public float normarizeDZ;  //乳下げ用 前後

        //範囲内の判定用
        public float rangeOutside;
        public float rangeTop;
        public float rangeBottom;
        public float rangeFront;
        public float rangeBack;

        //初期化  設定ファイルと拡張セーブデータから取得
        public MuneParam(VibeYourMaidCfgWriting cfgw, Maid maid)
        {
          //メイド個別設定 拡張セーブデータから取得 なければcfgwの値
          moveSpeedAmp = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneMoveSpeedAmp", cfgw.muneMoveSpeedAmp);
          moveSpeedTime = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneMoveSpeedTime", cfgw.muneMoveSpeedTime);
          //returnSpeedAmp = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneReturnSpeedAmp", cfgw.muneReturnSpeedAmp);
          //returnSpeedTime = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneReturnSpeedTime", cfgw.muneReturnSpeedTime);
          moveRatioX = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneMoveRatioX", cfgw.muneMoveRatioX);
          moveRatioY = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneMoveRatioY", cfgw.muneMoveRatioY);
          moveLimitX = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneMoveLimitX", cfgw.muneMoveLimitX);
          moveLimitY = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneMoveLimitY", cfgw.muneMoveLimitY);
          curvePointX = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneCurvePointX", cfgw.muneCurvePointX);
          curvePointY = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneCurvePointY", cfgw.muneCurvePointY);

          float muneAngleX = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneAngleX", cfgw.muneAngleX);
          float muneAngleY = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneAngleY", cfgw.muneAngleY);
          float muneAngleZ = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneAngleZ", cfgw.muneAngleZ);
          float muneArmX = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneArmX", cfgw.muneArmX);
          float muneArmY = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneArmY", cfgw.muneArmY);
          float muneArmZ = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneArmZ", cfgw.muneArmZ);

          float muneOutside = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneOutside", cfgw.muneOutside);
          float muneCenterX = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneCenterX", cfgw.muneCenterX);
          float muneTop = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneTop", cfgw.muneTop);
          float muneCenterY = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneCenterY", cfgw.muneCenterY);
          float muneBottom = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneBottom", cfgw.muneBottom);
          float muneFront = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneFront", cfgw.muneFront);
          float muneCenterZ = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneCenterZ", cfgw.muneCenterZ);
          float muneCenterBackZ = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneCenterBackZ", cfgw.muneCenterBackZ);
          float muneBack = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneBack", cfgw.muneBack);
          float muneDownOutside = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneDownOutside", cfgw.muneDownOutside);
          float muneDownCenterX = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneDownCenterX", cfgw.muneDownCenterX);
          float muneDownTop = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneDownTop", cfgw.muneDownTop);
          float muneDownCenterY = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneDownCenterY", cfgw.muneDownCenterY);
          float muneDownBottom = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneDownBottom", cfgw.muneDownBottom);
          float muneDownFront = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneDownFront", cfgw.muneDownFront);
          float muneDownCenterZ = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneDownCenterZ", cfgw.muneDownCenterZ);
          float muneDownBack = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneDownBack", cfgw.muneDownBack);

          //ボディのスケール変更チェック用
          scale = maid.body0.transform.localScale.x;

          float size = (float)maid.GetProp(MPN.MuneL).value;
          float yori = (float)maid.GetProp(MPN.MuneYori).value; //外側が+

          //胸寄りに応じた角度 正面が0 比率補正前のsize yoriで調整
          float yoriAngleY = muneAngleY + ((yori-50)*0.25f) * size*0.01f; //jbMuneの回転
          rotY = Quaternion.Euler(yoriAngleY, muneAngleZ, muneAngleX); //spine1aの軸向き(-y,z,x)での回転
          invRotY = Quaternion.Euler(muneAngleX, -yoriAngleY, muneAngleZ); //腕の位置xyzの回転用

          float updown = (float)maid.GetProp(MPN.MuneUpDown).value; //上が+
          float tare = (float)maid.GetProp(MPN.MuneYawaraka).value; //下が+

          //胸サイズによる位置補正比率 0→0倍 50→1倍 100→2倍
          float sizeRatio = size/50f;
          //移動量 50を基準に左右同倍率
          updown = (updown - 50) * sizeRatio;
          tare = (tare - 50) * sizeRatio;

          //胸サイズによる拡大比率  40以下はあまり動かなくなるため敢えてマイナス補正しない
          size = (Math.Max(40, size)-50f);

          //腕の原点からのオフセット 腕の軸に合わせる Yは胸の大きさに連動
          muneArmY = muneArmY - size*cfgw.muneArmOffsetY*0.01f; //サイズ補正
          //_IK_UpperArmL/Rとのずれ 0.09768134 は補正する
          armOffsetL = new Vector3(muneArmY-0.09768134f, -muneArmZ , muneArmX);
          armOffsetR = new Vector3(muneArmY-0.09768134f, -muneArmZ , -muneArmX); //左右反転

          //左右
          outside = muneOutside + size*cfgw.muneSizeExpandX*0.01f;
          centerX = muneCenterX + size*cfgw.muneSizeExpandX*0.005f; //サイズの半分で補正
          downOutside = muneDownOutside + size*cfgw.muneSizeExpandX*0.005f; //サイズの半分で補正
          downCenterX = muneDownCenterX;
          downInside = downCenterX - (downOutside-downCenterX);

          //上下  サイズでtopとcenterは変わらずbottomだけ下がる
          top = muneTop;
          centerY = muneCenterY - size*cfgw.muneSizeExpandY*0.005f + updown*cfgw.muneUpDownAdjust*0.01f - tare*cfgw.muneTareAdjust*0.01f; //サイズ補正の半分下げる
          bottom = muneBottom - size*cfgw.muneSizeExpandY*0.01f + updown*cfgw.muneUpDownAdjust*0.01f - tare*cfgw.muneTareAdjust*0.01f; //下端だけ下げる
          downTop = muneDownTop - size*cfgw.muneSizeExpandY*0.0025f; //サイズ補正の1/4下げる
          downCenterY = muneDownCenterY - size*cfgw.muneSizeExpandY*0.0025f + updown*cfgw.muneUpDownAdjust*0.01f - tare*cfgw.muneTareAdjust*0.01f; //サイズ補正の1/4下げる
          downBottom = muneDownBottom  - size*cfgw.muneSizeExpandY*0.0025f + updown*cfgw.muneUpDownAdjust*0.01f - tare*cfgw.muneTareAdjust*0.01f; //サイズ補正の1/4下げる

          //前後 先端は前方にサイズ補正
          front = muneFront + size*cfgw.muneSizeExpandZ*0.01f;
          centerFrontZ = muneCenterZ;
          centerBackZ = muneCenterBackZ;
          back = muneBack;
          downFront = muneDownFront + size*cfgw.muneSizeExpandZ*0.005f; //半分
          downCenterZ = muneDownCenterZ + size*cfgw.muneSizeExpandZ*0.0025f;  //1/4
          downBack = muneDownBack;

          //localScale反映
          centerX *= scale;
          outside *= scale;
          top *= scale;
          centerY *= scale;
          bottom *= scale;
          front *= scale;
          centerFrontZ *= scale;
          centerBackZ *= scale;
          back *= scale;
          downCenterX *= scale;
          downOutside *= scale;
          downInside *= scale;
          downCenterY *= scale;
          downTop *= scale;
          downBottom *= scale;
          downCenterZ *= scale;
          downFront *= scale;
          downBack *= scale;

          normarizeX = 1f/(outside-centerX);
          normarizeYT = 1f/(top-centerY);
          normarizeYB = 1f/(centerY-bottom);
          normarizeZF = 1f/(front-centerFrontZ);
          //normarizeZFT = 1f/(front-centerBackZ);
          normarizeZB = 1f/(centerBackZ-back);
          normarizeDX = 1f/(downOutside-downCenterX);
          normarizeDYT = 1f/(downTop-downCenterY);
          normarizeDYB = 1f/(downCenterY-downBottom);
          normarizeDZ = 1f/(downFront-downCenterZ);

          //座標側が回転されるので範囲はそのまま
          rangeOutside = Math.Max(outside, downOutside);
          rangeTop = Math.Max(top, downTop);
          rangeBottom = Math.Min(bottom, downBottom);
          rangeFront = Math.Max(front, downFront);
          rangeBack = Math.Min(back, downBack);

          if (cfgw.muneDrawGizmo) {
            Debug.Log("[VibeYourMaid] muneYori Enabled : Maid="+maid);
            Debug.Log("  MoveSpeed T="+moveSpeedTime+" A="+moveSpeedAmp+" CurvePoint x="+curvePointX+" y="+curvePointY);
            Debug.Log("  MoveRatio X="+moveRatioX+" Y="+moveRatioY+"  MoveLimit X="+moveLimitX+" Y="+moveLimitY);
            Debug.Log("  angle=("+muneAngleX+","+muneAngleY+","+muneAngleZ+")  ArmOffset=("+armOffsetL.x+","+armOffsetL.y+","+armOffsetL.z+")");
            Debug.Log("  outside="+outside+" centerX="+centerX+"  top="+top+" centerY="+centerY+" bottom="+bottom+"  front="+front+" centerZ="+centerFrontZ+" centerBackZ="+centerBackZ+" back="+back);
            Debug.Log("  down cx="+downCenterX+" outside="+downOutside+" cy="+downCenterY+" top="+downTop+" bottom="+downBottom+" cz="+downCenterZ+" front="+downFront+" back="+downBack);
            //Debug.Log("  range outside="+rangeOutside+" top="+rangeTop+" bottom="+rangeBottom+" front="+rangeFront+" back="+rangeBack);
          }
        }
      }

      //胸寄せ処理 Updateでメイド毎に呼ばれる
      //腕とと胸の距離をチェック 胸寄り分のオフセットを設定してosawari.muneMorphで反映
      //とりあえず距離のみで横移動のみ実装
      private void checkMuneYori(Maid maid, MaidState maidState)
      {
        //メイドが破棄された場合は処理しない
        if (maidState.maidMuneA == null) return;

        //無効化時は元に戻す
        if (!cfgw.muneYoriEnabled) {
          //無効化済み
          if (maidState.muneParam == null) return;

          maidState.muneValue = new MuneValue(maid);
          resetMuneYori(maid, maidState);

          //胸設定を削除して次から無効化
          maidState.muneParam = null;
          return;
        }

        //スケールが変わっていたら判定用座標を再設定
        if (maid.body0.transform.localScale.x != maidState.muneParam.scale) {
          maidState.muneParam = new MuneParam(cfgw, maid);
        }

        MuneParam muneParam = maidState.muneParam;

        //胸と腕の相対位置取得 左右:z 上下:x 前後:y  ※ メイド読み込み時にjbMuneL.transformを取得しても見えない場合がある
        Vector3 directionL, directionR;
        Quaternion muneInverse = Quaternion.Inverse(maidState.maidMuneA.rotation);
        #if COM3D2_5
        if (maid.IsCrcBody) {
          directionL = muneInverse * (maid.body0.dbMuneL.transform.position - maid.body0.UpperArmL.position - maid.body0.UpperArmL.rotation * muneParam.armOffsetL);
          directionR = muneInverse * (maid.body0.dbMuneR.transform.position - maid.body0.UpperArmR.position - maid.body0.UpperArmR.rotation * muneParam.armOffsetR);
        } else
        #endif
        {
          directionL = muneInverse * (maid.body0.jbMuneL.transform.position - maid.body0.UpperArmL.position - maid.body0.UpperArmL.rotation * muneParam.armOffsetL);
          directionR = muneInverse * (maid.body0.jbMuneR.transform.position - maid.body0.UpperArmR.position - maid.body0.UpperArmR.rotation * muneParam.armOffsetR);
        }
        //紛らわしいので軸と向きを修正 上後右→外前上
        directionL.Set(-directionL.z, directionL.x, -directionL.y); //左胸は左右反転して外向きに
        directionR.Set(directionR.z, directionR.x, -directionR.y);

        //胸の角度に応じて上腕原点座標を逆に回転させる
        directionL = muneParam.invRotY * directionL;
        directionR = muneParam.invRotY * directionR;
        //if (cfgw.muneDrawGizmo) { Debug.Log("L ("+directionL.x+", "+directionL.y+", "+directionL.z+")"); Debug.Log("R ("+directionR.x+", "+directionR.y+", "+directionR.z+")"); } //DEBUG

        //左胸 回転前の座標で範囲チェック 範囲外ならsetMuneYoriからfalseが返ってくる
        MuneOffset muneOffset = maidState.muneOffsetL;
        if (setMuneYori(muneOffset, muneParam, directionL)) {
          float muneDeltaTime = Math.Min(0.02f, Time.deltaTime); //50fps制限 fpsが低いと移動量が大きすぎて揺れが収束せずに暴れる
          //反復収束移動
          float preSpeedX = muneOffset.speedX;
          float preSpeedY = muneOffset.speedY;
          //秒速
          muneOffset.speedX = preSpeedX - (preSpeedX+(muneOffset.x-muneOffset.targetX) * muneParam.moveSpeedAmp) * muneParam.moveSpeedTime * muneDeltaTime;
          muneOffset.speedY = preSpeedY - (preSpeedY+(muneOffset.y-muneOffset.targetY) * muneParam.moveSpeedAmp) * muneParam.moveSpeedTime * muneDeltaTime;
          //ほぼ動かないなら変形処理はスキップ
          if (Math.Abs(muneOffset.speedX) > 0.001f || Math.Abs(muneOffset.speedY) > 0.001f) {
            //胸オフセット移動
            muneOffset.x += muneOffset.speedX * muneDeltaTime;
            muneOffset.y += muneOffset.speedY * muneDeltaTime;
            //胸変形
            osawari.muneMorphLeft(maid, maidState, 0f, 0f);
          }
        } else {
          //範囲外の戻し処理
          if (muneOffset.x != 0 || muneOffset.y != 0 || muneOffset.speedX != 0 || muneOffset.speedY != 0) {
            setMuneReturn(maid, maidState, muneParam, muneOffset);
            osawari.muneMorphLeft(maid, maidState, 0f, 0f);
          }
        }

        //右胸 回転前の座標で範囲チェック 範囲外ならsetMuneYoriからfalseが返ってくる
        muneOffset = maidState.muneOffsetR;
        if (setMuneYori(muneOffset, muneParam, directionR)) {
          float muneDeltaTime = Math.Min(0.02f, Time.deltaTime); //50fps制限 fpsが低いと移動量が大きすぎて揺れが収束せずに暴れる
          //反復収束移動
          float preSpeedX = muneOffset.speedX;
          float preSpeedY = muneOffset.speedY;
          //秒速
          muneOffset.speedX = preSpeedX - (preSpeedX+(muneOffset.x-muneOffset.targetX) * muneParam.moveSpeedAmp) * muneParam.moveSpeedTime * muneDeltaTime;
          muneOffset.speedY = preSpeedY - (preSpeedY+(muneOffset.y-muneOffset.targetY) * muneParam.moveSpeedAmp) * muneParam.moveSpeedTime * muneDeltaTime;
          //ほぼ動かないなら変形処理はスキップ
          if (Math.Abs(muneOffset.speedX) > 0.001f || Math.Abs(muneOffset.speedY) > 0.001f) {
            //胸オフセット移動
            muneOffset.x += muneOffset.speedX * muneDeltaTime;
            muneOffset.y += muneOffset.speedY * muneDeltaTime;
            //胸変形
            osawari.muneMorphRight(maid, maidState, 0f, 0f);
          }

        } else {
          //範囲外の戻し処理
          if (muneOffset.x != 0 || muneOffset.y != 0 || muneOffset.speedX != 0 || muneOffset.speedY != 0) {
            setMuneReturn(maid, maidState, muneParam, muneOffset);
            osawari.muneMorphRight(maid, maidState, 0f, 0f);
          }
        }
      }

      //胸寄りの移動量を初期化
      private void resetMuneYori(Maid maid, MaidState maidState)
      {
        //オフセットとスピードを0に
        maidState.muneOffsetL.reset();
        maidState.muneOffsetR.reset();
        //胸変形を0に戻す
        osawari.muneMorphLeft(maid, maidState, 0f, 0f);
        osawari.muneMorphRight(maid, maidState, 0f, 0f);
      }
      //胸の衝突範囲外 胸の移動量を戻す
      private void setMuneReturn(Maid maid, MaidState maidState, MuneParam muneParam, MuneOffset muneOffset)
      {
          float muneDeltaTime = Math.Min(0.02f, Time.deltaTime); //50fps制限 fpsが低いと移動量が大きすぎて揺れが収束せずに暴れる
          float preSpeedX = muneOffset.speedX;
          float preSpeedY = muneOffset.speedY;
          muneOffset.speedX = preSpeedX - (preSpeedX+muneOffset.x * muneParam.moveSpeedAmp) * muneParam.moveSpeedTime * muneDeltaTime;
          muneOffset.speedY = preSpeedY - (preSpeedY+muneOffset.y * muneParam.moveSpeedAmp) * muneParam.moveSpeedTime * muneDeltaTime;
          muneOffset.x += muneOffset.speedX * muneDeltaTime;
          muneOffset.y += muneOffset.speedY * muneDeltaTime;
          if (muneOffset.x < 0.01f && Math.Abs(muneOffset.speedX) < 0.01f) {
            muneOffset.x = 0;
            muneOffset.speedX = 0;
            maidState.muneValue = new MuneValue(maid);
          }
          if (muneOffset.y < 0.01f && Math.Abs(muneOffset.speedY) < 0.01f) {
            muneOffset.y = 0;
            muneOffset.speedY = 0;
            maidState.muneValue = new MuneValue(maid);
          }
      }

      //胸の衝突範囲内 胸寄りを計算して変形処理を実行 2.5はdbMuneを引数に追加
      //腕が範囲内ならtrueを返す
      private bool setMuneYori(MuneOffset muneOffset, MuneParam muneParam, Vector3 d)
      {
        //乳寄せの判定
        if (d.x > muneParam.outside || d.y > muneParam.top || d.y < muneParam.bottom || d.z > muneParam.front || d.z < muneParam.back) {
          //範囲外
          muneOffset.targetX = 0;
        } else {
          //範囲内
          float dx = Math.Max(0f, Math.Min(1f, (d.x - muneParam.centerX) *  muneParam.normarizeX)); //0-1 内側は0
          float dy;
          float dz = 0;
          if (d.y > muneParam.centerY) {
            dy = (d.y - muneParam.centerY) * muneParam.normarizeYT; //前 上側
            if (d.z > muneParam.centerFrontZ) {
              dz = Math.Min(1f, (d.z - muneParam.centerFrontZ) * muneParam.normarizeZF); //前
              dy = dy * (1f + dz * 0.7f); //前側のyを70%高くする
            } else if (d.z < muneParam.centerBackZ) {
              if (d.z < muneParam.centerBackZ) Math.Min(1f, dz = (muneParam.centerBackZ - d.z) * muneParam.normarizeZB); //後
            }
          } else {
            dy = Math.Min(1f, (muneParam.centerY - d.y) * muneParam.normarizeYB); //下
            if (d.z > muneParam.centerFrontZ) {
              dz = Math.Min(1f, (d.z - muneParam.centerFrontZ) * muneParam.normarizeZF); //前
            } else if (d.z < muneParam.centerBackZ) {
              dz = Math.Min(1f, (muneParam.centerBackZ - d.z) * muneParam.normarizeZB); //後
            }
          }
          muneOffset.targetX = 1f - Math.Min(1f, (float)(Math.Sqrt(dx*dx + dy*dy + dz*dz))); //中心からの距離で 1～0
          //if (cfgw.muneDrawGizmo) Debug.Log("dx="+dx+" dy="+dy+" dz="+dz);
        }

        //乳下げの判定 中心はdownCenterX downCenterY downCenterZを利用
        if (d.x > muneParam.downOutside || d.x < muneParam.downInside || d.y > muneParam.downTop || d.y < muneParam.downBottom || d.z > muneParam.downFront || d.z < muneParam.downBack) {
          //範囲外
          muneOffset.targetY = 0;
        } else {
          //XとZは範囲内
          float dx = (d.x - muneParam.downCenterX) *  muneParam.normarizeDX; //0-1
          float dy;
          float dz;
          if (d.y > muneParam.downCenterY) dy = ((d.y - muneParam.downCenterY) * muneParam.normarizeDYT); //上
          else dy = (muneParam.downCenterY - d.y) * muneParam.normarizeDYB; //下
          dz = (d.z - muneParam.downCenterZ) * muneParam.normarizeDZ; //前後
          muneOffset.targetY = 1f - Math.Min(1f, (float)(Math.Sqrt(dx*dx + dy*dy + dz*dz))); //中心からの距離で1～0 中心が1
        }

        //範囲外なのでfalseを返して戻し処理を行う
        if (muneOffset.targetX == 0 && muneOffset.targetY == 0) return false;
        return true;
      }


      //胸衝突判定 コライダー (VRコントローラー、前腕、ポール)----------------------

      /// <summary>
      /// Updateで利用 メイドごとに保存
      /// </summary>
      public class MuneColliderInfo
      {
        //TBodyから取得
        public Transform m_trsMuneL;
        public Transform m_trsMuneLsub;
        public Transform m_trsMuneR;
        public Transform m_trsMuneRsub;

        //コライダーセット時に作成される
        public Transform m_trHitParentL;
        public Transform m_trHitChildL;
        public Transform m_trHitParentR;
        public Transform m_trHitChildR;

        //前腕コライダーを動かす用
        public Transform foreArmL;
        public Transform foreArmR;

        //胸のコライダーを設定するオブジェクト
        public SphereCollider muneColliderL;
        public SphereCollider muneColliderR;
        //前腕のコライダーを設定するオブジェクト
        public CapsuleCollider foreArmColliderL;
        public CapsuleCollider foreArmColliderR;
        public Vector3 foreArmPosL;
        public Quaternion foreArmRotL;
        public Vector3 foreArmSclL;
        public Vector3 foreArmPosR;
        public Quaternion foreArmRotR;
        public Vector3 foreArmSclR;


        //前側の移動制限 胸サイズで調整 通常時の位置+1mm程度 CRCボディは値が違う
        const float FTONR_LIMIT = -0.087f;
        const float FTONR_LIMIT_CRC = -0.106f;
        private float frontLimit = FTONR_LIMIT;

        //全方向の最大移動量 動きすぎるので胸サイズでは広げない
        private float hitLimit = 0.01f + (0.04f - 0.01f) * 0.5f/1.3f;

        public MuneColliderInfo(Maid maid, VibeYourMaidCfgWriting cfgw)
        {
          //TBodyにあるものと同じ privateなのでm_trBonesから取得
          if (maid.body0.m_trBones) {
            m_trsMuneL = CMT.SearchObjName(maid.body0.m_trBones, "Mune_L", true);
            m_trsMuneLsub = CMT.SearchObjName(maid.body0.m_trBones, "Mune_L_sub", true);
            m_trsMuneR = CMT.SearchObjName(maid.body0.m_trBones, "Mune_R", true);
            m_trsMuneRsub = CMT.SearchObjName(maid.body0.m_trBones, "Mune_R_sub", true);
          }

          //設定ファイルに合わせて調整
          updateParam(maid, cfgw);
        }

        public void updateParam(Maid maid, VibeYourMaidCfgWriting cfgw)
        {
          //移動制限
          float distanceMin = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneHitLimitDistanceMin", cfgw.muneHitLimitDistanceMin);
          float distanceMax = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneHitLimitDistanceMax", cfgw.muneHitLimitDistanceMax);
          hitLimit = distanceMin + (distanceMax - distanceMin) * (float)maid.GetProp(MPN.MuneL).value / 130f;
          //前側の移動制限
          if (maid.IsCrcBody) frontLimit = FTONR_LIMIT_CRC;
          //オフセットさせる
          frontLimit -= ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneColliderFrontLimit", cfgw.muneColliderFrontLimit);
        }

        //メイドごとの胸変形処理 手前や外側への移動は制限したい
        public void Update(Maid maid)
        {
          //親子付けするとエラーになるので自力で動かす
          float bodyScale = maid.body0.transform.localScale.x;
          Vector3 localScale = foreArmSclL * bodyScale;
          if (foreArmColliderL && foreArmL) { //ボディ切り替え時はforeArmLがnullになるため両方チェック
            foreArmColliderL.transform.rotation = foreArmL.rotation * foreArmRotL;
            foreArmColliderL.transform.position = foreArmL.position + foreArmL.rotation * foreArmPosL * bodyScale; //オフセットは回転と拡大縮小してから加算
            foreArmColliderL.transform.localScale  = localScale;
          }
          if (foreArmColliderR && foreArmR) { //ボディ切り替え時はforeArmRがnullになるため両方チェック
            foreArmColliderR.transform.rotation = foreArmR.rotation * foreArmRotR;
            foreArmColliderR.transform.position = foreArmR.position + foreArmR.rotation * foreArmPosR * bodyScale; //オフセットは回転と拡大縮小してから加算
            foreArmColliderR.transform.localScale  = localScale;
          }

          if (m_trsMuneLsub != null && m_trHitChildL != null) {
            Vector3 vector2 = m_trsMuneL.InverseTransformPoint(m_trHitChildL.position);
            //移動制限
            //Debug.Log("vector2=("+vector2.x+","+vector2.y+","+vector2.z+")");
            if (vector2.x < frontLimit) vector2.x = frontLimit;

            if ((vector2 - m_trHitParentL.localPosition).magnitude < hitLimit) {
              m_trsMuneLsub.localPosition = vector2;
            } else {
              m_trsMuneLsub.localPosition = m_trHitParentL.localPosition + (vector2 - m_trHitParentL.localPosition).normalized * hitLimit;
              m_trHitChildL.position = m_trsMuneLsub.position;
            }
          }
          if (m_trsMuneRsub != null && m_trHitChildR != null) {
            Vector3 vector2 = m_trsMuneR.InverseTransformPoint(m_trHitChildR.position);
            //移動制限
            if (vector2.x < frontLimit) vector2.x = frontLimit;
            
            if ((vector2 - m_trHitParentR.localPosition).magnitude < hitLimit) {
              m_trsMuneRsub.localPosition = vector2;
            } else {
              m_trsMuneRsub.localPosition = m_trHitParentR.localPosition + (vector2 - m_trHitParentR.localPosition).normalized * hitLimit;
              m_trHitChildR.position = m_trsMuneRsub.position;
            }
          }
        }

        //メイドに設定された胸コライダーと前腕のコライダーオブジェクトを破棄する
        public void destroyMuneCollider()
        {
          //再設定時にずれないように位置を戻す
          if (m_trsMuneLsub && m_trHitParentL) m_trsMuneLsub.localPosition = m_trHitParentL.localPosition;
          if (m_trsMuneRsub && m_trHitParentR) m_trsMuneRsub.localPosition = m_trHitParentR.localPosition;

          m_trsMuneL = null;
          m_trsMuneLsub = null;
          m_trsMuneR = null;
          m_trsMuneRsub = null;

          if (muneColliderL) GameObject.Destroy(muneColliderL);
          if (muneColliderR) GameObject.Destroy(muneColliderR);

          if (foreArmColliderL) {
            GameObject obj = foreArmColliderL.gameObject;
            GameObject.Destroy(foreArmColliderL);
            GameObject.Destroy(obj);
          }
          if (foreArmColliderR) {
            GameObject obj = foreArmColliderR.gameObject;
            GameObject.Destroy(foreArmColliderR);
            GameObject.Destroy(obj);
          }
          if (m_trHitParentL) GameObject.Destroy(m_trHitParentL.gameObject);
          if (m_trHitChildL) GameObject.Destroy(m_trHitChildL.gameObject);
          if (m_trHitParentR) GameObject.Destroy(m_trHitParentR.gameObject);
          if (m_trHitChildR) GameObject.Destroy(m_trHitChildR.gameObject);
        }
      }

      /// <summary>
      /// メイドに胸のコライダーを追加するクラス
      /// </summary>
      public class MuneCollider
      {
        public const int LAYER_NO = 27; //胸と衝突するコライダーのオブジェクトのレイヤ番号

        public SphereCollider camCollider; //カメラ位置の球コライダー

        //竿のコライダー シーンロード時に破棄する 男はシーン内で0～6で固定 init時のupdateChinkoPosで配列が足りない場合は拡大される
        public CapsuleCollider[] chinkoCollider = new CapsuleCollider[10];

        //ポールダンスのポール位置に追加したオブジェクト
        GameObject[] poleColliderObj = new GameObject[3];

        public VibeYourMaidCfgWriting cfgw;

        //ダンス前に無効化していたらダンス終了後に戻す
        public bool muneHitChinkoEnabledBak = false;
        public bool muneTouchColliderEnabledBak = false;
        public bool camColliderEnabledBak = false;

        public MuneCollider(VibeYourMaidCfgWriting cfgw)
        {
          this.cfgw = cfgw;
        }

        //TBodyに設定されている胸とコントローラのコライダーを無効化する 髪やスカートは別制御なので影響ない
        public void disableTBodyMuneCollider(Maid maid, MuneColliderInfo colInfo)
        {
          //TBodyのUpdateを無効化する m_trsMuneLsub側はnullにしない
          FieldInfo fieldInfo;
          fieldInfo = typeof(TBody).GetField("m_trHitChildL", BindingFlags.Instance | BindingFlags.NonPublic);
          fieldInfo.SetValue(maid.body0, null);
          fieldInfo = typeof(TBody).GetField("m_trHitChildR", BindingFlags.Instance | BindingFlags.NonPublic);
          fieldInfo.SetValue(maid.body0, null);

          //追加済みのobjectとコライダーを無効化
          Transform t = colInfo.m_trsMuneL.Find("SphereParent(Clone)");
          if (t) {
            SphereCollider sphereCollider = t.gameObject.GetComponent<SphereCollider>();
            if (sphereCollider) sphereCollider.enabled = false;
            //t.gameObject.SetActive(false);
            DestroyImmediate(t.gameObject);
          }
          t = colInfo.m_trsMuneL.Find("SphereChild(Clone)");
          if (t) {
            SphereCollider sphereCollider = t.gameObject.GetComponent<SphereCollider>();
            if (sphereCollider) sphereCollider.enabled = false;
            DestroyImmediate(t.gameObject);
          }
          t = colInfo.m_trsMuneL.Find("SphereParent(Clone)");
          if (t) {
            SphereCollider sphereCollider = t.gameObject.GetComponent<SphereCollider>();
            if (sphereCollider) sphereCollider.enabled = false;
            DestroyImmediate(t.gameObject);
          }
          t = colInfo.m_trsMuneL.Find("SphereChild(Clone)");
          if (t) {
            SphereCollider sphereCollider = t.gameObject.GetComponent<SphereCollider>();
            if (sphereCollider) sphereCollider.enabled = false;
            DestroyImmediate(t.gameObject);
          }
        }

        //初期化 mmaidState.muneColliderInfo がない場合のみ実行
        public MuneColliderInfo initMuneCollider(Maid maid, MaidState maidState)
        {
          if (!maid.body0.m_trBones) return null;
          
          //Updateで利用する胸の位置をセットする
          MuneColliderInfo colInfo = new MuneColliderInfo(maid, cfgw);

          //コライダーの位置が胸の変形でずれるので胸の変形を初期状態に戻す
          Vector3 muneScaleL;
          Vector3 muneScaleR;
          #if COM3D2_5
          if (maid.IsCrcBody) {
            muneScaleL = maid.body0.dbMuneL.transform.localScale;
            muneScaleR = maid.body0.dbMuneR.transform.localScale;
          } else 
          #endif
          {
            muneScaleL = maid.body0.jbMuneL.transform.localScale;
            muneScaleR = maid.body0.jbMuneR.transform.localScale;
          }
          resetMuneValue(maid);

          //VR用のTBodyに元々あるコライダーは破棄
          if (GameMain.Instance.VRMode) {
            //TBodyのコライダーとUpdateを無効化
            disableTBodyMuneCollider(maid, colInfo);
          }

          //TbodyのLoadBody_Rの生成と同じ
          colInfo.m_trHitParentL = (UnityEngine.Object.Instantiate(Resources.Load("OVR/SphereParent")) as GameObject).transform;
          colInfo.m_trHitChildL = (UnityEngine.Object.Instantiate(Resources.Load("OVR/SphereChild")) as GameObject).transform;
          colInfo.m_trHitParentR = (UnityEngine.Object.Instantiate(Resources.Load("OVR/SphereParent")) as GameObject).transform;
          colInfo.m_trHitChildR = (UnityEngine.Object.Instantiate(Resources.Load("OVR/SphereChild")) as GameObject).transform;

          //メイドが動いていてコライダーのcenterがspine1aの向きになっていないので回す必要がある
          //立ちポーズの時のspine1aが正面で(0,270,277→(0,0,0)) 後ろ(0,90,277)→（0,180,0）仰向けで(360,270,7)→(270,0,0)になるように調整
          Quaternion rot = Quaternion.Euler(277-maidState.maidMuneA.eulerAngles.z, maidState.maidMuneA.eulerAngles.y-270, maidState.maidMuneA.eulerAngles.x);

          //ポーズで胸が移動しているとずれるので回転
          colInfo.m_trHitParentL.rotation = rot;
          colInfo.m_trHitChildL.rotation = rot;
          SpringJoint springJoint = colInfo.m_trHitChildL.GetComponent<SpringJoint>();
          springJoint.connectedBody = colInfo.m_trHitParentL.GetComponent<Rigidbody>();
          updateSpringJointParam(springJoint);
          colInfo.m_trHitParentL.parent = colInfo.m_trsMuneL;
          colInfo.m_trHitChildL.parent = colInfo.m_trsMuneL;
          colInfo.m_trHitParentL.localPosition = colInfo.m_trsMuneLsub.localPosition;
          colInfo.m_trHitChildL.localPosition = colInfo.m_trsMuneLsub.localPosition;

          colInfo.m_trHitParentR.rotation = rot;
          colInfo.m_trHitChildR.rotation = rot;
          springJoint = colInfo.m_trHitChildR.GetComponent<SpringJoint>();
          springJoint.connectedBody = colInfo.m_trHitParentR.GetComponent<Rigidbody>();
          updateSpringJointParam(springJoint);
          colInfo.m_trHitParentR.parent = colInfo.m_trsMuneR;
          colInfo.m_trHitChildR.parent = colInfo.m_trsMuneR;
          colInfo.m_trHitParentR.localPosition = colInfo.m_trsMuneRsub.localPosition;
          colInfo.m_trHitChildR.localPosition = colInfo.m_trsMuneRsub.localPosition;

          //1に戻したスケールを復元
          restoreMuneValue(maid, muneScaleL, muneScaleR);

          //SphereColliderの位置を調整
          colInfo.muneColliderL = adjustMuneCollider(maid, colInfo.m_trHitChildL, null, true);
          colInfo.muneColliderR = adjustMuneCollider(maid, colInfo.m_trHitChildR, null, false);

          //上腕にコライダー追加 IKはつかむとずれるので使わない privateなのでm_Bonesから取得  腕の中心(_IK_ForeArmL/R)とのずれ 0.09420826
          colInfo.foreArmL = CMT.SearchObjName(maid.body0.m_Bones.transform, "Bip01 L Forearm", true);
          colInfo.foreArmR = CMT.SearchObjName(maid.body0.m_Bones.transform, "Bip01 R Forearm", true);

          if (colInfo.foreArmL) {
            colInfo.foreArmColliderL = addForearmCollider(maid, colInfo.foreArmL, true);
            colInfo.foreArmPosL = colInfo.foreArmColliderL.transform.localPosition;
            colInfo.foreArmRotL = colInfo.foreArmColliderL.transform.localRotation;
            colInfo.foreArmSclL = colInfo.foreArmColliderL.transform.localScale;
          }
          if (colInfo.foreArmR) {
            colInfo.foreArmColliderR = addForearmCollider(maid, colInfo.foreArmR, false);
            colInfo.foreArmPosR = colInfo.foreArmColliderR.transform.localPosition;
            colInfo.foreArmRotR = colInfo.foreArmColliderR.transform.localRotation;
            colInfo.foreArmSclR = colInfo.foreArmColliderR.transform.localScale;
          }

          return colInfo;
        }

        //コライダーの位置が胸の変形でずれるので胸の変形を初期状態に戻す （MuneYori MuneUpDownは親の胸が回転するので反映されている）
        public void resetMuneValue(Maid maid)
        {
          #if COM3D2_5
          if (maid.IsCrcBody) {
              maid.body0.dbMuneL.PhysicsReset();
              maid.body0.dbMuneR.PhysicsReset();
          } else 
          #endif
          {
            FieldInfo defQtnFieldInfo = typeof(jiggleBone).GetField("defQtn", BindingFlags.Instance | BindingFlags.NonPublic);
            maid.body0.jbMuneL.transform.localRotation = (Quaternion)defQtnFieldInfo.GetValue(maid.body0.jbMuneL);
            maid.body0.jbMuneL.transform.localScale = Vector3.one;
            maid.body0.jbMuneR.transform.localRotation = (Quaternion)defQtnFieldInfo.GetValue(maid.body0.jbMuneR);
            maid.body0.jbMuneR.transform.localScale = Vector3.one;
          }
        }
        //初期化した胸のスケールを戻す
        public void restoreMuneValue(Maid maid, Vector3 muneScaleL, Vector3 muneScaleR)
        {
          #if COM3D2_5
          if (maid.IsCrcBody) {
              maid.body0.dbMuneL.transform.localScale = muneScaleL;
              maid.body0.dbMuneR.transform.localScale = muneScaleR;
          } else 
          #endif
          {
            maid.body0.jbMuneL.transform.localScale = muneScaleL;
            maid.body0.jbMuneR.transform.localScale = muneScaleR;
          }
        }

        //設定ファイル読み込み後の位置等の調整 → コライダーの原点は生成時から移動できない
        public void updateMuneColliderParam(List<MaidState> maidsState, VibeYourMaidCfgWriting cfgw, Maid[] SubMans, SphereCollider[] touchCollider)
        {
          //設定置き換え
          this.cfgw = cfgw;

          foreach (MaidState maidState in maidsState) {
            Maid maid = maidState.maid;
            MuneColliderInfo colInfo = maidState.muneColliderInfo;
            if (colInfo == null) continue;

            colInfo.updateParam(maid, cfgw);

            adjustMuneCollider(maid, colInfo.m_trHitChildL, colInfo.muneColliderL, true);
            adjustMuneCollider(maid, colInfo.m_trHitChildR, colInfo.muneColliderR, false);

            //SpringJoint設定更新
            updateSpringJointParam(colInfo.m_trHitChildL.GetComponent<SpringJoint>());
            updateSpringJointParam(colInfo.m_trHitChildR.GetComponent<SpringJoint>());

            //前腕コライダー有効状態
            setForearmEnabled(colInfo, cfgw.muneColliderEnabled);
            //前腕コライダー更新
            if (colInfo.foreArmColliderL) setForeArmPos(maid, colInfo.foreArmColliderL.gameObject, colInfo.foreArmColliderL, true);
            if (colInfo.foreArmColliderR) setForeArmPos(maid, colInfo.foreArmColliderR.gameObject, colInfo.foreArmColliderR, false);

          }

          //竿の位置調整 enabled関係なくすべて位置調整
          updateChinkoPos();

          //VRの手のコライダーサイズ調整
          updateTouchCollider(touchCollider);

          //カメラ位置のコライダー設定
          setCamColliderEnabled(cfgw.camColliderEnabled);

          //ポール更新
          addPoleDanceCollider();
        }

        private SphereCollider adjustMuneCollider(Maid maid, Transform hitChild, SphereCollider sphereCollider, bool bLeft)
        {
          //SphereParent(Clone) のlocalScaleは 0.15 程度になっている  ボディのlocalScaleに対応
          float normalize = 1f / hitChild.localScale.x * maid.body0.transform.localScale.x;

          //半径増加分
          float radiusExpand = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneColliderRadiusExpand", cfgw.muneColliderRadiusExpand) * normalize;

          float offsetX;
          float offsetY;
          float offsetZ;
          if (maid.IsCrcBody) {
            offsetX = cfgw.muneColliderOffsetCrcX;
            offsetY = cfgw.muneColliderOffsetCrcY;
            offsetZ = cfgw.muneColliderOffsetCrcZ;
          } else {
            offsetX = cfgw.muneColliderOffsetX;
            offsetY = cfgw.muneColliderOffsetY;
            offsetZ = cfgw.muneColliderOffsetZ;
          }
          offsetX = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneColliderOffsetX", offsetX) * normalize;
          offsetY = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneColliderOffsetY", offsetY) * normalize;
          offsetZ = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneColliderOffsetZ", offsetZ) * normalize;

          //BlendValueはMuneLの値 0～1
          //float num = maid.body0.jbMuneL.BlendValue / 1.3f;
          float muneSize = (float)maid.GetProp(MPN.MuneL).value;
          float num = muneSize / 130f;

          //TBodyのデフォルト値 m_fHitRadiusMin = 0.1f; m_fHitRadiusMax = 0.32f;
          float hitRadiusMin = maid.body0.m_fHitRadiusMin + radiusExpand;
          float hitRadiusMax = maid.body0.m_fHitRadiusMax + radiusExpand;

          float minRadius = hitRadiusMin;
          float radius = hitRadiusMin + (hitRadiusMax - hitRadiusMin) * num;
          //float z = maid.body0.m_fHitCenterZMin + (maid.body0.m_fHitCenterZMax - maid.body0.m_fHitCenterZMin) * num;

          //コライダーがnullなら取得
          if (sphereCollider == null) sphereCollider = hitChild.GetComponent<SphereCollider>();

          //胸の位置を初期化した状態で補正
          if (muneSize > 0) {
            offsetX += (radius-minRadius) * cfgw.muneColliderOffsetXRatio;
            //大きいと回転してさらに下に行くので下げすぎない
            offsetY -= (radius-minRadius) * cfgw.muneColliderOffsetYRatio * Math.Max(0f, (1f-((muneSize-50f)/80f))); //0->1.625 50->1 130以上->0
            offsetZ += (radius-minRadius) * cfgw.muneColliderOffsetZRatio;
          }

          if (bLeft) offsetX = -offsetX;
          //centerはコライダーの親Objectの回転方向に移動する
          sphereCollider.center = new Vector3(offsetX, offsetY, offsetZ);
          sphereCollider.radius = radius;

          return sphereCollider;
        }

        //SpringJointのばね設定を更新
        private void updateSpringJointParam(SpringJoint springJoint)
        {
          springJoint.spring = cfgw.muneColliderSpring;
          springJoint.damper = cfgw.muneColliderDamper;
          springJoint.minDistance = cfgw.muneColliderMinDistance;
          springJoint.maxDistance = cfgw.muneColliderMaxDistance;
          springJoint.tolerance = cfgw.muneColliderTolerance;
        }

        //前腕のコライダーを追加
        private CapsuleCollider addForearmCollider(Maid maid, Transform trArm, bool bLeft)
        {
          if (trArm == null) return null;

          //Debug.Log(GetHierarchyPath(trArm) + " (lScl="+trArm.localScale+" lPos="+trArm.localPosition+" Ang="+trArm.eulerAngles+" lAng="+trArm.localEulerAngles+")");
          GameObject gameObject = GameObject.CreatePrimitive(PrimitiveType.Capsule);
          gameObject.GetComponent<Renderer>().enabled = false; //非表示
          gameObject.name = "ForeArmCollider_" + trArm.name + "_" + maid.ActiveSlotNo;
          gameObject.layer = LAYER_NO;
          //gameObject.transform.SetParent(trArm, false); //スタジオのポーズ設定中の解除でエラーになる
          return setForeArmPos(maid, gameObject, null, bLeft);
        }
        //前腕のコライダーサイズを調整
        private CapsuleCollider setForeArmPos(Maid maid, GameObject gameObject, CapsuleCollider capsuleCollider, bool bLeft)
        {
          int sintyo = Math.Max(-10, maid.GetProp(MPN.sintyou).value);
          int UdeScl = maid.GetProp(MPN.UdeScl).value;
          float mpnLength = (sintyo-60) * 0.0002f + (UdeScl-60) * 0.00015f;
          float mpnOffsetY = (sintyo-50) * 0.000133f + (UdeScl-50) * 0.0001f;
          
          float localScale = 1f;//maid.body0.transform.localScale.x;
          float radius = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneHitForearmRadius", cfgw.muneHitForearmRadius) * localScale;
          float length = (ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneHitForearmLength", cfgw.muneHitForearmLength) + mpnLength) * localScale;
          float offsetX = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneHitForearmOffsetX", cfgw.muneHitForearmOffsetX) * localScale;
          float offsetY = -(0.09f + ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneHitForearmOffsetY", cfgw.muneHitForearmOffsetY) + mpnOffsetY) * localScale;
          float offsetZ = -ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneHitForearmOffsetZ", cfgw.muneHitForearmOffsetZ) * localScale;
          if (bLeft) offsetZ = -offsetZ;
          float angleX = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneHitForearmAngleX", cfgw.muneHitForearmAngleX);
          float angleZ = ExSaveData.GetFloat(maid, "CM3D2.VibeYourMaid.Plugin", "muneHitForearmAngleZ", cfgw.muneHitForearmAngleZ);
          
          gameObject.transform.localPosition = new Vector3(offsetY, offsetX, offsetZ); //x-が指先側 前腕の中心を基準にするためxを-0.09 軸はXYが逆
          gameObject.transform.localScale = new Vector3(radius*2, length*0.5f, radius*2); //コライダーもなぜかこのサイズになる
          gameObject.transform.localRotation = Quaternion.Euler(0, angleZ, 90f+angleX); //軸は回転済 Y軸は回転不要
          //コライダーがなければ追加
          if (capsuleCollider == null) capsuleCollider = gameObject.AddComponent<CapsuleCollider>();
          capsuleCollider.height = length; //オブジェクトのサイズから変わらないが範囲描画用に設定
          capsuleCollider.radius = radius;
          capsuleCollider.enabled = true;
          return capsuleCollider;
        }
        //前腕のコライダーの有効無効のみ変更
        public void setForearmEnabled(MuneColliderInfo colInfo, bool enabled)
        {
          if (colInfo != null) {
            if (colInfo.foreArmColliderL) {
              colInfo.foreArmColliderL.gameObject.SetActive(enabled);
              colInfo.foreArmColliderL.enabled = enabled;
            }
            if (colInfo.foreArmColliderR) {
              colInfo.foreArmColliderR.gameObject.SetActive(enabled);
              colInfo.foreArmColliderR.enabled = enabled;
            }
          }
        }

        //すべての男の竿をチェックしてコライダーを設定 Updateから定期的に実行される 最大7人？
        public void checkChinkoColliderAll()
        {
          int manCnt = GameMain.Instance.CharacterMgr.GetStockManCount();
          for (int i = 0; i < manCnt; i++) {
            Maid man = GameMain.Instance.CharacterMgr.GetStockMan(i);
            #if COM3D2_5
            if (man.HasNewRealMan && man.pairMan.Visible) man = man.pairMan;
            #endif
            CapsuleCollider collider = this.chinkoCollider[i];
            if (man.Visible) {
              //コライダー有効化 なければ追加
              if (collider == null) {
                collider = addChinkoCollider(man, i);
                if (collider == null) continue; //追加できなかったらスキップ
                this.chinkoCollider[i] = collider;
              }
              //竿が表示されていなければ無効化
              if (cfgw.muneHitChinkoCheckVisible) collider.enabled = getChinkoVisible(man);
              else collider.enabled = true;
              collider.gameObject.SetActive(collider.enabled);
            } else {
              //コライダー無効化
              if (collider != null) {
                collider.enabled = false;
                collider.gameObject.SetActive(false);
              }
            }
          }
        }
        //竿コライダー生成
        private CapsuleCollider addChinkoCollider(Maid man, int idx)
        {
          if (!man || !man.body0 || !man.body0.m_Bones) return null;

          Transform trChinko = man.body0.trManChinko.Find("chinko1");
          if (trChinko) {
            GameObject gameObject = GameObject.CreatePrimitive(PrimitiveType.Capsule);
            gameObject.GetComponent<Renderer>().enabled = false; //非表示
            gameObject.name = "ChinkoCollider_" + trChinko.name+"_"+idx;
            gameObject.layer = LAYER_NO;
            gameObject.transform.SetParent(trChinko, false);

            return setChinkoPos(man, gameObject, null);
          }
          return null;
        }
        //竿の表示状態を取得 man.body0.GetChinkoVisible(Maid) と同等 ※取得できなかったらfalse
        private bool getChinkoVisible(Maid man)
        {
          #if COM3D2_5
          if (man.body0.IsCrcBody) {
            return man.body0.trManChinko.localScale.x != 0;
          }
          #endif
          GameObject obj = man.body0.goSlot[(int)TBody.SlotID.body].obj;
          if (obj != null) {
            Transform trChinko = CMT.SearchObjName(obj.transform, "chinkoCenter", false);
            if (trChinko) return trChinko.localScale.x != 0;
          }
          return false;
        }
        //すべての竿コライダーを有効・無効化
        public void setChinkoColliderEnabledAll(bool enabled)
        {
          foreach (CapsuleCollider collider in this.chinkoCollider) {
            if (collider != null) { //男が破棄されていればnull
              collider.enabled = enabled;
              collider.gameObject.SetActive(enabled);
            }
          }
        }
        //竿コライダーを破棄 シーンロード時と胸コライダー無効化時に実行
        public void destroyChinkoColliderAll()
        {
          for (int i=0; i<this.chinkoCollider.Length; i++) {
            CapsuleCollider collider = this.chinkoCollider[i];
            if (collider != null) { //男が破棄されていればnull
              Destroy(collider.gameObject);
              this.chinkoCollider[i] = null;
            }
          }
        }
        //男全員の追加済みの竿コライダーの位置を調整
        public void updateChinkoPos()
        {
          int manCnt = GameMain.Instance.CharacterMgr.GetStockManCount();
          //配列サイズを拡張
          if (manCnt > this.chinkoCollider.Length) Array.Resize(ref this.chinkoCollider, manCnt);
          for (int i = 0; i < manCnt; i++) {
            Maid man = GameMain.Instance.CharacterMgr.GetStockMan(i);
            #if COM3D2_5
            if (man.HasNewRealMan && man.pairMan.Visible) man = man.pairMan;
            #endif
            if (man.Visible) {
              CapsuleCollider collider = this.chinkoCollider[i];
              if (collider != null) {
                setChinkoPos(man, collider.gameObject, collider);
              }
            }
          }
        }
        //竿の位置を調整
        private CapsuleCollider setChinkoPos(Maid man, GameObject gameObject, CapsuleCollider capsuleCollider)
        {
          float localScale = man.body0.transform.localScale.x;
          float radius = cfgw.muneHitChinkoRadius * localScale;
          float length = cfgw.muneHitChinkoLength * localScale;
          float offsetX = cfgw.muneHitChinkoOffsetX * localScale;
          float offsetY = cfgw.muneHitChinkoOffsetY * localScale;
          
          gameObject.transform.localPosition = new Vector3(offsetX, offsetY, 0); //x-が指先側 前腕の中心を基準にするためxを-0.09 軸はXYが逆
          gameObject.transform.localScale = new Vector3(radius*2, length*0.5f, radius*2); //コライダーもなぜかこのサイズになる
          gameObject.transform.localRotation = Quaternion.Euler(0f, 0f, -cfgw.muneHitChinkoAngle); //Z軸のみ 上を+にする

          //コライダーがなければ追加
          if (capsuleCollider == null) capsuleCollider = gameObject.AddComponent<CapsuleCollider>();
          capsuleCollider.height = length;
          capsuleCollider.radius = radius;
          capsuleCollider.enabled = man.Visible; //表示されている場合のみ有効
          return capsuleCollider;
        }

        //VRコントローラーのコライダー有効状態とサイズ調整
        public void updateTouchCollider(SphereCollider[] touchCollider)
        {
          foreach (SphereCollider collider in touchCollider) {
            collider.enabled = cfgw.muneTouchColliderEnabled;
            collider.radius = cfgw.muneTouchColliderRadius / collider.transform.localScale.x;
          }
        }

        //カメラコライダー生成
        public void setCamColliderEnabled(bool enabled)
        {
          if (!enabled) {
            if (camCollider) camCollider.enabled = false;
            return;
          }

          if (camCollider) {
            camCollider.enabled = enabled;
            setCamPos(camCollider.gameObject, camCollider);
          } else {
            //なければ生成
            Transform trCam = GameMain.Instance.MainCamera.GetRealHeadTransform();
            GameObject gameObject = GameObject.CreatePrimitive(PrimitiveType.Sphere);
            gameObject.GetComponent<Renderer>().enabled = false; //非表示
            gameObject.name = "CamCollider";
            gameObject.layer = LAYER_NO;
            gameObject.transform.SetParent(trCam, false);
            camCollider = setCamPos(gameObject, null);
          }
        }
        //カメラの位置を調整
        private SphereCollider setCamPos(GameObject gameObject, SphereCollider ccollider)
        {
          gameObject.transform.localPosition = new Vector3(0, cfgw.camColliderOffsetY, cfgw.camColliderOffsetZ); //x-が指先側 前腕の中心を基準にするためxを-0.09 軸はXYが逆
          gameObject.transform.localScale = new Vector3(cfgw.camColliderRadius*2, cfgw.camColliderRadius*2, cfgw.camColliderRadius*2); //コライダーもなぜかこのサイズになる

          //コライダーがなければ追加
          if (ccollider == null) ccollider = gameObject.AddComponent<SphereCollider>();
          ccollider.radius = cfgw.camColliderRadius;
          return ccollider;
        }

        //ポールダンスの背景ならポールに胸用のコライダーを追加
        public void addPoleDanceCollider()
        {
          //太さ0以下は無効
          if (cfgw.muneHitPoleRadius <= 0) return;

          GameObject stage;
          if (GameMain.Instance.GetNowSceneName().StartsWith("SceneDance_")) {
            stage = GameObject.Find("LiveGimic/PoleDanceStage"); //ダンス
          } else {
            stage = GameObject.Find("__GameMain__/BG/PoleDanceStage(Clone)"); //スタジオ
          }
          if (!stage) return;

          Debug.Log("[VibeYourMaid] addPoleDanceCollider Stage="+stage);

          //追加する前に削除
          destroyPoleDanceCollider();

          poleColliderObj[0] = addPoleCollider(stage.transform.Find("ctrl_pole_Center"), cfgw.muneHitPoleRadius, 3f);
          poleColliderObj[1] = addPoleCollider(stage.transform.Find("ctrl_pole_Left"), cfgw.muneHitPoleRadius, 3f);
          poleColliderObj[2] = addPoleCollider(stage.transform.Find("ctrl_pole_Right"), cfgw.muneHitPoleRadius, 3f);
        }
        private void destroyPoleDanceCollider()
        {
          foreach (GameObject gameObject in poleColliderObj) {
            if (gameObject) Destroy(gameObject);
          }
        }
        private GameObject addPoleCollider(Transform trPole, float radius, float height)
        {
          if (!trPole) return null;
          GameObject gameObject = GameObject.CreatePrimitive(PrimitiveType.Capsule);
          gameObject.GetComponent<Renderer>().enabled = false;
          gameObject.name = "PoleCollider_" + trPole.name;
          gameObject.layer = LAYER_NO;
          gameObject.transform.position = new Vector3(trPole.position.x, trPole.position.y+height*0.5f, trPole.position.z);
          gameObject.transform.parent = trPole;
          gameObject.transform.localScale = new Vector3(radius*2, height, radius*2); //半径調整
          CapsuleCollider capsuleCollider = gameObject.AddComponent<CapsuleCollider>();
          capsuleCollider.radius = radius; //こっちの設定は効かないけど一応設定
          capsuleCollider.enabled = true;
          return gameObject;
        }

        #if DEBUG
        static private void printPos(string name, Transform tm) {
          Debug.Log(name+" pos=("+tm.position.x+","+tm.position.y+","+tm.position.z+")"+
          " lpos=("+tm.localPosition.x+","+tm.localPosition.y+","+tm.localPosition.z+")");
        }
        static private void printRot(string name, Transform tm) {
          Debug.Log(name+" rot=("+tm.rotation.eulerAngles.x+","+tm.rotation.eulerAngles.y+","+tm.rotation.eulerAngles.z+")"+
          " lrot=("+tm.localRotation.eulerAngles.x+","+tm.localRotation.eulerAngles.y+","+tm.localRotation.eulerAngles.z+")");
        }
        #endif
      }

      /// <summary>
      /// 胸衝突範囲のGizmoをGLで描画する 左のみ（腕座標がわを変換しているので右胸座標の向きは問題ない）
      /// 胸コライダーは両胸描画
      /// </summary>
      public class MuneColliderRenderer : MonoBehaviour
      {
        Maid maid;
        MaidState maidState;
        Transform spine1a;
        Transform muneL;
        Transform muneR;
        Transform armL;
        Transform armR;

        CapsuleCollider[] chinkoCollider;
        SphereCollider[] touchCollider;
        SphereCollider camCollider;

        Color xColor1;
        Color xColor2;
        Color yColor1;
        Color yColor2;
        Material lineMaterial;

        Vector3 munePosL;
        Vector3 munePosR;

        //胸のコライダー設定 無効時はnull
        MuneColliderInfo colliderInfo;
        SphereCollider muneColliderL;
        SphereCollider muneColliderR;

        public void init(Maid maid, MaidState maidState, CapsuleCollider[] chinkoCollider, SphereCollider[] touchCollider, SphereCollider camCollider)
        {
          this.maid = maid;
          this.maidState = maidState;
          this.spine1a = maidState.maidMuneA;
          #if COM3D2_5
          if (maid.IsCrcBody) {
            this.muneL = maid.body0.dbMuneL.transform;
            this.muneR = maid.body0.dbMuneR.transform;
          } else {
            this.muneL = maid.body0.jbMuneL.transform;
            this.muneR = maid.body0.jbMuneR.transform;
          }
          #else 
          this.muneL = maid.body0.jbMuneL.transform;
          this.muneR = maid.body0.jbMuneR.transform;
          #endif
          this.armL = maid.body0.UpperArmL;
          this.armR = maid.body0.UpperArmR;

          this.chinkoCollider = chinkoCollider;
          this.touchCollider = touchCollider;
          this.camCollider = camCollider;

          this.colliderInfo = maidState.muneColliderInfo;
          if (this.colliderInfo != null) {
            this.muneColliderL = this.colliderInfo.m_trHitChildL.GetComponent<SphereCollider>();
            this.muneColliderR = this.colliderInfo.m_trHitChildR.GetComponent<SphereCollider>();
          }

          this.xColor1 = new Color(1f,0.5f,0.75f,1f);
          this.xColor2 = Color.red;
          this.yColor1 = new Color(0.5f,0.75f,1f,1f);
          this.yColor2 = Color.blue;

          if (lineMaterial == null) {
            lineMaterial = new Material(Shader.Find("Hidden/Internal-Colored"));
            lineMaterial.hideFlags = HideFlags.HideAndDontSave;
            lineMaterial.SetInt("_ZTest", 0); //最前面表示にはこれが必要
            lineMaterial.SetInt("_SrcBlend", (int)UnityEngine.Rendering.BlendMode.SrcAlpha);
            lineMaterial.SetInt("_DstBlend", (int)UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);
            lineMaterial.SetInt("_Cull", (int)UnityEngine.Rendering.CullMode.Off);
            lineMaterial.SetInt("_ZWrite", 0);
            lineMaterial.renderQueue = 5000;
          }
        }

        //GL描画はOnRenderObjectで実行しないと描画されない
        private void OnRenderObject()
        {
          //メイドが破棄された場合は破棄
          if (maidState.maidMuneA == null) {
            GameObject.Destroy(this);
            return;
          }

          GL.PushMatrix();
          try {

          MuneParam muneParam = maidState.muneParam;
          if (muneParam != null) {

            Vector3 pos = muneL.position;
            //spine1aからのOffset
            munePosL = Quaternion.Inverse(spine1a.rotation) * (pos - spine1a.position);
            munePosR = Quaternion.Inverse(spine1a.rotation) * (pos - spine1a.position);
            Quaternion rot = muneParam.rotY;

            //腕原点
            if (maidState.muneOffsetL.targetX > 0.0001f && maidState.muneOffsetL.targetY > 0.0001f) lineMaterial.color = Color.red;
            else if (maidState.muneOffsetL.targetX > 0.0001f) lineMaterial.color = Color.yellow;
            else if (maidState.muneOffsetL.targetY > 0.0001f) lineMaterial.color = Color.blue;
            else lineMaterial.color = Color.green;
            lineMaterial.SetPass(0);
            GL.MultMatrix(armL.localToWorldMatrix);
            drawCross(muneParam.armOffsetL, 0.02f);

            if (maidState.muneOffsetR.targetX > 0.0001f && maidState.muneOffsetR.targetY > 0.0001f) lineMaterial.color = Color.red;
            else if (maidState.muneOffsetR.targetX > 0.0001f) lineMaterial.color = Color.yellow;
            else if (maidState.muneOffsetR.targetY > 0.0001f) lineMaterial.color = Color.blue;
            else lineMaterial.color = Color.green;
            lineMaterial.SetPass(0);
            GL.MultMatrix(armR.localToWorldMatrix);
            drawCross(muneParam.armOffsetR, 0.02f);

            //左胸原点
            lineMaterial.color = Color.white;
            lineMaterial.SetPass(0);
            GL.MultMatrix(muneL.localToWorldMatrix);
            drawCross(Vector3.zero, 0.02f);
            drawCrossRGB(Vector3.zero, 0.02f);

            //右原点
            lineMaterial.color = Color.white;
            lineMaterial.SetPass(0);
            GL.MultMatrix(muneR.localToWorldMatrix);
            drawCross(Vector3.zero, 0.02f);
            drawCrossRGB(Vector3.zero, 0.02f);

            //胸(spine1a)の座標系に
            //localScaleが反映されているのでMatrix側をスケールする
            //GL.MultMatrix(spine1a.localToWorldMatrix);
            Matrix4x4 matrix = spine1a.localToWorldMatrix;
            Transform t = maid.body0.transform;
            matrix *= Matrix4x4.Scale(new Vector3(1f/t.localScale.x, 1f/t.localScale.y, 1f/t.localScale.z));
            GL.MultMatrix(matrix);
            //胸原点
            //drawCross(Vector3.zero, 0.02f);

            //左右移動範囲
            lineMaterial.color = Color.Lerp(xColor1, xColor2, Math.Min(muneParam.moveLimitX, maidState.muneOffsetL.targetX * muneParam.moveRatioX)); //色を値で変更
            lineMaterial.SetPass(0);
            float rx, ryt, ryb, rz;
            Vector3 center = new Vector3(muneParam.centerX, muneParam.centerY, muneParam.centerFrontZ);
            rx = muneParam.outside - muneParam.centerX;
            ryt = muneParam.top - muneParam.centerY;
            ryb = muneParam.bottom - muneParam.centerY;
            rz = muneParam.front - muneParam.centerFrontZ;
            drawArcXY(munePosL, center, rx, ryt, 0, 90, rot); //左右 上半分
            drawArcXY(munePosL, center, rx, ryb, 0, 90, rot); //左右 下半分
            drawArcZX(munePosL, center, rx, rz, 0, 90, rot); //水平面 外側前
            //drawLine(munePosL, center.x, center.y, muneParam.front, center.x, muneParam.top, center.z, rot); //垂直面 前 上 直線
            //drawArcYZ(munePosL, center, ryt, rz, 0, 90, rot); //垂直面 前 上 円弧
            drawBrestFront(munePosL, center.x, center.y, center.z, ryt, rz, rot); //垂直面 前 上
            drawArcYZ(munePosL, center, ryb, rz, 0, 90, rot); //垂直面 前 下半分
            drawLine(munePosL, center.x, muneParam.top, center.z, center.x-rx*0.5f, muneParam.top, center.z, rot); //内側横線 上
            drawLine(munePosL, center.x, center.y, muneParam.front, center.x-rx*0.5f, center.y, muneParam.front, rot); //内側横線 前
            rz = muneParam.centerFrontZ - muneParam.back;

            //乳の後ろ側 水平のみcenterBackZから
            center.z = muneParam.centerBackZ;
            rz = muneParam.back - muneParam.centerBackZ;
            drawArcXY(munePosL, center, rx, ryt, 0, 90, rot); //左右 上半分
            drawArcXY(munePosL, center, rx, ryb, 0, 90, rot); //左右 下半分
            drawArcZX(munePosL, center, rx, rz, 0, 90, rot); //水平面 後ろ
            drawLine(munePosL, center.x, muneParam.top, center.z, center.x-rx*0.5f, muneParam.top, center.z, rot); //内側横線 上
            drawLine(munePosL, center.x, center.y, muneParam.back, center.x-rx*0.5f, center.y, muneParam.back, rot); //内側横線 後
            drawArcYZ(munePosL, center, ryb, rz, 0, 90, rot); //垂直面 後 下半分 
            drawArcYZ(munePosL, center, ryt, rz, 0, 90, rot); //垂直面 後 上半分
            drawLine(munePosL, center.x, muneParam.top, muneParam.centerFrontZ, center.x, muneParam.top, muneParam.centerBackZ, rot); //接続線 上
            drawLine(munePosL, muneParam.outside, center.y, muneParam.centerFrontZ, muneParam.outside, center.y, muneParam.centerBackZ, rot); //接続線 横
            drawLine(munePosL, center.x, muneParam.bottom, muneParam.centerFrontZ, center.x, muneParam.bottom, muneParam.centerBackZ, rot); //接続線 下

            //乳下げ範囲 左右
            lineMaterial.color = Color.Lerp(yColor1, yColor2, Math.Min(muneParam.moveLimitY, maidState.muneOffsetL.targetY * muneParam.moveRatioY)); //色を値で変更
            lineMaterial.SetPass(0);
            Vector3 downCenter = new Vector3(muneParam.downCenterX, muneParam.downCenterY, muneParam.downCenterZ);
            rx = muneParam.downOutside - muneParam.downCenterX;
            ryt = muneParam.downTop - muneParam.downCenterY;
            ryb = muneParam.downBottom - muneParam.downCenterY;
            rz = muneParam.downFront - muneParam.downCenterZ;
            drawArcXY(munePosL, downCenter, rx, ryt, 0, 180, rot); //左右 上半分
            drawArcXY(munePosL, downCenter, rx, ryb, 0, 180, rot); //左右 下半分
            drawArcZX(munePosL, downCenter, rx, rz, 0, 360, rot); //水平面 一周
            drawArcYZ(munePosL, downCenter, ryt, rz, 0, 180, rot); //垂直面 中心 上側
            drawArcYZ(munePosL, downCenter, ryb, rz, 0, 180, rot); //垂直面 中心 下側
          }

          //胸コライダー 半径はlocalScale分大きくなっている
          if (this.muneColliderL != null && this.muneColliderR != null) {
            GL.MultMatrix(this.muneColliderL.transform.localToWorldMatrix);
            lineMaterial.color = Color.white;
            lineMaterial.SetPass(0);
            //左胸
            drawCross(this.muneColliderL.center, this.muneColliderL.radius);
            drawSphere(this.muneColliderL.center, this.muneColliderL.radius);
            //右胸
            GL.MultMatrix(this.muneColliderR.transform.localToWorldMatrix);
            drawCross(this.muneColliderR.center, this.muneColliderR.radius);
            drawSphere(this.muneColliderR.center, this.muneColliderR.radius);

            //前腕 左
            if (this.colliderInfo.foreArmColliderL != null && this.colliderInfo.foreArmColliderL.enabled) {
              lineMaterial.color = Color.white;
              lineMaterial.SetPass(0);
              //前腕の子になっていなければスケール調整はしない
              drawCapsuleCollider(this.colliderInfo.foreArmColliderL, maid.body0.transform.localScale);
            }
            //前腕 右
            if (this.colliderInfo.foreArmColliderR != null && this.colliderInfo.foreArmColliderR.enabled) {
              lineMaterial.color = Color.white;
              lineMaterial.SetPass(0);
              //前腕の子になっていなければスケール調整はしない
              drawCapsuleCollider(this.colliderInfo.foreArmColliderR, maid.body0.transform.localScale);
            }
          }

          //竿 初期化されていないか破棄されていたらコライダーはnull
          if (chinkoCollider != null) {
            foreach (CapsuleCollider collider in chinkoCollider) {
              if (collider && collider.enabled) {
                lineMaterial.color = Color.cyan;
                lineMaterial.SetPass(0);
                drawCapsuleCollider(collider, Vector3.one);
              }
            }
          }

          //VRコントローラー
          if (touchCollider != null) {
            foreach (SphereCollider collider in touchCollider) {
              if (collider && collider.enabled) {
                lineMaterial.color = Color.cyan;
                lineMaterial.SetPass(0);
                GL.MultMatrix(collider.transform.localToWorldMatrix);
                drawSphere(collider.center, collider.radius);
                drawCrossRGB(collider.center, collider.radius);
              }
            }
          }

          //カメラ位置コライダー
          if (camCollider && camCollider.enabled) {
            lineMaterial.color = Color.cyan;
            lineMaterial.SetPass(0);
            GL.MultMatrix(camCollider.transform.localToWorldMatrix);
            drawSphere(camCollider.center, camCollider.radius);
            drawCrossRGB(camCollider.center, camCollider.radius);
          }

          } finally {
            GL.PopMatrix();
          }
        }

        //指定位置に十字
        private void drawCross(Vector3 c, float radius)
        {
          GL.Begin(GL.LINES);
            GL.Vertex3(c.x-radius, c.y, c.z); GL.Vertex3(c.x+radius, c.y, c.z);
            GL.Vertex3(c.x, c.y-radius, c.z); GL.Vertex3(c.x, c.y+radius, c.z);
            GL.Vertex3(c.x, c.y, c.z-radius); GL.Vertex3(c.x, c.y, c.z+radius);
          GL.End();
        }

        //xyz +側先端ををRGBで描画
        private void drawCrossRGB(Vector3 c, float radius)
        {
          lineMaterial.color = Color.red;
          lineMaterial.SetPass(0);
          GL.Begin(GL.LINES); GL.Vertex3(c.x+radius, c.y, c.z); GL.Vertex3(c.x+radius*0.5f, c.y, c.z); GL.End();
          lineMaterial.color = Color.green;
          lineMaterial.SetPass(0);
          GL.Begin(GL.LINES); GL.Vertex3(c.x, c.y+radius, c.z); GL.Vertex3(c.x, c.y+radius*0.5f, c.z); GL.End();
          lineMaterial.color = Color.blue;
          lineMaterial.SetPass(0);
          GL.Begin(GL.LINES); GL.Vertex3(c.x, c.y, c.z+radius); GL.Vertex3(c.x, c.y, c.z+radius*0.5f); GL.End();
        }

        private void drawLine(Vector3 pos, float x1, float y1, float z1, float x2, float y2, float z2, Quaternion rot)
        {
            GL.Begin(GL.LINES);
            GL.Vertex(pos + rot * new Vector3(-y1, z1, x1));
            GL.Vertex(pos + rot * new Vector3(-y2, z2, x2));
            GL.End();
        }

        //胸の前 上側ラインの描画 判定計算処理にあわせる
        private void drawBrestFront(Vector3 pos, float x0, float y0, float z0, float h, float d, Quaternion rot)
        {
          GL.Begin(GL.LINE_STRIP);
          for (int i=0; i<=90; i+=5) {
            float z = (float)Math.Cos(Math.PI*i/180.0);
            float y = (float)Math.Sin(Math.PI*i/180.0);
            y = y / (1f + z * 0.7f); //前側のyを70%高くする
            GL.Vertex(pos + rot * new Vector3(-(y0 + y*h), z0 + z*d, x0));
          }
          GL.End();
        }

        //放物線を描画
        private void drawParaboraYZ(Vector3 pos, float x0, float y0, float z0, float h, float d, Quaternion rot)
        {
          GL.Begin(GL.LINE_STRIP);
          for (int i=0; i<=20; i++) {
            float z = i*0.05f;
            GL.Vertex(pos + rot * new Vector3(-(y0 + h*z*z), z0 + z*d, x0));
          }
          GL.End();
        }

        //垂直面 左右 外側が0 5度単位 cの軸は左胸座標に合わせて入れ替えている -y,z,x
        private void drawArcXY(Vector3 pos, Vector3 c, float rx, float ry, int angle1, int angle2, Quaternion rot)
        {
          float rad = Mathf.PI/180.0f;
          GL.Begin(GL.LINE_STRIP);
          for (int i=angle1; i<=angle2; i+=5) GL.Vertex(pos + rot * new Vector3(-(c.y+(float)Math.Sin(rad*i)*ry), c.z, c.x+(float)Math.Cos(rad*i)*rx));
          GL.End();
        }
        //垂直面 前後 前側が0  5度単位 cの軸は左胸座標に合わせて入れ替えている -y,z,x
        private void drawArcYZ(Vector3 pos, Vector3 c, float ry, float rz, int angle1, int angle2, Quaternion rot)
        {
          float rad = Mathf.PI/180.0f;
          GL.Begin(GL.LINE_STRIP);
          for (int i=angle1; i<=angle2; i+=5) GL.Vertex(pos + rot * new Vector3(-(c.y+(float)Math.Sin(rad*i)*ry), c.z+(float)Math.Cos(rad*i)*rz, c.x));
          GL.End();
        }
        //水平面 外側が0  5度単位 cの軸は左胸座標に合わせて入れ替えている -y,z,x
        private void drawArcZX(Vector3 pos, Vector3 c, float rx, float rz, int angle1, int angle2, Quaternion rot)
        {
          float rad = Mathf.PI/180.0f;
          GL.Begin(GL.LINE_STRIP);
          for (int i=angle1; i<=angle2; i+=5) GL.Vertex(pos + rot * new Vector3(-c.y, c.z+(float)Math.Sin(rad*i)*rz, c.x+(float)Math.Cos(rad*i)*rx));
          GL.End();
        }
        //球
        private void drawSphere(Vector3 c, float r)
        {
          float rad = Mathf.PI/180.0f;
          GL.Begin(GL.LINE_STRIP);
          for (int i=0; i<=360; i+=5) GL.Vertex3(c.x-(float)Math.Sin(rad*i)*r, c.y, c.z+(float)Math.Cos(rad*i)*r);
          GL.End();
          GL.Begin(GL.LINE_STRIP);
          for (int i=0; i<=360; i+=5) GL.Vertex3(c.x-(float)Math.Sin(rad*i)*r, c.y+(float)Math.Cos(rad*i)*r, c.z);
          GL.End();
          GL.Begin(GL.LINE_STRIP);
          for (int i=0; i<=360; i+=5) GL.Vertex3(c.x, c.y+(float)Math.Sin(rad*i)*r, c.z+(float)Math.Cos(rad*i)*r);
          GL.End();
        }

        //カプセル高さがy方向
        private void drawCapsuleCollider(CapsuleCollider capsule, Vector3 scale)
        {
          Transform t = capsule.transform;
          Matrix4x4 matrix = t.localToWorldMatrix;
          matrix *= Matrix4x4.Scale(new Vector3(scale.x/t.localScale.x, scale.y/t.localScale.y, scale.z/t.localScale.z));
          GL.MultMatrix(matrix);
          drawCapsule(capsule.center, capsule.radius, capsule.height); //高さがy方向
          drawCross(Vector3.zero, capsule.radius);
          drawCrossRGB(Vector3.zero, capsule.radius);
        }
        private void drawCapsule(Vector3 center, float radius, float height)
        {
          Vector3 yt = new Vector3(center.x, center.y - height*0.5f + radius, center.z);
          Vector3 yb = new Vector3(center.x, center.y + height*0.5f - radius, center.z);
          drawArcXY(yt, Vector3.zero, radius, radius, 0, 360, Quaternion.identity);
          drawArcXY(yb, Vector3.zero, radius, radius, 0, 360, Quaternion.identity);
          drawArcYZ(yt, Vector3.zero, radius, radius, 90, 270, Quaternion.identity);
          drawArcYZ(yb, Vector3.zero, radius, radius, -90, 90, Quaternion.identity);
          drawArcZX(yt, Vector3.zero, radius, radius, 180, 360, Quaternion.identity);
          drawArcZX(yb, Vector3.zero, radius, radius, 0, 180, Quaternion.identity);
          yt.x = center.x - radius;
          yb.x = center.x - radius;
          GL.Begin(GL.LINES); GL.Vertex(yt); GL.Vertex(yb); GL.End();
          yt.x = center.x + radius;
          yb.x = center.x + radius;
          GL.Begin(GL.LINES); GL.Vertex(yt); GL.Vertex(yb); GL.End();
          yt.x = center.x;
          yb.x = center.x;
          yt.z = center.z - radius;
          yb.z = center.z - radius;
          GL.Begin(GL.LINES); GL.Vertex(yt); GL.Vertex(yb); GL.End();
          yt.z = center.z + radius;
          yb.z = center.z + radius;
          GL.Begin(GL.LINES); GL.Vertex(yt); GL.Vertex(yb); GL.End();
        }
      }


      //おさわり処理関係-----------------------

      //おさわり用ターゲット配置
      private void targetSet(int maidID, Maid maid, MaidState maidState) {
        if (reGetMaid) return; //単独でも呼ばれるのでここでチェック

        if (maid.body0.m_Bones == null) return;

        maidState.bodyName = maid.GetProp(MPN.body).strFileName;
        Console.WriteLine("おさわりボディ:" + maidState.bodyName);
        try {
        //口
        maidState.targetSphere_mouth = GameObject.CreatePrimitive(PrimitiveType.Sphere);
        maidState.targetSphere_mouth.layer = 8;
        maidState.targetSphere_mouth.name = "MO_" + maidID;
        maidState.targetSphere_mouth.transform.localScale = new Vector3(0.06f, 0.06f, 0.06f);
        maidState.targetSphere_mouth.GetComponent<Renderer>().enabled = false;
        //BoxCollider boxCollider0 = maidState.targetSphere_mouth.AddComponent<BoxCollider>();
        maidState.targetSphere_mouth.GetComponent<Collider>().isTrigger = true;
        maidState.IK_mouth = maid.body0.trsHead; //CMT.SearchObjName(maid.body0.m_Bones.transform, "Bip01 Head", true);

        //胸サイス 20～100まで可変 (20→-1.5cm 60→1cm 100→5cm)
        float muneSize = (bVR ? 0.12f : 0.2f) + 0.002f * (Math.Min(100, Math.Max(20, maid.GetProp(MPN.MuneL).value - 50f)));
        //右胸
        maidState.targetSphere_muneR = GameObject.CreatePrimitive(PrimitiveType.Sphere);
        maidState.targetSphere_muneR.layer = 8;
        maidState.targetSphere_muneR.name = "MR_" + maidID;
        maidState.targetSphere_muneR.transform.localScale = new Vector3(muneSize, muneSize, muneSize); //VRとマウスで大きさ調整
        maidState.targetSphere_muneR.GetComponent<Renderer>().enabled = false;
        //BoxCollider boxCollider1 = maidState.targetSphere_muneR.AddComponent<BoxCollider>();
        maidState.targetSphere_muneR.GetComponent<Collider>().isTrigger = true;
        #if COM3D2_5
        if (maid.IsCrcBody) maidState.IK_muneR = maid.body0.dbMuneR.transform;
        else maidState.IK_muneR = maid.body0.jbMuneR.transform;
        #else
        maidState.IK_muneR = maid.body0.jbMuneR.transform;
        #endif
        //位置がずれるので_IKは使わない
        //if (maidState.IK_muneR == null) maidState.IK_muneR = CMT.SearchObjName(maid.body0.m_Bones.transform, "_IK_muneR", true);
        //左胸
        maidState.targetSphere_muneL = GameObject.CreatePrimitive(PrimitiveType.Sphere);
        maidState.targetSphere_muneL.layer = 8;
        maidState.targetSphere_muneL.name = "ML_" + maidID;
        maidState.targetSphere_muneL.transform.localScale = new Vector3(muneSize, muneSize, muneSize); //VRとマウスで大きさ調整
        maidState.targetSphere_muneL.GetComponent<Renderer>().enabled = false;
        //BoxCollider boxCollider2 = maidState.targetSphere_muneL.AddComponent<BoxCollider>();
        maidState.targetSphere_muneL.GetComponent<Collider>().isTrigger = true;
        #if COM3D2_5
        if (maid.IsCrcBody) maidState.IK_muneL = maid.body0.dbMuneL.transform;
        else maidState.IK_muneL = maid.body0.jbMuneL.transform;
        #else
        maidState.IK_muneL = maid.body0.jbMuneL.transform;
        #endif
        //位置がずれるので_IKは使わない
        //if (maidState.IK_muneL == null) maidState.IK_muneL = CMT.SearchObjName(maid.body0.m_Bones.transform, "_IK_muneL", true);

        //おしり
        //左
        maidState.targetSphere_hipL = GameObject.CreatePrimitive(PrimitiveType.Sphere);
        maidState.targetSphere_hipL.layer = 8;
        maidState.targetSphere_hipL.name = "HL_" + maidID;
        maidState.targetSphere_hipL.transform.localScale = new Vector3(0.1f, 0.1f, 0.1f); //VR用に変更
        maidState.targetSphere_hipL.GetComponent<Renderer>().enabled = false;
        //BoxCollider boxCollider3 = maidState.targetSphere_hipL.AddComponent<BoxCollider>();
        maidState.targetSphere_hipL.GetComponent<Collider>().isTrigger = true;
        maidState.IK_hipL = CMT.SearchObjName(maid.body0.m_Bones.transform, "_IK_hipL", true);
        maidState.Hip_L = CMT.SearchObjName(maid.body0.m_Bones.transform, "Hip_L", true);
        //右
        maidState.targetSphere_hipR = GameObject.CreatePrimitive(PrimitiveType.Sphere);
        maidState.targetSphere_hipR.layer = 8;
        maidState.targetSphere_hipR.name = "HR_" + maidID;
        maidState.targetSphere_hipR.transform.localScale = new Vector3(0.1f, 0.1f, 0.1f); //VR用に変更
        maidState.targetSphere_hipR.GetComponent<Renderer>().enabled = false;
        //BoxCollider boxCollider4 = maidState.targetSphere_hipR.AddComponent<BoxCollider>();
        maidState.targetSphere_hipR.GetComponent<Collider>().isTrigger = true;
        maidState.IK_hipR = CMT.SearchObjName(maid.body0.m_Bones.transform, "_IK_hipR", true);
        maidState.Hip_R = CMT.SearchObjName(maid.body0.m_Bones.transform, "Hip_R", true);

        //大事なとこ
        maidState.targetSphere_vagina = GameObject.CreatePrimitive(PrimitiveType.Sphere);
        maidState.targetSphere_vagina.layer = 8;
        maidState.targetSphere_vagina.name = "VA_" + maidID;
        maidState.targetSphere_vagina.transform.localScale = new Vector3(0.1f, 0.1f, 0.1f);
        maidState.targetSphere_vagina.GetComponent<Renderer>().enabled = false;
        //BoxCollider boxCollider5 = maidState.targetSphere_vagina.AddComponent<BoxCollider>();
        maidState.targetSphere_vagina.GetComponent<Collider>().isTrigger = true;
        maidState.IK_vagina = maid.body0.Pelvis; //CMT.SearchObjName(maid.body0.m_Bones.transform, "Bip01 Pelvis", true);

        //アナル
        maidState.targetSphere_anal = GameObject.CreatePrimitive(PrimitiveType.Sphere);
        maidState.targetSphere_anal.layer = 8;
        maidState.targetSphere_anal.name = "AN_" + maidID;
        maidState.targetSphere_anal.transform.localScale = new Vector3(0.05f, 0.05f, 0.05f);
        maidState.targetSphere_anal.GetComponent<Renderer>().enabled = false;
        //BoxCollider boxCollider6 = maidState.targetSphere_anal.AddComponent<BoxCollider>();
        maidState.targetSphere_anal.GetComponent<Collider>().isTrigger = true;
        maidState.IK_anal = CMT.SearchObjName(maid.body0.m_Bones.transform, "_IK_anal", true);

        } catch { //(Exception e) {
          Debug.LogError("targetSet Error : "+maid);
          targetDestroy(maidState); //targetを削除
          setTBodyTransform(maidState); //TBodyの部位をmadeStateに再設定
        }
      }


      //おさわりターゲット消去
      private void targetDestroy(MaidState maidState) {
        if (maidState.targetSphere_mouth) UnityEngine.Object.Destroy(maidState.targetSphere_mouth);
        if (maidState.targetSphere_muneR) UnityEngine.Object.Destroy(maidState.targetSphere_muneR);
        if (maidState.targetSphere_muneL) UnityEngine.Object.Destroy(maidState.targetSphere_muneL);
        if (maidState.targetSphere_hipL) UnityEngine.Object.Destroy(maidState.targetSphere_hipL);
        if (maidState.targetSphere_hipR) UnityEngine.Object.Destroy(maidState.targetSphere_hipR);
        if (maidState.targetSphere_vagina) UnityEngine.Object.Destroy(maidState.targetSphere_vagina);
        if (maidState.targetSphere_anal) UnityEngine.Object.Destroy(maidState.targetSphere_anal);
      }


      //ターゲット位置の更新 おさわりが有効の場合は毎フレーム呼ばれる
      private void targetUpdate(int maidID, MaidState maidState) {
        try {
        //if (maidState.bodyName != stockMaids[maidID].mem.GetProp(MPN.body).strFileName) targetDestroy(maidID); //例外処理で対応
        //if (!maidState.targetSphere_mouth) targetSet(maidID, maid, maidState); //例外処理で対応

        maidState.targetSphere_mouth.transform.position = maidState.IK_mouth.transform.position;

        maidState.targetSphere_muneR.transform.position = maidState.IK_muneR.transform.position;
        maidState.targetSphere_muneL.transform.position = maidState.IK_muneL.transform.position;

        maidState.targetSphere_hipL.transform.position = new Vector3(
          (maidState.IK_hipL.transform.position.x + maidState.Hip_L.transform.position.x) * 0.5f,
          (maidState.IK_hipL.transform.position.y + maidState.Hip_L.transform.position.y) * 0.5f,
          (maidState.IK_hipL.transform.position.z + maidState.Hip_L.transform.position.z) * 0.5f
        );

        maidState.targetSphere_hipR.transform.position = new Vector3(
          (maidState.IK_hipR.transform.position.x + maidState.Hip_R.transform.position.x) * 0.5f,
          (maidState.IK_hipR.transform.position.y + maidState.Hip_R.transform.position.y) * 0.5f,
          (maidState.IK_hipR.transform.position.z + maidState.Hip_R.transform.position.z) * 0.5f
        );

        maidState.targetSphere_vagina.transform.position = maidState.IK_vagina.transform.position;

        maidState.targetSphere_anal.transform.position = maidState.IK_anal.transform.position;

        } catch { //(Exception e) {
          //初回のtargetSet未実施の場合もここで例外処理して再作成される
          //スタジオで同じメイドをロードした場合にIK_mouthが取得できずにエラーになる
          //UnityEngine.Debug.LogError("targetUpdate Error : "+maidID);
          targetDestroy(maidState);
          targetSet(maidID, maidState.maid, maidState);
        }
      }


      //おさわり管理クラス初期化
      Osawari osawari = null;

      //おさわりクラス初期化
      private void initOsawari()
      {
        try {

        if (bVR) {
          osawari = new Osawari(2, stockMaids, maidsState, cfgw, true);
          OvrMgr OvrMgr = GameMain.Instance.OvrMgr;
#if UNITY_2022_3
            //SteamVRと同じ ボタンはVIRTUAL_L_CLICKに変更
            AVRControllerButtons.BTN LButton = AVRControllerButtons.BTN.VIRTUAL_L_CLICK;
            AVRControllerButtons.BTN RButton = AVRControllerButtons.BTN.VIRTUAL_L_CLICK;
            if (cfgw.osawariButton != null) {
              string button = cfgw.osawariButton.ToUpper();
              if (button.StartsWith("BY")) {
                LButton = AVRControllerButtons.BTN.MENU;
                RButton = AVRControllerButtons.BTN.MENU;
              } else if (button.StartsWith("T")) {
                LButton = AVRControllerButtons.BTN.TRIGGER;
                RButton = AVRControllerButtons.BTN.TRIGGER;
              } else if (button.StartsWith("G")) {
                LButton = AVRControllerButtons.BTN.GRIP;
                RButton = AVRControllerButtons.BTN.GRIP;
              }
            }
            osawari.setOsawariInput(0, true, new OsawariQuestController(LButton, OvrMgr.ovr_obj.left_controller, AVRControllerButtons.BTN.VIRTUAL_MENU, OvrMgr.GetVRControllerTransform(true)));
            osawari.setOsawariInput(1, false, new OsawariQuestController(RButton, OvrMgr.ovr_obj.left_controller, AVRControllerButtons.BTN.VIRTUAL_MENU, OvrMgr.GetVRControllerTransform(false)));
            //初期化ログ
            Debug.Log("[VibeYourMaid] initOsawari LButton="+LButton+" RButton="+RButton);
#else
          if (bOculusVR) {
            //Quest
            OVRInput.RawButton LButton = OVRInput.RawButton.X;
            OVRInput.RawButton RButton = OVRInput.RawButton.A;
            if (cfgw.osawariButton != null) {
              string button = cfgw.osawariButton.ToUpper();
              if (button.StartsWith("BY")) {
                LButton = OVRInput.RawButton.Y;
                RButton = OVRInput.RawButton.B;
              } else if (button.StartsWith("T")) {
                LButton = OVRInput.RawButton.LIndexTrigger;
                RButton = OVRInput.RawButton.RIndexTrigger;
              } else if (button.StartsWith("G")) {
                LButton = OVRInput.RawButton.LHandTrigger;
                RButton = OVRInput.RawButton.RHandTrigger;
              }
            }
            osawari.setOsawariInput(0, true, new OsawariQuestController(LButton, OVRInput.Controller.LTouch, OVRInput.RawButton.Y, OvrMgr.GetVRControllerTransform(true)));
            osawari.setOsawariInput(1, false, new OsawariQuestController(RButton, OVRInput.Controller.RTouch, OVRInput.RawButton.B, OvrMgr.GetVRControllerTransform(false)));
            //初期化ログ
            Debug.Log("[VibeYourMaid] initOsawari LButton="+LButton+" RButton="+RButton);
          } else {
            //SteamVR
            AVRControllerButtons.BTN LButton = AVRControllerButtons.BTN.STICK_PAD;
            AVRControllerButtons.BTN RButton = AVRControllerButtons.BTN.STICK_PAD;
            if (cfgw.osawariButton != null) {
              string button = cfgw.osawariButton.ToUpper();
              if (button.StartsWith("L")) {
                LButton = AVRControllerButtons.BTN.VIRTUAL_L_CLICK; //AXボタン
                RButton = AVRControllerButtons.BTN.VIRTUAL_L_CLICK;
              } else if (button.StartsWith("R")) {
                LButton = AVRControllerButtons.BTN.VIRTUAL_R_CLICK; //BYボタン
                RButton = AVRControllerButtons.BTN.VIRTUAL_R_CLICK;
              } else if (button.StartsWith("T")) {
                LButton = AVRControllerButtons.BTN.TRIGGER;
                RButton = AVRControllerButtons.BTN.TRIGGER;
              } else if (button.StartsWith("G")) {
                LButton = AVRControllerButtons.BTN.GRIP;
                RButton = AVRControllerButtons.BTN.GRIP;
              }
            }
            osawari.setOsawariInput(0, true, new OsawariViveController(LButton, OvrMgr.ovr_obj.left_controller, AVRControllerButtons.BTN.VIRTUAL_MENU));
            osawari.setOsawariInput(1, false, new OsawariViveController(RButton, OvrMgr.ovr_obj.right_controller, AVRControllerButtons.BTN.VIRTUAL_MENU));
            //初期化ログ
            Debug.Log("[VibeYourMaid] initOsawari LButton="+LButton+" RButton="+RButton);
          }
#endif

        } else {
          //その他
          osawari = new Osawari(2, stockMaids, maidsState, cfgw, false);
          osawari.setOsawariInput(0);
          //マルチタッチは Input.touches[] の順番が入れ替わる
          osawari.setOsawariInput(1); //マルチタッチ用
        }

        } catch (Exception e) {
          Debug.Log("[VibeYourMaid] initOsawari Failed : "+e);
          if (osawari != null ) osawari.initFailed();
        }
      }

      /// <summary>
      /// おさわり用メインクラス
      /// 複数のOsawariInputクラスとMuneOsawariクラスを管理する
      /// </summary>
      public class Osawari
      {
        //おさわりクラス
        private OsawariInput[] osawariInput;

        //VYM側の値を格納
        public List<MaidInfo> stockMaids;
        public List<MaidState> maidsState;
        public VibeYourMaidCfgWriting cfgw;
        bool bVR = false;

        //胸揺れを制御するクラス
        private List<OsawariRelease> listMuneRelease;

        //おさわり状態取得用 おさわり開始時にサイズは調整する
        private byte[] maidOsawariLevel = new byte[100];

        //コンストラクタ
        /// <param name="size">コントローラーの数 マウスなら1 タッチやVRは2</param>
        public Osawari(int size, List<MaidInfo> stockMaids, List<MaidState> maidsState, VibeYourMaidCfgWriting cfgw, bool bVR)
        {
          //リスト初期化
          listMuneRelease = new List<OsawariRelease>();

          this.stockMaids = stockMaids;
          this.maidsState = maidsState;
          this.cfgw = cfgw;
          this.bVR = bVR;

          osawariInput = new OsawariInput[size];
        }

        //初期化失敗時の処理
        public void initFailed()
        {
          osawariInput = new OsawariInput[0];
        }

        public void endOsawari()
        {
          for (int i=0; i<osawariInput.Length; i++) {
            osawariInput[i].endOsawari();
          }
        }

        public void setOsawariInput(int idx)
        {
          osawariInput[idx] = new OsawariInput(idx, this);
        }
        //Quest用のOsawariInput追加
        /// <param name="modeButton">コントローラーの形状を変えるボタン X/Y</param>
        public void setOsawariInput(int idx, bool bLeft, OsawariQuestController osawariController)
        {
          osawariInput[idx] = new OsawariInput(idx, this, bLeft, osawariController);
        }
        //Vibe用のOsawariInput追加
        /// <param name="modeButton">コントローラーの形状を変えるボタン</param>
        public void setOsawariInput(int idx, bool bLeft, OsawariViveController osawariController)
        {
          osawariInput[idx] = new OsawariInput(idx, this, bLeft, osawariController);
        }

        //stockMaidsの配列数が変わったら呼び出す
        public void setStockMaidsCount(int count)
        {
          //配列が足りなかったら拡張
          if (maidOsawariLevel.Length < count) {
            Array.Resize(ref maidOsawariLevel, count + 10);
          }
        }
        //対応するメイドのおさわりレベルを取得
        public int getOsawariLevel(int maidID)
        {
          //キャッシュを利用
          return maidOsawariLevel[maidID];
          /*int osawariLevel = 0;
          for (int i=0; i<osawariInput.Length; i++) {
            if (maidID == osawariInput[i].osawariID) osawariLevel = Math.Max(osawariLevel, osawariInput[i].osawariLevel);
          }
          return osawariLevel;*/
        }

        //おさわりレベルを更新する 各コントローラーの最大値を設定
        public void updateMaidOsawariLevel(int maidID)
        {
          //配列が足りなかったら拡張
          setStockMaidsCount(stockMaids.Count);
          //最大値を取得
          byte level = 0;
          for (int i=0; i<osawariInput.Length; i++) {
            if (maidID == osawariInput[i].osawariID) {
              level = Math.Max(level, osawariInput[i].osawariLevel);
            }
          }
          maidOsawariLevel[maidID] = level;
          //Console.WriteLine("updateMaidOsawariLevel("+maidID+") "+maidOsawariLevel[maidID]);
        }

        //メイドがおさわり状態か  基本2つなのでループなし
        public bool isOsawari(int maidID)
        {
          if (maidID == osawariInput[0].osawariID) return true;
          if (maidID == osawariInput[1].osawariID) return true;
          /*for (int i=0; i<osawariInput.Length; i++) {
            if (maidID == osawariInput[i].osawariID) {
              return true;
            }
          }*/
          return false;
        }
        //メイドの指定したポイントがおさわり状態か  基本2つなのでループなし
        //OsawariInputから呼ぶ場合は自分もチェックされるので注意
        public bool isOsawari(int maidID, string osawariPoint)
        {
          if (maidID == osawariInput[0].osawariID && osawariPoint == osawariInput[0].osawariPoint) return true;
          if (maidID == osawariInput[1].osawariID && osawariPoint == osawariInput[1].osawariPoint) return true;
          /*for (int i=0; i<osawariInput.Length; i++) {
            if (maidID == osawariInput[i].osawariID && osawariPoint == osawariInput[i].osawariPoint) return true;
          }*/
          return false;
        }

        //SE停止チェック用 すべてのメイドで股間が触られているかバイブが動作しているならtrue
        public bool isOsawariKokan()
        {
          for (int i=0; i<osawariInput.Length; i++) {
            if (osawariInput[i].osawariID != -1 &&
              (osawariInput[i].osawariPoint == "VA_" || osawariInput[i].osawariPoint == "AN_") &&
              maidsState[osawariInput[i].osawariID].vLevel > 0) return true;
          }
          return false;
        }

        //すべてのメイドのバイブレベルの最大値取得
        public int getMaidVibeLevel()
        {
          int vLevel = 0;
          foreach (MaidState maidState in maidsState) {
            if (maidState.maid.Visible) vLevel = Math.Max(vLevel, maidState.vLevel);
          }
          return vLevel;
        }

        //コントローラーの胸コライダーの有効無効を切り変える
        public void setTouchColliderEnabled(bool enabled)
        {
          //おさわり中でも変更する
          for (int i=0; i<osawariInput.Length; i++) {
            if (osawariInput[i].touchCollider != null) osawariInput[i].touchCollider.enabled = enabled;
          }
        }
        //コントローラーの胸コライダーを取得 VR以外は長さ0の配列
        public SphereCollider[] getTouchCollider()
        {
          if (!bVR) return new SphereCollider[0];

          SphereCollider[] col = new SphereCollider[osawariInput.Length];
          for (int i=0; i<col.Length; i++) {
            col[i] = osawariInput[i].touchCollider;
          }
          return col;
        }


        public float getMouseMove(int maidID)
        {
          float mouse_move = 0f;
          for (int i=0; i<osawariInput.Length; i++) {
            if (maidID == osawariInput[i].osawariID) mouse_move += osawariInput[i].mouse_move;
          }
          return mouse_move;
        }

        //VYM側から利用 基本は-1～1に制限した値 形状に応じて値変更
        public float getMoveAtpY_VA(int maidID)
        {
          for (int i=0; i<osawariInput.Length; i++) {
            OsawariInput input = osawariInput[i];
            if (maidID == input.osawariID && "VA_" == input.osawariPoint) {
              if (input.handType != 10 & input.handType != 11) {
                return Math.Max(-1f, Math.Min(0.4f, input.Move_atp.y)); //Vibeは以外は小さく
              }
              return Math.Max(-1f, Math.Min(1f, input.Move_atp.y));
            }
          }
          return 0f;
        }
        public float getMoveAtpY_AN(int maidID)
        {
          for (int i=0; i<osawariInput.Length; i++) {
            OsawariInput input = osawariInput[i];
            if (maidID == input.osawariID && "AN_" == input.osawariPoint) {
              if (input.handType == 11) return Math.Max(-1f, Math.Min(1.5f, input.Move_atp.y)); //Vibeなら1.5倍まで広げる
              if (input.handType == 12) {
                //AnalVibe形状に合わせて変動 -1～0.3の正弦波を反転して-0.69～1.2で可変
                return Math.Max(-1f, Math.Min(1f, input.Move_atp.y)) - (float)Math.Min(0.3, Math.Sin(2 * Math.PI * input.Move_atp.y * 1.8f)) * 0.3f - 0.1f;
              }
              return Math.Max(-1f, Math.Min(1f, input.Move_atp.y));
            }
          }
          return 0f;
        }

        //メイドの左右の胸揺れを取得
        public OsawariRelease getMuneRelease(bool bLeft, int osawariID)
        {
          foreach (OsawariRelease osawariRelease in listMuneRelease) {
            if (osawariRelease.bLeft == bLeft && osawariRelease.osawariID == osawariID) {
              return osawariRelease;
            }
          }
          return null;
        }
        //胸リリース時に胸揺れ処理を追加
        public void addMuneRelease(OsawariRelease osawariRelease)
        {
          listMuneRelease.Add(osawariRelease);
        }

        //胸変形処理 左胸
        public void muneMorphLeft(Maid maid, MaidState maidState, float x, float y)
        {
          muneMorph(maid, maidState, 
            #if COM3D2_5
            maid.body0.dbMuneL,
            #endif
            maid.body0.jbMuneL, maidState.muneOffsetL, x, y);
        }
        //胸変形処理 右胸  xは呼び出し側で反転しておく
        public void muneMorphRight(Maid maid, MaidState maidState, float x, float y)
        {
          muneMorph(maid, maidState, 
            #if COM3D2_5
            maid.body0.dbMuneR,
            #endif
            maid.body0.jbMuneR, maidState.muneOffsetR, x, y);
        }

        //胸変形処理 おさわり時と胸揺れ時に利用 可動範囲が円形になるように調整
        //bornmorph.Blend() は不要
        public void muneMorph(Maid maid, MaidState maidState, 
          #if COM3D2_5
          DynamicMuneBone dbMune,
          #endif
          jiggleBone jbMune, MuneOffset muneOffset, float x, float y)
        {
          //円の中に収める
          double theta = Math.Atan2(y, x);
          //x *= Math.Abs((float)Math.Cos(theta));
          y *= Math.Abs((float)Math.Sin(theta));
          if (y < 0) y *= 0.7f; //下側は70%に制限

          //中心部の移動量を2倍に
          if (x > 0) x = x * (2f-x); else x = x * (2f+x);
          if (y > 0) y = y * (2f-y); else y = y * (2f+y);

          //胸が小さい場合は移動量を増やす
          int mpnMune = maid.GetProp(MPN.MuneL).value;
          float muneSize = Math.Max(0, Math.Min(150, mpnMune)); //0～150に制限
          if (muneSize < 50) {
            muneSize = 1.5f - muneSize*0.01f;  //0=1.5 50=1.0
          } else {
            muneSize = 50f / muneSize;  //50=1.0 100=0.5 150=0.33
          }

          float offsetX;
          float offsetY;
          if (mpnMune <= 0 || maidState.muneParam == null) {
            offsetX = 0;
            offsetY = 0;
          } else {
            //胸下げオフセット
            offsetY = Math.Min(maidState.muneParam.moveLimitY, muneOffset.y * maidState.muneParam.moveRatioY); //最大移動量は制限
            //胸寄りオフセット
            offsetX = Math.Min(maidState.muneParam.moveLimitX, muneOffset.x * maidState.muneParam.moveRatioX); //最大移動量は制限
            //両端を放物曲線にする
            if (maidState.muneParam.curvePointX >= 0) {
              float w1 = maidState.muneParam.moveLimitX * maidState.muneParam.curvePointX;
              if (offsetX < w1)  { //前
                float x1 = offsetX / w1; //始点から分割点まで0～1
                offsetX = (x1 * x1) * w1;
              } else { //後
                float w2 = maidState.muneParam.moveLimitX - w1;
                float x2 = (maidState.muneParam.moveLimitX - offsetX) / w2; //分割点から終点まで1～0
                offsetX = maidState.muneParam.moveLimitX - (x2 * x2) * w2;
              }
            }
            if (maidState.muneParam.curvePointY >= 0) {
              float w1 = maidState.muneParam.moveLimitY * maidState.muneParam.curvePointY;
              if (offsetY < w1)  { //上端と下端
                float y1 = offsetY / w1; //始点から分割点まで0～1
                offsetY = (y1 * y1) * w1;
              } else { //中央
                float w2 = maidState.muneParam.moveLimitY - w1;
                float y2 = (maidState.muneParam.moveLimitY - offsetY) / w2; //分割点から終点まで1～0
                offsetY = maidState.muneParam.moveLimitY - (y2 * y2) * w2;
              }
            }
            //胸サイズにあわせて移動量調整
            offsetX *= muneSize;
            offsetY *= muneSize;
          }

          if (jbMune) {
            jbMune.MuneUpDown = maidState.muneValue.MuneUpDown + (y * muneSize - offsetY) * cfgw.jbMuneMoveRatioY;
            //jbMune.BlendValue2 = maidState.muneValue.MuneBlend + y; //先端の動きがおかしい
            jbMune.MuneUpDown_f = maidState.muneValue.MuneUpDown_f + Math.Abs(y) * 2f;

            jbMune.MuneYori = maidState.muneValue.MuneYori + (x * muneSize - offsetX) * cfgw.jbMuneMoveRatioX;
            jbMune.MuneYori_f = maidState.muneValue.MuneYori_f + Math.Abs(x) * 2f;

            //bonemorph.Blend()は不要
            return;
          }

          #if COM3D2_5
          if (dbMune) {
            Dictionary<MPN, int> MunePropValueDic = (Dictionary<MPN, int>)VibeYourMaid.MunePropValueDicInfo.GetValue(dbMune);
            MunePropValueDic[MPN.MuneUpDown] = (int)(maidState.muneValue.MuneUpDown +  (y * muneSize - offsetY) * cfgw.dbMuneMoveRatioY);
            MunePropValueDic[MPN.MuneYori] = (int)(maidState.muneValue.MuneYori + (x * muneSize - offsetX) * cfgw.dbMuneMoveRatioX);
          }
          #endif
        }

        //おさわり処理を実行
        public void osawariHand()
        {
          //マルチタッチの入れ替え処理 とりあえず2つのみ
          if (Input.touchCount == 1) {
            if (osawariInput.Length >= 2 && !osawariInput[0].touchActive && osawariInput[1].touchActive) {
              OsawariInput tmp = osawariInput[0];
              osawariInput[0] = osawariInput[1];
              osawariInput[1] = tmp;
              osawariInput[0].idx = 0;
              osawariInput[1].idx = 1;
            }
          }

          //前のフレームでリリースされていたら胸揺れ処理 osawariInput[i].osawariHand(); でキャンセルが入るので先に実行
          for (int i=listMuneRelease.Count-1; i>=0; i--) { //逆順で実行 RemoveAtしているため
            OsawariRelease osawariRelease = listMuneRelease[i];
            osawariRelease.muneRelease();
            if (!osawariRelease.bActive) listMuneRelease.RemoveAt(i); //揺れが終わっていたら解放
          }

          //各osawariInputのおさわり処理を逆順で実行
      		for (int i=osawariInput.Length-1; i>=0; i--) { //逆順で実行 タッチ入れ替えのため
            osawariInput[i].osawariHand();
          }

        }

      } //class Osawari

      /// <summary>
      /// 胸揺れクラス
      /// おさわり処理とは非同期で実行 同じメイドの同じ胸を再び触ったらキャンセルする
      /// </summary>
      public class OsawariRelease
      {
        public bool bActive = true;

        Osawari osawari;

        public bool bLeft;
        public int osawariID;

        public MuneValue muneValue;
        public MuneOffset muneOffset;

        //胸の変更量 キャンセル時の復元で使う
        public Vector3 Mune_atp;

        //反覆運動計算用
        private float MuneX = 0f;
        private float MuneY = 0f;
        private float Mune_time = 0f;
        private float delta_x = 1.0f;
        private float delta_y = 1.0f;
        private float delta_time = 1.0f;

        public OsawariRelease(Osawari osawari, bool bLeft, int osawariID, MuneOffset muneOffset, Vector2 Mune_atp)
        {
          this.osawari = osawari;
          this.bLeft = bLeft;
          this.osawariID = osawariID;

          this.muneOffset = muneOffset;

          this.Mune_atp.x = Mune_atp.x;
          this.Mune_atp.y = Mune_atp.y;

          //初期化
          MuneX = Mune_atp.x;
          MuneY = Mune_atp.y;
          Mune_time = 0f;

          //胸の大きさスライダの値 0～100 範囲拡張あり 50が通常 胸が小さい場合はほぼ揺れないのであまり変動させない
          //timerRate / (60f + (float)maid.GetProp(MPN.MuneL).value * 0.5f);
          Maid maid = osawari.stockMaids[osawariID].mem;
          float muneSize = Math.Max(0, Math.Min(100, maid.GetProp(MPN.MuneL).value)); //0～100に制限
          muneSize = (float)Math.Sqrt(1f + (50f-muneSize)*0.01f);  //10=1.18 50=1.0 100=0.7

          //減少量係数 0～ 胸位置が1fなら1秒 ループ内でTime.deltaTimeと乗算
          delta_x = muneSize * (1f+Math.Abs(MuneX))*0.5f;
          delta_y = muneSize * (1f+Math.Abs(MuneY))*0.5f;
          delta_time = muneSize;

          this.bActive = true;
        }

        //おさわり開始されていたら非活性化して後で破棄
        public void muneRelease()
        {
          if (!bActive) return;

          //左右入れ替えの場合は開始時にキャンセルしているので不要
          /*if (osawari.isOsawari(osawariID, bLeft ? "ML_" : "MR_")) {
            bActive = false; return;
          }*/
          //胸揺れ処理 胸のサイズに連動
          if (MuneX > 0) MuneX = Math.Max(0f, MuneX - Time.deltaTime * delta_x);
          else if (MuneX < 0) MuneX = Math.Min(0f, MuneX + Time.deltaTime * delta_x);
          if (MuneY > 0) MuneY = Math.Max(0f, MuneY - Time.deltaTime * delta_y);
          else if (MuneY < 0) MuneY = Math.Min(0f, MuneY + Time.deltaTime * delta_y);

          float sin = (float)-Math.Sin(2 * Math.PI * 3 * Mune_time); //1秒に3周期
          Mune_time += Time.deltaTime * delta_time;

          Mune_atp.x = sin * MuneX;
          Mune_atp.y = sin * MuneY;

          //胸変形 共通関数利用
          MaidState maidState = osawari.maidsState[osawariID];
          if (bLeft) {
            osawari.muneMorphLeft(maidState.maid, maidState, Mune_atp.x, Mune_atp.y);
          } else {
            osawari.muneMorphRight(maidState.maid, maidState, -Mune_atp.x, Mune_atp.y); //xは反転
          }

          if (MuneX == 0 && MuneY == 0) bActive = false;
        }

        public void cancel()
        {
          this.bActive = false;
        }

      } //class OsawariRelease

      /// <summary>
      /// おさわり用VRコントローラーのWrapper
      /// </summary>
      public interface OsawariController
      {
        int getType(); //種別 1:Quest, 2:Vive
        bool GetDown();
        bool Get();
        bool GetUp();
        bool GetModeUp();
        Vector3 GetLocalControllerVelocity(); //コントローラーの移動量を取得
        void setStartHandPosition(); //おさわり開始時に呼び出す GetLocalControllerVelocityの前のフレームで実行
        Transform getHandAnchor(); //handAnchor取得
      }

#if UNITY_2022_3
      public class OsawariQuestController : OsawariController
      {
        private AVRControllerButtons.BTN viveButton;
        private OvrMgr.OvrObject.Controller viveController;
        private AVRControllerButtons.BTN viveModeButton;
        private Transform handAnchor;

        private Vector3 preHandPos;
        private Vector3 velocity;

        public OsawariQuestController(AVRControllerButtons.BTN viveButton, OvrMgr.OvrObject.Controller viveController, AVRControllerButtons.BTN viveModeButton, Transform handAnchor)
        {
          this.viveButton = viveButton;
          this.viveController = viveController;
          this.viveModeButton = viveModeButton;
          this.handAnchor = handAnchor;

          preHandPos = new Vector3(0,0,0);
          velocity = new Vector3(0,0,0);
        }
        public int getType() { return 1; }
        public bool GetDown() { return viveController.controller_buttons.GetPressDown(viveButton); }
        public bool Get() { return viveController.controller_buttons.GetPress(viveButton); }
        public bool GetUp() { return viveController.controller_buttons.GetPressUp(viveButton); }
        public bool GetModeUp() { return viveController.controller_buttons.GetPressUp(viveModeButton); }
        //前のフレームからの移動量 Questとyが逆で単位も1/100 同一フレームで複数回呼ばないこと
        public Vector3 GetLocalControllerVelocity() {
          if (GameMain.Instance.MainCamera.IsFadeOut()) {
            velocity.Set(0, 0, 0);
            setStartHandPosition();
            return velocity;
          }
          velocity.Set(preHandPos.x - handAnchor.position.x, handAnchor.position.y - preHandPos.y, preHandPos.z - handAnchor.position.z);
          preHandPos.Set(handAnchor.position.x, handAnchor.position.y, handAnchor.position.z);
          return velocity * 100f; //Quest側の単位に合わせる
        }
        public void setStartHandPosition() {
          preHandPos.Set(handAnchor.position.x, handAnchor.position.y, handAnchor.position.z);
        }
        //handAnchor取得
        public Transform getHandAnchor() { return this.handAnchor; }
      }

#else
      /// <summary>
      /// おさわり用VRコントローラー Quest用
      /// </summary>
      public class OsawariQuestController : OsawariController
      {
        private OVRInput.RawButton dragButton;
        private OVRInput.Controller dragController;
        private OVRInput.RawButton modeButton;
        private Transform handAnchor;

        public OsawariQuestController(OVRInput.RawButton dragButton, OVRInput.Controller dragController, OVRInput.RawButton modeButton, Transform handAnchor)
        {
          this.dragButton = dragButton;
          this.dragController = dragController;
          this.modeButton = modeButton;
          this.handAnchor = handAnchor;
        }
        public int getType() { return 1; }
        public bool GetDown() { return OVRInput.GetDown(dragButton, dragController); }
        public bool Get() { return OVRInput.Get(dragButton, dragController); }
        public bool GetUp() { return OVRInput.GetUp(dragButton, dragController); }
        public bool GetModeUp() { return OVRInput.GetUp(modeButton, dragController); }
        //右手座標でXが逆
        public Vector3 GetLocalControllerVelocity() { return OVRInput.GetLocalControllerVelocity(dragController); }
        public void setStartHandPosition() { }
        //handAnchor取得
        public Transform getHandAnchor() { return this.handAnchor; }
      }
#endif
      /// <summary>
      /// おさわり用VRコントローラー SteamVR用
      /// </summary>
      public class OsawariViveController : OsawariController
      {
        private AVRControllerButtons.BTN viveButton;
        private OvrMgr.OvrObject.Controller viveController;
        private AVRControllerButtons.BTN viveModeButton;
        private Transform handAnchor;

        private Vector3 preHandPos;
        private Vector3 velocity;

        public OsawariViveController(AVRControllerButtons.BTN viveButton, OvrMgr.OvrObject.Controller viveController, AVRControllerButtons.BTN viveModeButton)
        {
          this.viveButton = viveButton;
          this.viveController = viveController;
          this.viveModeButton = viveModeButton;
          this.handAnchor = viveController.controller.transform;
          preHandPos = new Vector3(0,0,0);
          velocity = new Vector3(0,0,0);

        }
        public int getType() { return 2; }
        public bool GetDown() { return viveController.controller_buttons.GetPressDown(viveButton); }
        public bool Get() { return viveController.controller_buttons.GetPress(viveButton); }
        public bool GetUp() { return viveController.controller_buttons.GetPressUp(viveButton); }
        public bool GetModeUp() { return viveController.controller_buttons.GetPressUp(viveModeButton); }
        //前のフレームからの移動量 Questとyが逆で単位も1/100 同一フレームで複数回呼ばないこと
        public Vector3 GetLocalControllerVelocity() {
          if (GameMain.Instance.MainCamera.IsFadeOut()) {
            velocity.Set(0, 0, 0);
            setStartHandPosition();
            return velocity;
          }
          velocity.Set(preHandPos.x - handAnchor.position.x, handAnchor.position.y - preHandPos.y, preHandPos.z - handAnchor.position.z);
          preHandPos.Set(handAnchor.position.x, handAnchor.position.y, handAnchor.position.z);
          return velocity * 100f; //Quest側の単位に合わせる
        }
        public void setStartHandPosition() {
          preHandPos.Set(handAnchor.position.x, handAnchor.position.y, handAnchor.position.z);
        }
        //handAnchor取得
        public Transform getHandAnchor() { return this.handAnchor; }
      }

      /// <summary>
      /// おさわり操作と変形を処理するクラス
      /// マウス、タッチパネル、Questコントローラーに対応
      /// </summary>
      public class OsawariInput
      {
        //コントローラーidx マウスは0 タッチはタッチ順に0,1 VRは左:0,右:1
        public int idx = 0;
        Osawari osawari;

        //VYM本体側にあわせる
        private bool bVR = false;

        //VRおさわり中のボタンとコントローラー
        OsawariController osawariController;

        public bool bLeft = false; //左手かどうか

        //外から参照される値
        public int osawariID = -1;
        public byte osawariLevel = 0;
        public string osawariPoint = "";
        public int osawariLock = 0;

        //osawariID変更時にメイドを設定しておく
        public Maid osawariMaid = null;
        public MaidState osawariMaidState = null;

        //レベル計算用移動量
        public float mouse_move = 0f;

        //タッチパネル用
        public bool touchActive = false;

        //内部で利用する変数
        private float sensitivity = 0.1f; // マウス感度
        private float vrSensitive = 0.2f; //VR動作感度 胸の動きに合わせる

        private Vector3 move = new Vector3(0f, 0f, 0f);
        private float moveCheck = 20f;
        //マウス位置への変形量 0f～1f
        public Vector3 Move_atp = new Vector3(0f, 0f, 0f);
        //胸の変形量 遅延変形用 0f～1f
        private Vector3 Mune_atp = new Vector3(0f, 0f, 0f);

        //private float holeSensitive = 5.0f; //感度増幅 前後の穴のみ VR以外は初期化時に1.0に戻す → cfgwに移動

        public float releaseDistance = 0.25f; //VR時 対象からこの距離離れたらマウスリリース扱い
        private float overlapRadius = 0.015f; //コントローラーの当たり判定半径
        public float osawariHandRadius = 0.015f; //手の当たり判定半径

        public float osawariHSliderMin = 20f; //終了時のスライダ最小値
        public float osawariASliderMin = 10f; //終了時のスライダ最小値

        //ターゲット名判別正規表現
        private Regex osawariReg = new Regex("^(MO|ML|MR|HL|HR|VA|AN)_", RegexOptions.Compiled);

        //おさわりしている対象
        private GameObject dragObject;

        //HMDの座標取得用transform
        Transform trackingSpaceTransform;
        Transform handAnchor;
        Transform handItem;

        //ボタンを押した時点のコントローラーの種類
        public int handType;
        //bool checkHandType = false;
        float checkHandTime = float.PositiveInfinity;

        //VR標準の胸変形コライダー 胸おさわり時は無効にする
        public SphereCollider touchCollider = null;

        //おさわりポイントの向き Bodyからの差分
        static readonly Quaternion rotMune = Quaternion.Inverse(new Quaternion(0.4f, -0.6f, -0.4f, 0.6f));
        static readonly Quaternion rotHead = Quaternion.Inverse(new Quaternion(-0.1f, 0.7f, 0.0f, 0.7f));
        static readonly Quaternion rotXxx = Quaternion.Inverse(new Quaternion(0.5f, -0.5f, -0.5f, 0.5f));

        //NonAllocの当たり判定返却用
        Collider[] collider = new Collider[5];

        #if DEBUG
        GameObject controller1;
        GameObject controller2;
        #endif


        /// <summary>コンストラクタ マウス・タッチ用</summary>
        /// <param name="idx">コントローラーidx マウスは0 タッチはタッチ順に0,1</param>
        /// <param name="osawari">各OsawariInputクラスを管理するクラス</param>
        public OsawariInput(int idx, Osawari osawari)
        {
          this.idx = idx;
          this.osawari = osawari;
          //VR以外は感度倍率を上げない
          //this.holeSensitive = 1.0f;
        }
        /// <summary>コンストラクタ Questコントローラー用</summary>
        /// <param name="idx">VRは左:0,右:1</param>
        /// <param name="osawari">各OsawariInputクラスを管理するクラス</param>
        /// <param name="osawariController">左右のコントローラー</param>
        public OsawariInput(int idx, Osawari osawari, bool bLeft, OsawariQuestController osawariController)
        {
          this.bVR = true;

          this.idx = idx;
          this.osawari = osawari;
          this.bLeft = bLeft;
          this.osawariController = osawariController;

          //VRのHMDとコントローラーのtransformをメンバ変数に保存 初回のみ
          //trackingSpaceTransform = GameMain.Instance.OvrMgr.OvrCamera.GetBaseHeadTransform(); → GripMoveの回転は取れない
          trackingSpaceTransform = GameObject.Find("TrackingSpace").transform;

          //handAnchor = trackingSpaceTransform.Find(bLeft ? "LeftHandAnchor": "RightHandAnchor");
          handAnchor = osawariController.getHandAnchor();

          //VR胸変形コライダー キャンセル用
          Transform touchSphere = handAnchor.Find("TouchSphere");
          if (touchSphere) touchCollider = touchSphere.gameObject.GetComponent<SphereCollider>();

          initVR();
        }

        /// <summary>コンストラクタ Viveコントローラー用</summary>
        /// <param name="idx">VRは左:0,右:1</param>
        /// <param name="osawari">各OsawariInputクラスを管理するクラス</param>
        /// <param name="osawariController">左右のコントローラー</param>
        public OsawariInput(int idx, Osawari osawari, bool bLeft, OsawariViveController osawariController)
        {
          this.bVR = true;

          this.idx = idx;
          this.osawari = osawari;
          this.bLeft = bLeft;
          this.osawariController = osawariController;

          //VRのHMDとコントローラーのtransformをメンバ変数に保存 初回のみ
          //trackingSpaceTransform = GameMain.Instance.OvrMgr.OvrCamera.GetBaseHeadTransform();
          trackingSpaceTransform = GameObject.Find("ViveCamBaseHead").transform;

          handAnchor = osawariController.getHandAnchor();

          //VR胸変形コライダー キャンセル用
          GameObject touchSphere = GameObject.Find("Controller (" + (bLeft ?  "left" : "right") + ")/TouchSphere");
          if (touchSphere) {
            touchCollider = touchSphere.GetComponent<SphereCollider>();
          }

          initVR();
        }

        private void initVR()
        {
          //手の種別取得用
          handItem = handAnchor.Find("HandItem");

          //設定値を格納
          releaseDistance = osawari.cfgw.osawariRelease;
          osawariHandRadius = osawari.cfgw.osawariHandRadius;
          osawariHSliderMin = osawari.cfgw.osawariHSliderMin;
          osawariASliderMin = osawari.cfgw.osawariASliderMin;
        }

        //おさわり中のシーン切り替え等があったら呼ぶ
        public void endOsawari()
        {
          //リリース処理
          if (osawariLock == 1 || osawariLock == 2 || osawariLock == 3) {
            Move_atp.x = 0f;
            Move_atp.y = 0f;
            Move_atp.z = 0f;
            Mune_atp.x = 0f;
            Mune_atp.y = 0f;
            Mune_atp.z = 0f;
            //胸の変形を初期化
            if (osawariPoint == "ML_") {
              OsawariRelease osawariRelease = osawari.getMuneRelease(true, osawariID);
              if (osawariRelease != null) osawariRelease.cancel();
              osawari.muneMorphLeft(osawariMaid, osawariMaidState, Move_atp.x, Move_atp.y);
              if (touchCollider != null && osawari.cfgw.muneTouchColliderEnabled) touchCollider.enabled = true; //VR用コライダー有効
              osawariPoint = "";
            } else if (osawariPoint == "MR_") {
              OsawariRelease osawariRelease = osawari.getMuneRelease(false, osawariID);
              if (osawariRelease != null) osawariRelease.cancel();
              osawari.muneMorphRight(osawariMaid, osawariMaidState, -Move_atp.x, Move_atp.y); //xは反転
              if (touchCollider != null && osawari.cfgw.muneTouchColliderEnabled) touchCollider.enabled = true; //VR用コライダー有効
              osawariPoint = "";
            }
            osawariLock = 3; //胸以外の変形初期化
          } else {
            osawariLock = 9;
          }
        }

        //コントローラーの種別を取得 0=Hand, 10=Light 11=Vibe 12=AnalVibe 20=Camera
        //毎フレーム実行しない
        private int getHandType()
        {
          //通常の手 "RightHandAnchor/HandPlayer"
          int handType = 0;
          Transform hand = handItem.Find("Sticklight");
          if (hand && hand.gameObject.activeInHierarchy) return 10;
          hand = handItem.Find("VR_HandItemR_VibePink");
          if (hand && hand.gameObject.activeInHierarchy) return 11;
          hand = handItem.Find("VR_HandItemR_AnalVibe");
          if (hand && hand.gameObject.activeInHierarchy) return 12;
          hand = handAnchor.Find("HandCamera");
          if (hand && hand.gameObject.activeInHierarchy) return 20;
          return handType;
        }

        //当たり判定カプセル用の相対位置 毎回newせずに使いまわす
        static readonly Vector3 vibePosL1 = new Vector3(-0.0005f, 0.0165f, 0.0125f); //バイブ付け根 左
        static readonly Vector3 vibePosR1 = new Vector3(-0.0015f, 0.017f, 0f); //バイブ付け根 右
        static readonly Vector3 vibePos2 = new Vector3(0f, -0.015f, -0.02f); //バイブ付け根 SteamVR用
        static readonly Vector3 cameraPosL = new Vector3( 0.025f, 0f, 0f); //カメラ画面中央 左
        static readonly Vector3 cameraPosR = new Vector3(-0.015f, 0f, 0f); //カメラ画面中央 右
        static readonly Vector3 handPosL = new Vector3(-0.02f, -0.01f, 0f); //親指付け根 左
        static readonly Vector3 handPosR = new Vector3( 0.02f, -0.01f, 0f); //親指付け根 右
        static readonly Vector3 vibeDirection = new Vector3(0f, 0f, 0.13f);
        static readonly Vector3 cameraDirection = new Vector3(0.03f, -0.15f, 0.04f);
        static readonly Vector3 handDirection = new Vector3(0f, -0.05f, -0.01f); //手のカプセル用の2つ目差分

        //コントローラー座標のカプセル形状内のColliderをすべて取得
        /// <param name="result">判定結果を格納する固定長の配列</param>
        private int getOverlapSphereCollider(Collider[] result)
        {
          //Vector3 controllerPos = OVRInput.GetLocalControllerPosition(controller); //HMDからの相対位置
          //controllerPos = trackingSpaceTransform.TransformPoint(controllerPos); //ワールド座標の位置に変換
          //Quaternion controllerRot = OVRInput.GetLocalControllerRotation(controller); //HMDからの相対回転
          Vector3 controllerPos = handAnchor.position;
          Quaternion controllerRot = handAnchor.rotation;

          //int handType = getHandType(); //開始時だけ取得
          float radius = overlapRadius;
          //判定位置調整
          Vector3 direction;
          switch (handType) {
          case 10: case 11: case 12://バイブ
            if (bLeft) {
              controllerPos += controllerRot * (osawariController.getType() == 1 ? vibePosL1 : vibePos2); //バイブ付け根 左
              direction = controllerRot * (handItem.localRotation * vibeDirection); //バイブ先端 左
            } else {
              controllerPos += controllerRot * (osawariController.getType() == 1 ? vibePosR1 : vibePos2); //バイブ付け根 右
              direction = controllerRot * (handItem.localRotation * vibeDirection); //バイブ先端 右
            }
            if (handType == 12) radius *= 0.5f; //AnalVibeは半分の細さにする
            break;
          case 20 : //Camera カメラ画面中央に移動
            if (osawariController.getType() == 1) {
              controllerPos += controllerRot * (bLeft ? cameraPosL : cameraPosR);
            } else {
              controllerPos -= controllerRot * (bLeft ? cameraPosL : cameraPosR);
            }
            direction = controllerRot * cameraDirection; //カメラ先端
            break;
          default:
            if (osawariController.getType() == 1) {
              controllerPos += controllerRot * (bLeft ? handPosL : handPosR); //手のひら原点を調整
            } else {
              controllerPos -= controllerRot * (bLeft ? handPosL : handPosR); //手のひら原点を調整
            }
            direction = controllerRot * handDirection; //中指付け根
            radius = osawariHandRadius;
            break;
          }
          Vector3 controllerPos2 = controllerPos + direction;

          #if DEBUG
          if (controller1 == null) {
            controller1 = GameObject.CreatePrimitive(PrimitiveType.Sphere);
            controller1.transform.localScale = new Vector3(overlapRadius*2, overlapRadius*2, overlapRadius*2);
            controller2 = GameObject.CreatePrimitive(PrimitiveType.Sphere);
            controller2.transform.localScale = new Vector3(overlapRadius*2, overlapRadius*2, overlapRadius*2);
          }
          controller1.transform.position = controllerPos;
          controller2.transform.position = controllerPos2;
          controller1.transform.localScale = new Vector3(radius*2, radius*2, radius*2);
          controller2.transform.localScale = new Vector3(radius*2, radius*2, radius*2);
          #endif

          //カプセル形状内のColliderをすべて取得 LayeMaskはレイヤ番号のビットを立てた値 8=256 9=512
          return Physics.OverlapCapsuleNonAlloc(controllerPos, controllerPos2, radius, result, 256, QueryTriggerInteraction.Collide);
        }

        string getHitPoint(string hitName)
        {
          if (hitName.Length > 3) return hitName.Substring(0, 3);
          return "";
        }

        void startMuneL(Maid maid)
        {
          OsawariRelease osawariRelease = osawari.getMuneRelease(true, osawariID);
          if (osawariRelease != null) {
            //胸揺れ中なら値を取得してキャンセル
            this.Mune_atp.x = osawariRelease.Mune_atp.x;
            this.Mune_atp.y = osawariRelease.Mune_atp.y;
            osawariRelease.cancel();
          } else {
            if (osawariMaidState.muneValue == null) osawariMaidState.muneValue = new MuneValue(maid);
            Mune_atp.x = 0f; Mune_atp.y = 0f; Mune_atp.z = 0f;
          }
          Move_atp.x = 0f; Move_atp.y = 0f; Move_atp.z = 0f;
        }

        void startMuneR(Maid maid)
        {
          OsawariRelease osawariRelease = osawari.getMuneRelease(false, osawariID);
          if (osawariRelease != null) {
            //胸揺れ中なら値を取得してキャンセル
            this.Mune_atp.x = osawariRelease.Mune_atp.x;
            this.Mune_atp.y = osawariRelease.Mune_atp.y;
            osawariRelease.cancel();
          } else {
            if (osawariMaidState.muneValue == null) osawariMaidState.muneValue = new MuneValue(maid);
            Mune_atp.x = 0f; Mune_atp.y = 0f; Mune_atp.z = 0f;
          }
          Move_atp.x = 0f; Move_atp.y = 0f; Move_atp.z = 0f;
        }

        //おさわり処理 (オリジナルの osawariHand() の処理)
        public void osawariHand()
        {
          if (osawariLock == 0) {

            int hitMaidID = -1;
            string hitPoint = "";

            if (bVR) {
              if (osawariController.GetDown()) {
                handType = getHandType(); //コントローラーの種類を取得
              }
              if (osawari.cfgw.osawariAlways) {
                if (checkHandTime > Time.time) {
                  handType = getHandType(); //コントローラーの種類を取得
                } else if (osawariController.GetModeUp()) {
                  //モードチェンジ後に取得
                  checkHandTime = Time.time+1; //1秒後
                }
              }
              //VRコントローラーのボタンが押されている、または常時おさわり
              if (osawari.cfgw.osawariAlways || osawariController.Get()) {
                int length = getOverlapSphereCollider(collider);
                for (int i=0; i<length; i++) {
                  string name = collider[i].gameObject.name;
                  if (osawariReg.IsMatch(name)) {
                    hitMaidID = intCnv(osawariReg.Replace(name, ""));
                    hitPoint = getHitPoint(name);
                    //他のコントローラで選択中なら無視する
                    if (osawari.isOsawari(hitMaidID, hitPoint)) {
                      hitPoint = "";
                    } else {
                      dragObject = collider[i].gameObject;
                      osawariController.setStartHandPosition();
                      break;
                    }
                  }
                }
              }
            } else {
              bool mousedown = false;
              Vector3 mosuePosition = Vector3.zero;
              if (Input.touchCount > idx) {
                Touch touch = Input.GetTouch(idx);
                //感度が悪いのでBegan以外も取得
                if (touch.phase == UnityEngine.TouchPhase.Began || touch.phase == UnityEngine.TouchPhase.Moved || touch.phase == UnityEngine.TouchPhase.Stationary) {
                  mousedown = true;
                  mosuePosition = touch.position;
                }
              } else if (idx == 0 && Input.GetMouseButtonDown(0)) {
                mousedown = true;
                mosuePosition = Input.mousePosition;
              }
              if (mousedown) {
                Ray ray = Camera.main.ScreenPointToRay(mosuePosition);
                RaycastHit hit;
                if (Physics.Raycast(ray, out hit)) {
                  string name = hit.collider.gameObject.name;
                  if (osawariReg.IsMatch(name)) {
                    hitMaidID = intCnv(osawariReg.Replace(name, ""));
                    hitPoint = getHitPoint(name);
                    if (Input.touchCount > idx) { //マルチタッチの場合は排他
                      if (osawari.isOsawari(hitMaidID, hitPoint)) {
                        hitPoint = "";
                      } else {
                        touchActive = true;
                      }
                    }
                  }
                }
              }
            }
            if (hitPoint != "") {

                osawariID = hitMaidID;
                osawariPoint = hitPoint;
                //変数に格納
                osawariMaid = osawari.stockMaids[osawariID].mem;
                osawariMaidState = osawari.maidsState[osawariID];
                
                //if (isMouseDown) {
                  osawariLock = 1;
                  //osawariID = intCnv(osawariReg.Replace(hitName, ""));

                  if (hitPoint.StartsWith("ML_")) {
                    startMuneL(osawariMaid);
                    if (touchCollider != null) touchCollider.enabled = false; //VR用コライダー無効
                  }
                  else if (hitPoint.StartsWith("MR_")) {
                    startMuneR(osawariMaid);
                    if (touchCollider != null) touchCollider.enabled = false; //VR用コライダー無効
                  }

                  //checkBlowjobing(osawariID);
                  if (!osawariMaidState.stunFlag && osawariMaidState.bIsBlowjobing != 2) osawariMaid.EyeToCamera((Maid.EyeMoveType)5, 0.8f);
                  //if (maidsState[osawariID].vStateMajor == 10) ReactionPlay(osawariID);
                //}
            }

          } else if (osawariLock == 1) {

            //マウスリリース判定
            bool bUp = false;
            //マウスドラッグ判定
            bool bDrag = false;

            if (bVR) {
              if (osawariController.GetUp() && !osawari.cfgw.osawariAlways) {
                bUp = true;
              } else if (osawari.cfgw.osawariAlways || osawariController.Get()) {
                bDrag = true;
                //対象から離れたらマウスリリース扱いにする
                if (releaseDistance < Vector3.Distance(dragObject.transform.position, handAnchor.position)) {
                  bDrag = false;
                  bUp = true;
                } else {
                  bool muneLtoR = false;
                  bool muneRtoL = false;
                  bool onMuneL = false;
                  bool onMuneR = false;
                  //別のメイドのおさわりポイントにヒットでマウスリリース扱いにする 胸の左右は入れ替える
                  int length = getOverlapSphereCollider(collider);
                  for (int i=0; i<length; i++) {
                    string name = collider[i].gameObject.name;
                    if (osawariReg.IsMatch(name)) {
                      //他のメイド
                      if (osawariID != intCnv(osawariReg.Replace(name, ""))) {
                        bDrag = false;
                        bUp = true;
                        muneRtoL = false;
                        muneLtoR = false;
                        break;
                      }
                      //胸 左右入れ替えチェック（重なっているかもチェック）
                      if (name.StartsWith("ML_")) {
                        onMuneL = true;
                        if (osawariPoint == "MR_" && !osawari.isOsawari(osawariID, "ML_")) muneRtoL = true;
                      }
                      if (name.StartsWith("MR_")) {
                        onMuneR = true;
                        if (osawariPoint == "ML_" && !osawari.isOsawari(osawariID, "MR_")) muneLtoR = true;
                      }
                    }
                  }
                  //胸入れ替え実行 重なっていたら入れ替えない
                  if (muneLtoR && !onMuneL) {
                    bDrag = false;
                    //左リリース
                    osawari.addMuneRelease(new OsawariRelease(osawari, true, osawariID, osawariMaidState.muneOffsetL, Mune_atp));
                    osawariPoint = "MR_";
                    dragObject = osawariMaidState.targetSphere_muneR; //VRの距離判定用
                    startMuneR(osawariMaid);
                  } else if (muneRtoL && !onMuneR) {
                    bDrag = false;
                    //右リリース
                    osawari.addMuneRelease(new OsawariRelease(osawari, false, osawariID, osawariMaidState.muneOffsetR, Mune_atp));
                    osawariPoint = "ML_";
                    dragObject = osawariMaidState.targetSphere_muneL; //VRの距離判定用
                    startMuneL(osawariMaid);
                  }
                }
              } else {
                bUp = true;
              }
            } else {
              if (Input.touchCount > idx) {
                Touch touch = Input.GetTouch(idx);
                if (touch.phase == UnityEngine.TouchPhase.Ended || touch.phase == UnityEngine.TouchPhase.Canceled) {
                  bUp = true;
                  touchActive = false;
                } else {
                  if (touch.phase == UnityEngine.TouchPhase.Moved || touch.phase == UnityEngine.TouchPhase.Stationary) {
                    bDrag = true;

                    Ray ray = Camera.main.ScreenPointToRay(touch.position);
                    RaycastHit hit;
                    if (Physics.Raycast(ray, out hit)) {
                      string name = hit.collider.gameObject.name;
                      //他のメイド
                      if (osawariID != intCnv(osawariReg.Replace(name, ""))) {
                        bDrag = false;
                        bUp = true;
                      }
                      //胸 左右入れ替え
                      else if (osawariPoint == "ML_" && name.StartsWith("MR_") && !osawari.isOsawari(osawariID, "MR_")) {
                        bDrag = false;
                        //左リリース
                        osawari.addMuneRelease(new OsawariRelease(osawari, true, osawariID, osawariMaidState.muneOffsetL, Mune_atp));
                        osawariPoint = "MR_";
                        startMuneR(osawariMaid);
                      }
                      else if (osawariPoint == "MR_" && name.StartsWith("ML_") && !osawari.isOsawari(osawariID, "ML_")) {
                        bDrag = false;
                        //右リリース
                        osawari.addMuneRelease(new OsawariRelease(osawari, false, osawariID, osawariMaidState.muneOffsetR, Mune_atp));
                        osawariPoint = "ML_";
                        startMuneL(osawariMaid);
                      }
                    }
                  }
                }
              } else {
                if (Input.GetMouseButtonUp(0)) {
                  bUp = true;
                } else {
                  bDrag = Input.GetMouseButton(0);
                }
              }
            }

            //マウスリリース時の処理
            if (bUp) {
              //胸の戻りをメイドの各胸ごとに登録する
              if (osawariPoint == "ML_") {
                osawariPoint = "";
                osawari.addMuneRelease(new OsawariRelease(osawari, true, osawariID, osawariMaidState.muneOffsetL, Mune_atp));
                if (touchCollider != null && osawari.cfgw.muneTouchColliderEnabled) touchCollider.enabled = true; //VR用コライダー有効
              } else if (osawariPoint == "MR_") {
                osawariPoint = "";
                osawari.addMuneRelease(new OsawariRelease(osawari, false, osawariID, osawariMaidState.muneOffsetR, Mune_atp));
                if (touchCollider != null && osawari.cfgw.muneTouchColliderEnabled) touchCollider.enabled = true; //VR用コライダー有効
              }
              osawariLock = 3; //ドラッグ終了
            }
            //マウスドラッグ時の処理
            else if (bDrag) {
              //マウスの移動値取得
              if (moveCheck > 0f) {
                float moveRate = osawari.cfgw.osawariMoveRate;
                Quaternion bodyRot; //体の回転
                if (osawariPoint == "ML_" || osawariPoint == "MR_") {
                  bodyRot = osawariMaidState.maidMune.rotation * rotMune;
                  moveRate *= 0.5f; //胸の移動量は半分に調整
                } else if (osawariPoint == "MO_") {
                  bodyRot = osawariMaidState.maidHead.rotation * rotHead;
                } else { //"VA_", "AN_"
                  bodyRot = osawariMaidState.maidXxx.rotation * rotXxx;
                }
                if (bVR) {
                  Vector3 vec = osawariController.GetLocalControllerVelocity();

                  //おさわりポイントの向き成分のXYに変換 基本立ちのrotationのInverseをかけてBodyと同じ(0,0,0,0)にする
                  vec = trackingSpaceTransform.rotation * vec; //HMD向き
                  vec = Quaternion.Inverse(bodyRot) * vec;

                  moveRate *= vrSensitive;
                  //シェイプキー操作用の値
                  Move_atp.x = Move_atp.x - vec.x * moveRate; //Xは右手系なので左右反転
                  Move_atp.y = Move_atp.y + vec.y * moveRate;
                  //Move_atp.z = Move_atp.z + vec.z * moveRate;

                  move.x += System.Math.Abs(vec.x * moveRate);
                  move.y += System.Math.Abs(vec.y * moveRate);
                  move.z += System.Math.Abs(vec.z * moveRate);
                } else {
                  float mouseX = 0, mouseY = 0;
                  if (Input.touchCount > idx) {
                    //マウスより感度は下げる
                    mouseX = Input.touches[idx].deltaPosition.x * 0.2f;
                    mouseY = Input.touches[idx].deltaPosition.y * 0.2f;
                  } else {
                    mouseX = Input.GetAxis("Mouse X");
                    mouseY = Input.GetAxis("Mouse Y");
                  }
                  //メイドの向きにあわせたXY成分を取得
                  Vector3 vec = Quaternion.Inverse(bodyRot) * Camera.main.transform.rotation * new Vector3(mouseX, mouseY, 0);
                  mouseX = -vec.x; //Xは逆
                  if (osawariPoint == "VA_" || osawariPoint == "AN_") {
                    Vector3 vec2 = Quaternion.Inverse(bodyRot) * Camera.main.transform.rotation * new Vector3(mouseX, 0, mouseY); //Z軸のほうが大きければ入れ替え
                    if (Math.Abs(vec.y) < Math.Abs(vec2.y)) mouseY = vec2.y;
                    else mouseY = vec.y;
                  } else {
                    mouseY = vec.y;
                  }
                  moveRate *= sensitivity;
                  //シェイプキー操作用の値
                  Move_atp.x = Move_atp.x + mouseX * moveRate;
                  Move_atp.y = Move_atp.y + mouseY * moveRate;
                  //Move_atp.z = Move_atp.z + vec.z * moveRate;

                  move.x += System.Math.Abs(mouseX * moveRate);
                  move.y += System.Math.Abs(mouseY * moveRate);
                }

                moveCheck -= Time.deltaTime * 60;

              } else {
                mouse_move = (mouse_move + Math.Max(Math.Max(move.x, move.y) ,move.z)) * 0.5f;
                move.x = 0f;
                move.y = 0f;
                move.z = 0f;
                moveCheck = 20f;

                //おさわりレベル判定 キャッシュも更新
                float mm = osawari.getMouseMove(osawariID);
                //感度増幅
                mm *= this.osawari.cfgw.osawariSensitive;
                if (osawariPoint == "VA_" || osawariPoint == "AN_") {
                  mm *= this.osawari.cfgw.osawariHoleSensitive;
                }
                if (osawariLevel == 0) {
                  if (mm > 2f) {
                    osawariLevel = 1;
                    osawari.updateMaidOsawariLevel(osawariID);
                  }
                } else if (osawariLevel == 1) {
                  if (mm < 0.5f) {
                    osawariLevel = 0;
                    osawari.updateMaidOsawariLevel(osawariID);
                  } else if (mm > 4f) {
                    osawariLevel = 2;
                    osawari.updateMaidOsawariLevel(osawariID);
                  }
                } else if (osawariLevel == 2) {
                  if (mm < 2f) {
                    osawariLevel = 1; osawari.updateMaidOsawariLevel(osawariID);
                  }
                }

              }
            }

          }

          if (osawariLock == 1) { //変形処理

            TBody body0 = osawariMaid.body0;

            //おさわりポイント別の変形処理
            if (osawariPoint == "VA_") {
              float x = Move_atp.x = Math.Max(-1f, Math.Min(1f, Move_atp.x)); //xは-1～1に毎回置き換え
              float y = Math.Max(-1f, Math.Min(1f, Move_atp.y*0.5f)); //Y方向は移動量を調整 -1～1以上も保持する
              //float z = Move_atp.z = Math.Max(-1f, Math.Min(1f, Move_atp.z)); //zは-1～1に毎回置き換え

              //try { VertexMorph_FromProcItem(body0, "atp_vagina", (y - 1f) * -0.5f); } catch { /*LogError(ex);*/ }
              //"kupa"がhibuValueで広がっているのでY方向の最大値は調整
              float kupa = 0.60f;
              if (osawariMaidState.vStateMajor != 10) { kupa = Math.Max(0f, kupa - osawariMaidState.hibuValue * 0.01f); }
              try { VertexMorph_FromProcItem(body0, "vaginakupa", (y - 0.2f) * kupa / 0.8f); } catch { /*LogError(ex);*/ } //20%入るまで広げない
              try { VertexMorph_FromProcItem(body0, "labiakupa_dia", (x*x)*0.2f + y * kupa ); } catch { /*LogError(ex);*/ }
              //左右kupa Yにあわせて狭める 1～1/2
              kupa = 0.4f / (1f+Math.Max(0, y)*2f);
              if (x >= 0) try { VertexMorph_FromProcItem(body0, "labiakupa_dia_L", (x*x) * kupa); } catch { /*LogError(ex);*/ }
              if (x < 0)  try { VertexMorph_FromProcItem(body0, "labiakupa_dia_R", (x*x) * kupa); } catch { /*LogError(ex);*/ }

              //スライダ最小値調整 Yに応じて設定
              if (osawariMaidState.hibuSlider1Value < osawariHSliderMin * y) osawariMaidState.hibuSlider1Value = osawariHSliderMin * y;
              if (osawariMaidState.hibuSlider2Value < osawariHSliderMin * y) osawariMaidState.hibuSlider2Value = osawariHSliderMin * y;

              //骨盤の前後 XZ 親のBoneの向き Bip01 L Thigh Bip01 R Thigh も一緒に動いてしまう
              //osawariMaidState.maidXxx.transform.localPosition = Quaternion.Inverse(rotXxx) * new Vector3(
              //  (float)(x > 0 ? -Math.Sqrt(x) : Math.Sqrt(-x)) *0.001f, 0f, (float)(z > 0 ? Math.Sqrt(z) : -Math.Sqrt(-z))*0.003f
              //);
            }

            else if (osawariPoint == "ML_") {
              Move_atp.x = Math.Max(-1f, Math.Min(1f, Move_atp.x));
              Move_atp.y = Math.Max(-1f, Math.Min(1f, Move_atp.y));
              //毎フレーム1/5だけ移動
              if (Math.Abs(Move_atp.x - Mune_atp.x) > 0.001f) Mune_atp.x += Math.Min(0.05f, (Move_atp.x - Mune_atp.x) * 0.2f) * Time.deltaTime * 120f;
              if (Math.Abs(Move_atp.y - Mune_atp.y) > 0.001f) Mune_atp.y += Math.Min(0.05f, (Move_atp.y - Mune_atp.y) * 0.2f) * Time.deltaTime * 120f;
              //胸変形 共通関数利用
              osawari.muneMorphLeft(osawariMaid, osawariMaidState, Move_atp.x, Move_atp.y);
            }

            else if (osawariPoint == "MR_") {
              Move_atp.x = Math.Max(-1f, Math.Min(1f, Move_atp.x));
              Move_atp.y = Math.Max(-1f, Math.Min(1f, Move_atp.y));
              //毎フレーム1/5だけ移動
              if (Math.Abs(Move_atp.x - Mune_atp.x) > 0.001f) Mune_atp.x += Math.Min(0.05f, (Move_atp.x - Mune_atp.x) * 0.2f) * Time.deltaTime * 120f;
              if (Math.Abs(Move_atp.y - Mune_atp.y) > 0.001f) Mune_atp.y += Math.Min(0.05f, (Move_atp.y - Mune_atp.y) * 0.2f) * Time.deltaTime * 120f;
              //胸変形 共通関数利用
              osawari.muneMorphRight(osawariMaid, osawariMaidState, -Move_atp.x, Move_atp.y); //xは反転
            }

            else if (osawariPoint == "HL_" || osawariPoint == "HR_") {
              Move_atp.x = Math.Max(-1f, Math.Min(1f, Move_atp.x));
              Move_atp.y = Math.Max(-1f, Math.Min(1f, Move_atp.y));
              float hipX = osawariPoint == "HL_" ? Move_atp.x : -Move_atp.x;

              try {
                if (osawari.cfgw.osawariMoveHipCkackT1 > 0f)VertexMorph_FromProcItem(body0, "hip_crack_t1", -hipX * osawari.cfgw.osawariMoveHipCkackT1);
                if (osawari.cfgw.osawariMoveHipTypeA > 0f) VertexMorph_FromProcItem(body0, "hip_type_A", Move_atp.y * osawari.cfgw.osawariMoveHipTypeA);
                if (osawari.cfgw.osawariMoveHipTypeV > 0f)VertexMorph_FromProcItem(body0, "hip_type_V", -hipX * osawari.cfgw.osawariMoveHipTypeV);
                if (osawari.cfgw.osawariMoveSlimHip1 > 0f)VertexMorph_FromProcItem(body0, "slim_hip1", Move_atp.y * osawari.cfgw.osawariMoveSlimHip1);
                if (osawari.cfgw.osawariMoveSlimHip2 > 0f)VertexMorph_FromProcItem(body0, "slim_hip2", Move_atp.y * osawari.cfgw.osawariMoveSlimHip2);
                if (osawari.cfgw.osawariMoveSlimOsihri > 0f)VertexMorph_FromProcItem(body0, "slim_oshiri", (float)Math.Sqrt(Move_atp.y*Move_atp.y + Move_atp.x*Move_atp.x) * osawari.cfgw.osawariMoveSlimOsihri);
                if (osawari.cfgw.osawariMoveDebuPelvisX > 0f)VertexMorph_FromProcItem(body0, "debu_pelvis_x", hipX * osawari.cfgw.osawariMoveDebuPelvisX);
              } catch { /*LogError(ex);*/ }
            }

            else if (osawariPoint == "AN_") {
              Move_atp.x = Math.Max(-1f, Math.Min(1f, Move_atp.x)); //xは-1～1に毎回置き換え
              float y = Math.Max(-1f, Math.Min(1f, Move_atp.y*0.5f)); //Y方向は移動量を調整 -1～1以上も保持する
              try { VertexMorph_FromProcItem(body0, "anal_swell2", (y) * -0.5f); } catch { /*LogError(ex);*/ }
              try { VertexMorph_FromProcItem(body0, "anal_swell3", (y - 1f) * -0.5f); } catch { /*LogError(ex);*/ }

              //スライダ最小値調整 Yに応じて設定
              if (osawariMaidState.analSlider1Value < osawariASliderMin * y) osawariMaidState.analSlider1Value = osawariASliderMin * y;
              if (osawariMaidState.analSlider2Value < osawariASliderMin * y) osawariMaidState.analSlider2Value = osawariASliderMin * y;
            }

          }

          else if (osawariLock == 3) { //変形を初期化する処理

            TBody body0 = osawariMaid.body0;

            if (osawariPoint == "VA_") {
              //try { VertexMorph_FromProcItem(maid.body0, "atp_vagina", 0f); } catch { /*LogError(ex);*/ }
              try { VertexMorph_FromProcItem(body0, "vaginakupa", 0f); } catch { /*LogError(ex);*/ }
              try { VertexMorph_FromProcItem(body0, "labiakupa_dia", 0f); } catch { /*LogError(ex);*/ }
              try { VertexMorph_FromProcItem(body0, "labiakupa_dia_L", 0f); } catch { /*LogError(ex);*/ }
              try { VertexMorph_FromProcItem(body0, "labiakupa_dia_R", 0f); } catch { /*LogError(ex);*/ }
              //腰の前後
              //osawariMaidState.maidXxx.transform.localPosition = Vector3.zero;

            } else if (osawariPoint == "AN_") {
              try { VertexMorph_FromProcItem(body0, "anal_swell2", 0f); } catch { /*LogError(ex);*/ }
              try { VertexMorph_FromProcItem(body0, "anal_swell3", 0f); } catch { /*LogError(ex);*/ }

            } else if (osawariPoint == "HL_" || osawariPoint == "HR_") {
              try { VertexMorph_FromProcItem(body0, "hip_type_A", 0f); } catch { /*LogError(ex);*/ }
              try { VertexMorph_FromProcItem(body0, "hip_type_V", 0f); } catch { /*LogError(ex);*/ }
              try { VertexMorph_FromProcItem(body0, "hip_crack_t1", 0f); } catch { /*LogError(ex);*/ }
              try { VertexMorph_FromProcItem(body0, "slim_hip1", 0f); } catch { /*LogError(ex);*/ }
              try { VertexMorph_FromProcItem(body0, "slim_hip2", 0f); } catch { /*LogError(ex);*/ }
              try { VertexMorph_FromProcItem(body0, "slim_oshiri", 0f); } catch { /*LogError(ex);*/ }
              try { VertexMorph_FromProcItem(body0, "debu_pelvis_x", 0f); } catch { /*LogError(ex);*/ }
            }
            //胸は別処理 MuneOsawariクラスで戻す

            //LateUpdate()で変形のFixがあるので一応次フレームで終了処理
            osawariLock = 9;

          }

          else if (osawariLock == 9) {
            //我慢チェック用
            int maidID = osawariID;
            //停止前に我慢中かチェック
            bool bGaman = maidID != -1 && osawari.cfgw.osawariGamanLevel > 0 && osawari.cfgw.osawariGamanLevel >= osawari.getOsawariLevel(maidID);

            //おさわり終了処理
            osawariLevel = 0;
            if (osawariID != -1) osawari.updateMaidOsawariLevel(osawariID); //終了時は逆の手もチェックしてレベル更新
            osawariLock = 0;
            osawariID = -1;
            osawariPoint = "";
            mouse_move = 0f;
            Move_atp.x = 0f;
            Move_atp.y = 0f;
            Move_atp.z = 0f;
            Mune_atp.x = 0f;
            Mune_atp.y = 0f;
            Mune_atp.z = 0f;

            osawariMaid = null;
            osawariMaidState = null;

            //おさわり我慢中でメイドへおさわりしていない
            if (bGaman && !osawari.isOsawari(maidID)) {
              MaidState maidState = osawari.maidsState[maidID];
              //バイブ停止中
              if (maidState.vLevel == 0) {
                maidState.vStateMajor = 40; //余韻に変更
                maidState.yoinHoldTime = 120f;
              }
            }
            //おさわりで股間を触っていない & すべてのメイドのバイブが止まっていたらSE終了
            if (!osawari.isOsawariKokan() && osawari.getMaidVibeLevel() == 0) {
              GameMain.Instance.SoundMgr.StopSe();
            }

          }

        } //osawariHand()


        //int変換
        private int intCnv(string s) {
          int i;
          if (int.TryParse(s, out i)) return i;
          else return 0;
        }

      } //class OsawariInput

      //おさわり処理関係終了-----------------------

      //-------------------------------------------------
      //外部操作 APIクラスから呼び出すメソッド

      /// <summary>バージョン取得</summary>
      public string vymGetVersion()
      {
        return PluginVersion;
      }

      /// <summary>設定取得</summary>
      public VibeYourMaidCfgWriting vymGetConfig()
      {
        return cfgw;
      }
      /// <summary>設定再読込後の初期化処理を実行</summary>
      public void vymInitConfig()
      {
        initConfig();
      }
      /// <summary>メインメイドのMaid取得</summary>
      public Maid vymGetMainMaid()
      {
        if (!cfgw.bPluginEnabledV) return null;
        int mainID = tgID;
        if (mainID == -1) return null;
        return stockMaids[mainID].mem;
      }
      /// <summary>正面のメイドの取得</summary>
      public Maid vymGetFrontMaid()
      {
        if (!cfgw.bPluginEnabledV) return null;
        int mainID = tgID; //メインメイド
        if (mainID == -1) return null;
        mainID = GetLookingkMaidID(45f); //正面にいるメイド取得
        return stockMaids[mainID].mem;
      }
      /// <summary>リンクに応じたメイドをすべて取得</summary>
      public List<Maid> vymGetMaidList(int linkType)
      {
        int mainID = vymMaidID();
        if (mainID == -1) return null;

        List<Maid> maidList =  new List<Maid>();
        foreach (int maidID in vymMaidIDList(mainID, linkType)) { //リンクメイド対応
          maidList.Add(stockMaids[maidID].mem);
        }
        return maidList;
      }
      /// <summary>メインメイドのMaidState取得</summary>
      public MaidState vymGetMainMaidState()
      {
        if (!cfgw.bPluginEnabledV) return null;
        int mainID = tgID;
        if (mainID == -1) return null;
        return maidsState[mainID];
      }

      /// <summary>名前に対応したメイドをメインメイドに選択</summary>
      public void vymSelectMaidName(string name)
      {
        foreach (int maidID in vmId) {
          #if DEBUG
          Debug.Log("vymSelectMaidName("+name+") "+stockMaids[maidID].mem.status.lastName+" "+stockMaids[maidID].mem.status.firstName);
          #endif
          if (name == stockMaids[maidID].mem.status.lastName+" "+stockMaids[maidID].mem.status.firstName) {
            tgID = maidID;
            return;
          }
        }
      }

      /// <summary>VRの場合は見ているメイドをメインメイドに選択</summary>
      public void vymSelectFrontMaid()
      {
        if (!cfgw.bPluginEnabledV) return;
        int mainID = tgID; //メインメイド
        if (mainID == -1) return;
        mainID = GetLookingkMaidID(45f); //正面にいるメイド取得
        tgID = mainID;
      }
      /// <summary>
      /// メインメイドと他のメイドをリンク + モーション同期
      /// </summary>
      public void vymMaidLink(string type)
      {
        int mainID = tgID;
        if (mainID == -1) return;

        if (type == "all") {
          foreach (int maidID in vmId) {
            if (maidID == mainID) maidsState[maidID].linkID = -1; //自分は解除
            else maidsState[maidID].linkID = mainID;
          }
        } else if (type == "null") {
          //モーションアジャストのサブメイドのリンクも解除
          maidsState[mainID].linkID = -1;
          maidsState[mainID].motionLinkID = -1;
          foreach (int maidID in vmId) {
            if (maidsState[maidID].linkID == mainID) maidsState[maidID].linkID = -1;
            if (maidsState[maidID].motionLinkID == mainID) maidsState[maidID].motionLinkID = -1;
          }
        } else if (type == "left") {
          //左のメイド
          int maidID = GetSideMaid(tgID, mainCamera.GetRealHeadTransform(), true, false);
          if (maidID != mainID) maidsState[maidID].linkID = mainID;
        } else if (type == "right") {
          //右のメイド
          int maidID = GetSideMaid(tgID, mainCamera.GetRealHeadTransform(), false, false);
          if (maidID != mainID) maidsState[maidID].linkID = mainID;
        } else if (type == "sync") {
          //モーションを同期 リンクしたメイドと男
          syncMotionAnimeTime(mainID, false, true);
        }
      }

      /// <summary>前のメイド</summary>
      public void vymPrevMaid(bool camChange)
      {
        if (!cfgw.bPluginEnabledV) return;
        changePrevMaid(camChange, false);
      }
      /// <summary>次のメイド</summary>
      public void vymNextMaid(bool camChange)
      {
        if (!cfgw.bPluginEnabledV) return;
        changeNextMaid(camChange, false);
      }
      /// <summary>左のメイド</summary>
      public void vymLeftMaid(bool camChange)
      {
        if (!cfgw.bPluginEnabledV) return;
        changePrevMaid(camChange, true);
      }
      /// <summary>右のメイド</summary>
      public void vymRightMaid(bool camChange)
      {
        if (!cfgw.bPluginEnabledV) return;
        changeNextMaid(camChange, true);
      }

      /// <summary>男を非表示</summary>
      public void vymManVisible(int manVisible)
      {
        bool visible = true;
        if (manVisible < 0) {
          visible = false;
          manVisible *= -1;
        }

        for (int im = 0; im < SubMans.Length; im++) {
          if ((manVisible & 1) == 1) {
            if (visible) {
              if (!isSubManVisible(im)) MansVisible(im); //非表示なら表示させる
            } else {
              setSubManVisible(im, false);
              checkFpsMan(); //一人称対象を再チェック
            }
          }
          manVisible = manVisible >> 1; //右にシフト
        }
      }

      /// <summary>RoomBaseを移動する VRのRoomBase移動のみ</summary>
      public void vymCamMove(Vector3 move, bool useMoveValue)
      {
        if (vrShortCutController.vrCameraOrigin == null) return;
        if (useMoveValue) move *= moveValue;
        //頭の向きに合わせる
        vrShortCutController.vrCameraOrigin.position += vrShortCutController.headTransform.rotation * move;
      }

      /// <summary>メインメイドとの距離を変更する メイド固定の注視点が正面になる</summary>
      public void vymCamDistance(float distance, int moveType)
      {
        int mainID = tgID;
        if (mainID == -1) return;
        MaidState maidState = maidsState[mainID];

        //GripMoveの移動をリセット
        if (bVR && vrShortCutController.trRoomBase) resetRoomBase(vrShortCutController.trRoomBase);
        Vector3 realPos = mainCamera.GetRealHeadTransform().position;

        float maidDistance;

        if (maidFollowEnabled) {
          //メイド固定中は距離の変更のみ
          maidDistance = mainCamera.GetDistance();
          if (bVR) maidDistance /= cfgw.vrCamSetDistanceAdjust; //VRは2倍なっているので半分に戻す
        } else {
          //メイドの注視点をターゲットにする
          Transform maidObj = getMaidLookpointTransform(mainID);
          if (maidObj) {
            mainCamera.SetTargetPos(maidObj.transform.position, true);
            //回転を現在位置とTargetの向きに合わせる
            Vector3 targetPos = maidObj.position;
            Vector3 up = Vector3.Normalize(maidState.maidHead.position - maidState.maidMune.position); //頭と胸の方向 //-maidObj.right; //頭の上
            setTargetAroundAngle(targetPos - realPos, 0, up); //回転は再調整
            maidDistance = Vector3.Distance(targetPos, realPos); //距離は現在位置から
          } else {
            Vector3 targetPos = mainCamera.GetTargetPos();
            maidDistance = Vector3.Distance(targetPos, realPos); //距離は現在位置から
          }
        }

        if (moveType == 2) maidDistance += Math.Max(0.1f, maidDistance) * distance*0.01f; //% 10cmより近くでも比率は同じ
        else if (moveType == 1) maidDistance += distance; //offset
        else maidDistance = distance;

        if (bVR) maidDistance *= cfgw.vrCamSetDistanceAdjust; //VRは2倍に補正
        mainCamera.SetDistance(Math.Max(0.1f, maidDistance), true); //最短 10cm
      }

      /// <summary>カメラを回転 メイド固定の注視点が回転の原点になる Y軸のみ回転しX軸回転はリセット</summary>
      public void vymCamAround(int aroundType, float angleOffset)
      {
        int mainID = tgID;
        if (mainID == -1) return;

        //GripMoveの移動をリセット
        if (bVR && vrShortCutController.trRoomBase) resetRoomBase(vrShortCutController.trRoomBase);

        CameraChange(mainID, -1, aroundType, angleOffset); //カメラジャンプ
        //距離は現在位置で変更しない
        float dist = Vector3.Distance(mainCamera.GetTargetPos(), mainCamera.GetRealHeadTransform().position);
        if (bVR) dist *= cfgw.vrCamSetDistanceAdjust; //VR距離補正
        mainCamera.SetDistance(dist, true);
      }

      /// <summary>メイドの部位の正面に移動 メイド固定の注視点も変更される  部位の角度にあわせて高さと向きを調整</summary>
      public void vymCamTarget(float distance, int target, bool backword)
      {
        int mainID = vymMaidID();
        if (mainID == -1) return;
        MaidState maidState = maidsState[mainID];

        //GripMoveの移動をリセット
        if (bVR && vrShortCutController.trRoomBase) resetRoomBase(vrShortCutController.trRoomBase);

        //メイドの部位取得 メイド固定の注視点も変更
        Transform tr; //顔 forward→右(x=+1)  right→下(y=-1)  up→前(z=+1)
        Vector3 dir; //手前から奥の方向
        float angleXOffset = 0f; //仰角の補正 首や胸が若干下向きなのを補正

        if (target == 2) {
          lookPoint = 0;
          tr = maidState.maidMune; //胸
          dir = -tr.up; //手前から奥の方向
          angleXOffset = 5f; //5度下向き
        } else if (target == 3) {
          lookPoint = 2;
          tr = maidState.maidXxx; //腰
          dir = -tr.up; //手前から奥の方向
        } else {
          lookPoint = 1;
          tr = maidState.maidHead; //位置は頭
          dir = -maidState.maidNeck.up; //手前から奥の方向 首の向きを利用
          angleXOffset = 10f; //10度下向き
        }
        //向き取得 軸のずれは共通
        if (backword) dir = -dir; //反転
        Vector3 up = Vector3.Normalize(maidState.maidNeck.position - maidState.maidMune.position); //首と胸の方向

        //カメラ ターゲット位置
        mainCamera.SetTargetPos(tr.position, true);
        if (distance > 0f) mainCamera.SetDistance(bVR ? (distance * cfgw.vrCamSetDistanceAdjust) : distance, true);
        //回転
        setTargetAroundAngle(dir, angleXOffset, up);
      }

      /// <summary>男の頭の位置に移動</summary>
      public void vymCamManHead(int manID, int target)
      {
        if (manID == -1) {
          for (int im = 0; im < SubMans.Length; im++) {
            if (isSubManVisible(im)) {
              manID = im;
              break;
            }
          }
          if (manID == -1) return;
        }
        Maid man = getSubMan(manID);
        if (man == null || !man.Visible) return;
        
        //メイド固定は解除
        maidFollowEnabled = false;
        //GripMoveの移動をリセット
        if (bVR && vrShortCutController.trRoomBase) resetRoomBase(vrShortCutController.trRoomBase);

        Transform head = ManHeadGet(man);
        Vector3 pos = head.position;
        //オフセット指定があれば上下位置調整
        #if COM3D2_5
        if (man.IsNewManIsRealMan) {
          //right→上(y=-1) up→前(z=+1) right→左(x=-1)
          if (cfgw.fpsManHeadOffsetY != 0) pos -= head.right * cfgw.fpsManHeadOffsetY;
          if (cfgw.fpsManHeadOffsetZ != 0) pos += head.up * (cfgw.fpsManHeadOffsetZ + 0.01f); //SetDistanceの分は前に補正
        } else
        #endif
        {
          // forward→上(y=+1) up→後ろ(z=-1) right→左(x=-1)
          if (cfgw.fpsManHeadOffsetY != 0) pos += head.forward * cfgw.fpsManHeadOffsetY;
          if (cfgw.fpsManHeadOffsetZ != 0) pos -= head.up * (cfgw.fpsManHeadOffsetZ + 0.01f); //SetDistanceの分は前に補正
        }

        //カメラ位置の移動
        mainCamera.SetTargetPos(pos, true);
        mainCamera.SetDistance(0.01f, true); //0だと向きがおかしくなる
        //回転
        if (target != -1) {
          Vector3 dir = -head.up; //前
          Vector3 up = head.forward; //上
          #if COM3D2_5
          if (man.IsNewManIsRealMan) {
            dir = head.up;
            up = head.right;
          }
          #endif
          //連携するメイドの部位方向のVector3に変更
          if (MansTg[manID] != -1) {
            if (target >= 1) {
              Transform maidObj = null;
              if (target == 1) { //顔
                maidObj = maidsState[MansTg[manID]].maidHead;
              } else if (target == 2) { //胸
                maidObj = maidsState[MansTg[manID]].maidMune;
              } else if (target == 3) { //腰
                maidObj = maidsState[MansTg[manID]].maidXxx;
              } else if (target == 4) { //注視点
                maidObj = getMaidLookpointTransform(MansTg[manID]);
              }
              if (maidObj != null) dir = Vector3.Normalize(maidObj.position - head.transform.position);
            }
          }
          setTargetAroundAngle(dir, 0, up);
        }
      }

      /// <summary>メイド固定場所と一人称モードの設定</summary>
      public void vymLookPoint(int fpsMode, int follow, int _lookPoint)
      {
        int mainID = vymMaidID();

        if (fpsMode != -1) {
          checkFpsMan(); //一人称の対象の男再チェック
          setFpsModeEnabled(fpsMode == 1 && fpsMan.Visible); //男表示時のみ
        }

        if (_lookPoint == 10) aoutAngle = true;   //アングルON
        else if (_lookPoint == -10) aoutAngle = false; //アングルOFF
        else if (_lookPoint != -1) this.lookPoint = _lookPoint;

        if (follow == 0) {
          if (!maidFollowEnabled) { //OFFに変わった
            setDanceCameraDisabled(false);
          }
          maidFollowEnabled = false; //0指定を優先
        } else if (follow == 1) {
          if (!maidFollowEnabled) { //ONに変わった
            maidFollowEnabled = true;
            if (bVR) {
              if (mainID != -1) MaidFollowingCameraStart(mainID); //視点の向きを正面にしてメイド固定 VRのみ
              if (vrShortCutController.trRoomBase) resetRoomBase(vrShortCutController.trRoomBase);
            }
            setDanceCameraDisabled(true);
          }
        }

      }


      /// <summary>地面判定調整</summary>
      public void vymBoneHitHeight(float height, bool offset)
      {
        int mainID = vymMaidID();
        if (mainID == -1) return;
        Maid maid = stockMaids[mainID].mem;

        if (offset) maid.body0.SetBoneHitHeightY(maid.body0.BoneHitHeightY + height*0.01f);
        else maid.body0.SetBoneHitHeightY(height*0.01f); 
      }

      /// <summary>興奮度を変更</summary>
      public void vymExcite(int excite, bool offset)
      {
        int mainID = vymMaidID();
        if (mainID == -1) return;
        Maid maid = stockMaids[mainID].mem;

        if (offset) excite = maid.status.currentExcite + excite;
        setExcite(mainID, maid, excite);
      }

      /// <summary>コライダーの有効設定 存在しないスロット名の場合エラーで停止するので注意</summary>
      public void vymCollider(string[] slots, bool enabled)
      {
        int mainID = vymMaidID(cfgw.vibeLookingMaid);
        if (mainID == -1) return;
        Maid maid = stockMaids[mainID].mem;
        MaidState maidState = maidsState[mainID];

        foreach (string slotName in slots) {
          setDynamicBoneColliderEnabled(maid, slotName, enabled);
          //GUIのチェックに反映のため再チェック
          if (slotName == "hairR") maidState.colliderEnabledHairR = isDynamicBoneColliderEnabled(maid, "hairR");
          else if (slotName == "hairT") maidState.colliderEnabledHairT = isDynamicBoneColliderEnabled(maid, "hairT");
        }
      }

      /// <summary>強制射精と射精ロック  男指定</summary>
      public void vymSyasei(int man, bool lockMode) {
        bool bLock = true;
        if (lockMode) {
          //マイナスならロック解除
          if (man < 0) {
            bLock = false;
            man = -man; //プラスに変更
          }
        }
        for (int im = 0; im < SubMans.Length; im++) {
          if ((man & 1) == 1) {
            if (lockMode) syaseiLock[im] = bLock;
            else {
              if (isSubManVisible(im)) {
                syaseiValue[im] = cfgw.forceSyaseiValue; //射精値100より小さければ少し遅延
                //射精有効で対象メイドがいればバイブは強
                MaidState maidState = maidsState[MansTg[im]];
                if (mansLevel[im] >= 0 && cfgw.forceSyaseiValue < 100f && MansTg[im] != -1) maidState.vLevel = 2;
              }
            }
          }
          man = man >> 1; //右にシフト
        }
      }

      /// <summary>拭き取り メインメイドまたはVRの正面のメイド</summary>
      public void vymFukitori(int mode)
      {
        int mainID = vymMaidID(cfgw.vibeLookingMaid);
        if (mainID == -1) return;
        Maid maid = stockMaids[mainID].mem;
        if (mode == 0 || mode == 1) RemoveSeiekiFace(maid);
        if (mode == 0 || mode == 2) RemoveSeiekiBody(maid);
      }

      /// <summary>おしっこ メインメイドまたはVRの正面のメイド</summary>
      public void vymStartNyo(int linkType)
      {
        int mainID = vymMaidID(cfgw.vibeLookingMaid);
        if (mainID == -1) return;

        foreach (int maidID in vymMaidIDList(mainID, linkType)) { //リンクメイド対応
          Maid maid = stockMaids[maidID].mem;
          MaidState maidState = maidsState[maidID];

          float nr = UnityEngine.Random.Range(50f, maidState.nyoVolume);
          EffectNyo(maid, maidState, nr, true);
        }
      }

      /// <summary>潮 メインメイドまたはVRの正面のメイド</summary>
      public void vymStartSio(int linkType)
      {
        int mainID = vymMaidID(cfgw.vibeLookingMaid);
        if (mainID == -1) return;

        foreach (int maidID in vymMaidIDList(mainID, linkType)) { //リンクメイド対応
          Maid maid = stockMaids[maidID].mem;
          MaidState maidState = maidsState[maidID];

          maidState.fSio = true;
          maidState.sioTime = Time.time + 1f; //潮吹き終了時間 1秒後
          maidState.sioTime2 = 0; //待ち時間なし
          maidState.sioVolume = 0;  //OrgasmProcessでの潮吹き判定はリセット
          EffectSio(maid, maidState);
        }
      }

      /// <summary>バイブ操作 メインメイドまたはVRの正面のメイド + リンクしているメイド</summary>
      public void vymVibe(int level, int linkType)
      {
        int mainID = vymMaidID(cfgw.vibeLookingMaid);
        if (mainID == -1) return;

        level = Math.Max(0, Math.Min(2, level)); //指定した値に変更

        foreach (int maidID in vymMaidIDList(mainID, linkType)) { //リンクメイド対応
          MaidState maidState = maidsState[maidID];
          maidState.vLevel = level; //指定した値に変更
          maidState.pAutoSelect = 0; //オートは無効
          //停止操作時は専用処理実行
          if (level == 0) vibeStop(maidID, maidState);
          else vibeStart(maidID, maidState);
        }
      }

      /// <summary>バイブ操作 メインメイドまたはVRの正面のメイド</summary>
      public void vymVibeAuto(int auto, bool offset, int linkType)
      {
        int mainID = vymMaidID(cfgw.vibeLookingMaid);
        if (mainID == -1) return;

        foreach (int maidID in vymMaidIDList(mainID, linkType)) { //リンクメイド対応
          MaidState maidState = maidsState[maidID];
          if (offset) { //順番にモード変更
            maidState.pAutoSelect += auto;
            if (maidState.pAutoSelect > 3) maidState.pAutoSelect = 0;
            else if (maidState.pAutoSelect < 0) maidState.pAutoSelect = 3;
          } else {
            maidState.pAutoSelect = auto;
          }
        }
      }

      /// <summary>あそこを広げる メインメイドまたはVRの正面のメイド</summary>
      public void vymKupa(float kupaValue, bool offset)
      {
        int mainID = vymMaidID(cfgw.vibeLookingMaid);
        if (mainID == -1) return;
        Maid maid = stockMaids[mainID].mem;
        MaidState maidState = maidsState[mainID];

        //バイブ動作時はスライダーを変更
        //バイブ中でなければ一時状態も変更
        if (offset) {
          //相対指定 拡げる場合は現在値または一時変更値から変更
          if (maidState.vLevel == 0 && maidState.pAutoSelect == 0) {
            //一時変更
            maidState.hibuTempValue = Math.Max(0, Math.Min(100, maidState.hibuTempValue + kupaValue));
          } else {
            //開度スライダー変更
            maidState.hibuSlider1Value = Math.Max(0, Math.Min(100, maidState.hibuSlider1Value + kupaValue));
          }
        } else {
          kupaValue = Math.Max(0, Math.Min(100, kupaValue));
          if (maidState.vLevel == 0 && maidState.pAutoSelect == 0) {
            //一時変更
            maidState.hibuTempValue = kupaValue;
          } else {
            //開度スライダー変更
            maidState.hibuSlider1Value = kupaValue;
          }
        }

        //EffectHibuAnime(tgID, maidState.maid, maidState); //LateUpdadeで呼ばれているので不要
      }
      /// <summary>アナルを広げる メインメイドまたはVRの正面のメイド</summary>
      public void vymAnal(float analValue, bool offset)
      {
        int mainID = vymMaidID(cfgw.vibeLookingMaid);
        if (mainID == -1) return;
        Maid maid = stockMaids[mainID].mem;
        MaidState maidState = maidsState[mainID];

        //バイブ中でなくてもゆっくり広げる
        if (offset) {
          //相対指定 拡げる場合は現在値または一時変更値から変更
          if (maidState.vLevel == 0 && maidState.pAutoSelect == 0) {
            //一時変更
            maidState.analTempValue = Math.Max(0, Math.Min(100, maidState.analTempValue + analValue));
          } else {
            //スライダー変更
            maidState.analSlider1Value = Math.Max(0, Math.Min(100, maidState.analSlider1Value + analValue));
          }
        } else {
          analValue = Math.Max(0, Math.Min(100, analValue));
          if (maidState.vLevel == 0 && maidState.pAutoSelect == 0) {
            //一時変更
            maidState.analTempValue = analValue;
          } else {
            //スライダー変更
            maidState.analSlider1Value = analValue;
          }
        }

        maidState.analTempValue = Math.Max(0, Math.Min(100, maidState.analTempValue)); //0-100
      }

      /// <summary>クリのサイズを変更 クリ肥大値も連動 メインメイドまたはVRの正面のメイド</summary>
      public void vymBokki(float bokkiValue, bool offset)
      {
        int mainID = vymMaidID(cfgw.vibeLookingMaid);
        if (mainID == -1) return;
        Maid maid = stockMaids[mainID].mem;
        MaidState maidState = maidsState[mainID];

        if (offset) {
          //相対指定 拡大時は現在値または一時変更値から変更
          if (bokkiValue > 0) maidState.bokkiTempValue = Math.Max(maidState.bokkiTempValue, maidState.bokkiValue1) + bokkiValue;
          else maidState.bokkiTempValue = maidState.bokkiTempValue + bokkiValue;
        }
        else maidState.bokkiTempValue = bokkiValue;
        maidState.bokkiTempValue = Math.Max(0, Math.Min(100, maidState.bokkiTempValue)); //0-100
        if (maidState.bokkiValue1 == 0) maidState.bokkiValue1++; //0だと反映されないので+1して処理させる
        EffectBokki(maidState.maid, maidState, 1);
      }

      /// <summary>UNZIPのモーションを再生する MotionAdjust.xml のモーション名を指定</summary>
      public void vymUnzip(string motion)
      {
        int mainID = vymMaidID();
        if (mainID == -1) return;

        SelectYotogiMenu(motion); //パネル切替
        StartMaidUnzip(mainID, motion);
      }

      // <summary>UNZIP派生モーションへの切替</summary>
      public void vymUnzipDerive(string[] derives)
      {
        int mainID = vymMaidID();
        if (mainID == -1) return;
        MaidState maidState = maidsState[mainID];

        if (maidState.motionID == -1) return;
        
        //現在のモーション
        string motion = maj.motionName[maidState.motionID];
        string newMotion = motion;

        //基本モーションに戻す _1_f の前を除去
        if (derives == null || derives.Length == 0) {
          newMotion = Regex.Replace(motion, "_[^_]+_1_f$", "_1_f");
          if (newMotion != motion && majValidNameSet.Contains(newMotion)) {
            //モーションがあれば変更
            StartMaidUnzip(mainID, newMotion);
          }
          return;
        }

        //派生モーションへ置換して有無をチェック 複数指定
        //派生文字列追加
        foreach (string derive in derives) {
          newMotion = Regex.Replace(motion, "_1_f$", derive+"_1_f");
          if (newMotion != motion && majValidNameSet.Contains(newMotion)) {
            //モーションがあれば変更
            StartMaidUnzip(mainID, newMotion);
            return;
          }
        }
        //派生を入れ替え 基本に戻してから追加
        foreach (string derive in derives) {
          if (motion.Contains("_hibu_aibu_1_f")) newMotion = motion.Replace("_hibu_aibu_1_f", "_1_f"); //例外 _が2つ以上ある
          else {
            newMotion = Regex.Replace(motion, "_[^_]+_1_f$", derive+"_1_f");
          }
          if (newMotion != motion && majValidNameSet.Contains(newMotion)) {
            //モーションがあれば変更
            StartMaidUnzip(mainID, newMotion);
            return;
          }
        }
      }

      /// <summary> UNZIPのランダムモーションを再生する EditMotionSet以下のxmlファイル名を指定</summary>
      public void vymUnzipRandom(string emsFile)
      {
        int mainID = vymMaidID();
        if (mainID == -1) return;

        YotogiMenu = YotogiGroup.Count-1; //パネル切替
        StartRandomUnzip(mainID, emsFile+".xml");
      }

      /// <summary>UNZIPモーションの切替</summary>
      public void vymUnzipChange(int changeType)
      {
        int mainID = vymMaidID();
        if (mainID == -1) return;
        MaidState maidState = maidsState[mainID];

        if (maidState.editMotionSetName == "") {
          if (changeType == -1) StartPrevUnzip();
          else if (changeType == 1) StartNextUnzip();
        } else {
          if (changeType == 1) maidState.msTime2 = 0; //ランダムモーション即時変更
          else if (changeType == 2) maidState.msTime1 = 0; //ランダムカテゴリ即時変更
          else if (changeType == -3) StartPrevUnzip();
          else if (changeType == 3) StartNextUnzip();
        }
      }

      /// <summary>抜く  UNZIP中で抜くモーションがある場合のみ動作</summary>
      public void vymRemoveMotion(bool syasei)
      {
        int mainID = vymMaidID();
        if (mainID == -1) return;
        MaidState maidState = maidsState[mainID];

        removeMotionChange(mainID, maidState, syasei);
      }

      /// <summary>再挿入  抜いたモーションまたは射精後モーションの場合のみ動作</summary>
      public void vymInsertMotion()
      {
        int mainID = vymMaidID();
        if (mainID == -1) return;
        MaidState maidState = maidsState[mainID];

        insertMotionChange(mainID, maidState);
      }

      /// <summary>素股に切替 ボタン表示時のみ メインメイドまたはVRの正面のメイド</summary>
      public void vymSumataMotion()
      {
        int mainID = vymMaidID();
        if (mainID == -1) return;
        MaidState maidState = maidsState[mainID];

        sumataMotionChange(mainID, maidState);
      }

      /// <summary>後ろ/前を使う ボタン表示時のみ メインメイドまたはVRの正面のメイド</summary>
      public void vymAnalMode(bool analMode)
      {
        int mainID = vymMaidID();
        if (mainID == -1) return;
        MaidState maidState = maidsState[mainID];

        if (maidState.analMode == analMode) return;
        if (maidState.motionID != -1 && maj.analEnabled[maidState.motionID] && !maidState.stunFlag) {
          maidState.analMode = analMode;
          analMotionChange(mainID, maidState);
        }
      }

      /// <summary>オリジナルボイスセット設定</summary>
      public void vymVoiceSet(string voiceFile)
      {
        int mainID = vymMaidID();
        if (mainID == -1) return;
        MaidState maidState = maidsState[mainID];

        //解除
        if (string.IsNullOrEmpty(voiceFile)) {
          maidState.editVoiceSetName = "";
          maidState.editVoiceSet = new List<string[]>();
        } else {
          //ファイル読み込み ＋ 設定画面の表示切替
          if (voiceSetLoad(voiceFile+".xml", mainID)) vsNormalMode = true;
        }
      }

      /// <summary>キス用オリジナルボイスセット設定</summary>
      public void vymKissVoiceSet(string voiceFile)
      {
        int mainID = vymMaidID();
        if (mainID == -1) return;
        MaidState maidState = maidsState[mainID];

        //解除
        if (string.IsNullOrEmpty(voiceFile)) {
          maidState.kissVoiceSetName = "";
          maidState.kissVoiceSet = null;
        } else {
          //ファイル読み込み ＋ 設定画面の表示切替
          if (kissVoiceSetLoad(voiceFile+".xml", mainID)) vsNormalMode = false;
        }
      }


      /// <summary>表情変更</summary>
      public void vymFace(string face, string blend, float fade, int linkType)
      {
        int mainID = vymMaidID();
        if (mainID == -1) return;
        Maid maid = stockMaids[mainID].mem;
        MaidState maidState = maidsState[mainID];

        if (face != null) {
          //表情の有無をチェック
          if (maid.body0.Face.morph.dicBlendSet.ContainsKey(face)) {
            foreach (int maidID in vymMaidIDList(mainID, linkType)) { //リンクメイド対応
              stockMaids[maidID].mem.FaceAnime(face, fade , 0);
            }
          }
        }

        if (blend != null) {
          //"頬" "涙"のどちらかなら指定された側のみ変更 "よだれ"は指定の有無で強制変更
          string newBlend = maid.FaceName3;

          //「VYMオリジナル」になっていたら元に戻す
          if (newBlend == vymFaceBlendSetName) {
            newBlend = maidState.faceBlendBackup=="" ? "通常" : maidState.faceBlendBackup;
          }
          newBlend = newBlend.Replace("オリジナル", ""); //取得したフェイスブレンド情報から「オリジナル」の記述を削除
          if (newBlend == "") newBlend = "頬０涙０";  // 背景選択時、スキル選択時は、"" が返ってきてエラーが出るため

          Match m = Regex.Match(blend, "頬[０１２３]");
          if (m.Value != String.Empty) {
            newBlend = Regex.Replace(newBlend, "頬.", m.Value);
          }
          m = Regex.Match(blend, "涙[０１２３]");
          if (m.Value != String.Empty) {
            newBlend = Regex.Replace(newBlend, "涙.", m.Value);
          }
          if (blend.Contains("よだれ")) {
            if (!newBlend.Contains("よだれ")) newBlend += "よだれ";
          } else {
            newBlend = newBlend.Replace("よだれ", "");
          }
          #if DEBUG
          Debug.Log("vymFace face="+face+" blend="+blend+" → "+newBlend);
          #endif

          maid.FaceBlend(newBlend);
        }
      }

      /// <summary>表情詳細変更 "VYMオリジナル"に現在の表情を反映してから変更する</summary>
      public void vymFaceBlend(string[] tagInfo, int linkType)
      {
        int mainID = vymMaidID();
        if (mainID == -1) return;
        
        foreach (int maidID in vymMaidIDList(mainID, linkType)) { //リンクメイド対応
          Maid maid = stockMaids[maidID].mem;
          setFaceBlend(maid, maidsState[maidID], tagInfo);
        }

      }

      /// <summary>表情の詳細をtag指定で変更する
      /// 表情「VYMオリジナル」を追加して変更
      /// スタジオは「オリジナル」でないと表情設定できないので変更しない
      /// Shepeキーの変更はLateUpdateの前にGetBlendValuesの値で上書きされてしまうためここからはできない
      /// 「オリジナル」だとストーリーの顔がおかしくならないように別途設定</summary>
      const string vymFaceBlendSetName = "VYMオリジナル";

      private void setFaceBlend(Maid maid, MaidState maidState, string[] tagInfo)
      {
        string blendSetName = maid.ActiveFace;

        #if DEBUG
        Debug.Log("vymFaceBlend blendSetName="+blendSetName);
        //foreach (string key in maid.body0.Face.morph.hash.Keys) { Debug.Log("  hash.Key="+key); }
        #endif

        if (vSceneLevel != 26) {
          //"VYMオリジナル"は事前に追加しておく
          if (!maid.body0.Face.morph.dicBlendSet.ContainsKey(vymFaceBlendSetName)) maid.body0.Face.morph.NewBlendSet(vymFaceBlendSetName);

          //表情名が異なるなら現在の値からコピー
          if (blendSetName != vymFaceBlendSetName && maid.body0.Face.morph.dicBlendSet.ContainsKey(blendSetName)) {
            float[] arrayFrom = maid.body0.Face.morph.dicBlendSet[blendSetName];
            float[] arrayTo = maid.body0.Face.morph.dicBlendSet[vymFaceBlendSetName];
            for (int i=0; i<arrayFrom.Length; i++) {
              arrayTo[i] = arrayFrom[i];
            }
            maidState.faceBlendBackup = blendSetName; //バックアップに保存
          }
          blendSetName = vymFaceBlendSetName;
        }

        foreach (string tagKV in tagInfo) {
          string[] tag = tagKV.Split(':');
          if (tag.Length != 2) continue;
          bool offset = tag[1].StartsWith("+") || tag[1].StartsWith("-");
          float value;
          if (float.TryParse(tag[1], out value)) {
            value *= 0.01f;

            float[] array = maid.body0.Face.morph.dicBlendSet[blendSetName];
            if (maid.body0.Face.morph.hash.ContainsKey(tag[0])) {
              int num = (int)maid.body0.Face.morph.hash[tag[0]];
                if (offset) array[num] = Math.Max(0f, Math.Min(1f, array[num] + value)); //相対値変更
                else array[num] = Math.Max(0f, Math.Min(1f, value));
            } else {
              //Fbフェイスは目の後ろに種別が必要 3つともtagがあるのですべて変更
              if (tag[0] == "eyeclose") tag[0] = "eyeclose1"; //Fbは eyeclose1
              foreach (string suffix in new string[]{"_normal", "_tare", "_tsuri"}) {
                string eyetag = tag[0]+suffix;
                if (maid.body0.Face.morph.hash.ContainsKey(eyetag)) {
                  int num = (int)maid.body0.Face.morph.hash[eyetag];
                  if (offset) array[num] = Math.Max(0f, Math.Min(1f, array[num] + value)); //相対値変更
                  else array[num] = Math.Max(0f, Math.Min(1f, value));
                }
              }
            }
          }
          //"VYMオリジナル"に切り替え
          if (vSceneLevel != 26) maid.FaceAnime(vymFaceBlendSetName, 0.5f , 0);
        }
      }

      /// <summary>モーションを再生する</summary>
      public void vymMotion(string[] motions, float[] motionFades, bool loop, int linkType)
      {
        int mainID = vymMaidID();
        if (mainID == -1) return;

        foreach (int maidID in vymMaidIDList(mainID, linkType)) { //リンクメイド対応
          Maid maid = stockMaids[maidID].mem;
          //連続モーション対応
          //string preFace = "";
          //最初以外はaddQue=true
          for (int i=0; i<motions.Length; i++) {
            string motion = motions[i];
            float fade = 0.7f;
            if (motionFades != null) fade = motionFades[Math.Min(i, motionFades.Length-1)];
            bool addQue = i>0;
            bool bLast = i==motions.Length-1;
            //マイポーズ再生 スタジオのみ
            if (playMyPose(maid, motion, loop && bLast, addQue, fade)) {
            } else if (playMotion(maid, motion, loop && bLast, addQue, fade)) {
            } else {
              //マイポーズもモーションも見つからない場合
              Debug.LogError("モーションがありません : "+motion);
            }
          }
        }
      }

      //-------------------------------------------------
      // 外部操作 共通メソッド

      /// <summary>メインメイドのメイドIDを取得</summary>
      /// <returns>対象がいなければ-1</returns>
      private int vymMaidID()
      {
        if (!cfgw.bPluginEnabledV) return -1;
        int mainID = tgID; //メインメイド
        if (mainID == -1) return -1;
        return mainID;
      }
      /// <summary>操作対象のメイドIDを取得 メインメイドまたはVRで正面のメイド(バイブ対象設定がtrueの場合)</summary>
      /// <returns>対象がいなければ-1</returns>
      private int vymMaidID(bool lookingMaid)
      {
        if (!cfgw.bPluginEnabledV) return -1;
        int mainID = tgID; //メインメイド
        if (mainID == -1) return -1;
        if (bVR && lookingMaid) mainID = GetLookingkMaidID(45f); //正面にいるメイド取得
        return mainID;
      }

      /// <summary>
      /// メインメイドのIDとメインメイドとリンクしているメイドのIDを返却
      /// </summary>
      /// <param name="mainID">メインメイドのID</param>
      /// <param name="linkType">リンクしているメイドも対象にする  0:メインメイドのみ  1:メイン＋リンクしているメイド  2:UNZIPのメインとサブメイド  9:表示中のアクティブなメイド全員</param>
      /// <returns>メインメイドのIDとメインメイドとリンクしているメイドのIDのリスト</returns>
      private List<int> vymMaidIDList(int mainID, int linkType)
      {
        List<int> maidList;
        switch (linkType) {
        case 0 :
          //メインメイドのみ
          maidList = new List<int>(1);
          maidList.Add(mainID);
          return maidList;
        case 1 :
          //メインメイドとリンクしているメイド
          maidList = new List<int>();
          maidList.Add(mainID);
          foreach (int id in vmId) {
            if (mainID != id && id >= 0 && maidsState[id].linkID == mainID) maidList.Add(id);
          }
          return maidList;
        case 2 :
          //メインメイド+モーションリンクしたサブメイド
          maidList = new List<int>();
          maidList.Add(mainID);
          foreach (int subId in vmId) {
            if (subId != mainID) {
              if (maidsState[subId].motionLinkID == mainID || subId == maidsState[mainID].motionLinkID) maidList.Add(subId);
              //サブにリンクしているメイドも取得（サブメイドをメインにしている場合）
              foreach (int subId2 in vmId) {
                if (subId2 != mainID) {
                  if (maidsState[subId2].motionLinkID == subId) {
                    if (!maidList.Contains(subId2)) maidList.Add(subId2);
                  }
                }
              }
            }
          }
          return maidList;
        case 9 :
          //表示中のアクティブなメイド
          maidList = new List<int>();
          foreach (int id in vmId) {
            if (isActiveMaid(stockMaids[mainID].mem)) maidList.Add(id);
          }
          return maidList;
        }
        return null;
      }

      //モーション再生
      ///<returns>モーションが存在していて再生されたらtrue</returns>
      private bool playMotion(Maid maid, string motion, bool loop, bool addQue, float fade)
      {
        //モーションの有無をチェック
        if (MotionOldCheck(motion) == -1) return false;
        //前のモーションが止まっていた場合にもCrossFadeさせる
        /*if (!addQue) {
          Animation animation = maid.body0.m_Animation;
          if (!animation.isPlaying) {
            //timeを一番最後に設定する必要あり？
            AnimationState state = animation[maid.body0.LastAnimeFN.ToLower()];
            if (state != null) {
              state.speed = 0;
              state.time = state.length;
              animation.Play(maid.body0.LastAnimeFN.ToLower(), PlayMode.StopAll); //PlayMode.StopAll にしないとエラーが出る
            }
          }
        }*/
        //胸物理設定
        if (!maid.boMAN) {
          bool useMuneAnime = (CheckPaizuriMode(motion) & 1) == 1;
          setPaizuriEnable(maid, useMuneAnime, useMuneAnime);
        }
        //通常モーション再生
        if (!addQue) MotionChange(maid, motion+".anm", loop, fade, 1f);
        else MotionChangeAf(maid, motion+".anm", loop, fade, 1f);

        #if DEBUG
        debugAnimationState(maid.body0.m_Animation, motion+".anm");
        #endif

        return true;
      }

      //マイポーズ再生 CrossFade対応
      ///<returns>マイポーズが存在していて再生されたらtrue</returns>
      private bool playMyPose(Maid maid, string name, bool loop, bool addQue, float fade)
      {
        PhotoMotionData myPose = getMyPoseName(name);
        if (myPose == null) return false;

        //マイポーズ適用
        //myPose.Apply(maid); //CrossFade 0なので内部の処理を↓で実装
        if (string.IsNullOrEmpty(myPose.direct_file)) return false;

        byte[] array = new byte[0];
        try {
          FileStream fileStream = new FileStream(myPose.direct_file, FileMode.Open, FileAccess.Read);
          array = new byte[fileStream.Length];
          fileStream.Read(array, 0, array.Length);
        } catch (Exception e) { Debug.LogError(e); }
        if (0 == array.Length) return false;

        //胸物理設定
        if (!maid.boMAN) setPaizuriEnable(maid, myPose.use_animekey_mune_l, myPose.use_animekey_mune_r);
        //if (!addQue) GameMain.Instance.ScriptMgr.StopMotionScript();
        //マイポーズ再生
        maid.body0.CrossFade(myPose.id.ToString(), array, false, loop, addQue, fade, 1f);
        maid.SetAutoTwist(Maid.AutoTwist.ShoulderL, true);
        maid.SetAutoTwist(Maid.AutoTwist.ShoulderR, true);
        maid.SetAutoTwist(Maid.AutoTwist.WristL, true);
        maid.SetAutoTwist(Maid.AutoTwist.WristR, true);
        maid.SetAutoTwist(Maid.AutoTwist.ThighL, true);
        maid.SetAutoTwist(Maid.AutoTwist.ThighR, true);

        #if DEBUG
       debugAnimationState(maid.body0.m_Animation, myPose.id.ToString());
       #endif

        return true;
      }

      #if DEBUG
      private void debugAnimationState(Animation animation, string tag)
      {
        AnimationState state = animation[tag];
        Debug.Log("animation["+tag+"]="+state);
        if (state != null) {
          Debug.Log("animation.IsPlaying="+animation.IsPlaying(tag));
          Debug.Log("state.enabled="+state.enabled);
          Debug.Log("state.time="+state.time);
          Debug.Log("state.length="+state.length);
          Debug.Log("state.layer="+state.layer);
          Debug.Log("state.blendMode="+state.blendMode);
          Debug.Log("state.clip="+state.clip);
          if (state.clip != null) {
            Debug.Log("state.clip.length="+state.clip.length);
          }
        }
      }
      #endif

      //-------------------------------------------------

    } //class VibeYourMaid

    /// <summary>
    /// 外部操作API
    /// </summary>
    static public class API
    {
      //VibeYourMaid操作用インスタンス
      static private VibeYourMaid instance;

      /// <summary>VibeYourMaid側からインスタンスを設定</summary>
      /// <param name="_instance"></param>
      static public void setInstance(VibeYourMaid _instance) {
        instance = _instance;
      }

      /// <summary>バージョン取得</summary>
      static public string vymGetVersion() {
        return instance.vymGetVersion();
      }

      /// <summary>設定取得</summary>
      static public VibeYourMaid.VibeYourMaidCfgWriting vymGetConfig() {
        return instance.vymGetConfig();
      }
      /// <summary>設定後の再初期化処理を実行</summary>
      static public void vymInitConfig() {
        instance.vymInitConfig();
      }

      /// <summary>メインメイドのMaidID取得</summary>
      static public int vymGetMainMaidID() {
        return instance.tgID;
      }
      /// <summary>メインメイドのMaid取得</summary>
      static public Maid vymGetMainMaid() {
        return instance.vymGetMainMaid();
      }
      /// <summary>メインメイドの取得 VRの場合は見ているメイド</summary>
      static public Maid vymGetFrontMaid() {
        return instance.vymGetFrontMaid();
      }
      /// <summary>リンクに応じたメイドをすべて取得</summary>
      static public List<Maid> vymGetMaidList(int linkType) {
        return instance.vymGetMaidList(linkType);
      }
      /// <summary>メインメイドのMaidState取得</summary>
      static public VibeYourMaid.MaidState vymGetMainMaidState() {
       return instance.vymGetMainMaidState();
      }

      /// <summary>見ているメイドを選択</summary>
      static public void vymSelectFrontMaid() {
        instance.vymSelectFrontMaid();
      }
      /// <summary>名前でメインメイドを選択</summary>
      static public void vymSelectMaidName(string name) {
        instance.vymSelectMaidName(name);
      }

      /// <summary>前のメイドを選択</summary>
      /// <param name="camChange">カメラも近くに移動する ※メイド固定時は自動移動</param>
      static public void vymPrevMaid(bool camChange) {
        instance.vymPrevMaid(camChange);
      }
      /// <summary>次のメイドを選択</summary>
      /// <param name="camChange">カメラも近くに移動する ※メイド固定時は自動移動</param>
      static public void vymNextMaid(bool camChange) {
        instance.vymNextMaid(camChange);
      }
      /// <summary>左のメイドを選択</summary>
      /// <param name="camChange">カメラも近くに移動する ※メイド固定時は自動移動</param>
      static public void vymLeftMaid(bool camChange) {
        instance.vymLeftMaid(camChange);
      }
      /// <summary>次のメイドを選択</summary>
      /// <param name="camChange">カメラも近くに移動する ※メイド固定時は自動移動</param>
      static public void vymRightMaid(bool camChange) {
        instance.vymRightMaid(camChange);
      }

      /// <summary>メインメイドと他のメイドをリンク + モーション同期</summary>
      /// <param name="type">リンク種別 "all":全リンク "null":リンク解除 "left"=左のメイド  "right"=右のメイド   "sync"=リンクしているメイドと男のモーションを同期</param>
      static public void vymMaidLink(string type) {
        instance.vymMaidLink(type);
      }


      /// <summary>RoomBaseを移動する VRのRoomBase移動のみ</summary>
      /// <param name="move">カメラ方向を基準にした移動量</param>
      /// <param name="useMoveValue">移動量の設定値を利用 moveはの移動量は1にしておく</param>
      static public void vymCamMove(Vector3 move, bool useMoveValue) {
        instance.vymCamMove(move, useMoveValue);
      }
      /// <summary>メインメイドとの距離を変更する メイド固定の注視点が正面になる 仰角(X軸)の回転はリセットしない</summary>
      /// <param name="distance">前後の移動量または移動比率(%)</param>
      /// <param name="moveType">0=距離 1=相対距離 2=比率(%)</param>
      static public void vymCamDistance(float distance, int moveType) {
        instance.vymCamDistance(distance, moveType);
      }
      // <summary>メイドを中心にカメラを回転 メイド固定の注視点が回転の原点になる Y軸のみ回転し仰角(X軸)の回転はリセットされる 角度指定の回転、メイドbody0の正面や後ろにジャンプ</summary>
      /// <param name="aroundType">回転方法 0=左右回転 1=body0の正面 2=胸の正面</param>
      /// <param name="angleOffset">左右の回転量 または 正面からの角度 0なら正面 180なら後ろ</param>
      static public void vymCamAround(int aroundType, float angleOffset) {
        instance.vymCamAround(aroundType,angleOffset);
      }
      /// <summary>メイドの部位の正面に移動 メイド固定の注視点も変更される  部位の角度にあわせて高さと向きを調整</summary>
      /// <param name="distance">距離 -1なら変更しない</param>
      /// <param name="target">対象の部位 1=顔 2=胸 3=股間</param>
      /// <param name="backword">trueなら後ろ</param>
      static public void vymCamTarget(float distance, int target, bool backword) {
        instance.vymCamTarget(distance, target, backword);
      }

      /// <summary>男の頭の位置に移動 表示中の最初の男</summary>
      /// <param name="manID">男ID  -1=最初の男 0=ご主人様 1=以降はモブ</param>
      /// <param name="target">対象の部位 -1~変更なし 0=男の顔の向き 1=メイドの顔 2=メイドの胸 3=メイドの股間</param>
      static public void vymCamManHead(int manID, int target) {
        instance.vymCamManHead(manID, target);
      }

      /// <summary>メイド固定場所と一人称モードの設定</summary>
      /// <param name="fpsMode">一人称 -1:変更なし 0:OFF 1:ON</param>
      /// <param name="follow">メイド固定 -1:変更なし 0:OFF 1:ON</param>
      /// <param name="lookPoint">注視点 -1:変更なし 0:胸 1:顔 2:腰</param>
      static public void vymLookPoint(int fpsMode, int follow, int lookPoint) {
        instance.vymLookPoint(fpsMode, follow, lookPoint);
      }

      /// <summary>地面判定調整</summary>
      /// <param name="height">地面の高さ(cm)</param>
      /// <param name="offset">相対的に高さを変更するならtrue</param>
      static public void vymBoneHitHeight(float height, bool offset) {
        instance.vymBoneHitHeight(height, offset);
      }

      /// <summary>髪等の部位のコライダーの有効無効を切り変える</summary>
      /// <param name="slotName">部位名称 存在しないスロット名の場合エラーで停止するので注意</param>
      /// <param name="enabled">コライダーの有効状態</param>
      static public void vymCollider(string[] slots, bool enabled) {
        instance.vymCollider(slots, enabled);
      }

      /// <summary>興奮値設定</summary>
      /// <param name="excite">興奮値</param>
      /// <param name="offset">相対的に変更するならtrue</param>
      static public void vymExcite(int excite, bool offset) {
        instance.vymExcite(excite, offset);
      }

      /// <summary>男の表示切替</summary>
      /// <param name="manVisible">表示対象をビット指定 ビット指定 (1=ご主人様 2=男1 4=男2 8=男3 16=男4 32=男5) マイナスなら非表示にする</param>
      static public void vymManVisible(int manVisible) {
        instance.vymManVisible(manVisible);
      }

      /// <summary>射精制御 強制射精(メイドとリンクしている場合のみ)と射精ロック
      /// モーションアジャスト中の男モーション変化のタイミングで射精処理される</summary>
      /// <param name="man">射精対象をビット指定 (1=ご主人様 2=男1 4=男2 8=男3 16=男4 32=男5)</param>
      /// <param name="lockMode">trueなら射精ロックを変更 manが1以上なら射精ロック manがマイナス値ならロック解除</param>
      static public void vymSyasei(int man, bool lockMode) {
        instance.vymSyasei(man, lockMode);
      }
      /// <summary>拭き取り メインメイドまたはVRの正面のメイド</summary>
      /// <param name="mode">0:すべて拭き取り 1:顔のみ拭き取り 2:体のみ拭き取り</param>
      static public void vymFukitori(int mode) {
        instance.vymFukitori(mode);
      }

      /// <summary>おしっこ メインメイドまたはVRの正面のメイド</summary>
      /// <param name="linkType">リンクしているメイドも対象にする  0:メインメイドのみ  1:メイン＋リンクしているメイド  2:UNZIPのメインとサブメイド  9:表示中のメイド全員</param>
      static public void vymStartNyo(int linkType) {
        instance.vymStartNyo(linkType);
      }
      /// <summary>潮 メインメイドまたはVRの正面のメイド</summary>
      /// <param name="linkType">リンクしているメイドも対象にする  0:メインメイドのみ  1:メイン＋リンクしているメイド  2:UNZIPのメインとサブメイド  9:表示中のメイド全員</param>
      static public void vymStartSio(int linkType) {
        instance.vymStartSio(linkType);
      }

      /// <summary>バイブ操作 メインメイドまたはVRの正面のメイド + リンクしているメイド</summary>
      /// <param name="level">バイブの強さを指定した値に変更 0=OFF 1=弱 2=強</param>
      /// <param name="linkType">リンクしているメイドも対象にする  0:メインメイドのみ  1:メイン＋リンクしているメイド  2:UNZIPのメインとサブメイド  9:表示中のメイド全員</param>
      static public void vymVibe(int level, int linkType) {
        instance.vymVibe(level, linkType);
      }
      /// <summary>バイブ操作 メインメイドまたはVRの正面のメイド</summary>
      /// <param name="auto">オートモードを変更 -1なら順次切替 0:"オート無効" 1:"じっくり" 2:"激しく" 3:"ほどほど"</param>
      /// <param name="offset">trueならオートモードを順次切替 先頭と最後でループする</param>
      /// <param name="linkType">リンクしているメイドも対象にする  0:メインメイドのみ  1:メイン＋リンクしているメイド  2:UNZIPのメインとサブメイド  9:表示中のメイド全員</param>
      static public void vymVibeAuto(int auto, bool offset, int linkType) {
        instance.vymVibeAuto(auto, offset, linkType);
      }

      /// <summary>あそこを拡げる 現在のバイブ状態側の設定値を変更する</summary>
      /// <param name="kupaValue">拡げる量</param>
      /// <param name="offset">現在の開度から相対的に開閉する</param>
      static public void vymKupa(float kupaValue, bool offset) {
        instance.vymKupa(kupaValue, offset);
      }
      /// <summary>アナルを拡げる 現在のバイブ状態側の設定値を変更する</summary>
      /// <param name="analValue">拡げる量</param>
      /// <param name="offset">現在の開度から相対的に開閉する</param>
      static public void vymAnal(float analValue, bool offset) {
        instance.vymAnal(analValue, offset);
      }
      /// <summary>クリのサイズを変更 一時設定値が変更される</summary>
      /// <param name="bokkiValue">拡げる量</param>
      /// <param name="offset">相対的に拡縮する</param>
      static public void vymBokki(float bokkiValue, bool offset) {
        instance.vymBokki(bokkiValue, offset);
      }

      /// <summary>
      /// UNZIPのモーションを再生する
      /// MotionAdjust.xml のモーション名を指定
      /// </summary>
      /// <param name="motion">UNZIPモーション名(.anmは不要)</param>
      static public void vymUnzip(string motion) {
        instance.vymUnzip(motion);
      }
      // <summary>UNZIP派生モーションへの切替</summary>
      /// <param name="derive">派生モーションの追加文字列 "_kiss" "_momi" nullか長さ0なら基本モーションに戻す</param>
      static public void vymUnzipDerive(string[] derives) {
        instance.vymUnzipDerive(derives);
      }
      /// <summary>
      /// UNZIPのランダムモーションを再生する
      /// </summary>
      /// <param name="emsFile">EditMotionSet以下のxmlファイル名(.xmlは不要)を指定</param>
      static public void vymUnzipRandom(string emsFile) {
        instance.vymUnzipRandom(emsFile);
      }
      /// <summary>UNZIPモーションの切替</summary>
      /// <param name="changeType">
      /// 通常モーション再生時: -1=前のモーション 1=次のモーション
      /// ランダムモーション再生時: 1=モーション即時変更 2=カテゴリ即時変更 -3:前のモーションセット  3:次のモーションセット
      /// </param>
      static public void vymUnzipChange(int changeType) {
        instance.vymUnzipChange(changeType);
      }

      /// <summary>抜く UNZIPで抜くモーションがあって挿入中の場合のみ</summary>
      /// <param name="syasei">trueなら抜くときに射精する</param>
      static public void vymRemoveMotion(bool syasei) {
        instance.vymRemoveMotion(syasei);
      }
      /// <summary>再挿入 抜いたモーションまたは射精後モーションの場合のみ有効</summary>
      static public void vymInsertMotion() {
        instance.vymInsertMotion();
      }
      /// <summary>素股に切替 ボタン表示時のみ メインメイドまたはVRの正面のメイド</summary>
      static public void vymSumataMotion() {
        instance.vymSumataMotion();
      }
      /// <summary>後ろを使う ボタン表示時のみ メインメイドまたはVRの正面のメイド</summary>
      /// <param name="analMode">trueなら後ろを使う</param>
      static public void vymAnalMode(bool analMode) {
        instance.vymAnalMode(analMode);
      }

      /// <summary>オリジナルボイスセット設定</summary>
      /// <param name="voiceFile">ボイスファイル名(.xmlは不要) nullなら解除</param>
      static public void vymVoiceSet(string voiceFile) {
        instance.vymVoiceSet(voiceFile);
      }
      /// <summary>キス用オリジナルボイスセット設定</summary>
      /// <param name="voiceFile">ボイスファイル名(.xmlは不要) nullなら解除</param>
      static public void vymKissVoiceSet(string voiceFile) {
        instance.vymKissVoiceSet(voiceFile);
      }

      /// <summary>表情変更</summary>
      /// <param name="face">表情名  nullなら表情は変更しない</param>
      /// <param name="blend">頬染め、涙 、よだれの指定  (設定例:"頬０涙０" "頬３涙３よだれ")  nullなら変更しない "頬"と"涙"は指定がなければ変更しない "よだれ"は指定がない場合は削除される</param>
      /// <param name="fade">表情のクロスフェード遷移時間</param>
      /// <param name="linkType">リンクしているメイドも対象にする  0:メインメイドのみ  1:メイン＋リンクしているメイド  2:UNZIPのメインとサブメイド  9:表示中のメイド全員</param>
      static public void vymFace(string face, string blend, float fade, int linkType) {
        instance.vymFace(face, blend, fade, linkType);
      }

      /// <summary>表情詳細  "VYMオリジナル"に現在の表情を反映してから変更する</summary>
      /// <param name="tagset">表情を変更するタグ  tag名:値 : で区切って設定 値の前に+-がついているときは相対値で変更</param>
      /// <param name="linkType">リンクしているメイドも対象にする  0:メインメイドのみ  1:メイン＋リンクしているメイド  2:UNZIPのメインとサブメイド  9:表示中のメイド全員</param>
      static public void vymFaceBlend(string[] tagset, int linkType) {
        instance.vymFaceBlend(tagset, linkType);
      }

      /// <summary>モーションを再生  複数指定で連続再生
      /// ※ランダムモーション設定の「取得」で再生中のファイル名を確認できます
		  /// ※マイポーズは COM3D2\PhotoModeData\MyPose にファイルがあります
      /// </summary>
      /// <param name="motions">モーションまたはマイポーズファイル名(.anmは不要) 連続するモーションを複数指定可</param>
      /// <param name="fadeMotion">モーションのクロスフェード遷移時間  モーション毎に指定 共通なら1つ指定 開始時だけクロスフェードしないなら{0f, 0.7f}</param>
      /// <param name="loop">最後のモーションをループ状態にする</param>
      /// <param name="linkType">リンクしているメイドも対象にする  0:メインメイドのみ  1:メイン＋リンクしているメイド  2:UNZIPのメインとサブメイド  9:表示中のメイド全員</param>
      static public void vymMotion(string[] motions, float[] motionFades, bool loop, int linkType) {
        instance.vymMotion( motions, motionFades, loop, linkType);
      }
    } //class API

#if DOF
  /// <summary>
  /// 被写界深度ポストエフェクトクラス
  /// 対象との距離に応じてボケ量をする (疑似的な距離連動なので離れると手前もぼけなくなる)
  /// nearBlurは無効
  /// </summary>
  public class DepthOfFieldDistance : PostEffectsBase
  {
    public enum BlurType {
      DiscBlur, DX11
    }

    public enum BlurSample {
      Low, Medium, High
    }

    public bool visualizeFocus = false;
    public float focalLength = 10f;
    private float _focalSize = 0.05f;
    public float focalSize {
      get { return _focalSize; }
      set {
        _focalSize = value;
        _focalSize = Mathf.Clamp(_focalSize, 0f, 2f);
      }
    }
    private float _aperture = 0.5f;
    public float aperture {
      get { return _aperture; }
      set {
        _aperture = value;
        if (_aperture < 0f) _aperture = 0f;
      }
    }
    public Transform focalTransform = null;
    private float _maxBlurSize = 2f;
    public float maxBlurSize {
      get { return _maxBlurSize; }
      set {
        _maxBlurSize = value;
        if (_maxBlurSize < 0.1f) _maxBlurSize = 0.1f;
        _maxBlurSize = Mathf.Max(_maxBlurSize, 0f);
      }
    }
    public bool highResolution = false;
    private BlurType _blurType = BlurType.DX11;
    public BlurType blurType {
      get { return _blurType; }
      set {
        _blurType = value;
        CreateComputeResources(); //マテリアル生成
      }
    }
    private BlurSample _blurSample = BlurSample.Low;
    public BlurSample blurSample {
      get { return _blurSample; }
      set {
        _blurSample = value;
        blurSamplePass = (_blurSample == BlurSample.High || _blurSample == BlurSample.Medium) ? 17 : 11;
        blurSampleCount = (_blurSample == BlurSample.High) ? 18 : 12;
      }
    }
    //public bool nearBlur = false;
    public float foregroundOverlap = 1f;
    public Shader dofHdrShader;
    public Shader dx11BokehShader;
    public float dx11BokehThreshold = 0.5f;
    public float dx11SpawnHeuristic = 0.0875f;
    public Texture2D dx11BokehTexture = null;
    public float dx11BokehScale = 1.2f;
    public float dx11BokehIntensity = 2.5f;

    public float focalTransformRadius = 0.05f;
    public float distanceCloseLimit = 1f;
    public float distanceCorrectRate = 1f; //距離補正倍率 focalDistance01*1000にかける倍率
    
    private int blurSamplePass = 11;
    private int blurSampleCount = 12;
    private Material dofHdrMaterial = null;
    private Material dx11bokehMaterial;
    private float focalDistance01 = 10f;
    private ComputeBuffer cbDrawArgs;
    private ComputeBuffer cbPoints;
    private float internalBlurWidth = 1f;
    private Camera camera;

    //フォーカス対象切り替えをスムーズに行う
    private Vector3 focalPosition = Vector3.zero;
    private Vector3 focalVelocity = Vector3.zero;
    public float focalTransformTime = 0.3f;

    public override bool CheckResources()
    {
      CheckSupport(true);
      dofHdrMaterial = CheckShaderAndCreateMaterial(dofHdrShader, dofHdrMaterial);
      if (supportDX11 && blurType == BlurType.DX11) {
        dx11bokehMaterial = CheckShaderAndCreateMaterial(dx11BokehShader, dx11bokehMaterial);
        CreateComputeResources();
      }
      if (!isSupported) ReportAutoDisable();
      return isSupported;
    }

    public override void OnEnable()
    {
      camera = GetComponent<Camera>();
      camera.depthTextureMode |= DepthTextureMode.Depth;

      CheckResources(); //マテリアル生成
    }

    private void OnDisable()
    {
      ReleaseComputeResources();
      if ((bool)dofHdrMaterial) UnityEngine.Object.DestroyImmediate(dofHdrMaterial);
      dofHdrMaterial = null;
      if ((bool)dx11bokehMaterial) UnityEngine.Object.DestroyImmediate(dx11bokehMaterial);
      dx11bokehMaterial = null;
    }

    private void ReleaseComputeResources()
    {
      if (cbDrawArgs != null) {
        cbDrawArgs.Release();
        cbDrawArgs = null;
      }
      if (cbPoints != null) {
        cbPoints.Release();
        cbPoints = null;
      }
    }

    private void CreateComputeResources()
    {
      if (cbDrawArgs == null) {
        cbDrawArgs = new ComputeBuffer(1, 16, ComputeBufferType.IndirectArguments);
        int[] data = new int[4] { 0, 1, 0, 0 };
        cbDrawArgs.SetData(data);
      }
      if (cbPoints == null) {
        cbPoints = new ComputeBuffer(90000, 28, ComputeBufferType.Append);
      }
    }

    private void WriteCoc(RenderTexture fromTo, bool fgDilate)
    {
      dofHdrMaterial.SetTexture("_FgOverlap", null);
      //if (nearBlur && fgDilate) {
      if (fgDilate) {
        int width = fromTo.width / 2;
        int height = fromTo.height / 2;
        RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0, fromTo.format);
        Graphics.Blit(fromTo, temporary, dofHdrMaterial, 4);
        float num = internalBlurWidth * foregroundOverlap;
        dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, num, 0f, num));
        RenderTexture temporary2 = RenderTexture.GetTemporary(width, height, 0, fromTo.format);
        Graphics.Blit(temporary, temporary2, dofHdrMaterial, 2);
        RenderTexture.ReleaseTemporary(temporary);
        dofHdrMaterial.SetVector("_Offsets", new Vector4(num, 0f, 0f, num));
        temporary = RenderTexture.GetTemporary(width, height, 0, fromTo.format);
        Graphics.Blit(temporary2, temporary, dofHdrMaterial, 2);
        RenderTexture.ReleaseTemporary(temporary2);
        dofHdrMaterial.SetTexture("_FgOverlap", temporary);
        fromTo.MarkRestoreExpected();
        Graphics.Blit(fromTo, fromTo, dofHdrMaterial, 13);
        RenderTexture.ReleaseTemporary(temporary);
      } else {
        fromTo.MarkRestoreExpected();
        Graphics.Blit(fromTo, fromTo, dofHdrMaterial, 0);
      }
    }
    private void WriteCocDX11(RenderTexture fromTo)
    {
      dofHdrMaterial.SetTexture("_FgOverlap", null);
      fromTo.MarkRestoreExpected();
      Graphics.Blit(fromTo, fromTo, dofHdrMaterial, 0);
    }

    private void OnRenderImage(RenderTexture source, RenderTexture destination)
    {
      /*if (!CheckResources()) {
        Graphics.Blit(source, destination);
        return;
      }*/
      internalBlurWidth = _maxBlurSize;
      float distance = 0;
      if (focalTransform) {
        if (focalTransformTime <= 0) focalPosition = focalTransform.position;
        else {
          focalPosition = Vector3.SmoothDamp(focalPosition, focalTransform.position, ref focalVelocity, focalTransformTime); //スムーズにフォーカス対象を切替
          focalTransformTime -= Time.deltaTime; //基本的に通常時は0にする 速度は等速になる
        }
        distance = camera.WorldToViewportPoint(focalPosition).z - focalTransformRadius; //実距離 中心からの半径も反映
        focalDistance01 = distance / camera.farClipPlane;
      } else {
        distance = camera.WorldToViewportPoint((focalLength - camera.nearClipPlane) * camera.transform.forward + camera.transform.position).z; //実距離
        focalDistance01 = distance / (camera.farClipPlane - camera.nearClipPlane);
      }
      float dist = Math.Max(distanceCloseLimit, distance * distanceCorrectRate);
      //dofHdrMaterial.SetVector("_CurveParams", new Vector4(1f, focalSize, _aperture / 10f, focalDistance01));
      dofHdrMaterial.SetVector("_CurveParams", new Vector4(1f, focalSize, _aperture / (10f + dist * dist), focalDistance01)); //距離補正
      RenderTexture renderTexture = null;
      RenderTexture renderTexture2 = null;
      RenderTexture renderTexture3 = null;
      RenderTexture renderTexture4 = null;
      float num = internalBlurWidth * foregroundOverlap;
      #if DEBUG
      if (visualizeFocus) {
        WriteCoc(source, true);
        Graphics.Blit(source, destination, dofHdrMaterial, 16);
      } else
      #endif
      if (blurType == BlurType.DX11) {
        if (highResolution) {
          internalBlurWidth = ((internalBlurWidth < 0.1f) ? 0.1f : internalBlurWidth);
          num = internalBlurWidth * foregroundOverlap;
          renderTexture = RenderTexture.GetTemporary(source.width, source.height, 0, source.format);
          RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height, 0, source.format);
          WriteCocDX11(source);
          renderTexture3 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
          renderTexture4 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
          Graphics.Blit(source, renderTexture3, dofHdrMaterial, 15);
          dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, 1.5f, 0f, 1.5f));
          Graphics.Blit(renderTexture3, renderTexture4, dofHdrMaterial, 19);
          dofHdrMaterial.SetVector("_Offsets", new Vector4(1.5f, 0f, 0f, 1.5f));
          Graphics.Blit(renderTexture4, renderTexture3, dofHdrMaterial, 19);
          /*if (nearBlur) {
            Graphics.Blit(source, renderTexture4, dofHdrMaterial, 4);
          }*/
          dx11bokehMaterial.SetTexture("_BlurredColor", renderTexture3);
          dx11bokehMaterial.SetFloat("_SpawnHeuristic", dx11SpawnHeuristic);
          dx11bokehMaterial.SetVector("_BokehParams", new Vector4(dx11BokehScale, dx11BokehIntensity, Mathf.Clamp(dx11BokehThreshold, 0.005f, 4f), internalBlurWidth));
          //dx11bokehMaterial.SetTexture("_FgCocMask", nearBlur ? renderTexture4 : null);
          dx11bokehMaterial.SetTexture("_FgCocMask", null);
          Graphics.SetRandomWriteTarget(1, cbPoints);
          Graphics.Blit(source, renderTexture, dx11bokehMaterial, 0);
          Graphics.ClearRandomWriteTargets();
          /*if (nearBlur) {
            dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, num, 0f, num));
            Graphics.Blit(renderTexture4, renderTexture3, dofHdrMaterial, 2);
            dofHdrMaterial.SetVector("_Offsets", new Vector4(num, 0f, 0f, num));
            Graphics.Blit(renderTexture3, renderTexture4, dofHdrMaterial, 2);
            Graphics.Blit(renderTexture4, renderTexture, dofHdrMaterial, 3);
          }*/
          Graphics.Blit(renderTexture, temporary, dofHdrMaterial, 20);
          dofHdrMaterial.SetVector("_Offsets", new Vector4(internalBlurWidth, 0f, 0f, internalBlurWidth));
          Graphics.Blit(renderTexture, source, dofHdrMaterial, 5);
          dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0f, internalBlurWidth));
          Graphics.Blit(source, temporary, dofHdrMaterial, 21);
          Graphics.SetRenderTarget(temporary);
          ComputeBuffer.CopyCount(cbPoints, cbDrawArgs, 0);
          dx11bokehMaterial.SetBuffer("pointBuffer", cbPoints);
          dx11bokehMaterial.SetTexture("_MainTex", dx11BokehTexture);
          dx11bokehMaterial.SetVector("_Screen", new Vector3(1f / (1f * (float)source.width), 1f / (1f * (float)source.height), internalBlurWidth));
          dx11bokehMaterial.SetPass(2);
          Graphics.DrawProceduralIndirect(MeshTopology.Points, cbDrawArgs, 0);
          Graphics.Blit(temporary, destination);
          RenderTexture.ReleaseTemporary(temporary);
          RenderTexture.ReleaseTemporary(renderTexture3);
          RenderTexture.ReleaseTemporary(renderTexture4);
        } else {
          renderTexture = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
          renderTexture2 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
          num = internalBlurWidth * foregroundOverlap;
          WriteCocDX11(source);
          source.filterMode = FilterMode.Bilinear;
          Graphics.Blit(source, renderTexture, dofHdrMaterial, 6);
          renderTexture3 = RenderTexture.GetTemporary(renderTexture.width >> 1, renderTexture.height >> 1, 0, renderTexture.format);
          renderTexture4 = RenderTexture.GetTemporary(renderTexture.width >> 1, renderTexture.height >> 1, 0, renderTexture.format);
          Graphics.Blit(renderTexture, renderTexture3, dofHdrMaterial, 15);
          dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, 1.5f, 0f, 1.5f));
          Graphics.Blit(renderTexture3, renderTexture4, dofHdrMaterial, 19);
          dofHdrMaterial.SetVector("_Offsets", new Vector4(1.5f, 0f, 0f, 1.5f));
          Graphics.Blit(renderTexture4, renderTexture3, dofHdrMaterial, 19);
          //RenderTexture renderTexture5 = null;
          /*if (nearBlur) {
            renderTexture5 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
            Graphics.Blit(source, renderTexture5, dofHdrMaterial, 4);
          }*/
          dx11bokehMaterial.SetTexture("_BlurredColor", renderTexture3);
          dx11bokehMaterial.SetFloat("_SpawnHeuristic", dx11SpawnHeuristic);
          dx11bokehMaterial.SetVector("_BokehParams", new Vector4(dx11BokehScale, dx11BokehIntensity, Mathf.Clamp(dx11BokehThreshold, 0.005f, 4f), internalBlurWidth));
          //dx11bokehMaterial.SetTexture("_FgCocMask", renderTexture5);
          Graphics.SetRandomWriteTarget(1, cbPoints);
          Graphics.Blit(renderTexture, renderTexture2, dx11bokehMaterial, 0);
          Graphics.ClearRandomWriteTargets();
          RenderTexture.ReleaseTemporary(renderTexture3);
          RenderTexture.ReleaseTemporary(renderTexture4);
          /*if (nearBlur) {
            dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, num, 0f, num));
            Graphics.Blit(renderTexture5, renderTexture, dofHdrMaterial, 2);
            dofHdrMaterial.SetVector("_Offsets", new Vector4(num, 0f, 0f, num));
            Graphics.Blit(renderTexture, renderTexture5, dofHdrMaterial, 2);
            Graphics.Blit(renderTexture5, renderTexture2, dofHdrMaterial, 3);
          }*/
          dofHdrMaterial.SetVector("_Offsets", new Vector4(internalBlurWidth, 0f, 0f, internalBlurWidth));
          Graphics.Blit(renderTexture2, renderTexture, dofHdrMaterial, 5);
          dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0f, internalBlurWidth));
          Graphics.Blit(renderTexture, renderTexture2, dofHdrMaterial, 5);
          Graphics.SetRenderTarget(renderTexture2);
          ComputeBuffer.CopyCount(cbPoints, cbDrawArgs, 0);
          dx11bokehMaterial.SetBuffer("pointBuffer", cbPoints);
          dx11bokehMaterial.SetTexture("_MainTex", dx11BokehTexture);
          dx11bokehMaterial.SetVector("_Screen", new Vector3(1f / (1f * (float)renderTexture2.width), 1f / (1f * (float)renderTexture2.height), internalBlurWidth));
          dx11bokehMaterial.SetPass(1);
          Graphics.DrawProceduralIndirect(MeshTopology.Points, cbDrawArgs, 0);
          dofHdrMaterial.SetTexture("_LowRez", renderTexture2);
          //dofHdrMaterial.SetTexture("_FgOverlap", renderTexture5);
          dofHdrMaterial.SetVector("_Offsets", 1f * (float)source.width / (1f * (float)renderTexture2.width) * internalBlurWidth * Vector4.one);
          Graphics.Blit(source, destination, dofHdrMaterial, 9);
          /*if ((bool)renderTexture5) {
            RenderTexture.ReleaseTemporary(renderTexture5);
          }*/
        }
      } else {
        source.filterMode = FilterMode.Bilinear;
        WriteCoc(source, true);
        renderTexture = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
        renderTexture2 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
        if (highResolution) {
          internalBlurWidth *= 2f;
          dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0.025f, internalBlurWidth));
          Graphics.Blit(source, destination, dofHdrMaterial, blurSamplePass);
        } else {
          dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0.1f, internalBlurWidth));
          Graphics.Blit(source, renderTexture, dofHdrMaterial, 6);
          Graphics.Blit(renderTexture, renderTexture2, dofHdrMaterial, blurSamplePass);
          dofHdrMaterial.SetTexture("_LowRez", renderTexture2);
          dofHdrMaterial.SetTexture("_FgOverlap", null);
          dofHdrMaterial.SetVector("_Offsets", Vector4.one * (1f * (float)source.width / (1f * (float)renderTexture2.width)) * internalBlurWidth);
          Graphics.Blit(source, destination, dofHdrMaterial, blurSampleCount);
        }
      }
      if (renderTexture) RenderTexture.ReleaseTemporary(renderTexture);
      if (renderTexture2) RenderTexture.ReleaseTemporary(renderTexture2);
    }
  }
#endif
} //namespace
